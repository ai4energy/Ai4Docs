<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>静态链接库和动态链接库 · Ai4EDocs</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/css/ai4e.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Ai4EDocs logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Ai4EDocs</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">CSBase</span><ul><li><a class="tocitem" href="../1-Windows命令提示符介绍/">Windows的命令提示符简介</a></li><li><a class="tocitem" href="../2-PowerShell和WindowsTerminal/">PowerShell和Windows Terminal</a></li><li><a class="tocitem" href="../3-环境变量及其设置/">环境变量简介</a></li><li><a class="tocitem" href="../4-Windows下安装gcc编译器和CLion/">Windows下安装gcc编译器和CLion</a></li><li><a class="tocitem" href="../5-make和Makefile介绍/">make和Makefile介绍</a></li><li class="is-active"><a class="tocitem" href>静态链接库和动态链接库</a><ul class="internal"><li><a class="tocitem" href="#静态链接库和动态链接库是什么"><span>静态链接库和动态链接库是什么</span></a></li><li><a class="tocitem" href="#使用c语言，CMake工具，来个例子"><span>使用c语言，CMake工具，来个例子</span></a></li><li><a class="tocitem" href="#对应的c语言源文件"><span>对应的c语言源文件</span></a></li><li><a class="tocitem" href="#头文件呢？"><span>头文件呢？</span></a></li><li><a class="tocitem" href="#如何调用"><span>如何调用</span></a></li><li><a class="tocitem" href="#使用clion来一个step-by-step生成动态链接库的例子"><span>使用clion来一个step by step生成动态链接库的例子</span></a></li><li><a class="tocitem" href="#调用如何进行？"><span>调用如何进行？</span></a></li><li><a class="tocitem" href="#能否简单补充一下CMake是什么？"><span>能否简单补充一下CMake是什么？</span></a></li><li><a class="tocitem" href="#作业"><span>作业</span></a></li><li><a class="tocitem" href="#视频链接"><span>视频链接</span></a></li></ul></li><li><a class="tocitem" href="../7-以SAM为例整体实操一下/">以SAM为例实操</a></li><li><a class="tocitem" href="../8-以CoolProp为例的实操/">以CoolProp为例的实操</a></li><li><a class="tocitem" href="../9-dll生成与调用实操/">动态链接库(DLL)的生成与调用实操</a></li></ul></li><li><span class="tocitem">JuliaIntro</span><ul><li><a class="tocitem" href="../../JuliaIntro/1-julia的安装/">julia的安装</a></li><li><a class="tocitem" href="../../JuliaIntro/2-julia的REPL/">julia的REPL</a></li><li><a class="tocitem" href="../../JuliaIntro/3-julia的语法要点/">julia的语法要点</a></li><li><a class="tocitem" href="../../JuliaIntro/4-julia的包管理/">julia的包管理</a></li><li><a class="tocitem" href="../../JuliaIntro/5-julia的环境/">julia的环境</a></li><li><a class="tocitem" href="../../JuliaIntro/6-创建julia包/">创建julia包</a></li><li><a class="tocitem" href="../../JuliaIntro/7-julia的类型系统/">julia的类型系统</a></li><li><a class="tocitem" href="../../JuliaIntro/8-julia的元编程/">julia的元编程</a></li><li><a class="tocitem" href="../../JuliaIntro/9-ijulia/">IJulia</a></li></ul></li><li><span class="tocitem">CSAdv</span><ul><li><a class="tocitem" href="../../CSAdv/1-过程抽象/">过程抽象</a></li><li><a class="tocitem" href="../../CSAdv/2-数据抽象/">数据抽象</a></li><li><a class="tocitem" href="../../CSAdv/3-再说说递归/">再说说递归</a></li><li><a class="tocitem" href="../../CSAdv/4-从符号到模型/">从符号到模型</a></li><li><a class="tocitem" href="../../CSAdv/5-抽象语法树/">抽象语法树</a></li><li><a class="tocitem" href="../../CSAdv/6-代码生成/">代码生成</a></li><li><a class="tocitem" href="../../CSAdv/7-领域特定语言/">领域特定语言DSL</a></li><li><a class="tocitem" href="../../CSAdv/8-写个库还是创个语言/">写个库还是创个语言</a></li><li><a class="tocitem" href="../../CSAdv/9-Ascend等解构/">能源领域一些仿真软件解构</a></li><li><a class="tocitem" href="../../CSAdv/91-OpenFoam解构/">OpenFoam解构</a></li></ul></li><li><span class="tocitem">Modeling</span><ul><li><a class="tocitem" href="../../Modeling/DE_intro/">DifferentialEquations建模方法</a></li><li><a class="tocitem" href="../../Modeling/MTK_intro/">ModelingToolkit建模方法</a></li><li><a class="tocitem" href="../../Modeling/MTK_register/">ModelingToolkit调用外部函数</a></li><li><a class="tocitem" href="../../Modeling/MTK_tips/">MTK常见问题</a></li><li><a class="tocitem" href="../../Modeling/ModelingTutorial/">组织方程的艺术——组件化（入门）</a></li><li><a class="tocitem" href="../../Modeling/WathMTKdo/">MTK的&quot;前世今生&quot;</a></li><li><a class="tocitem" href="../../Modeling/neural_network/">数学视角下的神经网络</a></li></ul></li><li><span class="tocitem">Simulation</span><ul><li><a class="tocitem" href="../../Simulation/1-微分代数方程/">微分代数方程DAE</a></li><li><a class="tocitem" href="../../Simulation/DE_heattran/">DE求解PDE（对比MTK）</a></li><li><a class="tocitem" href="../../Simulation/MTK_heattran/">MTK手动空间离散求解PDE</a></li><li><a class="tocitem" href="../../Simulation/componementModel/">组件化建模实例</a></li><li><a class="tocitem" href="../../Simulation/steadyRC/">MTK稳态系统仿真实例</a></li></ul></li><li><span class="tocitem">Optimization</span><ul><li><a class="tocitem" href="../../Optimization/1-优化的概念/">优化的概念</a></li><li><a class="tocitem" href="../../Optimization/2-优化问题的分类/">优化问题的分类</a></li><li><a class="tocitem" href="../../Optimization/3-能源系统工程中的优化问题/">能源系统工程中有哪些优化问题</a></li><li><a class="tocitem" href="../../Optimization/4-优化问题的求解过程/">优化问题的求解过程</a></li><li><a class="tocitem" href="../../Optimization/5-优化问题的建模平台/">优化问题的建模平台</a></li><li><a class="tocitem" href="../../Optimization/6-传统决定性算法简介/">传统决定性算法</a></li><li><a class="tocitem" href="../../Optimization/7-启发式算法简介/">启发式算法简介</a></li><li><a class="tocitem" href="../../Optimization/8-黑箱优化问题/">黑箱优化问题</a></li><li><a class="tocitem" href="../../Optimization/9-优化问题建模之递归建模方法/">优化问题建模之递归建模方法</a></li><li><a class="tocitem" href="../../Optimization/90-优化应用之参数估计与软测量/">优化应用之参数估计与软测量</a></li><li><a class="tocitem" href="../../Optimization/91-优化应用之代理模型/">优化应用之代理模型</a></li><li><a class="tocitem" href="../../Optimization/92-一些可以看一看的优化相关工具/">一些值得看看的工具</a></li><li><a class="tocitem" href="../../Optimization/93-JuMP混合整数线性优化实例/">JuMP混合整数线性优化实例</a></li><li><a class="tocitem" href="../../Optimization/94-JuMP参数辨识/">JuMP非线性参数辨识实例</a></li><li><a class="tocitem" href="../../Optimization/95-微分方程参数辨识实例/">微分方程参数辨识实例</a></li><li><a class="tocitem" href="../../Optimization/96-MTK非线性参数辨识实例/">MTK非线性参数辨识实例</a></li><li><a class="tocitem" href="../../Optimization/97-MTK符号系统参数辨识实例/">MTK符号系统参数辨识</a></li><li><a class="tocitem" href="../../Optimization/98-MTK部分参数辨识实例/">MTK部分参数辨识实例</a></li></ul></li><li><span class="tocitem">Control</span><ul><li><a class="tocitem" href="../../Control/1-控制的本质/">控制的本质</a></li><li><a class="tocitem" href="../../Control/JuMPMPC/">JuMP求解MPC问题</a></li><li><a class="tocitem" href="../../Control/KalmanFiltering/">卡尔曼滤波理论与应用</a></li><li><a class="tocitem" href="../../Control/MTKMPC/">MTK求解MPC问题</a></li><li><a class="tocitem" href="../../Control/OptimControl/">最优控制理论与应用</a></li></ul></li><li><span class="tocitem">AIandML</span><ul><li><a class="tocitem" href="../../AIandML/1-机器学习和人工智能/">机器学习</a></li></ul></li><li><span class="tocitem">IotBigdataCloud</span><ul><li><a class="tocitem" href="../../IotBigdataCloud/1-物联网/">物联网</a></li><li><a class="tocitem" href="../../IotBigdataCloud/2-消息件/">物联网的消息件</a></li><li><a class="tocitem" href="../../IotBigdataCloud/3-大数据简介/">大数据简介</a></li><li><a class="tocitem" href="../../IotBigdataCloud/4-从虚拟机到云计算/">从虚拟机到云计算</a></li><li><a class="tocitem" href="../../IotBigdataCloud/5-容器化和k8s/">容器化和k8s</a></li></ul></li><li><span class="tocitem">Frameworks</span><ul><li><a class="tocitem" href="../../Frameworks/Ai4EComponentLib/">Ai4EComponentLib.jl设计理念</a></li><li><a class="tocitem" href="../../Frameworks/OptControl/">OptControl.jl设计理念</a></li></ul></li><li><span class="tocitem">Tools</span><ul><li><a class="tocitem" href="../../Tools/1-vscode安装及插件/">-</a></li><li><a class="tocitem" href="../../Tools/2-git使用简介/">-</a></li><li><a class="tocitem" href="../../Tools/3-ssh-git实操/">SSH、Git与Git图形化软件</a></li><li><a class="tocitem" href="../../Tools/CSV_jl_use/">CSV.jl使用简介</a></li><li><a class="tocitem" href="../../Tools/CoolProp/">CoolProp使用介绍</a></li><li><a class="tocitem" href="../../Tools/vscode_git/">VScode中使用Git</a></li></ul></li><li><span class="tocitem">WorkFlow</span><ul><li><a class="tocitem" href="../../WorkFlow/ julia-binary-wrappers/">julia对外部程序的加壳</a></li><li><a class="tocitem" href="../../WorkFlow/DocStructure/">文档（docs）编写方法</a></li><li><a class="tocitem" href="../../WorkFlow/REPL-of-Julia/">julia 的 REPL</a></li><li><a class="tocitem" href="../../WorkFlow/gitworkflow/">Ai4E组织合作开发流程</a></li><li><a class="tocitem" href="../../WorkFlow/julia-call-c7fortran/">julia调用dll中的函数</a></li><li><a class="tocitem" href="../../WorkFlow/julia_change_pkgserve/">Julia换源(更换国内镜像站)</a></li><li><a class="tocitem" href="../../WorkFlow/julia的安装/">Julia安装</a></li><li><a class="tocitem" href="../../WorkFlow/vscodePlugin/">VScode开发环境配置</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">CSBase</a></li><li class="is-active"><a href>静态链接库和动态链接库</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>静态链接库和动态链接库</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ai4energy/Ai4EDocs/blob/main/docs/src/CSBase/6-静态链接库和动态链接库.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="静态链接库和动态链接库"><a class="docs-heading-anchor" href="#静态链接库和动态链接库">静态链接库和动态链接库</a><a id="静态链接库和动态链接库-1"></a><a class="docs-heading-anchor-permalink" href="#静态链接库和动态链接库" title="Permalink"></a></h1><p>编程中函数的本质是把具有一定功能性代码整合起来，可以重复的使用。至于函数内部的实现，你可以认为就是一个黑箱。但是我得告诉你我这个黑箱中有什么功能。就像快递收发点一样，怎么运输的你不用管，但是我得有个目录告诉你有些什么选择和对应的收费标准。</p><p>c语言中，stdio等库就是这么个情况，把很多有用的函数封装在一起，成为一个库（静态和动态我们等会儿再说），库里有什么则通过stdio.h这个文件告诉你，同时stdio.h也告诉你了要以什么样的参数方式调用。</p><p>人们可以把一些函数封装成库，提供给用户服务。c语言就有很多这样的库，你写程序的时候，就可以调用c语言自带的这些库函数。编译的时候，你的c语言源代码会编译成.o文件，但是要做成exe文件，还需要把库里所有要用到的那些函数代码嵌入进来，这种方式就是静态的链接到了你的exe文件中。提供的这些库，就称呼为静态链接库。</p><p>而如果某些函数使用率非常的高，或者你自己脑回路清奇，或者乐意，你也可以把那些用到的函数不嵌入进来，只是告诉你的exe程序，需要用到某个库中的某个函数，在运行的时候才加载那个库，调用库里的函数。这样的方式就是动态链接库。</p><p>在windows下，静态链接库一般是lib为后缀名，动态链接库一般是dll为后缀名。</p><p>在linux下，静态链接库一般是a为后缀名，动态链接库一般是so为后缀名。</p><p>在mac os x 下，动态链接库一般是dylib为后缀名。</p><p>我们在julia中可以很方便的调用动态链接库里的函数。详情请见julia调用dll中的函数。</p><h2 id="静态链接库和动态链接库是什么"><a class="docs-heading-anchor" href="#静态链接库和动态链接库是什么">静态链接库和动态链接库是什么</a><a id="静态链接库和动态链接库是什么-1"></a><a class="docs-heading-anchor-permalink" href="#静态链接库和动态链接库是什么" title="Permalink"></a></h2><p>动态链接库（Dynamic Link Library，DLL）是一种在多个程序之间共享代码和数据的可执行文件格式。DLL包含一组可重用的函数、类、变量和资源，可以被不同的应用程序或进程调用和使用。</p><p>与静态链接库（Static Link Library）不同，DLL在运行时才加载到内存中，并且可以由多个应用程序同时使用。这种共享的特性带来了一些优势：</p><p>节省内存空间：由于多个应用程序可以共享同一个DLL，所以不同的应用程序不需要在内存中加载相同的代码和数据，从而节省了内存空间。</p><p>代码和数据的更新和维护：如果需要更新DLL中的代码或数据，只需更新DLL本身，而不需要重新编译和链接所有使用该DLL的应用程序。这样可以简化代码的维护和更新过程。</p><p>提供标准化的功能和接口：通过使用DLL，可以将常用的功能和接口封装在一个共享的库中，使得多个应用程序可以共享这些标准化的功能，减少了代码冗余和重复开发。</p><p>在Windows操作系统中，DLL文件具有特定的文件扩展名 &quot;.dll&quot;，并且可以通过动态链接方式进行加载和调用。应用程序可以使用特定的函数调用语法来调用DLL中的函数，从而实现对DLL中功能的使用。</p><p>需要注意的是，由于DLL是共享的，因此在使用DLL时需要注意版本兼容性和依赖关系。如果一个应用程序依赖于某个DLL的特定版本，那么必须确保该DLL的版本可用，并且正确配置应用程序的运行环境，以避免出现兼容性问题。</p><p>总之，动态链接库是一种方便共享代码和数据的可执行文件格式，它提供了灵活性、代码重用和资源共享的好处，被广泛用于软件开发中。</p><h2 id="使用c语言，CMake工具，来个例子"><a class="docs-heading-anchor" href="#使用c语言，CMake工具，来个例子">使用c语言，CMake工具，来个例子</a><a id="使用c语言，CMake工具，来个例子-1"></a><a class="docs-heading-anchor-permalink" href="#使用c语言，CMake工具，来个例子" title="Permalink"></a></h2><p>当使用CMake构建动态链接库或静态链接库时，您需要编写CMakeLists.txt文件来描述构建过程。下面是一个示例，展示如何使用C语言生成一个动态链接库和一个静态链接库。</p><p>首先，创建一个名为<code>mylib</code>的文件夹，并在其中创建以下文件：</p><ol><li><code>CMakeLists.txt</code> - 用于构建库的CMake文件。</li><li><code>mylib.h</code> - 库的头文件。</li><li><code>mylib.c</code> - 库的源代码文件。</li></ol><p>确保将这些文件放在同一个文件夹中。</p><p>下面是<code>CMakeLists.txt</code>的内容：</p><pre><code class="language-cmake hljs">cmake_minimum_required(VERSION 3.10)
project(mylib)

# 添加库的源文件
set(SOURCES mylib.c)

# 生成动态链接库
add_library(mylib_shared SHARED ${SOURCES})

# 生成静态链接库
add_library(mylib_static STATIC ${SOURCES})

# 设置库的输出名称
set_target_properties(mylib_shared PROPERTIES OUTPUT_NAME &quot;mylib&quot;)
set_target_properties(mylib_static PROPERTIES OUTPUT_NAME &quot;mylib&quot;)

# 设置库的安装路径
install(TARGETS mylib_shared mylib_static
        LIBRARY DESTINATION lib
        ARCHIVE DESTINATION lib)

# 设置头文件的安装路径
install(FILES mylib.h DESTINATION include)</code></pre><p>在上述示例中，我们使用<code>add_library</code>命令来创建动态链接库和静态链接库。<code>set_target_properties</code>命令用于设置库的输出名称，这里设置为&quot;mylib&quot;。<code>install</code>命令用于指定库的安装路径和头文件的安装路径。</p><p>要构建库，可以按照以下步骤进行操作：</p><ol><li>创建一个名为<code>build</code>的文件夹，并进入该文件夹。</li><li>打开终端，导航到<code>build</code>文件夹。</li><li>运行以下命令以生成构建文件：</li></ol><pre><code class="nohighlight hljs">cmake ..</code></pre><ol><li>运行以下命令以构建库：</li></ol><pre><code class="nohighlight hljs">cmake --build .</code></pre><p>完成上述步骤后，将在<code>build</code>文件夹中生成动态链接库（libmylib.so）和静态链接库（libmylib.a）。</p><p>如果您希望安装库到系统路径中，可以运行以下命令（需要管理员权限）：</p><pre><code class="nohighlight hljs">sudo make install</code></pre><p>这将把库文件和头文件安装到默认的系统路径（例如，/usr/local/lib和/usr/local/include）。</p><h2 id="对应的c语言源文件"><a class="docs-heading-anchor" href="#对应的c语言源文件">对应的c语言源文件</a><a id="对应的c语言源文件-1"></a><a class="docs-heading-anchor-permalink" href="#对应的c语言源文件" title="Permalink"></a></h2><p>这里是一个示例的C源文件mylib.c，用于生成动态链接库和静态链接库：</p><pre><code class="language-c hljs">#include &quot;mylib.h&quot;

int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}</code></pre><p>在上述示例中，我们定义了两个简单的函数：add和subtract。这些函数的实现位于mylib.c文件中，并在mylib.h文件中进行了声明。</p><p>您可以将这个mylib.c文件放在与CMakeLists.txt相同的目录中，然后按照上述说明使用CMake来构建动态链接库和静态链接库。</p><h2 id="头文件呢？"><a class="docs-heading-anchor" href="#头文件呢？">头文件呢？</a><a id="头文件呢？-1"></a><a class="docs-heading-anchor-permalink" href="#头文件呢？" title="Permalink"></a></h2><p>当生成动态链接库或静态链接库时，您需要一个头文件来声明库中的函数和数据结构。在上一个示例中，我忘记包含头文件<code>mylib.h</code>的内容，非常抱歉。以下是正确的<code>mylib.h</code>头文件内容：</p><pre><code class="language-c hljs">#ifndef MYLIB_H
#define MYLIB_H

int add(int a, int b);
int subtract(int a, int b);

#endif  // MYLIB_H</code></pre><p>请将上述代码保存到名为<code>mylib.h</code>的文件中，并确保与<code>CMakeLists.txt</code>和<code>mylib.c</code>文件位于同一个目录中。</p><p>这个头文件声明了两个函数：<code>add</code>和<code>subtract</code>，这些函数的实现位于<code>mylib.c</code>文件中。通过包含这个头文件，其他源文件就可以使用库中的函数。</p><p>希望这次提供的信息对您有所帮助！如果您还有其他问题，请随时提问。</p><h2 id="如何调用"><a class="docs-heading-anchor" href="#如何调用">如何调用</a><a id="如何调用-1"></a><a class="docs-heading-anchor-permalink" href="#如何调用" title="Permalink"></a></h2><p>当调用生成的动态链接库或静态链接库时，您需要创建一个主函数文件，并使用CMake来构建项目。下面是一个示例，展示如何编写主函数文件和CMakeLists.txt文件来调用生成的库。</p><p>首先，创建一个名为<code>myapp</code>的文件夹，并在其中创建以下文件：</p><ol><li><code>CMakeLists.txt</code> - 用于构建应用程序的CMake文件。</li><li><code>main.c</code> - 主函数文件，用于调用库中的函数。</li></ol><p>确保将这些文件放在同一个文件夹中。</p><p>下面是<code>CMakeLists.txt</code>的内容：</p><pre><code class="language-cmake hljs">cmake_minimum_required(VERSION 3.10)
project(myapp)

# 添加库的源文件
set(SOURCES main.c)

# 生成可执行文件
add_executable(myapp ${SOURCES})

# 链接动态链接库
target_link_libraries(myapp PRIVATE mylib)

# 设置库的搜索路径
link_directories(/path/to/mylib)

# 设置库的头文件路径
include_directories(/path/to/mylib)

# 设置可执行文件的安装路径
install(TARGETS myapp DESTINATION bin)</code></pre><p>在上述示例中，我们使用<code>add_executable</code>命令创建可执行文件，并使用<code>target_link_libraries</code>命令将生成的库（这里假设为<code>mylib</code>）链接到可执行文件中。通过<code>link_directories</code>和<code>include_directories</code>命令，我们设置库的搜索路径和头文件路径。</p><p>要构建应用程序，可以按照以下步骤进行操作：</p><ol><li>创建一个名为<code>build</code>的文件夹，并进入该文件夹。</li><li>打开终端，导航到<code>build</code>文件夹。</li><li>运行以下命令以生成构建文件：</li></ol><pre><code class="nohighlight hljs">cmake ..</code></pre><ol><li>运行以下命令以构建应用程序：</li></ol><pre><code class="nohighlight hljs">cmake --build .</code></pre><p>完成上述步骤后，将在<code>build</code>文件夹中生成可执行文件（myapp）。</p><p>如果您希望安装应用程序到系统路径中，可以运行以下命令（需要管理员权限）：</p><pre><code class="nohighlight hljs">sudo make install</code></pre><p>这将把可执行文件安装到默认的系统路径（例如，/usr/local/bin）。</p><p>请注意，您需要根据实际情况修改<code>link_directories</code>和<code>include_directories</code>中的路径，以确保正确链接和包含库的头文件。</p><h2 id="使用clion来一个step-by-step生成动态链接库的例子"><a class="docs-heading-anchor" href="#使用clion来一个step-by-step生成动态链接库的例子">使用clion来一个step by step生成动态链接库的例子</a><a id="使用clion来一个step-by-step生成动态链接库的例子-1"></a><a class="docs-heading-anchor-permalink" href="#使用clion来一个step-by-step生成动态链接库的例子" title="Permalink"></a></h2><p>使用CLion来生成动态链接库的步骤如下：</p><p>步骤 1: 创建一个新的CMake项目</p><ul><li>打开CLion并选择 &quot;Create New Project&quot;。</li><li>在对话框中选择 &quot;C Executable&quot; 并点击 &quot;Next&quot;。</li><li>为项目选择一个适当的名称和位置，并点击 &quot;Create&quot;.</li></ul><p>步骤 2: 创建源文件</p><ul><li>在项目中创建一个新的C源文件，例如 <code>mylib.c</code>。</li><li>编写您的库的实现代码。</li></ul><p>以下是一个简单的示例 <code>mylib.c</code>：</p><pre><code class="language-c hljs">#include &quot;mylib.h&quot;

int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}</code></pre><p>步骤 3: 创建头文件</p><ul><li>在项目中创建一个新的头文件，例如 <code>mylib.h</code>。</li><li>在头文件中声明您的库的函数和数据结构。</li></ul><p>以下是 <code>mylib.h</code> 的内容：</p><pre><code class="language-c hljs">#ifndef MYLIB_H
#define MYLIB_H

int add(int a, int b);
int subtract(int a, int b);

#endif  // MYLIB_H</code></pre><p>步骤 4: 编辑CMakeLists.txt</p><ul><li>在项目根目录下找到 <code>CMakeLists.txt</code> 文件，并编辑它。</li></ul><p>以下是一个基本的 <code>CMakeLists.txt</code> 示例：</p><pre><code class="language-cmake hljs">cmake_minimum_required(VERSION 3.10)
project(mylib)

# 添加库的源文件
set(SOURCES mylib.c)

# 生成动态链接库
add_library(mylib SHARED ${SOURCES})

# 设置库的安装路径
install(TARGETS mylib LIBRARY DESTINATION lib)
install(FILES mylib.h DESTINATION include)</code></pre><p>步骤 5: 配置和构建项目</p><ul><li>打开CLion中的项目。</li><li>在CLion界面的底部工具栏，点击 &quot;Reload CMake Project&quot; 以加载新的CMake配置。</li><li>在CLion界面的顶部工具栏，点击 &quot;Build&quot; 按钮构建项目。</li></ul><p>完成上述步骤后，CLion将使用CMake构建您的项目，并在构建过程中生成动态链接库。生成的动态链接库将位于 <code>build/lib</code> 目录中。</p><p>如果您希望安装库到系统路径中，可以在 <code>CMakeLists.txt</code> 中添加以下安装规则：</p><pre><code class="language-cmake hljs">install(TARGETS mylib LIBRARY DESTINATION /usr/local/lib)
install(FILES mylib.h DESTINATION /usr/local/include)</code></pre><p>运行 <code>Reload CMake Project</code> 和 <code>Build</code> 命令后，库将安装到 <code>/usr/local/lib</code> 和 <code>/usr/local/include</code> 路径中。</p><p>这样，您就可以在CLion中使用CMake逐步生成动态链接库了。如果您有任何进一步的问题，请随时提问。</p><h2 id="调用如何进行？"><a class="docs-heading-anchor" href="#调用如何进行？">调用如何进行？</a><a id="调用如何进行？-1"></a><a class="docs-heading-anchor-permalink" href="#调用如何进行？" title="Permalink"></a></h2><p>以下是在CLion中调用动态链接库的步骤：</p><p>步骤 1: 创建一个新的CMake项目</p><ul><li>打开CLion并选择 &quot;Create New Project&quot;。</li><li>在对话框中选择 &quot;C Executable&quot; 并点击 &quot;Next&quot;。</li><li>为项目选择一个适当的名称和位置，并点击 &quot;Create&quot;.</li></ul><p>步骤 2: 创建源文件</p><ul><li>在项目中创建一个新的C源文件，例如 <code>main.c</code>。</li><li>编写您的主函数代码。</li></ul><p>以下是一个简单的示例 <code>main.c</code>：</p><pre><code class="language-c hljs">#include &lt;stdio.h&gt;
#include &quot;mylib.h&quot;

int main() {
    int result = add(5, 3);
    printf(&quot;Addition result: %d\n&quot;, result);

    result = subtract(5, 3);
    printf(&quot;Subtraction result: %d\n&quot;, result);

    return 0;
}</code></pre><p>步骤 3: 添加动态链接库的引用</p><ul><li>打开项目的 <code>CMakeLists.txt</code> 文件。</li><li>在 <code>add_executable</code> 行之前，添加 <code>add_library</code> 行来引用动态链接库。</li></ul><p>以下是修改后的 <code>CMakeLists.txt</code> 示例：</p><pre><code class="language-cmake hljs">cmake_minimum_required(VERSION 3.10)
project(myapp)

# 引用动态链接库
add_library(mylib SHARED IMPORTED)

# 设置动态链接库的路径
set_target_properties(mylib PROPERTIES IMPORTED_LOCATION /path/to/mylib.so)

# 添加可执行文件
add_executable(myapp main.c)

# 链接动态链接库
target_link_libraries(myapp PRIVATE mylib)</code></pre><p>在上述示例中，您需要将 <code>/path/to/mylib.so</code> 替换为实际的动态链接库文件路径。</p><p>步骤 4: 配置和构建项目</p><ul><li>打开CLion中的项目。</li><li>在CLion界面的底部工具栏，点击 &quot;Reload CMake Project&quot; 以加载新的CMake配置。</li><li>在CLion界面的顶部工具栏，点击 &quot;Build&quot; 按钮构建项目。</li></ul><p>完成上述步骤后，CLion将使用CMake构建您的项目，并在构建过程中将动态链接库引用到可执行文件中。然后，您可以在CLion中运行项目，查看调用动态链接库函数的结果。</p><p>请注意，您需要将 <code>/path/to/mylib.so</code> 替换为实际的动态链接库文件路径，并确保动态链接库文件存在。</p><h2 id="能否简单补充一下CMake是什么？"><a class="docs-heading-anchor" href="#能否简单补充一下CMake是什么？">能否简单补充一下CMake是什么？</a><a id="能否简单补充一下CMake是什么？-1"></a><a class="docs-heading-anchor-permalink" href="#能否简单补充一下CMake是什么？" title="Permalink"></a></h2><p>当然可以！CMake是一个开源的跨平台构建系统，用于管理软件项目的构建过程。它使用名为CMakeLists.txt的文本文件来描述项目的构建配置，并根据此配置生成适合各种构建工具（如make、Ninja等）的构建文件。</p><p>CMake的主要优势在于它提供了一种简化和抽象构建过程的方式，使得开发者可以更方便地管理复杂的项目结构和依赖关系。通过CMake，您可以编写平台无关的构建脚本，这意味着您可以在不同的操作系统和编译器上使用相同的CMake配置来构建项目。</p><p>CMake使用类似于编程语言的语法，提供了丰富的命令和变量，用于定义项目的源文件、目标、库依赖关系、编译选项等。通过编写CMakeLists.txt文件，您可以描述项目的组织结构、源代码文件、库的构建方式等细节，从而使得构建过程更加灵活和可定制。</p><p>在使用CMake构建项目时，通常的步骤是：创建CMakeLists.txt文件，定义源文件和目标，指定库的依赖关系和链接选项，然后运行CMake来生成构建文件，最后使用构建工具进行实际的构建操作。</p><p>CMake已被广泛使用，并且许多开源项目和跨平台项目都使用CMake来管理其构建过程，使得项目在不同的平台和编译器上更容易构建和交付。</p><h2 id="作业"><a class="docs-heading-anchor" href="#作业">作业</a><a id="作业-1"></a><a class="docs-heading-anchor-permalink" href="#作业" title="Permalink"></a></h2><p>请自己完成静态链接库及其调用。使用CLion，CMake。</p><h2 id="视频链接"><a class="docs-heading-anchor" href="#视频链接">视频链接</a><a id="视频链接-1"></a><a class="docs-heading-anchor-permalink" href="#视频链接" title="Permalink"></a></h2><p><a href="https://www.bilibili.com/video/BV1WV4y1k72z/">动态链接库和静态链接库</a></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../5-make和Makefile介绍/">« make和Makefile介绍</a><a class="docs-footer-nextpage" href="../7-以SAM为例整体实操一下/">以SAM为例实操 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 13 July 2023 02:38">Thursday 13 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
