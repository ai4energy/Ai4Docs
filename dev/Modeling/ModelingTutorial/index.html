<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>组织方程的艺术——组件化（入门） · Ai4EDocs</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/css/ai4e.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Ai4EDocs logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Ai4EDocs</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">CSBase</span><ul><li><a class="tocitem" href="../../CSBase/1-Windows命令提示符介绍/">Windows的命令提示符简介</a></li><li><a class="tocitem" href="../../CSBase/2-PowerShell和WindowsTerminal/">PowerShell和Windows Terminal</a></li><li><a class="tocitem" href="../../CSBase/3-环境变量及其设置/">环境变量简介</a></li><li><a class="tocitem" href="../../CSBase/4-Windows下安装gcc编译器和CLion/">Windows下安装gcc编译器和CLion</a></li><li><a class="tocitem" href="../../CSBase/5-make和Makefile介绍/">make和Makefile介绍</a></li><li><a class="tocitem" href="../../CSBase/6-静态链接库和动态链接库/">静态链接库和动态链接库</a></li><li><a class="tocitem" href="../../CSBase/7-以SAM为例整体实操一下/">以SAM为例实操</a></li><li><a class="tocitem" href="../../CSBase/8-以CoolProp为例的实操/">以CoolProp为例的实操</a></li><li><a class="tocitem" href="../../CSBase/9-dll生成与调用实操/">动态链接库(DLL)的生成与调用实操</a></li></ul></li><li><span class="tocitem">JuliaIntro</span><ul><li><a class="tocitem" href="../../JuliaIntro/1-julia的安装/">julia的安装</a></li><li><a class="tocitem" href="../../JuliaIntro/2-julia的REPL/">julia的REPL</a></li><li><a class="tocitem" href="../../JuliaIntro/3-julia的语法要点/">julia的语法要点</a></li><li><a class="tocitem" href="../../JuliaIntro/4-julia的包管理/">julia的包管理</a></li><li><a class="tocitem" href="../../JuliaIntro/5-julia的环境/">julia的环境</a></li><li><a class="tocitem" href="../../JuliaIntro/6-创建julia包/">创建julia包</a></li><li><a class="tocitem" href="../../JuliaIntro/7-julia的类型系统/">julia的类型系统</a></li><li><a class="tocitem" href="../../JuliaIntro/8-julia的元编程/">julia的元编程</a></li><li><a class="tocitem" href="../../JuliaIntro/9-ijulia/">IJulia</a></li></ul></li><li><span class="tocitem">IotBigdataCloud</span><ul><li><a class="tocitem" href="../../IotBigdataCloud/1-物联网/">物联网</a></li><li><a class="tocitem" href="../../IotBigdataCloud/2-消息件/">物联网的消息件</a></li><li><a class="tocitem" href="../../IotBigdataCloud/3-大数据简介/">大数据简介</a></li><li><a class="tocitem" href="../../IotBigdataCloud/4-从虚拟机到云计算/">从虚拟机到云计算</a></li><li><a class="tocitem" href="../../IotBigdataCloud/5-容器化和k8s/">容器化和k8s</a></li></ul></li><li><span class="tocitem">Modeling</span><ul><li><a class="tocitem" href="../DE_intro/">DifferentialEquations建模方法</a></li><li><a class="tocitem" href="../MTK_intro/">ModelingToolkit建模方法</a></li><li><a class="tocitem" href="../MTK_register/">ModelingToolkit调用外部函数</a></li><li><a class="tocitem" href="../MTK_tips/">MTK常见问题</a></li><li class="is-active"><a class="tocitem" href>组织方程的艺术——组件化（入门）</a><ul class="internal"><li><a class="tocitem" href="#前言"><span>前言</span></a></li><li><a class="tocitem" href="#电路问题"><span>电路问题</span></a></li><li><a class="tocitem" href="#求对比解"><span>求对比解</span></a></li><li><a class="tocitem" href="#小结"><span>小结</span></a></li></ul></li><li><a class="tocitem" href="../WathMTKdo/">MTK的&quot;前世今生&quot;</a></li><li><a class="tocitem" href="../neural_network/">数学视角下的神经网络</a></li></ul></li><li><span class="tocitem">Simulation</span><ul><li><a class="tocitem" href="../../Simulation/DE_heattran/">DE求解PDE（对比MTK）</a></li><li><a class="tocitem" href="../../Simulation/MTK_heattran/">MTK手动空间离散求解PDE</a></li><li><a class="tocitem" href="../../Simulation/componementModel/">组件化建模实例</a></li><li><a class="tocitem" href="../../Simulation/steadyRC/">MTK稳态系统仿真实例</a></li></ul></li><li><span class="tocitem">Optimization</span><ul><li><a class="tocitem" href="../../Optimization/DE_Estim/">微分方程参数辨识实例</a></li><li><a class="tocitem" href="../../Optimization/JuMP参数辨识/">JuMP非线性参数辨识实例</a></li><li><a class="tocitem" href="../../Optimization/JumpMILP/">JuMP混合整数线性优化实例</a></li><li><a class="tocitem" href="../../Optimization/systemParaEste/">MTK符号系统参数辨识</a></li><li><a class="tocitem" href="../../Optimization/systemParaEste_batter/">MTK部分参数辨识实例</a></li><li><a class="tocitem" href="../../Optimization/参数辨识实例_MTK/">MTK非线性参数辨识实例</a></li></ul></li><li><span class="tocitem">Control</span><ul><li><a class="tocitem" href="../../Control/JuMPMPC/">JuMP求解MPC问题</a></li><li><a class="tocitem" href="../../Control/KalmanFiltering/">卡尔曼滤波理论与应用</a></li><li><a class="tocitem" href="../../Control/MTKMPC/">MTK求解MPC问题</a></li><li><a class="tocitem" href="../../Control/OptimControl/">最优控制理论与应用</a></li></ul></li><li><span class="tocitem">Frameworks</span><ul><li><a class="tocitem" href="../../Frameworks/Ai4EComponentLib/">Ai4EComponentLib.jl设计理念</a></li><li><a class="tocitem" href="../../Frameworks/OptControl/">OptControl.jl设计理念</a></li></ul></li><li><span class="tocitem">Tools</span><ul><li><a class="tocitem" href="../../Tools/1-vscode安装及插件/">-</a></li><li><a class="tocitem" href="../../Tools/2-git使用简介/">-</a></li><li><a class="tocitem" href="../../Tools/3-ssh-git实操/">SSH、Git与Git图形化软件</a></li><li><a class="tocitem" href="../../Tools/CSV_jl_use/">CSV.jl使用简介</a></li><li><a class="tocitem" href="../../Tools/CoolProp/">CoolProp使用介绍</a></li><li><a class="tocitem" href="../../Tools/vscode_git/">VScode中使用Git</a></li></ul></li><li><span class="tocitem">WorkFlow</span><ul><li><a class="tocitem" href="../../WorkFlow/ julia-binary-wrappers/">julia对外部程序的加壳</a></li><li><a class="tocitem" href="../../WorkFlow/DocStructure/">文档（docs）编写方法</a></li><li><a class="tocitem" href="../../WorkFlow/REPL-of-Julia/">julia 的 REPL</a></li><li><a class="tocitem" href="../../WorkFlow/gitworkflow/">Ai4E组织合作开发流程</a></li><li><a class="tocitem" href="../../WorkFlow/julia-call-c7fortran/">julia调用dll中的函数</a></li><li><a class="tocitem" href="../../WorkFlow/julia_change_pkgserve/">Julia换源(更换国内镜像站)</a></li><li><a class="tocitem" href="../../WorkFlow/julia的安装/">Julia安装</a></li><li><a class="tocitem" href="../../WorkFlow/vscodePlugin/">VScode开发环境配置</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Modeling</a></li><li class="is-active"><a href>组织方程的艺术——组件化（入门）</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>组织方程的艺术——组件化（入门）</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ai4energy/Ai4EDocs/blob/main/docs/src/Modeling/ModelingTutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="组织方程的艺术——组件化（入门）"><a class="docs-heading-anchor" href="#组织方程的艺术——组件化（入门）">组织方程的艺术——组件化（入门）</a><a id="组织方程的艺术——组件化（入门）-1"></a><a class="docs-heading-anchor-permalink" href="#组织方程的艺术——组件化（入门）" title="Permalink"></a></h1><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Contents：建模思想</p><p>Contributor: YJY</p><p>Email:522432938@qq.com</p><p>如有错误，请批评指正。</p></div></div><h2 id="前言"><a class="docs-heading-anchor" href="#前言">前言</a><a id="前言-1"></a><a class="docs-heading-anchor-permalink" href="#前言" title="Permalink"></a></h2><p>Ai4Energy开发者总是张口闭口组件化建模，那么组件化建模的内涵到底是什么？为什么要组件化建模？这篇我们从头至尾介绍做一个组件化思想的入门介绍。</p><p>建模用<a href="https://mtk.sciml.ai/stable/">ModelingToolkit.jl</a>；求解用<a href="https://diffeq.sciml.ai/dev_/">DifferentialEquations.jl</a>。</p><h2 id="电路问题"><a class="docs-heading-anchor" href="#电路问题">电路问题</a><a id="电路问题-1"></a><a class="docs-heading-anchor-permalink" href="#电路问题" title="Permalink"></a></h2><p>以电路系统切入，深入探讨组件化建模的内涵是最合适不过的了。</p><p>首先准备2个电路元件的方程。</p><ul><li>欧姆定律：电阻两端的电压与流过电阻电流成正比。</li></ul><p class="math-container">\[U=IR\]</p><ul><li>电容器：电容两端电压的变化率与电流成正比。</li></ul><p class="math-container">\[\frac{dV}{dt} = \frac{I}{C}\]</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>C是电容量，单位为法拉（F）。</p></div></div><p>我们再准备一个电路系统，如下图:</p><p><img src="../../assets/ModelingTutorial-20-37-51.png" alt="图 5"/>  </p><p><strong>需要求解的问题是</strong>：电容初始电压为0，当开关闭合后，电容电压电流的变化情况是？</p><h3 id="手搓求解"><a class="docs-heading-anchor" href="#手搓求解">手搓求解</a><a id="手搓求解-1"></a><a class="docs-heading-anchor-permalink" href="#手搓求解" title="Permalink"></a></h3><p>手搓的意思是电路中学的传统解法。开关闭合后，视为导线。采用节点电压法求解。标记三个节点1，2，3。节点电压分别为<span>$V_1,V_2,V_3$</span>，如下图。整个电路只有一条主路，所以电流为<span>$I$</span>。</p><p><img src="../../assets/ModelingTutorial-20-43-10.png" alt="图 6"/>  </p><p>所以电路的方程为：</p><p class="math-container">\[V_1-V_3=1 (V) \\
V_1-V_2=1 (\Omega) * I\\
\frac{d(V_2-V_3)}{dt} = \frac{I}{1 (F)} = I\\
V_3 = 0 \tag{1}\]</p><p>手动化简之后可以得到2种情况：</p><ul><li>保留<span>$I$</span>，化简掉<span>$V_1,V_3,V_2$</span>。开关刚闭合，有电容视为导线，则0时刻，<span>$I=1$</span></li></ul><p class="math-container">\[\frac{1-I}{dt} = -\frac{dI}{dt}= I\\
I_0 = 1(A) \tag{2}\]</p><ul><li>保留<span>$V_2$</span>，化简掉<span>$V_1,V_3,I$</span></li></ul><p class="math-container">\[\frac{dV_2}{dt} = 1-V_2\\
V_{2,0}=0(V) \tag{3}\]</p><p>以上微分方程式2或3，求解任何一个，把结果代回方程组1，整个电路系统的情况就可以得到了。这个问题就解决了。</p><p>下面看一看组件化怎么做！</p><h3 id="组件化求解"><a class="docs-heading-anchor" href="#组件化求解">组件化求解</a><a id="组件化求解-1"></a><a class="docs-heading-anchor-permalink" href="#组件化求解" title="Permalink"></a></h3><p>在之前的基础之上，我们只做一件事情——<strong>引入额外的变量</strong>。</p><p>为每个器件添加两个端口变量（地只加一个端口）。正极叫p，负极叫n。同时为器件取名，电源叫做source，电阻叫做resistor，电容叫做capacitor，地叫做ground。同时规定，器件索引其子要素的方式为“.”。例如，电阻正极电压的变量全名为<span>$resistor.p.V$</span>。如下图所示。</p><p><img src="../../assets/ModelingTutorial-13-57-04.png" alt="图 2"/>  </p><p>那么我们新引入了14个变量：</p><ul><li>电源的4个</li></ul><p class="math-container">\[source.n.V\\
source.n.i\\
source.p.V\\
source.p.i\\\]</p><ul><li>电阻的4个</li></ul><p class="math-container">\[resistor.n.V\\
resistor.n.i\\
resistor.p.V\\
resistor.p.i\\\]</p><ul><li>电容的4个</li></ul><p class="math-container">\[capacitor.n.V\\
capacitor.n.i\\
capacitor.p.V\\
capacitor.p.i\\\]</p><ul><li>地的两个</li></ul><p class="math-container">\[ground.port.V\\
ground.port.i\\\]</p><p>再研究一下变量关系，我们可以发现。<strong>所有端口电流（地端口除外）的数值都等于<span>$I$</span>，端口电压值都等于对应的电压节点的电压</strong>。</p><p>这，貌似就是给<span>$V_1,V_3,V_2,I$</span>这几个变量加了很多别名？一顿操作猛如虎，细想发现全白干，形式主义我最行？</p><p>下面才是主菜！</p><h4 id="Step1:-把V_1,V_3,V_2,I**全踢掉**，如下图。"><a class="docs-heading-anchor" href="#Step1:-把V_1,V_3,V_2,I**全踢掉**，如下图。">Step1: 把<span>$V_1,V_3,V_2,I$</span><strong>全踢掉</strong>，如下图。</a><a id="Step1:-把V_1,V_3,V_2,I**全踢掉**，如下图。-1"></a><a class="docs-heading-anchor-permalink" href="#Step1:-把V_1,V_3,V_2,I**全踢掉**，如下图。" title="Permalink"></a></h4><p><img src="../../assets/ModelingTutorial-11-29-31.png" alt="图 3"/>   </p><h4 id="Step2.-分别写组件的方程，规定电流入流为正，流出为负："><a class="docs-heading-anchor" href="#Step2.-分别写组件的方程，规定电流入流为正，流出为负：">Step2. 分别写组件的方程，规定电流入流为正，流出为负：</a><a id="Step2.-分别写组件的方程，规定电流入流为正，流出为负：-1"></a><a class="docs-heading-anchor-permalink" href="#Step2.-分别写组件的方程，规定电流入流为正，流出为负：" title="Permalink"></a></h4><ul><li>电源：</li></ul><p class="math-container">\[source.p.V - source.n.V = 1 (V)\\
source.p.I + source.n.I = 0\]</p><ul><li>电阻：</li></ul><p class="math-container">\[resistor.p.V - resistor.n.V = resistor.p.I * 1 (\Omega)\\
resistor.p.I + resistor.n.I = 0\]</p><ul><li>电容：</li></ul><p class="math-container">\[\frac{d(capacitor.p.V - capacitor.n.V)}{dt} = \frac{capacitor.p.I}{1 (F)} \\
capacitor.p.I + capacitor.n.I = 0\]</p><ul><li>地（规定电势为0的点，电流不做要求）：</li></ul><p class="math-container">\[ground.port.V = 0\\
ground.port.I = 0\]</p><h4 id="Step3:-构建连接关系"><a class="docs-heading-anchor" href="#Step3:-构建连接关系">Step3: 构建连接关系</a><a id="Step3:-构建连接关系-1"></a><a class="docs-heading-anchor-permalink" href="#Step3:-构建连接关系" title="Permalink"></a></h4><ul><li>电源和电阻连（等价于节点1，节点电压相等、电流净流量为0）</li></ul><p class="math-container">\[source.n.V = resistor.p.V\\
source.n.I + resistor.p.I = 0\]</p><ul><li>电阻和电容连（等价于节点2，节点电压相等、电流净流量为0）</li></ul><p class="math-container">\[resistor.n.V = capacitor.p.V\\
resistor.n.I + capacitor.p.I = 0\]</p><ul><li>电容、电源和地连（等价于节点3，节点电压相等、电流净流量为0）</li></ul><p class="math-container">\[capacitor.n.V = sourc.p.V = ground.port.V\\
capacitor.n.I + sourc.p.I + ground.port.I= 0\\
\]</p><p>稍微思考一下可以发现，上述10多个方程组成的方程大组，其数学本质与方程小组1<strong>完全等价</strong>！唯一的区别是前者多引入了很多变量，并且这些变量完全可以消去！</p><p>但是，前者完成了组件化的封装，由此<strong>连接关系与组件内部之间成了相互独立的关系</strong>。</p><p>什么意思呢？以<span>$V_1$</span>为例。<span>$V_1$</span>既是电压源的出口电压又是电阻的正极电压。同时<span>$V_1$</span>作为节点电压，已经消去了电流的概念。这就意味每节点是不同的。而组件化的内涵就是把这一点拆解成了两部分：连接与组件内部。以电阻的正负极端口为例，<strong>对内建立组件内部的方程</strong>：</p><p class="math-container">\[resistor.p.V - resistor.n.V = resistor.p.I * 1\]</p><p>其本质就是<span>$U=IR$</span>；<strong>对外建立与其他组件连接</strong>：</p><p class="math-container">\[source.p.V = resistor.p.V\\
source.n.I + resistor.p.I = 0\\
resistor.n.V = capacitor.p.V\\
resistor.n.I + capacitor.p.I = 0\]</p><p>其本质就是节点电压1和2.</p><p>这么多方程很复杂但逻辑清晰。其实它很简单，因为化简计算机会去做。</p><h2 id="求对比解"><a class="docs-heading-anchor" href="#求对比解">求对比解</a><a id="求对比解-1"></a><a class="docs-heading-anchor-permalink" href="#求对比解" title="Permalink"></a></h2><h3 id="手搓版"><a class="docs-heading-anchor" href="#手搓版">手搓版</a><a id="手搓版-1"></a><a class="docs-heading-anchor-permalink" href="#手搓版" title="Permalink"></a></h3><p>把节点电压法的分析过程，写成ModelingToolkit的代码。</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><ul><li>在VScode中，输入入V_3就能输入V₃</li></ul><p><img src="../../assets/ModelingTutorial-09-12-16.png" alt="图 1"/>  </p><ul><li>在VScode中，按下<code>Ctrl+Enter</code>可以执行光标所在行的一行代码。以下的代码可以一行一行执行，看中间结果。</li></ul></div></div><pre><code class="language-julia hljs">using ModelingToolkit, DifferentialEquations

# 定义变量
@variables t
@variables V₁(t) V₂(t) V₃(t) I(t)

# 定义微分
D = Differential(t)

# 设置参数
R = 1.0
C = 1.0
V = 1.0

# 输入方程
rc_eqs = [
    V₁ - V₃ ~ V
    V₁ - V₂ ~ I * R
    D(V₂) ~ I / C
    V₃ ~ 0
]

# 构建系统
@named rc_model = ODESystem(rc_eqs, t)

# 系统化简
sys = structural_simplify(rc_model)

# 设置初值
u0 = [
    V₂ =&gt; 0.0
]
# 求解时间范围
tspan = (0.0, 10.0)

# 构建问题并求解
prob = ODAEProblem(sys, u0, tspan)
sol = solve(prob, Tsit5())

# 分别查看 V₁, V₂, V₃ 的变化
sol[V₂]
sol[V₁]
sol[V₃]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">19-element Vector{Float64}:
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0</code></pre><p>再查看一下化简前的方程：</p><pre><code class="language-julia hljs">equations(rc_model)</code></pre><p class="math-container">\[ \begin{align}
\frac{\mathrm{d} V_2\left( t \right)}{\mathrm{d}t} =&amp; I\left( t \right) \\
 - V_3\left( t \right) + V_1\left( t \right) =&amp; 1 \\
 - V_2\left( t \right) + V_1\left( t \right) =&amp; I\left( t \right) \\
V_3\left( t \right) =&amp; 0
\end{align}
 \]</p><p>再查看一下化简后的方程：</p><pre><code class="language-julia hljs">equations(sys)</code></pre><p class="math-container">\[ \begin{align}
\frac{\mathrm{d} V_2\left( t \right)}{\mathrm{d}t} =&amp; I\left( t \right)
\end{align}
 \]</p><p>方程中<span>$V_1=1$</span>，和推导的结果是一致的。</p><h3 id="组件版"><a class="docs-heading-anchor" href="#组件版">组件版</a><a id="组件版-1"></a><a class="docs-heading-anchor-permalink" href="#组件版" title="Permalink"></a></h3><p>把组件化的过程，写成代码。</p><pre><code class="language-julia hljs">using ModelingToolkit, DifferentialEquations

# 定义独立时间变量
@variables t

# 器件端口作为连接点
@connector function Pin(; name)
    sts = @variables v(t) = 1.0 i(t) = 1.0 [connect = Flow]
    return ODESystem(Equation[], t, sts, []; name=name)
end

# 地，地的端口名字改为g，不是port
function Ground(; name)
    @named g = Pin()
    eqs = [g.v ~ 0; g.i ~ 0]
    return compose(ODESystem(eqs, t, [], []; name=name), g)
end
# 电阻元件
function Resistor(; name, R=1.0)
    @named p = Pin()
    @named n = Pin()
    ps = @parameters R = R
    eqs = [
        p.v - n.v ~ p.i * R
        0 ~ p.i + n.i
    ]
    return compose(ODESystem(eqs, t, [], ps; name=name), p, n)
end
# 电容元件，因为不能对表达式进行微分，所以再引入一个电容的电压差变量v
function Capacitor(; name, C=1.0)
    @named p = Pin()
    @named n = Pin()
    ps = @parameters C = C
    sts = @variables v(t) = 1.0
    D = Differential(t)
    eqs = [
        v ~ p.v - n.v
        D(v) ~ p.i / C
        0 ~ p.i + n.i
    ]
    return compose(ODESystem(eqs, t, sts, ps; name=name), p, n)
end
# 电压源
function ConstantVoltage(; name, V=1.0)
    @named p = Pin()
    @named n = Pin()
    ps = @parameters V = V
    eqs = [
        V ~ p.v - n.v
        0 ~ p.i + n.i
    ]
    return compose(ODESystem(eqs, t, [], ps; name=name), p, n)
end

# 定义组件
R = 1.0
C = 1.0
V = 1.0
@named resistor = Resistor(R=R) # @name可以视为给定义的组件起了个名字，Resistor(R=R)返回的组件名字就叫resistor
@named capacitor = Capacitor(C=C)
@named source = ConstantVoltage(V=V)
@named ground = Ground()

# 构建连接关系
rc_eqs = [
    connect(source.p, resistor.p)
    connect(resistor.n, capacitor.p)
    connect(capacitor.n, source.n, ground.g)
]
@named _rc_model = ODESystem(rc_eqs, t) #连接关系也需要放到ODESystem中。

# 组件与组件连接关系一起构建系统
@named rc_model = compose(_rc_model,[resistor, capacitor, source, ground])
equations(rc_model) # 查看方程

# 系统化简
sys = structural_simplify(rc_model)
equations(sys) # 查看方程

# 定义初值
u0 = [
    capacitor.v =&gt; 0.0
]

# 求解
prob = ODAEProblem(sys, u0, (0, 10.0))
sol = solve(prob, Tsit5())

# 查看
sol[capacitor.v]
sol[resistor.n.v]
sol[capacitor.p.v]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">19-element Vector{Float64}:
 0.0
 9.999500016666247e-5
 0.001099395221772342
 0.011038622307372232
 0.07387132069817183
 0.20198030129465658
 0.35954472556518147
 0.5167641452122544
 0.6637713825376198
 0.7841482271226826
 0.8737784044472122
 0.9331779821204208
 0.9684489616227439
 0.9869310637824636
 0.9953772824474669
 0.9986536797747498
 0.9996930416967437
 0.9999471971800106
 0.9999499280997356</code></pre><h2 id="小结"><a class="docs-heading-anchor" href="#小结">小结</a><a id="小结-1"></a><a class="docs-heading-anchor-permalink" href="#小结" title="Permalink"></a></h2><p>引入的组件端口变量作为内部方程与外部连接关系的桥梁，使得组件完整又独立，可以与任意外部组件相连接。连接就去干连接的活，组件内部就管组件内部的方程。</p><p>从另一个角度说，节点电压法需要针对每一个系统做比较复杂的系统分析，因为其包含了某种化简的内涵；而组件化模式则是批量定义组件和批量处理连接关系，最后统一化简。后者更加易于理解与设计计算算法。</p><p>组件化的意义就在于高效复用以提高系统构建效率。因为组件都是由开发者写好的，用户只需要构建连接关系，系统即可搭建好。这也是为什么说组件化是关于方程组织的艺术了，本质还是那个本质，只是换一种变量与方程的组织模式。电路系统的组件化是组件化思想的体现之一。</p><ul><li><a href="../../Simulation/componementModel/">组件化建模实例</a>简要介绍了组件化建模思想。</li><li><a href="https://ai4energy.github.io/Ai4EComponentLib.jl/dev/">Ai4EComponentLib.jl</a>中系统的设计方法，都体现了组件化思想。</li><li><a href="../../Frameworks/Ai4EComponentLib/">Ai4EComponentLib.jl设计理念</a>介绍了更高层次的抽象组件内涵。</li></ul><p>最后，思考如何用节点电压法解下图的电路，以及如何用组件搭建。</p><p><img src="../../assets/ModelingTutorial-10-10-46.png" alt="图 2"/> </p><p>其实思考之后就会发现组件化构建的优点：</p><ul><li>高复用性：节点电压法构建需要自己写组件的特性方程；组件化不需要，不管它内部是什么牛鬼蛇神，组件写好了就能拿来用。之后就一个事——连接。定义组件的过程就是对组件内部方程的重用。</li><li>高易用性：一旦组件设计好了，构建连接关系不需要再动脑子了，照着系统图哪里有节点连哪里不就完事了？剩下精髓，是如何去设计一个系统，不再需要考虑组件底层。</li></ul><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>提问：我们上面手敲代码定义组件和构建连接的过程，与在Simulink中通过图形化界面拖一个组件连一个线的过程，有本质的区别吗？</p><p>如果你觉得没有区别，恭喜，你已经大致掌握流程模拟仿真软件底层架构的逻辑了。</p></div></div><h3 id="练习"><a class="docs-heading-anchor" href="#练习">练习</a><a id="练习-1"></a><a class="docs-heading-anchor-permalink" href="#练习" title="Permalink"></a></h3><p>尝试用上面写好的组件构建上图系统并求解。同样的，都假设电容电压初值为0。</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../MTK_tips/">« MTK常见问题</a><a class="docs-footer-nextpage" href="../WathMTKdo/">MTK的&quot;前世今生&quot; »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Tuesday 4 July 2023 00:26">Tuesday 4 July 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
