<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MTK并行计算求解大规模电池阵列 · Ai4EDocs</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/css/ai4e.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Ai4EDocs logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Ai4EDocs</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">CSBase</span><ul><li><a class="tocitem" href="../../CSBase/1-Windows命令提示符介绍/">Windows的命令提示符简介</a></li><li><a class="tocitem" href="../../CSBase/2-PowerShell和WindowsTerminal/">PowerShell和Windows Terminal</a></li><li><a class="tocitem" href="../../CSBase/3-环境变量及其设置/">环境变量简介</a></li><li><a class="tocitem" href="../../CSBase/4-Windows下安装gcc编译器和CLion/">Windows下安装gcc编译器和CLion</a></li><li><a class="tocitem" href="../../CSBase/5-make和Makefile介绍/">make和Makefile介绍</a></li><li><a class="tocitem" href="../../CSBase/6-静态链接库和动态链接库/">静态链接库和动态链接库</a></li><li><a class="tocitem" href="../../CSBase/7-以SAM为例整体实操一下/">以SAM为例实操</a></li><li><a class="tocitem" href="../../CSBase/8-以CoolProp为例的实操/">以CoolProp为例的实操</a></li><li><a class="tocitem" href="../../CSBase/9-dll生成与调用实操/">动态链接库(DLL)的生成与调用实操</a></li></ul></li><li><span class="tocitem">JuliaIntro</span><ul><li><a class="tocitem" href="../../JuliaIntro/1-julia的安装/">julia的安装</a></li><li><a class="tocitem" href="../../JuliaIntro/2-julia的REPL/">julia的REPL</a></li><li><a class="tocitem" href="../../JuliaIntro/3-julia的语法要点/">julia的语法要点</a></li><li><a class="tocitem" href="../../JuliaIntro/4-julia的包管理/">julia的包管理</a></li><li><a class="tocitem" href="../../JuliaIntro/5-julia的环境/">julia的环境</a></li><li><a class="tocitem" href="../../JuliaIntro/6-创建julia包/">创建julia包</a></li><li><a class="tocitem" href="../../JuliaIntro/7-julia的类型系统/">julia的类型系统</a></li><li><a class="tocitem" href="../../JuliaIntro/8-julia的元编程/">julia的元编程</a></li><li><a class="tocitem" href="../../JuliaIntro/9-ijulia/">IJulia</a></li><li><a class="tocitem" href="../../JuliaIntro/91- julia-binary-wrappers/">julia对外部程序的加壳</a></li></ul></li><li><span class="tocitem">CSAdv</span><ul><li><a class="tocitem" href="../../CSAdv/1-过程抽象/">过程抽象</a></li><li><a class="tocitem" href="../../CSAdv/2-数据抽象/">数据抽象</a></li><li><a class="tocitem" href="../../CSAdv/3-再说说递归/">再说说递归</a></li><li><a class="tocitem" href="../../CSAdv/4-从符号到模型/">从符号到模型</a></li><li><a class="tocitem" href="../../CSAdv/5-抽象语法树/">抽象语法树</a></li><li><a class="tocitem" href="../../CSAdv/6-代码生成/">代码生成</a></li><li><a class="tocitem" href="../../CSAdv/7-领域特定语言/">领域特定语言DSL</a></li><li><a class="tocitem" href="../../CSAdv/8-写个库还是创个语言/">写个库还是创个语言</a></li><li><a class="tocitem" href="../../CSAdv/9-Ascend等解构/">能源领域一些仿真软件解构</a></li><li><a class="tocitem" href="../../CSAdv/91-OpenFoam解构/">OpenFoam解构</a></li></ul></li><li><span class="tocitem">Modeling</span><ul><li><a class="tocitem" href="../../Modeling/DE_intro/">DifferentialEquations建模方法</a></li><li><a class="tocitem" href="../../Modeling/MTK_intro/">ModelingToolkit建模方法</a></li><li><a class="tocitem" href="../../Modeling/MTK_register/">ModelingToolkit调用外部函数</a></li><li><a class="tocitem" href="../../Modeling/MTK_tips/">MTK常见问题</a></li><li><a class="tocitem" href="../../Modeling/ModelingTutorial/">组织方程的艺术——组件化（入门）</a></li><li><a class="tocitem" href="../../Modeling/WathMTKdo/">MTK的&quot;前世今生&quot;</a></li><li><a class="tocitem" href="../../Modeling/benchmark_de_mtk/">MTK为什么比DE慢？</a></li><li><a class="tocitem" href="../../Modeling/neural_network/">数学视角下的神经网络</a></li></ul></li><li><span class="tocitem">Simulation</span><ul><li><a class="tocitem" href="../1-微分代数方程/">微分代数方程DAE</a></li><li><a class="tocitem" href="../DE_heattran/">DE求解PDE（对比MTK）</a></li><li><a class="tocitem" href="../MTK_heattran/">MTK手动空间离散求解PDE</a></li><li class="is-active"><a class="tocitem" href>MTK并行计算求解大规模电池阵列</a><ul class="internal"><li><a class="tocitem" href="#为什么使用并行计算"><span>为什么使用并行计算</span></a></li><li><a class="tocitem" href="#.建立锂电池单体的P2D模型"><span>1.建立锂电池单体的P2D模型</span></a></li><li><a class="tocitem" href="#.程序初始化"><span>2.程序初始化</span></a></li><li><a class="tocitem" href="#.计算初始时刻系统参数"><span>3.计算初始时刻系统参数</span></a></li><li><a class="tocitem" href="#.系统显式时间推进迭代计算"><span>4.系统显式时间推进迭代计算</span></a></li><li><a class="tocitem" href="#最终效果"><span>最终效果</span></a></li></ul></li><li><a class="tocitem" href="../componementModel/">组件化建模实例</a></li><li><a class="tocitem" href="../steadyRC/">MTK稳态系统仿真实例</a></li></ul></li><li><span class="tocitem">Optimization</span><ul><li><a class="tocitem" href="../../Optimization/1-优化的概念/">优化的概念</a></li><li><a class="tocitem" href="../../Optimization/2-优化问题的分类/">优化问题的分类</a></li><li><a class="tocitem" href="../../Optimization/3-能源系统工程中的优化问题/">能源系统工程中有哪些优化问题</a></li><li><a class="tocitem" href="../../Optimization/4-优化问题的求解过程/">优化问题的求解过程</a></li><li><a class="tocitem" href="../../Optimization/5-优化问题的建模平台/">优化问题的建模平台</a></li><li><a class="tocitem" href="../../Optimization/6-传统决定性算法简介/">传统决定性算法</a></li><li><a class="tocitem" href="../../Optimization/7-启发式算法简介/">启发式算法简介</a></li><li><a class="tocitem" href="../../Optimization/8-黑箱优化问题/">黑箱优化问题</a></li><li><a class="tocitem" href="../../Optimization/9-优化问题建模之递归建模方法/">优化问题建模之递归建模方法</a></li><li><a class="tocitem" href="../../Optimization/90-优化应用之参数估计与软测量/">优化应用之参数估计与软测量</a></li><li><a class="tocitem" href="../../Optimization/91-优化应用之代理模型/">优化应用之代理模型</a></li><li><a class="tocitem" href="../../Optimization/92-一些可以看一看的优化相关工具/">一些值得看看的工具</a></li><li><a class="tocitem" href="../../Optimization/93-JuMP混合整数线性优化实例/">JuMP混合整数线性优化实例</a></li><li><a class="tocitem" href="../../Optimization/94-JuMP参数辨识/">JuMP非线性参数辨识实例</a></li><li><a class="tocitem" href="../../Optimization/95-微分方程参数辨识实例/">微分方程参数辨识实例</a></li><li><a class="tocitem" href="../../Optimization/96-MTK非线性参数辨识实例/">MTK非线性参数辨识实例</a></li><li><a class="tocitem" href="../../Optimization/97-MTK符号系统参数辨识实例/">MTK符号系统参数辨识</a></li><li><a class="tocitem" href="../../Optimization/98-MTK部分参数辨识实例/">MTK部分参数辨识实例</a></li><li><a class="tocitem" href="../../Optimization/GenSBO/">GenSBO—a General <strong>S</strong>imulation <strong>B</strong>ased <strong>O</strong>ptimizer</a></li><li><a class="tocitem" href="../../Optimization/MIDACO/">MIDACO</a></li><li><a class="tocitem" href="../../Optimization/Optimization.jl/">Optimization.jl</a></li></ul></li><li><span class="tocitem">Control</span><ul><li><a class="tocitem" href="../../Control/1-控制的本质/">控制的本质</a></li><li><a class="tocitem" href="../../Control/JuMPMPC/">JuMP求解MPC问题</a></li><li><a class="tocitem" href="../../Control/KalmanFiltering/">卡尔曼滤波理论与应用</a></li><li><a class="tocitem" href="../../Control/MTKMPC/">MTK求解MPC问题</a></li><li><a class="tocitem" href="../../Control/OptimControl/">最优控制理论与应用</a></li></ul></li><li><span class="tocitem">AIandML</span><ul><li><a class="tocitem" href="../../AIandML/1-机器学习和人工智能/">机器学习</a></li></ul></li><li><span class="tocitem">IotBigdataCloud</span><ul><li><a class="tocitem" href="../../IotBigdataCloud/1-物联网/">物联网</a></li><li><a class="tocitem" href="../../IotBigdataCloud/2-消息件/">物联网的消息件</a></li><li><a class="tocitem" href="../../IotBigdataCloud/3-大数据简介/">大数据简介</a></li><li><a class="tocitem" href="../../IotBigdataCloud/4-从虚拟机到云计算/">从虚拟机到云计算</a></li><li><a class="tocitem" href="../../IotBigdataCloud/5-容器化和k8s/">容器化和k8s</a></li></ul></li><li><span class="tocitem">Frameworks</span><ul><li><a class="tocitem" href="../../Frameworks/Ai4EComponentLib/">Ai4EComponentLib.jl设计理念</a></li><li><a class="tocitem" href="../../Frameworks/OptControl/">OptControl.jl设计理念</a></li></ul></li><li><span class="tocitem">Tools</span><ul><li><a class="tocitem" href="../../Tools/3-ssh-git实操/">SSH、Git与Git图形化软件</a></li><li><a class="tocitem" href="../../Tools/CSV_jl_use/">CSV.jl使用简介</a></li><li><a class="tocitem" href="../../Tools/CoolProp/">CoolProp使用介绍</a></li><li><a class="tocitem" href="../../Tools/vscode_git/">VScode中使用Git</a></li></ul></li><li><span class="tocitem">WorkFlow</span><ul><li><a class="tocitem" href="../../WorkFlow/1-thinkaboutstudy/">教育与学习</a></li><li><a class="tocitem" href="../../WorkFlow/DocStructure/">文档（docs）编写方法</a></li><li><a class="tocitem" href="../../WorkFlow/REPL-of-Julia/">julia 的 REPL</a></li><li><a class="tocitem" href="../../WorkFlow/gitworkflow/">Ai4E组织合作开发流程</a></li><li><a class="tocitem" href="../../WorkFlow/julia_change_pkgserve/">Julia换源(更换国内镜像站)</a></li><li><a class="tocitem" href="../../WorkFlow/julia的安装/">Julia安装</a></li><li><a class="tocitem" href="../../WorkFlow/vscodePlugin/">VScode开发环境配置</a></li></ul></li><li><span class="tocitem">GolangIntro</span><ul><li><a class="tocitem" href="../../GolangIntro/01-golang的安装/">golang的安装</a></li><li><a class="tocitem" href="../../GolangIntro/02-golang的特点/">golang简介</a></li></ul></li><li><span class="tocitem">StepByStep</span><ul><li><a class="tocitem" href="../../StepByStep/01-docker-compose环境准备/">docker-compose环境准备</a></li><li><a class="tocitem" href="../../StepByStep/02-emqx消息服务器准备/">消息服务器准备</a></li><li><a class="tocitem" href="../../StepByStep/03-mysql数据库准备/">数据库准备</a></li><li><a class="tocitem" href="../../StepByStep/04-go-zero环境准备/">准备go-zero环境</a></li><li><a class="tocitem" href="../../StepByStep/05-gateway设置/">GateWay设置</a></li><li><a class="tocitem" href="../../StepByStep/06-goctl生成api服务/">goctl生成api代码</a></li><li><a class="tocitem" href="../../StepByStep/07-goctl处理数据库模型/">goctl根据数据库生成model</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Simulation</a></li><li class="is-active"><a href>MTK并行计算求解大规模电池阵列</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MTK并行计算求解大规模电池阵列</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ai4energy/Ai4EDocs/blob/main/docs/src/Simulation/MTK_parallel_computing.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MTK并行计算求解大规模电池阵列"><a class="docs-heading-anchor" href="#MTK并行计算求解大规模电池阵列">MTK并行计算求解大规模电池阵列</a><a id="MTK并行计算求解大规模电池阵列-1"></a><a class="docs-heading-anchor-permalink" href="#MTK并行计算求解大规模电池阵列" title="Permalink"></a></h1><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Contents：MTK、PDE、并行计算</p><p>Contributor: HY</p><p>Email:1171006975@qq.com</p><p>如有错误，请批评指正。</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>MTK = ModelingToolkit.jl</p><p>PDE = Partial Differential Equation</p><p><a href="https://mtk.sciml.ai/stable/">ModelingToolkit.jl </a>符号建模包</p></div></div><h2 id="为什么使用并行计算"><a class="docs-heading-anchor" href="#为什么使用并行计算">为什么使用并行计算</a><a id="为什么使用并行计算-1"></a><a class="docs-heading-anchor-permalink" href="#为什么使用并行计算" title="Permalink"></a></h2><p>传统的系统建模，往往采用0维模型进行建模(如等效电路法，集中参数法等)，计算量较小，不需要并行计算。但有时候，我们可能不仅仅想研究整个系统的输出特性，还想追踪系统内部各个组件的输出特性。当系统由很多相同的组件(组件参数不一定相同)连接而成时(如上百个电池单体组成的电池阵列，上千个燃料电池单体组成的电堆，超大规模水力管网等)，即使每个单体的计算量很小，但加起来计算量会急剧上升。</p><p>如果我们使用@connector来连接各个组件，组成一个超大规模的矩阵来计算，这在单体数目较少时是可以实现的，但单体数目较多时，很可能会遇到一些瓶颈。这是因为计算时间不是与方程的维度成正比，而是与方程维度的平方成正比。例如，电池阵列中单体数目为100时，计算时间可能是1s，当电池数目为1000时，计算时间可能就变成了100s。更糟糕的是，编译时间和内存占用也是与方程维度的平方成正比！很可能会导致一个现象：编译2小时，计算5秒钟。</p><p>但我们仔细观察，可以发现，系统内部各个组件的联系有时候其实没有那么紧密，例如燃料电池电堆中，各个单体流过的电流是一样的(即具有相同的边界条件)，我们完全可以先算出各个单体的电压，然后再加起来，就是整个电池电堆的电压。这个时候，我们就能采用并行计算的方法，同时计算很多个单体。</p><p>接下来，我将以大规模的电池阵列为例，详细介绍如何实现MTK并行计算。</p><hr/><p>MTK并行计算求解大规模电池阵列有这么几步：</p><ul><li>建立锂电池单体的P2D模型(伪三维模型，空间离散后为DAEs)</li><li>求解各个锂电池单体模型，得到Li浓度等变量值(并行计算)。</li><li>通过戴维南定理，将单体模型等效为一个内阻和一个电压源(并行计算)。</li><li>求解由等效内阻和等效电压源组成的电池阵列电路方程(线性方程组)。</li></ul><p><img src="../../assets/MTK_parallel_computing_1.png" alt="图 1"/>  </p><p>每个步骤的实现方式和原理会在下文进一步展开。</p><hr/><h2 id=".建立锂电池单体的P2D模型"><a class="docs-heading-anchor" href="#.建立锂电池单体的P2D模型">1.建立锂电池单体的P2D模型</a><a id=".建立锂电池单体的P2D模型-1"></a><a class="docs-heading-anchor-permalink" href="#.建立锂电池单体的P2D模型" title="Permalink"></a></h2><p>具体的P2D模型建模过程可参考<a href="https://www.sciencedirect.com/science/article/pii/S0013468621001183">该文献</a>。</p><p>本文中将P2D模型拆成两部分，一部分是固液相模型，用来求电池的空间浓度变化，为ODEs，另一部分是传输线模型，用来求电池的外特性曲线，为NonlinerEqs。在一个时间步长内，我们可以认为电池的浓度是不变的，因此电池的外特性也就固定了，我们可以根据电池外特性将其等效为一个内阻和一个电压源。在每次迭代后，电池的外特性都会发生改变，因此等效内阻和等效电压源的参数是会一直变化的。</p><p>具体的代码文件为<code>P2D_并行_固液相模型.jl</code>和<code>P2D_并行_电路模型.jl</code>。</p><h2 id=".程序初始化"><a class="docs-heading-anchor" href="#.程序初始化">2.程序初始化</a><a id=".程序初始化-1"></a><a class="docs-heading-anchor-permalink" href="#.程序初始化" title="Permalink"></a></h2><pre><code class="nohighlight hljs">using Distributed
addprocs(4)</code></pre><p>开启4个子线程，<code>addprocs(n)</code>表示开启n个子线程。</p><pre><code class="nohighlight hljs">@everywhere begin
    #组件封装
    using SharedArrays, Pkg, LinearAlgebra
    include(&quot;../assets/P2D_并行_固液相模型.jl&quot;)
    include(&quot;../assets/P2D_并行_电路模型.jl&quot;)
    include(&quot;../assets/get_variables_index.jl&quot;)
end</code></pre><p>在每个线程中，都加载一下库和封装的组件。<code>@everywhere</code>表示在每个线程中都执行该代码。<code>get_variables_index.jl</code>用来找到变量对应的下标，以便于在不同<code>Problem</code>之间传递参数值。</p><pre><code class="nohighlight hljs">@everywhere begin
    #参数设置
    series_num = 100
    parallel_num = 2
    t_step = 5
    simulate_time = 2500
    n_mesh_neg = 8
    n_mesh_sep = 8
    n_mesh_pos = 8
    Current = 20 * parallel_num
    Current_standard = 20
    c_s_max_neg = 31390
    c_s_max_pos = 48390
    filename_neg = &quot;../assets/neg_OCV.txt&quot;
    filename_pos = &quot;../assets/pos_OCV.txt&quot;
    r_s_neg = 6.3e-6
    r_s_pos = 2.13e-6
    F = 96485
    R = 8.3145
    T = 293.15
    L_neg = 46.6e-6
    L_sep = 18.7e-6
    L_pos = 43e-6
    eps_s_neg = 0.49
    eps_s_pos = 0.57
    Sa_neg = 3 * eps_s_neg / r_s_neg
    Sa_pos = 3 * eps_s_pos / r_s_pos
    k_ct_neg = 2e-11
    k_ct_pos = 2e-11
    h_neg = L_neg / n_mesh_neg
    h_sep = L_sep / n_mesh_sep
    h_pos = L_pos / n_mesh_pos
    # 创建插值函数
    data_neg = readdlm(filename_neg)
    data_pos = readdlm(filename_pos)
    ocv_neg = LinearInterpolation(data_neg[:, 1], data_neg[:, 2])
    ocv_pos = LinearInterpolation(data_pos[:, 1], data_pos[:, 2])
end</code></pre><p>设置参数，创建插值函数。</p><pre><code class="nohighlight hljs">@everywhere begin
    #电化学方程
    @named batter_chemistry = P2D_Libatter_chemistry(n_mesh_neg=8, n_mesh_sep=8, n_mesh_pos=8)
    @named OdeFun_chemistry = ODESystem([], t)
    @named model_chemistry = compose(OdeFun_chemistry, [batter_chemistry])
    sys_chemistry = structural_simplify(model_chemistry)
    prob_chemistry = ODEProblem(sys_chemistry, [], (0.0, 5.0))
    sol_chemistry = solve(prob_chemistry, CVODE_Adams()).u[end]
    chemistery_index = get_chemistery_index(batter_chemistry, sys_chemistry)
    #传输线方程
    @named batter_electric = P2D_Libatter_electric()
    @named current = Constant(U=Current)
    @named current_source = Current_source()
    @named ground = Ground()
    eqs = [
        connect(batter_electric.n, ground.g, current_source.n)
        connect(batter_electric.p, current_source.p)
        connect(current.u, current_source.u)]
    @named OdeFun_electric = ODESystem(eqs, t)
    @named model_electric = compose(OdeFun_electric, [batter_electric, current, current_source, ground])
    sys_electric = structural_simplify(model_electric)
    prob_electric = NonlinearProblem(ODEProblem(sys_electric, [], (0.0, 0.0), []))
    sol_electric = solve(prob_electric, KINSOL()).u
    electric_index = get_electric_index(batter_electric, sys_electric)
    electric_vi_index = get_electric_vi_index(batter_electric, sys_electric)
end</code></pre><p>初始化固液相浓度方程(ODEs)和传输线方程(NonlinearEqs)。其中ODEs采用Sundials中的<code>CVODE_Adams()</code>方法,NonlinearEqs采用Sundials中的<code>KINSOL()</code>方法(速度非常快)。</p><pre><code class="nohighlight hljs">begin
    #创建共享数组
    electric_para_sharedarrays = SharedArray{Float64}(series_num * parallel_num, 2 * n_mesh_neg + 2 * n_mesh_pos + 4)
    chemistry_para_sharedarrays = SharedArray{Float64}(series_num * parallel_num, 3 * n_mesh_neg + 3 * n_mesh_pos + n_mesh_sep + 5)
    chemistry_last_stats_sharedarrays = SharedArray{Float64}(series_num * parallel_num, length(prob_chemistry.u0))
    electric_last_stats_sharedarrays = SharedArray{Float64}(series_num * parallel_num, length(prob_electric.u0))
    electric_fit_k_sharedarrays = SharedArray{Float64}(series_num * parallel_num, 2)
    equivalent_vi_sharedarrays = SharedArray{Float64}(parallel_num +1)
    electric_i_sharedarrays = SharedArray{Float64}(series_num * parallel_num,Int(floor(simulate_time/t_step+1)))
    electric_v_sharedarrays = SharedArray{Float64}(series_num * parallel_num,Int(floor(simulate_time/t_step+1)))
    iterations_sharedarrays = SharedArray{Int64}(1)
end</code></pre><p>创建共享数组，该数组保存在系统底层。各个线程均能以很快的速度直接访问。</p><h2 id=".计算初始时刻系统参数"><a class="docs-heading-anchor" href="#.计算初始时刻系统参数">3.计算初始时刻系统参数</a><a id=".计算初始时刻系统参数-1"></a><a class="docs-heading-anchor-permalink" href="#.计算初始时刻系统参数" title="Permalink"></a></h2><pre><code class="nohighlight hljs">    time_now = 0
    iterations_sharedarrays[1] = iterations_sharedarrays[1] + 1
    #电化学方程
    @sync @distributed for i in 1:series_num*parallel_num
        chemistry_para_sharedarrays[i, 1:2*n_mesh_neg+2*n_mesh_pos+n_mesh_sep+3] = sol_chemistry[chemistery_index]
        chemistry_last_stats_sharedarrays[i, :] = sol_chemistry
        for j in 2*n_mesh_neg+2*n_mesh_pos+n_mesh_sep+4:3*n_mesh_neg+2*n_mesh_pos+n_mesh_sep+4
            chemistry_para_sharedarrays[i, j] = ocv_neg(chemistry_para_sharedarrays[i, j-(2*n_mesh_neg+2*n_mesh_pos+n_mesh_sep+3)] / c_s_max_neg)
            chemistry_para_sharedarrays[i, j+n_mesh_neg+1] = ocv_pos(chemistry_para_sharedarrays[i, j-(2*n_mesh_neg+2*n_mesh_pos+n_mesh_sep+3)+n_mesh_neg+1] / c_s_max_pos)
        end
        electric_fit_k_sharedarrays[i, :] = inv([-Current_standard 1.0; -Current_standard/2 1.0]) *
                                            reshape([solve(remake(prob_electric, p=[chemistry_para_sharedarrays[i, :]..., Current_standard]), KINSOL()).u[electric_vi_index][1],
                solve(remake(prob_electric, p=[chemistry_para_sharedarrays[i, :]..., Current_standard / 2]), KINSOL()).u[electric_vi_index][1]], (2, 1))
    end
    #等效电路方程
    equivalent_vi_sharedarrays = inv([Diagonal([sum(electric_fit_k_sharedarrays[i*series_num-series_num+1:i*series_num, 1]) for i in 1:parallel_num]) -ones(parallel_num, 1);[ones(parallel_num, 1)... 0.0]]) * 
        [(-sum(electric_fit_k_sharedarrays[(i-1)*series_num+1:i*series_num, 2]) for i in 1:parallel_num)...,-Current];
    electric_i_sharedarrays[:, iterations_sharedarrays[1]] = vcat([ones(series_num)*equivalent_vi_sharedarrays[i] for i in 1:parallel_num]...)
    #传输线方程
    @sync @distributed for i in 1:series_num*parallel_num
        electric_last_stats_sharedarrays[i, :] = solve(remake(prob_electric, p=[chemistry_para_sharedarrays[i, :]..., -electric_i_sharedarrays[i, iterations_sharedarrays[1]]]), KINSOL()).u
        electric_para_sharedarrays[i, 1:n_mesh_neg+n_mesh_pos+2] = electric_last_stats_sharedarrays[i, :][electric_index]
        electric_v_sharedarrays[i, iterations_sharedarrays[1]] = electric_last_stats_sharedarrays[i, :][1]
        electric_para_sharedarrays[i, n_mesh_neg+n_mesh_pos+3:2*n_mesh_neg+2*n_mesh_pos+4] = [
            0.5 * Sa_neg * h_neg * (F * k_ct_neg * (c_s_max_neg - chemistry_para_sharedarrays[i, 1])^0.5 * chemistry_para_sharedarrays[i, 1]^0.5 * chemistry_para_sharedarrays[i, 1+n_mesh_pos+n_mesh_neg+2]^0.5) * (exp(0.5 * F * electric_para_sharedarrays[i, 1] / R / T) - exp(-0.5 * F * electric_para_sharedarrays[i, 1] / R / T)),
            [Sa_neg * h_neg * (F * k_ct_neg * (c_s_max_neg - chemistry_para_sharedarrays[i, j])^0.5 * chemistry_para_sharedarrays[i, j]^0.5 * chemistry_para_sharedarrays[i, j+n_mesh_pos+n_mesh_neg+2]^0.5) * (exp(0.5 * F * electric_para_sharedarrays[i, j] / R / T) - exp(-0.5 * F * electric_para_sharedarrays[i, j] / R / T)) for j in 2:n_mesh_neg]...,
            0.5 * Sa_neg * h_neg * (F * k_ct_neg * (c_s_max_neg - chemistry_para_sharedarrays[i, n_mesh_neg+1])^0.5 * chemistry_para_sharedarrays[i, n_mesh_neg+1]^0.5 * chemistry_para_sharedarrays[i, n_mesh_neg+1+n_mesh_pos+n_mesh_neg+2]^0.5) * (exp(0.5 * F * electric_para_sharedarrays[i, n_mesh_neg+1] / R / T) - exp(-0.5 * F * electric_para_sharedarrays[i, n_mesh_neg+1] / R / T)),
            0.5 * Sa_pos * h_pos * (F * k_ct_pos * (c_s_max_pos - chemistry_para_sharedarrays[i, 1+n_mesh_neg+1])^0.5 * chemistry_para_sharedarrays[i, 1+n_mesh_neg+1]^0.5 * chemistry_para_sharedarrays[i, 1+n_mesh_pos+n_mesh_neg+2+n_mesh_neg+1]^0.5) * (exp(0.5 * F * electric_para_sharedarrays[i, 1+n_mesh_neg+1] / R / T) - exp(-0.5 * F * electric_para_sharedarrays[i, 1+n_mesh_neg+1] / R / T)),
            [Sa_pos * h_pos * (F * k_ct_pos * (c_s_max_pos - chemistry_para_sharedarrays[i, j+n_mesh_neg+1])^0.5 * chemistry_para_sharedarrays[i, j+n_mesh_neg+1]^0.5 * chemistry_para_sharedarrays[i, j+n_mesh_pos+n_mesh_neg+2+n_mesh_neg+1]^0.5) * (exp(0.5 * F * electric_para_sharedarrays[i, j+n_mesh_neg+1] / R / T) - exp(-0.5 * F * electric_para_sharedarrays[i, j+n_mesh_neg+1] / R / T)) for j in 2:n_mesh_pos]...,
            0.5 * Sa_pos * h_pos * (F * k_ct_pos * (c_s_max_pos - chemistry_para_sharedarrays[i, n_mesh_neg+1+n_mesh_neg+1])^0.5 * chemistry_para_sharedarrays[i, n_mesh_neg+1+n_mesh_neg+1]^0.5 * chemistry_para_sharedarrays[i, n_mesh_neg+1+n_mesh_pos+n_mesh_neg+2+n_mesh_neg+1]^0.5) * (exp(0.5 * F * electric_para_sharedarrays[i, n_mesh_neg+1+n_mesh_neg+1] / R / T) - exp(-0.5 * F * electric_para_sharedarrays[i, n_mesh_neg+1+n_mesh_neg+1] / R / T))]
    end</code></pre><p>代码分别计算了锂电池模型的浓度，外特性，等效内阻和等效电压源。其中<code>@distributed</code>表示分布式计算，例如for i in 1:100，如果有四个线程，那么在各个线程中，i可能就是1:25,26:50,51:75,76:100。上文说过，各个电池单体相对独立，那么我们可以将电池阵列组装为一个数组，然后调用<code>@distributed</code>进行并行计算。<code>@sync</code>表示执行完该代码后，再执行下一行代码。因为<code>@distributed</code>本身是一个异步指令，子线程执行的同时，主线程会继续执行下一行代码。因此我们需要&quot;等等&quot;子线程。</p><h2 id=".系统显式时间推进迭代计算"><a class="docs-heading-anchor" href="#.系统显式时间推进迭代计算">4.系统显式时间推进迭代计算</a><a id=".系统显式时间推进迭代计算-1"></a><a class="docs-heading-anchor-permalink" href="#.系统显式时间推进迭代计算" title="Permalink"></a></h2><pre><code class="nohighlight hljs">while time_now &lt; 2500
    #loop
    iterations_sharedarrays[1] = iterations_sharedarrays[1] + 1
    time_now = time_now + t_step
    #电化学方程
    @sync @distributed for i in 1:series_num*parallel_num
        chemistry_last_stats_sharedarrays[i, :] = solve(remake(prob_chemistry, u0=chemistry_last_stats_sharedarrays[i, :], p=electric_para_sharedarrays[i, :]), CVODE_Adams()).u[end]
        chemistry_para_sharedarrays[i, 1:2*n_mesh_neg+2*n_mesh_pos+n_mesh_sep+3] = chemistry_last_stats_sharedarrays[i, :][chemistery_index]
        for j in 2*n_mesh_neg+2*n_mesh_pos+n_mesh_sep+4:3*n_mesh_neg+2*n_mesh_pos+n_mesh_sep+4
            chemistry_para_sharedarrays[i, j] = ocv_neg(chemistry_para_sharedarrays[i, j-(2*n_mesh_neg+2*n_mesh_pos+n_mesh_sep+3)] / c_s_max_neg)
            chemistry_para_sharedarrays[i, j+n_mesh_neg+1] = ocv_pos(chemistry_para_sharedarrays[i, j-(2*n_mesh_neg+2*n_mesh_pos+n_mesh_sep+3)+n_mesh_neg+1] / c_s_max_pos)
        end
        electric_fit_k_sharedarrays[i, :] = inv([-Current_standard 1.0; -Current_standard/2 1.0]) *
                                            [solve(remake(prob_electric, u0=electric_last_stats_sharedarrays[i, :], p=[chemistry_para_sharedarrays[i, :]..., Current_standard]), KINSOL()).u[electric_vi_index][1]
            solve(remake(prob_electric, u0=electric_last_stats_sharedarrays[i, :], p=[chemistry_para_sharedarrays[i, :]..., Current_standard / 2]), KINSOL()).u[electric_vi_index][1]]
    end
    #等效电路方程
    equivalent_vi_sharedarrays = inv([Diagonal([sum(electric_fit_k_sharedarrays[i*series_num-series_num+1:i*series_num, 1]) for i in 1:parallel_num]) -ones(parallel_num, 1);[ones(parallel_num, 1)... 0.0]]) * 
        [(-sum(electric_fit_k_sharedarrays[(i-1)*series_num+1:i*series_num, 2]) for i in 1:parallel_num)...,-Current];
    electric_i_sharedarrays[:, iterations_sharedarrays[1]] = vcat([ones(series_num)*equivalent_vi_sharedarrays[i] for i in 1:parallel_num]...)
    #传输线方程
    @sync @distributed for i in 1:series_num*parallel_num
        electric_last_stats_sharedarrays[i, :] = solve(remake(prob_electric, u0=electric_last_stats_sharedarrays[i, :], p=[chemistry_para_sharedarrays[i, :]..., -electric_i_sharedarrays[i, iterations_sharedarrays[1]]]), KINSOL()).u
        electric_para_sharedarrays[i, 1:n_mesh_neg+n_mesh_pos+2] = electric_last_stats_sharedarrays[i, :][electric_index]
        electric_v_sharedarrays[i, iterations_sharedarrays[1]] = electric_last_stats_sharedarrays[i, :][1]
        electric_para_sharedarrays[i, n_mesh_neg+n_mesh_pos+3:2*n_mesh_neg+2*n_mesh_pos+4] = [
            0.5 * Sa_neg * h_neg * (F * k_ct_neg * (c_s_max_neg - chemistry_para_sharedarrays[i, 1])^0.5 * chemistry_para_sharedarrays[i, 1]^0.5 * chemistry_para_sharedarrays[i, 1+n_mesh_pos+n_mesh_neg+2]^0.5) * (exp(0.5 * F * electric_para_sharedarrays[i, 1] / R / T) - exp(-0.5 * F * electric_para_sharedarrays[i, 1] / R / T)),
            [Sa_neg * h_neg * (F * k_ct_neg * (c_s_max_neg - chemistry_para_sharedarrays[i, j])^0.5 * chemistry_para_sharedarrays[i, j]^0.5 * chemistry_para_sharedarrays[i, j+n_mesh_pos+n_mesh_neg+2]^0.5) * (exp(0.5 * F * electric_para_sharedarrays[i, j] / R / T) - exp(-0.5 * F * electric_para_sharedarrays[i, j] / R / T)) for j in 2:n_mesh_neg]...,
            0.5 * Sa_neg * h_neg * (F * k_ct_neg * (c_s_max_neg - chemistry_para_sharedarrays[i, n_mesh_neg+1])^0.5 * chemistry_para_sharedarrays[i, n_mesh_neg+1]^0.5 * chemistry_para_sharedarrays[i, n_mesh_neg+1+n_mesh_pos+n_mesh_neg+2]^0.5) * (exp(0.5 * F * electric_para_sharedarrays[i, n_mesh_neg+1] / R / T) - exp(-0.5 * F * electric_para_sharedarrays[i, n_mesh_neg+1] / R / T)),
            0.5 * Sa_pos * h_pos * (F * k_ct_pos * (c_s_max_pos - chemistry_para_sharedarrays[i, 1+n_mesh_neg+1])^0.5 * chemistry_para_sharedarrays[i, 1+n_mesh_neg+1]^0.5 * chemistry_para_sharedarrays[i, 1+n_mesh_pos+n_mesh_neg+2+n_mesh_neg+1]^0.5) * (exp(0.5 * F * electric_para_sharedarrays[i, 1+n_mesh_neg+1] / R / T) - exp(-0.5 * F * electric_para_sharedarrays[i, 1+n_mesh_neg+1] / R / T)),
            [Sa_pos * h_pos * (F * k_ct_pos * (c_s_max_pos - chemistry_para_sharedarrays[i, j+n_mesh_neg+1])^0.5 * chemistry_para_sharedarrays[i, j+n_mesh_neg+1]^0.5 * chemistry_para_sharedarrays[i, j+n_mesh_pos+n_mesh_neg+2+n_mesh_neg+1]^0.5) * (exp(0.5 * F * electric_para_sharedarrays[i, j+n_mesh_neg+1] / R / T) - exp(-0.5 * F * electric_para_sharedarrays[i, j+n_mesh_neg+1] / R / T)) for j in 2:n_mesh_pos]...,
            0.5 * Sa_pos * h_pos * (F * k_ct_pos * (c_s_max_pos - chemistry_para_sharedarrays[i, n_mesh_neg+1+n_mesh_neg+1])^0.5 * chemistry_para_sharedarrays[i, n_mesh_neg+1+n_mesh_neg+1]^0.5 * chemistry_para_sharedarrays[i, n_mesh_neg+1+n_mesh_pos+n_mesh_neg+2+n_mesh_neg+1]^0.5) * (exp(0.5 * F * electric_para_sharedarrays[i, n_mesh_neg+1+n_mesh_neg+1] / R / T) - exp(-0.5 * F * electric_para_sharedarrays[i, n_mesh_neg+1+n_mesh_neg+1] / R / T))]
    end
end</code></pre><p>没啥好说的，时间方向上的迭代推进。</p><h2 id="最终效果"><a class="docs-heading-anchor" href="#最终效果">最终效果</a><a id="最终效果-1"></a><a class="docs-heading-anchor-permalink" href="#最终效果" title="Permalink"></a></h2><p><img src="../../assets/MTK_parallel_computing_2.png" alt="图 2"/> </p><p>如果采用MTK直接建立电池阵列的模型，那么计算时间与(单体数目)^2乘正比，如果采用并行计算，计算时间与(单体数目)^1乘正比。</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../MTK_heattran/">« MTK手动空间离散求解PDE</a><a class="docs-footer-nextpage" href="../componementModel/">组件化建模实例 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 1 September 2023 06:49">Friday 1 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
