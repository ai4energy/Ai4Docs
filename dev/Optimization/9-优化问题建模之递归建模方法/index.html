<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>优化问题建模之递归建模方法 · Ai4EDocs</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/css/ai4e.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Ai4EDocs logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Ai4EDocs</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">CSBase</span><ul><li><a class="tocitem" href="../../CSBase/1-Windows命令提示符介绍/">Windows的命令提示符简介</a></li><li><a class="tocitem" href="../../CSBase/2-PowerShell和WindowsTerminal/">PowerShell和Windows Terminal</a></li><li><a class="tocitem" href="../../CSBase/3-环境变量及其设置/">环境变量简介</a></li><li><a class="tocitem" href="../../CSBase/4-Windows下安装gcc编译器和CLion/">Windows下安装gcc编译器和CLion</a></li><li><a class="tocitem" href="../../CSBase/5-make和Makefile介绍/">make和Makefile介绍</a></li><li><a class="tocitem" href="../../CSBase/6-静态链接库和动态链接库/">静态链接库和动态链接库</a></li><li><a class="tocitem" href="../../CSBase/7-以SAM为例整体实操一下/">以SAM为例实操</a></li><li><a class="tocitem" href="../../CSBase/8-以CoolProp为例的实操/">以CoolProp为例的实操</a></li><li><a class="tocitem" href="../../CSBase/9-dll生成与调用实操/">动态链接库(DLL)的生成与调用实操</a></li></ul></li><li><span class="tocitem">JuliaIntro</span><ul><li><a class="tocitem" href="../../JuliaIntro/1-julia的安装/">julia的安装</a></li><li><a class="tocitem" href="../../JuliaIntro/2-julia的REPL/">julia的REPL</a></li><li><a class="tocitem" href="../../JuliaIntro/3-julia的语法要点/">julia的语法要点</a></li><li><a class="tocitem" href="../../JuliaIntro/4-julia的包管理/">julia的包管理</a></li><li><a class="tocitem" href="../../JuliaIntro/5-julia的环境/">julia的环境</a></li><li><a class="tocitem" href="../../JuliaIntro/6-创建julia包/">创建julia包</a></li><li><a class="tocitem" href="../../JuliaIntro/7-julia的类型系统/">julia的类型系统</a></li><li><a class="tocitem" href="../../JuliaIntro/8-julia的元编程/">julia的元编程</a></li><li><a class="tocitem" href="../../JuliaIntro/9-ijulia/">IJulia</a></li><li><a class="tocitem" href="../../JuliaIntro/91- julia-binary-wrappers/">julia对外部程序的加壳</a></li></ul></li><li><span class="tocitem">CSAdv</span><ul><li><a class="tocitem" href="../../CSAdv/1-过程抽象/">过程抽象</a></li><li><a class="tocitem" href="../../CSAdv/2-数据抽象/">数据抽象</a></li><li><a class="tocitem" href="../../CSAdv/3-再说说递归/">再说说递归</a></li><li><a class="tocitem" href="../../CSAdv/4-从符号到模型/">从符号到模型</a></li><li><a class="tocitem" href="../../CSAdv/5-抽象语法树/">抽象语法树</a></li><li><a class="tocitem" href="../../CSAdv/6-代码生成/">代码生成</a></li><li><a class="tocitem" href="../../CSAdv/7-领域特定语言/">领域特定语言DSL</a></li><li><a class="tocitem" href="../../CSAdv/8-写个库还是创个语言/">写个库还是创个语言</a></li><li><a class="tocitem" href="../../CSAdv/9-Ascend等解构/">能源领域一些仿真软件解构</a></li><li><a class="tocitem" href="../../CSAdv/91-OpenFoam解构/">OpenFoam解构</a></li></ul></li><li><span class="tocitem">Modeling</span><ul><li><a class="tocitem" href="../../Modeling/DE_intro/">DifferentialEquations建模方法</a></li><li><a class="tocitem" href="../../Modeling/MTK_intro/">ModelingToolkit建模方法</a></li><li><a class="tocitem" href="../../Modeling/MTK_register/">ModelingToolkit调用外部函数</a></li><li><a class="tocitem" href="../../Modeling/MTK_tips/">MTK常见问题</a></li><li><a class="tocitem" href="../../Modeling/ModelingTutorial/">组织方程的艺术——组件化（入门）</a></li><li><a class="tocitem" href="../../Modeling/WathMTKdo/">MTK的&quot;前世今生&quot;</a></li><li><a class="tocitem" href="../../Modeling/neural_network/">数学视角下的神经网络</a></li></ul></li><li><span class="tocitem">Simulation</span><ul><li><a class="tocitem" href="../../Simulation/1-微分代数方程/">微分代数方程DAE</a></li><li><a class="tocitem" href="../../Simulation/DE_heattran/">DE求解PDE（对比MTK）</a></li><li><a class="tocitem" href="../../Simulation/MTK_heattran/">MTK手动空间离散求解PDE</a></li><li><a class="tocitem" href="../../Simulation/componementModel/">组件化建模实例</a></li><li><a class="tocitem" href="../../Simulation/steadyRC/">MTK稳态系统仿真实例</a></li></ul></li><li><span class="tocitem">Optimization</span><ul><li><a class="tocitem" href="../1-优化的概念/">优化的概念</a></li><li><a class="tocitem" href="../2-优化问题的分类/">优化问题的分类</a></li><li><a class="tocitem" href="../3-能源系统工程中的优化问题/">能源系统工程中有哪些优化问题</a></li><li><a class="tocitem" href="../4-优化问题的求解过程/">优化问题的求解过程</a></li><li><a class="tocitem" href="../5-优化问题的建模平台/">优化问题的建模平台</a></li><li><a class="tocitem" href="../6-传统决定性算法简介/">传统决定性算法</a></li><li><a class="tocitem" href="../7-启发式算法简介/">启发式算法简介</a></li><li><a class="tocitem" href="../8-黑箱优化问题/">黑箱优化问题</a></li><li class="is-active"><a class="tocitem" href>优化问题建模之递归建模方法</a><ul class="internal"><li><a class="tocitem" href="#递归与plasmo.jl的思想"><span>递归与plasmo.jl的思想</span></a></li><li><a class="tocitem" href="#Plasmo.jl的相关信息"><span>Plasmo.jl的相关信息</span></a></li></ul></li><li><a class="tocitem" href="../90-优化应用之参数估计与软测量/">优化应用之参数估计与软测量</a></li><li><a class="tocitem" href="../91-优化应用之代理模型/">优化应用之代理模型</a></li><li><a class="tocitem" href="../92-一些可以看一看的优化相关工具/">一些值得看看的工具</a></li><li><a class="tocitem" href="../93-JuMP混合整数线性优化实例/">JuMP混合整数线性优化实例</a></li><li><a class="tocitem" href="../94-JuMP参数辨识/">JuMP非线性参数辨识实例</a></li><li><a class="tocitem" href="../95-微分方程参数辨识实例/">微分方程参数辨识实例</a></li><li><a class="tocitem" href="../96-MTK非线性参数辨识实例/">MTK非线性参数辨识实例</a></li><li><a class="tocitem" href="../97-MTK符号系统参数辨识实例/">MTK符号系统参数辨识</a></li><li><a class="tocitem" href="../98-MTK部分参数辨识实例/">MTK部分参数辨识实例</a></li></ul></li><li><span class="tocitem">Control</span><ul><li><a class="tocitem" href="../../Control/1-控制的本质/">控制的本质</a></li><li><a class="tocitem" href="../../Control/JuMPMPC/">JuMP求解MPC问题</a></li><li><a class="tocitem" href="../../Control/KalmanFiltering/">卡尔曼滤波理论与应用</a></li><li><a class="tocitem" href="../../Control/MTKMPC/">MTK求解MPC问题</a></li><li><a class="tocitem" href="../../Control/OptimControl/">最优控制理论与应用</a></li></ul></li><li><span class="tocitem">AIandML</span><ul><li><a class="tocitem" href="../../AIandML/1-机器学习和人工智能/">机器学习</a></li></ul></li><li><span class="tocitem">IotBigdataCloud</span><ul><li><a class="tocitem" href="../../IotBigdataCloud/1-物联网/">物联网</a></li><li><a class="tocitem" href="../../IotBigdataCloud/2-消息件/">物联网的消息件</a></li><li><a class="tocitem" href="../../IotBigdataCloud/3-大数据简介/">大数据简介</a></li><li><a class="tocitem" href="../../IotBigdataCloud/4-从虚拟机到云计算/">从虚拟机到云计算</a></li><li><a class="tocitem" href="../../IotBigdataCloud/5-容器化和k8s/">容器化和k8s</a></li></ul></li><li><span class="tocitem">Frameworks</span><ul><li><a class="tocitem" href="../../Frameworks/Ai4EComponentLib/">Ai4EComponentLib.jl设计理念</a></li><li><a class="tocitem" href="../../Frameworks/OptControl/">OptControl.jl设计理念</a></li></ul></li><li><span class="tocitem">Tools</span><ul><li><a class="tocitem" href="../../Tools/3-ssh-git实操/">SSH、Git与Git图形化软件</a></li><li><a class="tocitem" href="../../Tools/CSV_jl_use/">CSV.jl使用简介</a></li><li><a class="tocitem" href="../../Tools/CoolProp/">CoolProp使用介绍</a></li><li><a class="tocitem" href="../../Tools/vscode_git/">VScode中使用Git</a></li></ul></li><li><span class="tocitem">WorkFlow</span><ul><li><a class="tocitem" href="../../WorkFlow/1-thinkaboutstudy/">教育与学习</a></li><li><a class="tocitem" href="../../WorkFlow/DocStructure/">文档（docs）编写方法</a></li><li><a class="tocitem" href="../../WorkFlow/REPL-of-Julia/">julia 的 REPL</a></li><li><a class="tocitem" href="../../WorkFlow/gitworkflow/">Ai4E组织合作开发流程</a></li><li><a class="tocitem" href="../../WorkFlow/julia_change_pkgserve/">Julia换源(更换国内镜像站)</a></li><li><a class="tocitem" href="../../WorkFlow/julia的安装/">Julia安装</a></li><li><a class="tocitem" href="../../WorkFlow/vscodePlugin/">VScode开发环境配置</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Optimization</a></li><li class="is-active"><a href>优化问题建模之递归建模方法</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>优化问题建模之递归建模方法</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ai4energy/Ai4EDocs/blob/main/docs/src/Optimization/9-优化问题建模之递归建模方法.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="优化问题建模之递归建模方法"><a class="docs-heading-anchor" href="#优化问题建模之递归建模方法">优化问题建模之递归建模方法</a><a id="优化问题建模之递归建模方法-1"></a><a class="docs-heading-anchor-permalink" href="#优化问题建模之递归建模方法" title="Permalink"></a></h1><h2 id="递归与plasmo.jl的思想"><a class="docs-heading-anchor" href="#递归与plasmo.jl的思想">递归与plasmo.jl的思想</a><a id="递归与plasmo.jl的思想-1"></a><a class="docs-heading-anchor-permalink" href="#递归与plasmo.jl的思想" title="Permalink"></a></h2><p>还记得我们之前提到过的有理数计算吗？当我们之前提到有理数计算时，我们可以构建一个结构体来表示有理数，其中有理数由分子和分母组成。我们可以定义相应的运算符函数来进行有理数的运算，并返回新的有理数类型的实例。同样地，我们在优化问题建模中也可以采用类似的思路。</p><p>plasmo.jl 是一个基于 Julia 语言的优化建模库，它底层使用了 JuMP.jl。plasmo.jl 的核心概念是将一个优化系统定义为一个图。图由多个子图构成，而子图可以定义决策变量、约束和优化目标。子图和子图之间可以连接，并且连接具有不同的类型。实质上，连接是为了补充子图之间的变量之间的约束关系。</p><p>在 plasmo.jl 中，子图的决策变量是由子图各自的决策变量的并集组成。约束是子图原有约束的并集再加上连接约束。目标函数的定义则是子图目标函数的加和，因为我们处理的是单目标优化问题。可以将子图的目标函数看作是局部目标函数对整体目标函数的贡献。例如，对于能源系统的成本计算，我们可以将各子图的成本作为局部目标函数，然后将它们相加得到整体的目标函数。</p><p>综上所述，plasmo.jl 提供了一个灵活的图模型来描述优化系统，其中子图代表了特定的决策变量、约束和目标函数。子图之间的连接用于约束变量之间的关系。通过这种方式，我们可以构建一个整体的图，其中决策变量是各个子图决策变量的并集，约束是原有约束的并集加上连接约束，目标函数是各子图目标函数的加和。这种建模方式能够更好地表示复杂优化问题，并利用图的结构进行优化求解。</p><p><strong>递归思想</strong></p><p>递归是有理数计算和优化问题建模中的核心思想之一。在有理数计算中，递归可以用于实现分数的化简、相加、相减、相乘和相除等操作。通过递归的方式，可以不断地将复杂的运算拆解为更简单的子问题，并最终得到结果。</p><p>类似地，在优化问题建模中，递归思想也可以应用。优化问题往往可以分解为多个子问题，并将它们通过递归的方式进行组合和求解。每个子问题可以被视为一个独立的优化子图，其中包含决策变量、约束和目标函数。然后，通过连接子图之间的变量和约束，可以形成一个更大的图，并在整体图上进行优化求解。</p><p>递归的优势在于它能够处理复杂的问题，并将问题分解为更小的子问题。这种分解和组合的过程可以提供更好的问题结构表示，并且可以利用问题的局部性质进行优化搜索。通过递归的思想，我们可以将复杂的优化问题分解为多个子问题，并逐步解决每个子问题，最终得到整体的优化结果。</p><p>总结起来，递归是有理数计算和优化问题建模中的重要思想。它能够帮助我们处理复杂的问题，并通过分解和组合子问题的方式，提供更好的问题表示和优化求解的能力。</p><p><strong>建模的时候从子图开始，逐级建立，就好比列出有理数的四则运算表达式。</strong></p><p>整个建模过程类似于逐级建立子图并最终构建整体优化模型的过程。这种方法可以类比于列出有理数的四则运算表达式，其中每个子图对应于运算中的一个操作或子表达式。</p><p>在建模过程中，我们可以从最基本的子图开始，定义决策变量、约束和目标函数。这些子图可以代表优化问题的局部部分，例如某个子系统、某个环节或某个决策变量集合。然后，我们通过连接子图之间的变量和约束，逐级构建更大的子图，直到形成整体优化模型。</p><p>类似于有理数的四则运算表达式，我们可以将子图之间的连接视为运算符，用于描述变量之间的关系和约束。通过连接，我们可以将不同子图的决策变量和约束进行整合，并确保它们在整个优化模型中的一致性。</p><p>这种逐级建立子图的方法可以帮助我们分解复杂的优化问题，并将其组织为层次结构。每个子图对应于一个局部问题，可以更容易地进行建模和分析。同时，通过连接子图，我们能够构建出整体的优化模型，以便进行综合的优化求解。</p><p>需要注意的是，在建立子图和连接时，我们需要考虑子图之间的相互作用和约束，以确保整体模型的准确性和一致性。合理的子图划分和连接策略可以提高问题的可解性和求解效率，并使建模过程更加简洁和可管理。</p><p><strong>利用递归对整体优化问题展平</strong></p><p>递归在有理数计算表达式求值和整体优化问题展平中都起着重要的作用。</p><p>在有理数计算中，递归可以用于对表达式进行求值。当遇到复杂的表达式时，可以通过递归的方式将其分解为更简单的子表达式，并依次对子表达式进行求值，最终得到整个表达式的结果。递归的思想允许我们逐级展开表达式，直到达到基本的有理数计算操作。</p><p>类似地，在整体优化问题中，递归可以用于展平问题的层次结构。当优化问题包含多个层次的子问题或子图时，我们可以通过递归的方式将其展平为单层的问题。递归地处理每个子问题，将其转化为独立的决策变量、约束和目标函数，并最终将所有子问题的变量和约束整合到一个层次的优化模型中。</p><p>通过递归展平优化问题，我们可以减少问题的复杂性，并将其转化为更简单的形式。这有助于更好地理解问题结构，减少建模和求解的复杂度，并提供更高效的优化算法。递归展平可以使优化问题更易于理解、分析和求解，并为问题的优化求解提供更有效的方法。</p><p>需要注意的是，递归展平优化问题时，需要考虑子问题之间的相互作用和约束，以确保整体模型的一致性和有效性。适当的递归策略和合理的子问题划分可以使优化问题的求解更加高效和可行。</p><p>综上所述，递归在有理数计算表达式求值和整体优化问题展平中都发挥着关键作用。它们都利用递归的思想将复杂的问题分解为更简单的子问题，并通过逐级处理子问题来实现问题求解。</p><p><strong>我们以在操场上列队来类比一下</strong></p><p>我们在操场上排队的时候，按学院、班级、宿舍的顺序进行了排队，但是在主席台上的人看来，就只有第几行第几列的队员。这就是建立模型和模型展平。</p><p>在操场上列队的过程可以类比为一个层次化的结构，按学院、班级和宿舍的顺序进行排队。在这个层次化的结构中，每个层次都有一定的组织和规则，例如学院内按照班级划分，班级内按照宿舍划分。</p><p>当我们将这个列队过程建立为一个模型时，我们可以使用层次化的方式进行建模，将学院、班级和宿舍作为模型中的子结构。每个子结构都有自己的决策变量（队员的位置）、约束（按照规则排队）和目标函数（如最小化队伍长度）。</p><p>然而，对于主席台上的人来说，他们只看到一排一排的队员，而不知道具体的层次结构。这就是模型展平的概念。在模型展平过程中，我们将整个层次化的结构简化为一系列队员的排列顺序。对于主席台上的人来说，他们只需要知道每个队员在队伍中的位置即可，而无需关心队员所属的学院、班级和宿舍。</p><p>在优化问题中，建立模型类似于操场上的层次化排队，将问题分解为多个子问题，并为每个子问题定义决策变量、约束和目标函数。然后，通过模型展平的过程，将问题简化为一个整体的优化模型，只关注决策变量的排列顺序和其相互之间的约束关系。</p><p>这种建模和展平的思想可以帮助我们理清复杂问题的结构，减少问题的复杂性，并将问题转化为更简单的形式进行优化求解。同时，模型展平也有助于提高求解效率，简化优化算法的实现和应用。</p><p>总而言之，操场上的排队过程提供了一个生动的类比，帮助我们理解建模和模型展平的概念。通过层次化建模和模型展平，我们可以更好地处理复杂问题，并为问题的优化求解提供有效的方法。</p><h2 id="Plasmo.jl的相关信息"><a class="docs-heading-anchor" href="#Plasmo.jl的相关信息">Plasmo.jl的相关信息</a><a id="Plasmo.jl的相关信息-1"></a><a class="docs-heading-anchor-permalink" href="#Plasmo.jl的相关信息" title="Permalink"></a></h2><p>项目网址：<a href="https://github.com/plasmo-dev/Plasmo.jl">https://github.com/plasmo-dev/Plasmo.jl</a>。</p><p>开发组织：<a href="https://zavalab.engr.wisc.edu/">https://zavalab.engr.wisc.edu/</a>。</p><p>博士论文: <a href="https://www.proquest.com/docview/2434727631?pq-origsite=gscholar&amp;fromopenview=true">Graph-Based Modeling and Simulation of Cyber-Physical Systems</a>。</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../8-黑箱优化问题/">« 黑箱优化问题</a><a class="docs-footer-nextpage" href="../90-优化应用之参数估计与软测量/">优化应用之参数估计与软测量 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 17 July 2023 05:04">Monday 17 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
