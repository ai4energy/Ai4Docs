<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>JuMP混合整数线性优化实例 · Ai4EDocs</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/css/ai4e.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Ai4EDocs logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Ai4EDocs</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Modeling</span><ul><li><a class="tocitem" href="../../Modeling/DE_intro/">DifferentialEquations建模方法</a></li><li><a class="tocitem" href="../../Modeling/MTK_intro/">ModelingToolkit建模方法</a></li><li><a class="tocitem" href="../../Modeling/MTK_register/">ModelingToolkit调用外部函数</a></li><li><a class="tocitem" href="../../Modeling/MTK_tips/">MTK常见问题</a></li><li><a class="tocitem" href="../../Modeling/ModelingTutorial/">组织方程的艺术——组件化（入门）</a></li><li><a class="tocitem" href="../../Modeling/WathMTKdo/">MTK的&quot;前世今生&quot;</a></li><li><a class="tocitem" href="../../Modeling/neural_network/">数学视角下的神经网络</a></li></ul></li><li><span class="tocitem">Simulation</span><ul><li><a class="tocitem" href="../../Simulation/DE_heattran/">DE求解PDE（对比MTK）</a></li><li><a class="tocitem" href="../../Simulation/MTK_heattran/">MTK手动空间离散求解PDE</a></li><li><a class="tocitem" href="../../Simulation/componementModel/">组件化建模实例</a></li><li><a class="tocitem" href="../../Simulation/steadyRC/">MTK稳态系统仿真实例</a></li></ul></li><li><span class="tocitem">Optimization</span><ul><li><a class="tocitem" href="../DE_Estim/">微分方程参数辨识实例</a></li><li><a class="tocitem" href="../JuMP参数辨识/">JuMP非线性参数辨识实例</a></li><li class="is-active"><a class="tocitem" href>JuMP混合整数线性优化实例</a><ul class="internal"><li><a class="tocitem" href="#问题简介"><span>问题简介</span></a></li><li><a class="tocitem" href="#优化问题的数学表达"><span>优化问题的数学表达</span></a></li><li><a class="tocitem" href="#JuMP求解代码"><span>JuMP求解代码</span></a></li><li><a class="tocitem" href="#小结"><span>小结</span></a></li></ul></li><li><a class="tocitem" href="../systemParaEste/">MTK符号系统参数辨识</a></li><li><a class="tocitem" href="../systemParaEste_batter/">MTK部分参数辨识实例</a></li><li><a class="tocitem" href="../参数辨识实例_MTK/">MTK非线性参数辨识实例</a></li></ul></li><li><span class="tocitem">Control</span><ul><li><a class="tocitem" href="../../Control/JuMPMPC/">JuMP求解MPC问题</a></li><li><a class="tocitem" href="../../Control/KalmanFiltering/">卡尔曼滤波理论与应用</a></li><li><a class="tocitem" href="../../Control/MTKMPC/">MTK求解MPC问题</a></li><li><a class="tocitem" href="../../Control/OptimControl/">最优控制理论与应用</a></li></ul></li><li><span class="tocitem">Frameworks</span><ul><li><a class="tocitem" href="../../Frameworks/Ai4EComponentLib/">Ai4EComponentLib.jl设计理念</a></li><li><a class="tocitem" href="../../Frameworks/OptControl/">OptControl.jl设计理念</a></li></ul></li><li><span class="tocitem">CS Base</span><ul><li><a class="tocitem" href="../../CS Base/Creat and Call dll/">动态链接库(DLL)的生成与调用</a></li><li><a class="tocitem" href="../../CS Base/SSH_Git/">SSH、Git与Git图形化软件</a></li><li><a class="tocitem" href="../../CS Base/env_variable/">环境（变量）的本质</a></li></ul></li><li><span class="tocitem">Tools</span><ul><li><a class="tocitem" href="../../Tools/CSV_jl_use/">CSV.jl使用简介</a></li><li><a class="tocitem" href="../../Tools/CoolProp/">CoolProp使用介绍</a></li><li><a class="tocitem" href="../../Tools/vscode_git/">VScode中使用Git</a></li></ul></li><li><span class="tocitem">WorkFlow</span><ul><li><a class="tocitem" href="../../WorkFlow/DocStructure/">文档（docs）编写方法</a></li><li><a class="tocitem" href="../../WorkFlow/gitworkflow/">Ai4E组织合作开发流程</a></li><li><a class="tocitem" href="../../WorkFlow/julia_change_pkgserve/">Julia换源(更换国内镜像站)</a></li><li><a class="tocitem" href="../../WorkFlow/julia的安装/">Julia安装</a></li><li><a class="tocitem" href="../../WorkFlow/vscodePlugin/">VScode开发环境配置</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Optimization</a></li><li class="is-active"><a href>JuMP混合整数线性优化实例</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>JuMP混合整数线性优化实例</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ai4energy/Ai4EDocs/blob/main/docs/src/Optimization/JumpMILP.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="JuMP混合整数线性优化实例"><a class="docs-heading-anchor" href="#JuMP混合整数线性优化实例">JuMP混合整数线性优化实例</a><a id="JuMP混合整数线性优化实例-1"></a><a class="docs-heading-anchor-permalink" href="#JuMP混合整数线性优化实例" title="Permalink"></a></h1><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Contents：优化</p><p>Contributor: YJY</p><p>Email:522432938@qq.com</p><p>如有错误，请批评指正。</p></div></div><h2 id="问题简介"><a class="docs-heading-anchor" href="#问题简介">问题简介</a><a id="问题简介-1"></a><a class="docs-heading-anchor-permalink" href="#问题简介" title="Permalink"></a></h2><p><a href="https://adventofcode.com/2022/day/19">Advent Of Code</a>中有一个很有意思的问题，可用JuMP来求解。同时也是能源系统优化的一个缩影。</p><p>问题如下：</p><p>为了收获粘土，你需要专用的粘土收集机器人。要制造任何类型的机器人，你都需要矿石。收集矿石需要带大钻头的矿石收集机器人。幸运的是，你的背包中正好有一个矿石收集机器人，你可以使用它启动整个操作。</p><p>每个机器人<strong>每分钟可以收集1个其资源类型</strong>。机器人工厂（也在你的背包中）<strong>构建任何类型的机器人也需要一分钟</strong>，尽管它在构建开始时会消耗必要的可用资源，同时每分钟最多建造1个机器人。</p><p>机器人工厂有很多蓝图（问题的输入）你可以选择，但一旦你用蓝图配置好了，你就不能改变它。</p><pre><code class="nohighlight hljs">蓝图1：
    制造一个矿石机器人（ore robot）消耗4矿石（ore）。
    制造一个粘土机器人（clay robot）消耗2矿石（ore）。
    制造一个黑曜石机器人（obsidian robot）消耗3块矿石（ore）和14块粘土（clay）。
    制造一个紫晶机器人（geode robot）消耗2个矿石（ore）和7个黑曜石（obsidian）。

蓝图2：
    制造一个矿石机器人消耗2矿石。
    制造一个粘土机器人消耗3矿石。
    制造一个黑曜石机器人消耗3块矿石和8块粘土。
    制造一个紫晶机器人消耗3个矿石和12个黑曜石。</code></pre><p>优化问题为：<strong>如何分配资源去建造机器人，在24分钟后获得最多的紫晶</strong>。</p><p>蓝图1的最优方案为最多获得9个紫晶，具体操作过程为：</p><pre><code class="nohighlight hljs">==第1分钟==
1台矿石收集机器人收集1个矿石；你现在有1个矿石。

==第2分钟==
1台矿石收集机器人收集1个矿石；你现在有2个矿石。

==第3分钟==
花2矿石开始建造一个粘土收集机器人。
1台矿石收集机器人收集1个矿石；你现在有1个矿石。

新的粘土收集机器人准备就绪；你现在有一个了。

==第4分钟==
1台矿石收集机器人收集1个矿石；你现在有2个矿石。
1个粘土收集机器人收集1个粘土；你现在有1个粘土。

==第5分钟==

花2矿石开始建造一个粘土收集机器人。
1台矿石收集机器人收集1个矿石；你现在有1个矿石。
1个粘土收集机器人收集1个粘土；你现在有2个粘土。

新的粘土收集机器人准备就绪；你现在有两个了。

==第6分钟==
1台矿石收集机器人收集1个矿石；你现在有2个矿石。
2个粘土收集机器人收集2个粘土；你现在有4块粘土。

==第7分钟==
花2矿石开始建造一个粘土收集机器人。
1台矿石收集机器人收集1个矿石；你现在有1个矿石。
2个粘土收集机器人收集2个粘土；你现在有6块粘土。

新的粘土收集机器人准备就绪；你现在有3个了。

==第8分钟==
1台矿石收集机器人收集1个矿石；你现在有2个矿石。
3个粘土收集机器人收集3个粘土；你现在有9块粘土。

==第9分钟==
1台矿石收集机器人收集1个矿石；你现在有3个矿石。
3个粘土收集机器人收集3个粘土；你现在有12块粘土。

==第10分钟==
1台矿石收集机器人收集1个矿石；你现在有4个矿石。
3个粘土收集机器人收集3个粘土；你现在有15块粘土。

==分钟11==
花3块矿石和14块粘土开始建造一个黑曜石收集机器人。
1台矿石收集机器人收集1个矿石；你现在有2个矿石。
3个粘土收集机器人收集3个粘土；你现在有4块粘土。

新的黑曜石收集机器人准备就绪；你现在有一个了。

==第12分钟==
花2矿石开始建造一个粘土收集机器人。
1台矿石收集机器人收集1个矿石；你现在有1个矿石。
3个粘土收集机器人收集3个粘土；你现在有7块粘土。
1个黑曜石收集机器人收集1颗黑曜岩；你现在有1个黑曜石。

新的粘土收集机器人准备就绪；你现在有4个。

==第13分钟==
1台矿石收集机器人收集1个矿石；你现在有2个矿石。
4个粘土收集机器人收集4个粘土；你现在有11块粘土。
1个黑曜石收集机器人收集1颗黑曜岩；你现在有2颗黑曜石。

==第14分钟==
1台矿石收集机器人收集1个矿石；你现在有3个矿石。
4个粘土收集机器人收集4个粘土；你现在有15块粘土。
1个黑曜石收集机器人收集1颗黑曜岩；你现在有3个黑曜石。

==第15分钟==
花3块矿石和14块粘土开始建造一个黑曜石收集机器人。
1台矿石收集机器人收集1个矿石；你现在有1个矿石。
4个粘土收集机器人收集4个粘土；你现在有5块粘土。
1个黑曜石收集机器人收集1颗黑曜岩；你现在有4颗黑曜石。

新的黑曜石收集机器人准备就绪；你现在有两个了。

==第16分钟==
1台矿石收集机器人收集1个矿石；你现在有2个矿石。
4个粘土收集机器人收集4个粘土；你现在有9块粘土。
2个黑曜石收集机器人收集2个黑曜石；你现在有6颗黑曜石。

==第17分钟==
1台矿石收集机器人收集1个矿石；你现在有3个矿石。
4个粘土收集机器人收集4个粘土；你现在有13块粘土。
2个黑曜石收集机器人收集2个黑曜石；你现在有8颗黑曜石。

==第18分钟==
花2颗矿石和7颗黑曜石开始建造一个紫晶机器人。
1台矿石收集机器人收集1个矿石；你现在有2个矿石。
4个粘土收集机器人收集4个粘土；你现在有17块粘土。
2个黑曜石收集机器人收集2个黑曜石；你现在有3个黑曜石。

新的紫晶机器人准备就绪；你现在有一个了。

==第19分钟==
1台矿石收集机器人收集1个矿石；你现在有3个矿石。
4个粘土收集机器人收集4个粘土；你现在有21块粘土。
2个黑曜石收集机器人收集2个黑曜石；你现在有5颗黑曜石。

1个紫晶机器人收集1个紫晶；你现在有一个紫晶。

==第20分钟==
1台矿石收集机器人收集1个矿石；你现在有4个矿石。
4个粘土收集机器人收集4个粘土；你现在有25块粘土。
2个黑曜石收集机器人收集2个黑曜石；你现在有7颗黑曜石。

1个紫晶机器人收集1个紫晶；你现在有2个紫晶。

==第21分钟==
花2颗矿石和7颗黑曜石开始建造一个紫晶机器人。
1台矿石收集机器人收集1个矿石；你现在有3个矿石。
4个粘土收集机器人收集4个粘土；你现在有29块粘土。
2个黑曜石收集机器人收集2个黑曜石；你现在有2颗黑曜石。
1个紫晶开裂机器人开裂1个大地洞；你现在有3个紫晶。

新的紫晶机器人准备就绪；你现在有两个了。

==第22分钟==
1台矿石收集机器人收集1个矿石；你现在有4个矿石。
4个粘土收集机器人收集4个粘土；你现在有33块粘土。
2个黑曜石收集机器人收集2个黑曜石；你现在有4颗黑曜石。
2个紫晶机器人收集2个紫晶；你现在有5个紫晶。

==第23分钟==
1台矿石收集机器人收集1个矿石；你现在有5个矿石。
4个粘土收集机器人收集4个粘土；你现在有37块粘土。
2个黑曜石收集机器人收集2个黑曜石；你现在有6颗黑曜石。
2个紫晶机器人收集2个紫晶；你现在有7个紫晶。

==第24分钟==
1台矿石收集机器人收集1个矿石；你现在有6个矿石。
4个粘土收集机器人收集4个粘土；你现在有41块粘土。
2个黑曜石收集机器人收集2个黑曜石；你现在有8颗黑曜石。
2个紫晶机器人收集2个紫晶；你现在有9个紫晶。</code></pre><p>蓝图2最多获得12个紫晶。</p><p>对于以下蓝图，分别能获得的最多紫晶是多少？</p><pre><code class="nohighlight hljs">Blueprint 1: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 17 clay. Each geode robot costs 4 ore and 20 obsidian.
Blueprint 2: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 3 ore and 17 clay. Each geode robot costs 3 ore and 8 obsidian.
Blueprint 3: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 7 clay. Each geode robot costs 4 ore and 13 obsidian.
Blueprint 4: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 10 clay. Each geode robot costs 3 ore and 14 obsidian.
Blueprint 5: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 17 clay. Each geode robot costs 3 ore and 16 obsidian.
Blueprint 6: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 16 clay. Each geode robot costs 2 ore and 15 obsidian.
Blueprint 7: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 15 clay. Each geode robot costs 2 ore and 15 obsidian.
Blueprint 8: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 19 clay. Each geode robot costs 2 ore and 18 obsidian.
Blueprint 9: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 7 clay. Each geode robot costs 2 ore and 19 obsidian.
Blueprint 10: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 6 clay. Each geode robot costs 3 ore and 16 obsidian.
Blueprint 11: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 8 clay. Each geode robot costs 3 ore and 19 obsidian.
Blueprint 12: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 19 clay. Each geode robot costs 2 ore and 12 obsidian.
Blueprint 13: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 14 clay. Each geode robot costs 4 ore and 17 obsidian.
Blueprint 14: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 2 ore and 14 obsidian.
Blueprint 15: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 10 clay. Each geode robot costs 2 ore and 11 obsidian.
Blueprint 16: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 13 clay. Each geode robot costs 3 ore and 11 obsidian.
Blueprint 17: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 19 clay. Each geode robot costs 3 ore and 10 obsidian.
Blueprint 18: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 2 ore and 17 obsidian.
Blueprint 19: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 11 clay. Each geode robot costs 4 ore and 12 obsidian.
Blueprint 20: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 7 clay. Each geode robot costs 3 ore and 10 obsidian.
Blueprint 21: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 13 clay. Each geode robot costs 3 ore and 7 obsidian.
Blueprint 22: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 15 clay. Each geode robot costs 2 ore and 7 obsidian.
Blueprint 23: Each ore robot costs 3 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 3 ore and 18 obsidian.
Blueprint 24: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 18 clay. Each geode robot costs 4 ore and 8 obsidian.
Blueprint 25: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 3 ore and 14 clay. Each geode robot costs 4 ore and 15 obsidian.
Blueprint 26: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 3 ore and 9 obsidian.
Blueprint 27: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 5 clay. Each geode robot costs 3 ore and 7 obsidian.
Blueprint 28: Each ore robot costs 3 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 11 clay. Each geode robot costs 2 ore and 8 obsidian.
Blueprint 29: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 12 clay. Each geode robot costs 3 ore and 15 obsidian.
Blueprint 30: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 10 clay. Each geode robot costs 3 ore and 10 obsidian.</code></pre><h2 id="优化问题的数学表达"><a class="docs-heading-anchor" href="#优化问题的数学表达">优化问题的数学表达</a><a id="优化问题的数学表达-1"></a><a class="docs-heading-anchor-permalink" href="#优化问题的数学表达" title="Permalink"></a></h2><p>因为涉及到时间域上的状态改变（本质就是离散），所以需要在求解时间域上的每个时间点上设置一个变量。同时，每个不同种类的矿石也需要设置变量。</p><p>变量设置：</p><ul><li>每个种类每个时间点矿石数量，整数</li><li>每个种类每个时间点机器人数量，整数</li><li>每个种类每个时间点是否建造，0或1</li></ul><p>所以有：</p><p class="math-container">\[
robots_{i,j}  \in N\\
isBuild_{i,j} \in \{0,1\}\\
obtains_{i,j} \in N\\
i \in \{ore, clay, obsidian, geode\}\\
j \in \{1,2,3...,23,24\}
\]</p><p>优化目标为第24分钟，紫晶最多：</p><p class="math-container">\[
\max obtains_{geode,24} 
\]</p><p>约束：</p><ul><li>矿石量等于上一周期的矿石量加上本周期的产出减去本周期的消耗。</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>costs的每一行是建造不同种机器人消耗的材料个数。</p><p class="math-container">\[costs =  \begin{bmatrix}[4, 3, 2, 3] \\ [0, 0, 17, 0] \\ [0, 0, 0, 16] \\ [0, 0, 0, 0]\end{bmatrix}\]</p><p>例如，第一行为建造4中不同的机器人，分别要消耗4，3，2，3个ore；第二行为建造4中不同的机器人,分别要消耗0，0，17，0个clay：</p></div></div><p class="math-container">\[obtains_{i,j} = obtains_{i,j-1}+robots_{i,j} - \sum_{k}^{} costs_{i,k} * isBulid_{k,j}\]</p><ul><li>上一个周期结束，矿石足够才能在本周期建造机器人</li></ul><p class="math-container">\[obtains_{i,j-1} \geqslant \sum_{k}^{} costs_{i,k} * isBulid_{k,j}\]</p><ul><li>建造机器人，数量增加</li></ul><p class="math-container">\[robots_{i,j} =  robots_{i,j-1}  + isBulid_{i,j-1}\]</p><ul><li>一次只能建造一个机器人</li></ul><p class="math-container">\[\sum_{k}^{} isBulid_{k,j} \leqslant 1\]</p><ul><li>初值条件，没有材料且只有一台矿石机器人：</li></ul><p class="math-container">\[isBulid_{i,1} = 0, i \in \{ore, clay, obsidian, geode\}\\
obtain_{i,1} = 0, i \in \{ clay, obsidian, geode\}\\
robots_{i,1} = 0, i \in \{ clay, obsidian, geode\}\\
obtain_{ore,1} = 1 \\
robots_{ore,1} = 1 \\\]</p><h2 id="JuMP求解代码"><a class="docs-heading-anchor" href="#JuMP求解代码">JuMP求解代码</a><a id="JuMP求解代码-1"></a><a class="docs-heading-anchor-permalink" href="#JuMP求解代码" title="Permalink"></a></h2><pre><code class="language-julia hljs">using JuMP
import HiGHS

inputs = &quot;&quot;&quot;Blueprint 1: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 17 clay. Each geode robot costs 4 ore and 20 obsidian.
Blueprint 2: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 3 ore and 17 clay. Each geode robot costs 3 ore and 8 obsidian.
Blueprint 3: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 7 clay. Each geode robot costs 4 ore and 13 obsidian.
Blueprint 4: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 10 clay. Each geode robot costs 3 ore and 14 obsidian.
Blueprint 5: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 17 clay. Each geode robot costs 3 ore and 16 obsidian.
Blueprint 6: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 16 clay. Each geode robot costs 2 ore and 15 obsidian.
Blueprint 7: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 15 clay. Each geode robot costs 2 ore and 15 obsidian.
Blueprint 8: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 19 clay. Each geode robot costs 2 ore and 18 obsidian.
Blueprint 9: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 7 clay. Each geode robot costs 2 ore and 19 obsidian.
Blueprint 10: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 6 clay. Each geode robot costs 3 ore and 16 obsidian.
Blueprint 11: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 8 clay. Each geode robot costs 3 ore and 19 obsidian.
Blueprint 12: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 19 clay. Each geode robot costs 2 ore and 12 obsidian.
Blueprint 13: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 14 clay. Each geode robot costs 4 ore and 17 obsidian.
Blueprint 14: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 2 ore and 14 obsidian.
Blueprint 15: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 10 clay. Each geode robot costs 2 ore and 11 obsidian.
Blueprint 16: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 13 clay. Each geode robot costs 3 ore and 11 obsidian.
Blueprint 17: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 19 clay. Each geode robot costs 3 ore and 10 obsidian.
Blueprint 18: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 2 ore and 17 obsidian.
Blueprint 19: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 11 clay. Each geode robot costs 4 ore and 12 obsidian.
Blueprint 20: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 7 clay. Each geode robot costs 3 ore and 10 obsidian.
Blueprint 21: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 13 clay. Each geode robot costs 3 ore and 7 obsidian.
Blueprint 22: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 15 clay. Each geode robot costs 2 ore and 7 obsidian.
Blueprint 23: Each ore robot costs 3 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 3 ore and 18 obsidian.
Blueprint 24: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 18 clay. Each geode robot costs 4 ore and 8 obsidian.
Blueprint 25: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 3 ore and 14 clay. Each geode robot costs 4 ore and 15 obsidian.
Blueprint 26: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 3 ore and 9 obsidian.
Blueprint 27: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 5 clay. Each geode robot costs 3 ore and 7 obsidian.
Blueprint 28: Each ore robot costs 3 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 11 clay. Each geode robot costs 2 ore and 8 obsidian.
Blueprint 29: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 12 clay. Each geode robot costs 3 ore and 15 obsidian.
Blueprint 30: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 10 clay. Each geode robot costs 3 ore and 10 obsidian.
&quot;&quot;&quot;

inputs = IOBuffer(inputs)

function readData(path=inputs)
    rawData = readlines(path)
    rawData = split.(rawData, c -&gt; c == &#39;.&#39; || c == &#39;:&#39;)
    regs = [
        r&quot;Blueprint (\d+)&quot;,
        r&quot;costs (\d+) ore&quot;,
        r&quot;costs (\d+) ore&quot;,
        r&quot;costs (\d+) ore and (\d+) clay&quot;,
        r&quot;costs (\d+) ore and (\d+) obsidian&quot;,
    ]
    d = Dict{Int,Vector{Vector{Int64}}}()
    for line in rawData |&gt; eachindex
        c = map(x -&gt; zeros(Int64, 4), 1:4)
        r = Vector{Int64}[]
        for i in 1:5
            m = match(regs[i], rawData[line][i]).captures
            m = map(x -&gt; parse(Int64, x), m)
            push!(r, m)
        end
        c[1][1] = r[2][1]
        c[1][2] = r[3][1]
        c[1][3] = r[4][1]
        c[1][4] = r[5][1]
        c[2][3] = r[4][2]
        c[3][4] = r[5][2]
        d[r[1][1]] = c
    end
    return d
end


function solve_1(costs, periods)
    model = Model(HiGHS.Optimizer)
    set_silent(model)
    names = [&quot;ore&quot;, &quot;clay&quot;, &quot;obsidian&quot;, &quot;geode&quot;]
    # robots为每个机器人的数量，obtains为每个机器人每个周期的产出，isBuild为每个机器人每个周期是否建造
    @variable(model, robots[names, periods], Int)
    @variable(model, obtains[names, periods], Int)
    @variable(model, isBuild[names, periods], Bin)
    # 矿石量等于上一周期的矿石量加上本周期的产出减去本周期的消耗
    for (p1, p2) ∈ zip(periods[1:end-1], periods[2:end])
        @constraint(model, [ind = 1:4], obtains[names[ind], p2] == obtains[names[ind], p1] + robots[names[ind], p2] - sum(costs[ind] .* isBuild[:, p2]))
    end
    # 矿石足够才能建造机器人
    for (p1, p2) ∈ zip(periods[1:end-1], periods[2:end])
        @constraint(model, [ind = 1:4], obtains[names[ind], p1] &gt;= sum(costs[ind] .* isBuild[:, p2]))
    end
    # 建造机器人
    for (p1, p2) ∈ zip(periods[1:end-1], periods[2:end])
        @constraint(model, [ind = 1:4], robots[names[ind], p2] == robots[names[ind], p1] + isBuild[names[ind], p1])
    end
    # 一次只能建造一个机器人
    @constraint(model, [i = periods], sum(isBuild[:, i]) &lt;= 1)
    # 初始条件
    @constraint(model, [ind = 2:4], robots[names[ind], 1] == 0)
    @constraint(model, [ind = 1:1], robots[names[ind], 1] == 1)
    @constraint(model, [ind = 2:4], obtains[names[ind], 1] == 0)
    @constraint(model, [ind = 1:1], obtains[names[ind], 1] == 1)
    @constraint(model, [ind = 1:4], isBuild[names[ind], 1] == 0)
    # 目标函数
    @objective(model, Max, obtains[&quot;geode&quot;, lastindex(periods)])
    optimize!(model)
    return objective_value(model) |&gt; Int
end

function solve_P1()
    d = readData()
    s = String[]
    for (i, c) in d
        res = solve_1(c, 1:24)
        push!(s,&quot;第$(i)个结果:&quot;*string(res))
    end
    return s
end

solve_P1()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">30-element Vector{String}:
 &quot;第5个结果:0&quot;
 &quot;第16个结果:5&quot;
 &quot;第20个结果:5&quot;
 &quot;第12个结果:0&quot;
 &quot;第24个结果:2&quot;
 &quot;第28个结果:8&quot;
 &quot;第8个结果:0&quot;
 &quot;第17个结果:1&quot;
 &quot;第30个结果:5&quot;
 &quot;第1个结果:0&quot;
 ⋮
 &quot;第4个结果:1&quot;
 &quot;第13个结果:0&quot;
 &quot;第15个结果:14&quot;
 &quot;第2个结果:2&quot;
 &quot;第10个结果:5&quot;
 &quot;第18个结果:1&quot;
 &quot;第21个结果:4&quot;
 &quot;第26个结果:1&quot;
 &quot;第27个结果:9&quot;</code></pre><h2 id="小结"><a class="docs-heading-anchor" href="#小结">小结</a><a id="小结-1"></a><a class="docs-heading-anchor-permalink" href="#小结" title="Permalink"></a></h2><p>这个问题重要的特点为：</p><ul><li>存在时域上的状态转移（能源系统中负荷的变化等等），以及如何用变量之间的关联体现状态转移的关系</li><li>包含整数与布尔变量（设备启停、满足最小需求的设备数量等等）</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../JuMP参数辨识/">« JuMP非线性参数辨识实例</a><a class="docs-footer-nextpage" href="../systemParaEste/">MTK符号系统参数辨识 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 24 February 2023 09:15">Friday 24 February 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
