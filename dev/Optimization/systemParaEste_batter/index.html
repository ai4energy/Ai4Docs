<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MTK部分参数辨识实例 · Ai4EDocs</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/css/ai4e.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Ai4EDocs logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Ai4EDocs</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Modeling</span><ul><li><a class="tocitem" href="../../Modeling/DE_intro/">DifferentialEquations建模方法</a></li><li><a class="tocitem" href="../../Modeling/MTK_intro/">ModelingToolkit建模方法</a></li><li><a class="tocitem" href="../../Modeling/MTK_register/">ModelingToolkit调用外部函数</a></li><li><a class="tocitem" href="../../Modeling/MTK_tips/">MTK常见问题</a></li><li><a class="tocitem" href="../../Modeling/ModelingTutorial/">组织方程的艺术——组件化（入门）</a></li><li><a class="tocitem" href="../../Modeling/WathMTKdo/">MTK的&quot;前世今生&quot;</a></li><li><a class="tocitem" href="../../Modeling/neural_network/">数学视角下的神经网络</a></li></ul></li><li><span class="tocitem">Simulation</span><ul><li><a class="tocitem" href="../../Simulation/DE_heattran/">DE求解PDE（对比MTK）</a></li><li><a class="tocitem" href="../../Simulation/MTK_heattran/">MTK手动空间离散求解PDE</a></li><li><a class="tocitem" href="../../Simulation/componementModel/">组件化建模实例</a></li><li><a class="tocitem" href="../../Simulation/steadyRC/">MTK稳态系统仿真实例</a></li></ul></li><li><span class="tocitem">Optimization</span><ul><li><a class="tocitem" href="../DE_Estim/">微分方程参数辨识实例</a></li><li><a class="tocitem" href="../JuMP参数辨识/">JuMP非线性参数辨识实例</a></li><li><a class="tocitem" href="../JumpMILP/">JuMP混合整数线性优化实例</a></li><li><a class="tocitem" href="../systemParaEste/">MTK符号系统参数辨识</a></li><li class="is-active"><a class="tocitem" href>MTK部分参数辨识实例</a><ul class="internal"><li><a class="tocitem" href="#原理"><span>原理</span></a></li><li><a class="tocitem" href="#等效电路建模"><span>等效电路建模</span></a></li><li><a class="tocitem" href="#构建组件"><span>构建组件</span></a></li><li><a class="tocitem" href="#导入实验数据"><span>导入实验数据</span></a></li><li><a class="tocitem" href="#构建损失函数并求解"><span>构建损失函数并求解</span></a></li><li class="toplevel"><a class="tocitem" href="#模型验证"><span>模型验证</span></a></li></ul></li><li><a class="tocitem" href="../参数辨识实例_MTK/">MTK非线性参数辨识实例</a></li></ul></li><li><span class="tocitem">Control</span><ul><li><a class="tocitem" href="../../Control/JuMPMPC/">JuMP求解MPC问题</a></li><li><a class="tocitem" href="../../Control/KalmanFiltering/">卡尔曼滤波理论与应用</a></li><li><a class="tocitem" href="../../Control/MTKMPC/">MTK求解MPC问题</a></li><li><a class="tocitem" href="../../Control/OptimControl/">最优控制理论与应用</a></li></ul></li><li><span class="tocitem">Frameworks</span><ul><li><a class="tocitem" href="../../Frameworks/Ai4EComponentLib/">Ai4EComponentLib.jl设计理念</a></li><li><a class="tocitem" href="../../Frameworks/OptControl/">OptControl.jl设计理念</a></li></ul></li><li><span class="tocitem">CSBase</span><ul><li><a class="tocitem" href="../../CSBase/1-Windows命令提示符介绍/">Windows的命令提示符简介</a></li><li><a class="tocitem" href="../../CSBase/2-PowerShell和WindowsTerminal/">PowerShell和Windows Terminal</a></li><li><a class="tocitem" href="../../CSBase/3-环境变量及其设置/">环境变量简介</a></li><li><a class="tocitem" href="../../CSBase/4-Windows下安装gcc编译器和CLion/">Windows下安装gcc编译器和CLion</a></li><li><a class="tocitem" href="../../CSBase/5-make和Makefile介绍/">make和Makefile介绍</a></li><li><a class="tocitem" href="../../CSBase/6-静态链接库和动态链接库/">静态链接库和动态链接库</a></li><li><a class="tocitem" href="../../CSBase/7-以SAM为例整体实操一下/">以SAM为例实操</a></li><li><a class="tocitem" href="../../CSBase/8-以CoolProp为例的实操/">以CoolProp为例的实操</a></li><li><a class="tocitem" href="../../CSBase/9-dll生成与调用实操/">动态链接库(DLL)的生成与调用</a></li><li><a class="tocitem" href="../../CSBase/SSH_Git/">SSH、Git与Git图形化软件</a></li></ul></li><li><span class="tocitem">Tools</span><ul><li><a class="tocitem" href="../../Tools/CSV_jl_use/">CSV.jl使用简介</a></li><li><a class="tocitem" href="../../Tools/CoolProp/">CoolProp使用介绍</a></li><li><a class="tocitem" href="../../Tools/vscode_git/">VScode中使用Git</a></li></ul></li><li><span class="tocitem">WorkFlow</span><ul><li><a class="tocitem" href="../../WorkFlow/ julia-binary-wrappers/">julia对外部程序的加壳</a></li><li><a class="tocitem" href="../../WorkFlow/DocStructure/">文档（docs）编写方法</a></li><li><a class="tocitem" href="../../WorkFlow/REPL-of-Julia/">julia 的 REPL</a></li><li><a class="tocitem" href="../../WorkFlow/gitworkflow/">Ai4E组织合作开发流程</a></li><li><a class="tocitem" href="../../WorkFlow/julia-call-c7fortran/">julia调用dll中的函数</a></li><li><a class="tocitem" href="../../WorkFlow/julia_change_pkgserve/">Julia换源(更换国内镜像站)</a></li><li><a class="tocitem" href="../../WorkFlow/julia的安装/">Julia安装</a></li><li><a class="tocitem" href="../../WorkFlow/vscodePlugin/">VScode开发环境配置</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Optimization</a></li><li class="is-active"><a href>MTK部分参数辨识实例</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MTK部分参数辨识实例</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ai4energy/Ai4EDocs/blob/main/docs/src/Optimization/systemParaEste_batter.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MTK部分参数辨识实例"><a class="docs-heading-anchor" href="#MTK部分参数辨识实例">MTK部分参数辨识实例</a><a id="MTK部分参数辨识实例-1"></a><a class="docs-heading-anchor-permalink" href="#MTK部分参数辨识实例" title="Permalink"></a></h1><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Contents：MTK模型、优化、DiffEqParamEstim</p><p>Contributor: HY</p><p>Email:1171006975@qq.com</p><p>如有错误，请批评指正。</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>DEPE = DiffEqParamEstim.jl(Differential Equation Parameters Estimate)</p><p><a href="https://diffeqparamestim.sciml.ai/dev/">DiffEqParamEstim.jl</a>是计算微分方程参数估计的软件包。</p></div></div><h2 id="原理"><a class="docs-heading-anchor" href="#原理">原理</a><a id="原理-1"></a><a class="docs-heading-anchor-permalink" href="#原理" title="Permalink"></a></h2><p>在进行参数辨识的时候，我们往往会遇到一个问题——实验只能测一到两个关键数据，例如温度、电压电流等。但在咱们的<code>ODEsystem</code>中，状态量<code>states</code>往往不止一两个（甚至有几十个），而在<code>DiffEqParamEstim.jl</code>包中，构建损失函数时要求我们导入所有<code>states</code>的实验数据，显然咱们是办不到的。这个时候，咱们有两种解决方案：1.自己重构损失函数，这个方法显然是最高级的，是真正的治标又治本的方法，但是重构损失函数对初学者可能不够友好（比如说我）。因此，在这里给大家介绍第2种解决方案：引入加权值<code>weight</code>，无法通过实验测得的数据，我们可以将其的<code>weight</code>设为0，其他能测得的<code>states</code>设为1。这样，我们相当于重构了损失函数，程序只会根据我们“指定”的那些数据进行参数辨识，效果跟方案1是一样的。</p><p><strong>下面以三星18650锂电池为例，对锂电池的模型参数进行辨识</strong>。</p><h2 id="等效电路建模"><a class="docs-heading-anchor" href="#等效电路建模">等效电路建模</a><a id="等效电路建模-1"></a><a class="docs-heading-anchor-permalink" href="#等效电路建模" title="Permalink"></a></h2><p>基于ModelingToolkit，建立Thevenin二阶RC等效电路模型，如下图所示。 该等效电路模型是由开路电压Uoc，欧姆内阻R0和两个RC网络结构组成，U1、U2分别为R1、R2的端电压，UT表示电池的端电压。 <img src="../../assets/DiffEqParamEstim_Li_batter_1.png" alt="图1"/></p><h2 id="构建组件"><a class="docs-heading-anchor" href="#构建组件">构建组件</a><a id="构建组件-1"></a><a class="docs-heading-anchor-permalink" href="#构建组件" title="Permalink"></a></h2><p>组件总共有两个，一个是锂电池组件，用来模拟锂电池的伏安特性，另一个是充放电控制器组件，用来模拟锂电池的恒流充放电。</p><pre><code class="language-julia hljs">using DiffEqParamEstim, DifferentialEquations, Random, ModelingToolkit, PlotlyJS
using OptimizationOptimJL
using IfElse: ifelse
import RecursiveArrayTools.VectorOfArray
@variables t
∂ = Differential(t)
@connector function Pin(; name)
    sts = @variables v(t) = 1.0 i(t) = 1.0 [connect = Flow]
    ODESystem(Equation[], t, sts, []; name=name)
end
function OnePort(; name)
    @named p = Pin()
    @named n = Pin()
    sts = @variables v(t) = 1.0 i(t) = 1.0
    eqs = [
        v ~ p.v - n.v
        0 ~ p.i + n.i
        i ~ p.i
    ]
    compose(ODESystem(eqs, t, sts, []; name=name), p, n)
end
function OnePort_key(; name, v_start = 1.0, i_start = 0.0)
    @named p = Pin()
    @named n = Pin()
    sts = @variables v(t) = v_start [irreducible=true] i(t) = i_start [irreducible=true]
    eqs = [
        v ~ p.v - n.v
        0 ~ p.i + n.i
        i ~ p.i
    ]
    compose(ODESystem(eqs, t, sts, []; name=name), p, n)
end
function Ground(; name)
    @named g = Pin()
    eqs = [g.v ~ 0]
    compose(ODESystem(eqs, t, [], []; name=name), g)
end
function Lithium_ion_batteries(; name, OCV=3.9998, R0=0.029031, R1=0.00994, R2=0.01408, C1=147.462, C2=902.911)
    @named oneport = OnePort()
    @unpack v, i = oneport
    sts = @variables v_c1(t) = 0.001 v_c2(t) = 0.001 v_b(t) = 1.0 i_b(t) = 0.0
    ps = @parameters(
        R0 = R0,
        R1 = R1,
        R2 = R2,
        C1 = C1,
        C2 = C2,
        OCV = OCV,
    )
    eqs = [
        OCV ~ i_b * R0 + v_c1 + v_c2 + v_b
        i_b ~ C1 * ∂(v_c1) + v_c1 / R1
        i_b ~ C2 * ∂(v_c2) + v_c2 / R2
        v ~ v_b
        i ~ -i_b
    ]
    return extend(ODESystem(eqs, t, sts, ps; name=name), oneport)
end
function charge_controller(; name)
    @named oneport = OnePort_key()
    @unpack v, i = oneport
    equa = ifelse(t &lt;= 10.0,16.0,ifelse(t &lt;= 40.0,0.0,ifelse(t &lt;= 50.0,-16.0,0.0)))
    eqs = [i ~ equa]
    return extend(ODESystem(eqs, t, [], []; name=name), oneport)
end</code></pre><p>不难发现，系统一共定义有6个参数，分别是欧姆内阻<code>R0</code>,两个RC支路所对应的<code>R1,R2,C1,C2</code>以及开路电压<code>OCV</code>。</p><hr/><p>然后，通过连接函数，组建系统</p><pre><code class="language-julia hljs">@named ground = Ground()
@named cg = charge_controller()
@named batter = Lithium_ion_batteries()
eqs = [
    connect(batter.p, cg.p)
    connect(batter.n, cg.n, ground.g)
]

@named OdeFun = ODESystem(eqs, t)
@named model = compose(OdeFun, [batter, cg, ground])
sys = structural_simplify(model)
u0 = [
    batter.v_c1 =&gt; 0.024058864
    batter.v_c2 =&gt; 0.002594792
    cg.v =&gt; 3.928902637
    cg.i =&gt; 0
    batter.R0 =&gt; 0.037517357
    batter.R1 =&gt; 0.020913201
    batter.R2 =&gt; 0.006915906
    batter.C1 =&gt; 4636.08469
    batter.C2 =&gt; 1292.103841
    batter.OCV =&gt; 3.955556293
]
prob = ODEProblem(sys, u0, (40.0, 60.0))</code></pre><h2 id="导入实验数据"><a class="docs-heading-anchor" href="#导入实验数据">导入实验数据</a><a id="导入实验数据-1"></a><a class="docs-heading-anchor-permalink" href="#导入实验数据" title="Permalink"></a></h2><p>导入实验数据，并对数据的格式进行一定的处理。</p><pre><code class="language-julia hljs">time = [
    40.98797751
    42.00601125
    42.99980609
    43.99360093
    45.01163467
    46.00542951
    46.99922436
    47.9930192
    50.99864262
    53.0104712
    55.99185573]
real_data = [
    4.511920324
    4.536819172
    4.551011516
    4.570183629
    4.57665733
    4.5881108
    4.593588547
    4.598817305
    3.985060691
    3.94746343
    3.910364146]

randomized = VectorOfArray([[0, 0, real_data[i], 0] for i in 1:length(time)])
data = convert(Array, randomized)

weight = VectorOfArray([[0.0, 0.0, 1.0, 0.0] for i in 1:length(time)])
data_weight = convert(Array, weight)</code></pre><p>本实例的数据通过getdata软件从文献中扣取。</p><p>系统变量有四个，分别为<code>batter.v_c1</code>,<code>batter.v_c2</code>,<code>cg.v</code>,<code>cg.i</code>。其中<code>cg.v</code>的数据通过实验获得，其权重值<code>weight</code>设为1，其他的变量权重值设为0。</p><p>系统参数有六个，分别为<code>batter.R0</code>,<code>batter.R1</code>,<code>batter.R2</code>,<code>batter.C1</code>,<code>batter.C2</code>,<code>batter.OCV</code>。</p><p>最终生成了<code>data</code>和<code>data_weight</code>矩阵，分别代表实验数据和相应权重值。</p><p><img src="../../assets/DiffEqParamEstim_Li_batter_2.png" alt="图2"/></p><p>在不知道参数的顺序时，可以使用parameters和states函数查看系统参数。</p><pre><code class="language-julia hljs">parameters(sys)
states(sys)</code></pre><h2 id="构建损失函数并求解"><a class="docs-heading-anchor" href="#构建损失函数并求解">构建损失函数并求解</a><a id="构建损失函数并求解-1"></a><a class="docs-heading-anchor-permalink" href="#构建损失函数并求解" title="Permalink"></a></h2><pre><code class="language-julia hljs">obj = build_loss_objective(prob, Rosenbrock23(), L2Loss(time, data, data_weight=data_weight), maxiters=100000)

result = OptimizationOptimJL.optimize(obj,[0.037517357, 0.020913201, 0.006915906, 4636.08469, 1292.103841, 3.955556293])
result.minimizer</code></pre><p>参数辨识结果为：</p><p><img src="../../assets/DiffEqParamEstim_Li_batter_3.png" alt="图3"/></p><p>至此，锂电池充电阶段的参数辨识完毕。同理可辨识放电阶段的参数。</p><p>放电阶段实验数据：</p><pre><code class="language-julia hljs">time = [
    1.502811712	
    3.005623424
    4.508435137	
    6.011246849	
    7.489819663	
    11.9982548	
    13.50106651	
    15.00387822	
    16.50668994	
    18.00950165	
    19.48807446	
    20.99088617	
    22.49369789	
    23.9965096	
    25.49932131	
    27.00213302	
    28.50494474
    30.00775645	
    31.51056816	
    32.98914097
    34.49195269
    35.9947644]
real_data = [
    3.335698724
    3.31503268
    3.295860566
    3.277933396
    3.266977902
    3.864799253
    3.878244631
    3.880734516
    3.888702148
    3.897167756
    3.898910675
    3.902645503
    3.908372238
    3.911858077
    3.915094927
    3.918082789
    3.91957672
    3.926797386
    3.923311547
    3.92107065
    3.92107065
    3.926299409]</code></pre><p>放电阶段参数辨识结果为：</p><p><img src="../../assets/DiffEqParamEstim_Li_batter_4.png" alt="图4"/></p><h1 id="模型验证"><a class="docs-heading-anchor" href="#模型验证">模型验证</a><a id="模型验证-1"></a><a class="docs-heading-anchor-permalink" href="#模型验证" title="Permalink"></a></h1><p>当放电阶段和充电阶段的模型参数全部辨识出来了以后，我们再将模型参数重新带回<code>ODEsystem</code>中，验证一下辨识结果是否有效。</p><pre><code class="nohighlight hljs">continuous_events = [
    [t ~ 40.0] =&gt; [batter.R0 ~ 0.037203619
        batter.R1 ~ 0.062205413
        batter.R2 ~ 0.007078411
        batter.C1 ~ 6373.89753
        batter.C2 ~ 407.3465496
        batter.OCV ~ 3.902760964]
]

@named OdeFun = ODESystem(eqs,t,continuous_events=continuous_events)
@named model = compose(OdeFun, [batter, cg, ground])
sys = structural_simplify(model)
u0 = [
    batter.v_c1 =&gt; 0.0
    batter.v_c2 =&gt; 0.0
    cg.v =&gt; 0.0
    cg.i =&gt; 0.0
    batter.R0 =&gt; 0.037517357
    batter.R1 =&gt; 0.020913201
    batter.R2 =&gt; 0.006915906
    batter.C1 =&gt; 4636.08469
    batter.C2 =&gt; 1292.103841
    batter.OCV =&gt; 3.955556293
]
prob = ODEProblem(sys, u0, (0.0, 60.0))
sol = solve(prob)</code></pre><p>对比锂电池的实验数据和仿真数据，可以得到锂电池模型的端电压响应拟合曲线与实际端电压响应曲线的误差，如下图所示。</p><p><img src="../../assets/DiffEqParamEstim_Li_batter_5.png" alt="图5"/></p><p><img src="../../assets/DiffEqParamEstim_Li_batter_6.png" alt="图6"/></p><p>可以看到，各点的拟合电压曲线误差范围均在约±0.006 V以内，即0.19%。电压最大误差为0.0059 V，平均误差为0.0021 V。电压误差大小远远较锂电池平台电压的变化范围小。因此从精度上看，模型误差尚在可接受的范围之内。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>该参数辨识仍然是优化问题的子集，选择不同的初值很可能得到不同的结果。 完整代码可以在<code>/src</code>目录下查看</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../systemParaEste/">« MTK符号系统参数辨识</a><a class="docs-footer-nextpage" href="../参数辨识实例_MTK/">MTK非线性参数辨识实例 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Sunday 2 July 2023 22:15">Sunday 2 July 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
