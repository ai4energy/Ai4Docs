var documenterSearchIndex = {"docs":
[{"location":"Optimization/5-优化问题的建模平台/#优化问题的建模平台","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"","category":"section"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"优化问题建模平台为研究者、工程师和决策者提供了一个方便、灵活且高效的工具，用于建立和求解各种复杂的优化问题。这些平台集成了优化算法、建模语言和求解器，使用户能够轻松地描述优化问题、定义目标函数和约束条件，并使用强大的求解器找到最优解或近似最优解。","category":"page"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"优化问题建模平台的选择具有重要意义，它可以对优化问题的建模和求解过程产生重大影响。这些平台提供了多种建模语言和工具，例如优化问题的表达式、变量定义、约束条件、目标函数的设定等。此外，它们通常还支持灵活的求解器配置、结果分析和可视化功能，帮助用户理解和解释优化结果。","category":"page"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"通过使用优化问题建模平台，用户能够更好地理解问题的本质、优化目标和约束条件，并能够更快速地开发、测试和比较不同的优化方法。这样的平台不仅提供了丰富的建模功能，还能够自动处理数学优化问题的复杂性，提供高效的求解算法和工具，帮助用户在最短的时间内找到最佳解决方案。","category":"page"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"无论是线性规划、非线性规划、整数规划，还是多目标优化等问题，优化问题建模平台都提供了丰富的功能和工具，促进了优化领域的研究和实践。通过使用这些平台，用户可以更好地处理复杂的实际问题，优化资源利用、提高效率、降低成本，并做出更明智的决策。 以下是一些主流的优化问题建模平台和库：","category":"page"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"GAMS (General Algebraic Modeling System)\nPyomo (Python Optimization Modeling Objects)\nJuMP (Julia for Mathematical Programming)\nAMPL (A Mathematical Programming Language)\nAIMMS (Advanced Interactive Multidimensional Modeling System)\nCVXPY (Python-based Convex Optimization Modeling)\nYALMIP (MATLAB-based Modeling Language for Optimization)\nLINGO (Linear, Nonlinear, and Integer Programming System)\nCPLEX Optimization Studio (IBM's optimization suite)\nMATLAB Optimization Toolbox\nOPTMODEL (SAS Optimization Modeling)\nSAS/OR (Operations Research)","category":"page"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"这些平台和库提供了丰富的功能和工具，用于建立和求解各种优化问题。它们支持不同的编程语言，如GAMS和AMPL支持专门的建模语言，而Pyomo、JuMP和CVXPY等库则与通用编程语言（如Python、Julia和MATLAB）集成。选择适合的优化问题建模平台取决于个人偏好、问题复杂性、可扩展性需求以及与其他工具和系统的集成要求。","category":"page"},{"location":"Optimization/5-优化问题的建模平台/#GAMS","page":"优化问题的建模平台","title":"GAMS","text":"","category":"section"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"GAMS（General Algebraic Modeling System）是一种广泛应用于数学建模和优化的高级建模语言和环境。它提供了一个强大的平台，用于描述、求解和分析各种数学优化问题，包括线性规划、非线性规划、整数规划、混合整数规划、多目标优化等。","category":"page"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"GAMS的特点和优势包括：","category":"page"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"建模语言的表达能力：GAMS提供了直观而灵活的建模语言，使用户能够轻松地定义决策变量、约束条件和目标函数。其表达能力强大，支持数学表达式、条件约束、集合和参数的定义等。\n多领域应用：GAMS广泛应用于多个领域，包括能源、交通、供应链、决策支持系统等。它可以用于模拟和优化问题，支持跨学科的建模和分析。\n多种求解器支持：GAMS可以与多种优化求解器集成，如CPLEX、GUROBI、CONOPT等。用户可以根据问题的性质和规模选择最适合的求解器，以获得高效的求解性能。\n灵活的求解器配置和参数调整：GAMS允许用户对求解器进行灵活的配置和参数调整，以优化求解过程。用户可以根据具体问题的要求和约束调整求解器的行为，以获得更好的性能和求解质量。\n结果分析和报告生成：GAMS提供丰富的结果分析和报告生成功能，用户可以轻松地分析和解释优化结果。它支持生成可视化图表、报表和导出结果到其他格式，以便更好地理解问题和向决策者传达结果。\n跨平台和集成能力：GAMS是跨平台的，支持Windows、Linux和Mac等操作系统。它还可以与其他编程语言（如Python、MATLAB）进行集成，提供更大的灵活性和扩展性。","category":"page"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"总而言之，GAMS是一个强大而全面的优化建模工具，为用户提供了一个高效、灵活且直观的环境来建立和求解各种数学优化问题。它被广泛应用于学术研究、工业应用和决策支持系统中，帮助用户优化决策、提高效率和解决复杂的实际问题。","category":"page"},{"location":"Optimization/5-优化问题的建模平台/#Pyomo","page":"优化问题的建模平台","title":"Pyomo","text":"","category":"section"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"Pyomo（Python Optimization Modeling Objects）是一个基于Python的开源优化建模语言和框架。它提供了一个强大的工具集，用于描述、求解和分析各种数学优化问题，包括线性规划、非线性规划、混合整数规划、多目标优化等。","category":"page"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"Pyomo的特点和优势包括：","category":"page"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"Python语言的灵活性：Pyomo使用Python作为建模语言，利用了Python语言的灵活性和强大的科学计算生态系统。用户可以利用Python的丰富库和工具来进行数据处理、可视化、结果分析等。\n建模的直观性和灵活性：Pyomo提供了直观且易于使用的建模语法，使用户能够轻松定义决策变量、约束条件和目标函数。用户可以根据问题的特点和要求，自定义约束形式和目标函数，灵活调整问题的建模方式。\n求解器的多样性和可扩展性：Pyomo支持多种优化求解器，包括商业求解器（如Gurobi、CPLEX）、开源求解器（如GLPK、Ipopt）以及其他第三方求解器。用户可以根据问题的性质和需求选择合适的求解器，并通过扩展接口集成其他求解器。\n高级建模对象和约束表达：Pyomo提供了丰富的建模对象和约束表达方式。它支持线性、非线性和混合整数约束，以及各种约束类型（如等式约束、不等式约束、范围约束等）。这使得Pyomo能够灵活地描述各种复杂的优化问题。\n结果分析和可视化：Pyomo提供了用于结果分析和可视化的工具和函数。用户可以轻松地获取和解释优化结果，生成图表、报表和导出结果到其他格式。\n开源和活跃的社区支持：Pyomo是开源项目，拥有一个活跃的社区，提供了文档、教程、示例和技术支持。用户可以获取开源代码、贡献改进、分享经验和与其他用户交流。","category":"page"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"总而言之，Pyomo是一个功能丰富且易于使用的优化建模框架，使用Python作为建模语言，提供了灵活性和可扩展性。它被广泛应用于学术界、工业界和决策支持系统中，帮助用户解决各种实际问题，并优化决策、提高效率。","category":"page"},{"location":"Optimization/5-优化问题的建模平台/#JuMP.jl","page":"优化问题的建模平台","title":"JuMP.jl","text":"","category":"section"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"JuMP（Julia for Mathematical Programming）是一个基于Julia语言的优化建模语言和框架。它提供了一个高性能、易于使用且灵活的环境，用于描述、求解和分析各种数学优化问题。","category":"page"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"JuMP的特点和优势包括：","category":"page"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"高性能和灵活性：JuMP是基于Julia语言构建的，Julia是一种高性能科学计算语言。JuMP利用Julia语言的优势，具有出色的性能和灵活性，能够处理大规模和复杂的优化问题。\n直观的建模语法：JuMP提供了直观且易于使用的建模语法，使用户能够轻松定义决策变量、约束条件和目标函数。其语法与数学表达式类似，使得建模过程更加直观和易于理解。\n多种优化求解器支持：JuMP可以与多种优化求解器集成，包括商业求解器（如Gurobi、CPLEX）和开源求解器（如GLPK、Ipopt）。这使得用户可以根据问题的性质和需求选择合适的求解器，并灵活地切换求解器以获得更好的性能。\n灵活的建模对象和约束表达：JuMP提供了丰富的建模对象和约束表达方式。它支持线性、非线性和混合整数约束，以及各种约束类型（如等式约束、不等式约束、范围约束等）。这使得JuMP能够灵活地描述各种复杂的优化问题。\n高级优化建模功能：JuMP支持高级建模功能，如多目标优化、参数化优化、约束松弛和敏感性分析等。这些功能使用户能够更好地探索问题的解空间、进行决策分析和优化策略调整。\n开源和活跃的社区支持：JuMP是一个开源项目，拥有一个活跃的社区。用户可以从开源社区中获得文档、教程、示例和技术支持。此外，用户还可以贡献代码、提出改进建议和与其他用户交流。","category":"page"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"JuMP提供了一个强大而灵活的环境，用于解决各种优化问题。它被广泛应用于学术研究、工业应用和决策支持系统中，为用户提供了一种高效、可扩展的方法来优化决策、提高效率和解决实际问题。","category":"page"},{"location":"Optimization/5-优化问题的建模平台/#AMPL","page":"优化问题的建模平台","title":"AMPL","text":"","category":"section"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"AMPL（A Mathematical Programming Language）是一种高级建模语言和环境，用于数学建模和优化问题的建模、求解和分析。它提供了一个灵活而强大的平台，用于描述和求解各种优化问题，包括线性规划、非线性规划、整数规划、混合整数规划等。","category":"page"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"AMPL的特点和优势包括：","category":"page"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"建模语言的表达能力：AMPL提供了一个丰富、直观且易于使用的建模语言，使用户能够轻松定义决策变量、约束条件和目标函数。它支持数学表达式、集合和参数的定义，以及高级建模概念，如索引、约束逻辑和条件约束。\n多领域应用：AMPL被广泛应用于多个领域，包括供应链管理、生产调度、能源系统优化、金融规划等。它能够处理各种实际问题，并支持跨学科的建模和分析。\n多种优化求解器支持：AMPL可以与多种商业和开源优化求解器集成，如CPLEX、GUROBI、CONOPT、KNITRO等。这使得用户可以根据问题的性质和要求选择合适的求解器，并利用其强大的求解能力。\n灵活的数据输入和输出：AMPL支持多种数据输入和输出方式，包括文本文件、电子表格和数据库。它可以与外部数据源无缝集成，方便用户处理大量和实时的数据。\n结果分析和报告生成：AMPL提供了丰富的结果分析和报告生成功能，用户可以轻松地获取和解释优化结果。它支持生成可视化图表、报表和导出结果到其他格式，以便更好地理解问题和向决策者传达结果。\n跨平台和集成能力：AMPL是跨平台的，支持Windows、Linux和Mac等操作系统。它可以与其他编程语言（如Python、MATLAB）进行集成，提供更大的灵活性和扩展性。","category":"page"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"总而言之，AMPL是一个功能丰富且易于使用的优化建模语言和环境，提供了一个高效、灵活且直观的平台来建立和求解各种数学优化问题。它被广泛应用于学术研究、工业应用和决策支持系统中，帮助用户优化决策、提高效率和解决复杂的实际问题。","category":"page"},{"location":"Optimization/5-优化问题的建模平台/#AIMMS","page":"优化问题的建模平台","title":"AIMMS","text":"","category":"section"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"AIMMS（Advanced Interactive Multidimensional Modeling System）是一种高级交互式多维建模系统，用于建立和求解复杂的优化和决策支持问题。它提供了一个综合的环境，集成了建模语言、求解器、可视化和报告生成工具，帮助用户在各种领域中进行高效的优化建模和决策分析。","category":"page"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"AIMMS的特点和优势包括：","category":"page"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"综合建模环境：AIMMS提供了一个综合的建模环境，使用户能够方便地定义决策变量、约束条件和目标函数。它支持多维数据和多个优化目标，并提供了丰富的建模对象和约束表达方式。\n交互式建模和分析：AIMMS具有交互式建模和分析功能，用户可以实时调整参数、运行模型并观察结果变化。这种交互性使用户能够更好地理解问题、探索解空间并进行决策分析。\n多领域应用：AIMMS被广泛应用于多个领域，包括供应链管理、生产调度、能源系统优化、金融规划等。它能够处理各种实际问题，并支持复杂的约束条件和问题特性。\n多种优化求解器支持：AIMMS可以与多种商业和开源优化求解器集成，如CPLEX、GUROBI、CONOPT等。用户可以根据问题的性质和要求选择合适的求解器，并利用其强大的求解能力。\n结果可视化和报告生成：AIMMS提供了丰富的结果可视化和报告生成工具，用户可以轻松地生成图表、报表和可视化结果。这有助于用户更好地理解问题、传达结果并支持决策过程。\n跨平台和集成能力：AIMMS是跨平台的，可在Windows和Linux等操作系统上运行。它可以与其他软件和系统集成，如Excel、MATLAB和数据库，以方便数据交换和系统集成。","category":"page"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"总而言之，AIMMS是一个强大且全面的优化建模和决策分析平台，为用户提供了一个高效、灵活和交互式的环境来建立和求解各种优化问题。它被广泛应用于学术研究、工业应用和决策支持系统中，帮助用户优化决策、提高效率并解决复杂的实际问题。","category":"page"},{"location":"Optimization/5-优化问题的建模平台/#Gekko","page":"优化问题的建模平台","title":"Gekko","text":"","category":"section"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"Gekko是一个用于动态优化和非线性模型预测控制（NMPC）的Python库。它提供了一种灵活且易于使用的方式来建立和求解动态优化问题，特别适用于连续时间系统的建模和控制。","category":"page"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"Gekko的特点和优势包括：","category":"page"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"建模灵活性：Gekko允许用户使用Python语言进行建模，具有灵活性和便捷性。用户可以轻松地定义系统的动态方程、约束条件和目标函数，同时利用Python的丰富库进行数据处理和分析。\n连续时间建模和控制：Gekko专注于连续时间动态系统的建模和控制，特别适用于非线性模型预测控制（NMPC）。它能够处理包括微分方程和代数方程在内的动态系统，通过优化控制变量来实现最优控制策略。\n高效求解器：Gekko集成了高性能的非线性优化求解器，能够有效地求解复杂的动态优化问题。它使用差分变量和状态估计技术来处理连续时间问题，并提供了多种求解方法和策略，以获得高效和精确的解。\n实时优化和控制：Gekko支持实时优化和控制应用，可用于在线系统的优化和响应。它可以通过在线更新模型参数和约束条件，实时调整优化策略，并生成最优的控制策略。\n开源和活跃的社区支持：Gekko是一个开源项目，拥有一个活跃的社区。用户可以从开源社区中获得文档、示例和技术支持。此外，用户还可以贡献代码、提出改进建议和与其他用户交流。","category":"page"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"Gekko是一个用于动态优化和非线性模型预测控制的强大工具，为用户提供了一个高效、灵活且易于使用的环境来解决动态系统建模和控制问题。它被广泛应用于学术研究、工业应用和自动化控制领域，帮助用户优化系统性能、实现最优控制策略，并解决复杂的实时优化问题。","category":"page"},{"location":"Optimization/5-优化问题的建模平台/#比较一下","page":"优化问题的建模平台","title":"比较一下","text":"","category":"section"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"当比较优化建模平台时，可以考虑以下方面进行权衡和比较：","category":"page"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"商用 vs. 开源： 商用平台通常提供更完善的技术支持和专业服务，但可能需要支付许可费用。开源平台具有免费的使用许可，并且由活跃的社区支持，但技术支持可能有限。\n许可证类型： 不同的平台采用不同的许可证类型。商用平台通常采用专有许可证，开源平台通常采用开放源代码许可证（如MIT、GPL等）。选择适合的许可证类型取决于个人或组织的需求和偏好。\n求解器支持程度： 每个建模平台对求解器的支持程度不同。商用平台通常支持多种商业求解器，并提供与这些求解器的深度集成。开源平台通常也支持多个开源或商业求解器，但对求解器的支持程度可能有所不同。\n易用性： 平台的易用性是一个重要的考虑因素。易用性包括建模语法的简洁性、文档和教程的可用性、API的友好程度以及可视化和交互功能的便捷性。一个易于学习和使用的平台可以提高建模和求解的效率。\n结果分析便捷性： 不同的平台提供不同的结果分析和报告功能。一些平台提供丰富的结果可视化和报告生成工具，使用户能够更好地分析和解释优化结果。其他平台可能需要用户自行编写代码或使用外部工具进行结果分析。\n功能和灵活性： 平台的功能和灵活性对于不同类型的优化问题非常重要。某些平台可能更适用于特定类型的问题，如线性规划、非线性规划或混合整数规划。考虑问题的特性和需求，并选择具有适当功能和灵活性的平台。","category":"page"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"综合考虑这些方面，您可以根据具体需求和偏好，选择适合您的优化建模平台。不同的平台在不同的方面可能有所突出，因此权衡各个方面的优势和限制将有助于选择最合适的平台。","category":"page"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"以下是对典型优化问题建模平台在商用、开源、许可证、求解器支持程度、易用性和结果分析便捷性方面的比较：","category":"page"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"GAMS：\n商用：商用平台，需要购买许可证。\n开源：不是开源平台。\n许可证：采用专有许可证。\n求解器支持程度：对多种商业求解器提供广泛且深度的支持。\n易用性：具有直观且易于使用的建模语言，具有较高的易用性。\n结果分析便捷性：提供丰富的结果分析和报告生成功能。\nPyomo：\n商用：开源平台，免费使用。\n开源：开源平台，由活跃的社区支持。\n许可证：采用开放源代码许可证（如BSD、Apache等）。\n求解器支持程度：对多个商业和开源求解器提供支持，但对一些商业求解器的集成可能相对较少。\n易用性：使用Python作为建模语言，具有灵活性和易用性。\n结果分析便捷性：可以利用Python的数据分析和可视化库来进行结果分析和报告生成。\nJuMP：\n商用：开源平台，免费使用。\n开源：开源平台，由活跃的社区支持。\n许可证：采用开放源代码许可证（如MIT、GPL等）。\n求解器支持程度：对多个商业和开源求解器提供支持，具有良好的求解器集成能力。\n易用性：使用Julia作为建模语言，具有高性能和易用性。\n结果分析便捷性：可以利用Julia的数据分析和可视化库来进行结果分析和报告生成。\nAMPL：\n商用：商用平台，需要购买许可证。\n开源：不是开源平台。\n许可证：采用专有许可证。\n求解器支持程度：对多种商业和开源求解器提供广泛的支持。\n易用性：具有直观且易于使用的建模语言，具有较高的易用性。\n结果分析便捷性：提供丰富的结果分析和报告生成功能。","category":"page"},{"location":"Optimization/5-优化问题的建模平台/","page":"优化问题的建模平台","title":"优化问题的建模平台","text":"请注意，上述比较是基于一般情况和常见的特点，每个平台在具体的细节和版本中可能会有所不同。选择最适合的平台还应根据个人或组织的需求、问题特性和可用资源进行综合评估。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/#动态链接库(DLL)的生成与调用实操","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"","category":"section"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"tip: Tip\nContents：Julia调用DllContributor: 杨月宝Email:812987139@qq.com如有错误，请批评指正。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/#问题的产生与解决过程概述","page":"动态链接库(DLL)的生成与调用实操","title":"问题的产生与解决过程概述","text":"","category":"section"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"我们试图使用Julia来调用热流问题数值计算课程的代码。这些代码是在2003年重新整理的Fortran代码。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"第一步：我们生成了Fortran动态链接库（dll），并尝试使用C语言调用该dll。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"第二步：接着，我们尝试使用C++来调用该dll，并试图使用Julia来调用它。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"第三步：我们配置了VS2013，生成了64位的dll，并使用64位的Julia来调用该dll。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/#工作环境","page":"动态链接库(DLL)的生成与调用实操","title":"工作环境","text":"","category":"section"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"Julia版本：Julia 1.7.0-beta2\n使用的Fortran编译器：Intel.Visual.Fortran.Composer.XE.2013-SP1，这是在VS2013中的Fortran编译器。\n开发环境：VSCode（Visual Studio Code）","category":"page"},{"location":"CSBase/9-dll生成与调用实操/#实践过程","page":"动态链接库(DLL)的生成与调用实操","title":"实践过程","text":"","category":"section"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"<!–  1.使用Fortran生成dll","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"2.使用VS2013开发人员命令提示查看dll位数","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"3.使用C++调用dll","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"4.使用Julia调用dll –>","category":"page"},{"location":"CSBase/9-dll生成与调用实操/#使用Fortran生成dll","page":"动态链接库(DLL)的生成与调用实操","title":"使用Fortran生成dll","text":"","category":"section"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"新建一个Fortran动态链接库项目","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"(Image: 1)","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"在Resource Files中添加一个f90文件，并输入如下内容","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"SUBROUTINE OUTPUT(a, b, sum)\n    !MS$ ATTRIBUTES DLLEXPORT::OUTPUT\n    !声明本函数为输出函数\n    IMPLICIT NONE\n    INTEGER a, b, sum\n    sum = a + b\nEND SUBROUTINE OUTPUT","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"这段Fortran代码定义了一个名为\"OUTPUT\"的子程序（SUBROUTINE），它接受三个参数：a、b和sum。代码的解释如下：","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"!MS$ ATTRIBUTES DLLEXPORT::OUTPUT：这是一个特定于编译器的注释（directive），用于指示将该函数声明为输出函数（export function），以便其他程序或语言可以调用它。\nIMPLICIT NONE：这是一个编译器指令，用于禁用隐式类型声明。它要求所有变量都必须显式地声明其类型。\nINTEGER a, b, sum：这是变量声明的部分，它指定了a、b和sum都是整数类型的变量。\nsum = a + b：这一行将a和b的值相加，并将结果赋给变量sum。这行代码的作用是计算a和b的和，并将结果存储在sum变量中。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"因此，这段代码定义了一个名为\"OUTPUT\"的子程序，它接受两个整数参数a和b，并计算它们的和，并将结果存储在sum变量中。通过!MS$ ATTRIBUTES DLLEXPORT::OUTPUT的声明，该子程序可以被导出为一个可供其他程序或语言调用的函数。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"Fortran通过下句表示dll输出函数","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"!MS$ ATTRIBUTES DLLEXPORT::OUTPUT","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"配置编译器属性，选择64位的编译器来生成64位的dll","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"(Image: 1) (Image: 1) (Image: 1) (Image: 1)","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"编译文件后生成项目，就可以在.\\x64\\Debug文件夹下找到生成的dll文件","category":"page"},{"location":"CSBase/9-dll生成与调用实操/#使用VS2013开发人员命令提示查看dll位数","page":"动态链接库(DLL)的生成与调用实操","title":"使用VS2013开发人员命令提示查看dll位数","text":"","category":"section"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"VS2013的工具路径在安装目录下","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":".\\Microsoft Visual Studio 12.0\\Common7\\Tools\\Shortcuts","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"选择VS2013开发人员命令提示，可以使用dumpbit命令获得dll信息","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"dumpbin /headers 路径","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"读取上段生成dll，部分结果：","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"(Image: 1)","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"以下是更多的参考：","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"在Windows下，可以使用以下方法来查看DLL文件的位数：","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"打开文件资源管理器（Windows资源管理器）。\n导航到包含所需DLL文件的目录。\n右键单击DLL文件，然后选择\"属性\"。\n在属性对话框中，切换到\"详细信息\"选项卡。\n在\"属性\"部分中，查找\"位数\"或\"架构\"相关的信息。通常会显示为\"32位\"或\"64位\"。\n查看该信息以确定DLL文件的位数。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"另外，您还可以使用命令行来查看DLL文件的位数：","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"打开命令提示符（CMD）或PowerShell。\n使用cd命令导航到包含DLL文件的目录。\n运行以下命令来查看DLL文件的位数：\ndumpbin /headers <DLL文件名>\n将 <DLL文件名> 替换为实际的DLL文件名。\n在输出中查找 \"x86\" 表示32位，\"x64\" 表示64位。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"通过这些方法，您可以方便地查看DLL文件的位数，以确定其兼容性和与其他程序的配合情况。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/#使用C调用dll","page":"动态链接库(DLL)的生成与调用实操","title":"使用C++调用dll","text":"","category":"section"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"这里采用动态调用方法，根据网上找到的资料和Fortran程序设计课程讲义，我重新整理了C++代码。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"这部分代码把那几个冒号去了就是C的代码（就是说实质是c语言代码）。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"调试或启动exe文件前，请将dll文件放于EXE文件所在的Debug文件夹内。我的是在E:\\Programs\\program VS2013\\HF_first\\ForDllCreat\\x64\\Debug","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"我的解决方案名和Fortran生成dll的方案同名了，请不要混淆。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"#include <stdio.h>\n#include <windows.h> // 调用 WINDOWS API 函数所需的头文件\n\ntypedef void(*Func)(int *, int *, int *);//定义一个函数指针类型，这个指针类型与被调用函数的输入类型要一一对应\n\nint main()\n{\n int a = 1, b = 2, sum;\n\n //宏定义函数指针类型\n HMODULE hLibrary = ::LoadLibrary(L\"ForDLLCreat.dll\"); //加载动态库文件，dll名前不加L会报错\n if (hLibrary == NULL)\n {\n  printf(\"No DLL file exist!\\n\");\n  return -1;\n }\n Func dllPro = (Func)::GetProcAddress(hLibrary, \"OUTPUT\");\n //获得 Fortran 导出函数的地址\n if (dllPro == NULL)\n {\n  printf(\"Can not fine the address of the function!\\n\");\n  return -2;\n }\n dllPro(&a, &b, &sum);\n printf(\"%d + %d = %d\\n\", a, b, sum);\n FreeLibrary(hLibrary); //卸载动态库文件\n return 0;\n}","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"这段代码是一个使用C语言调用动态链接库（DLL）中函数的示例代码，其解释如下：","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"#include <stdio.h>：包含了标准输入输出函数的头文件。\n#include <windows.h>：包含了调用Windows API函数所需的头文件。\ntypedef void(*Func)(int *, int *, int *);：定义了一个函数指针类型Func，该指针类型与被调用函数的输入类型一一对应，即接受三个int型指针作为参数且没有返回值。\nint main()：主函数的入口。\nint a = 1, b = 2, sum;：声明整型变量a、b和sum，并分别初始化a和b的值。\nHMODULE hLibrary = ::LoadLibrary(L\"ForDLLCreat.dll\");：加载名为\"ForDLLCreat.dll\"的动态库文件。LoadLibrary函数返回一个句柄（HMODULE），用于后续操作。\nif (hLibrary == NULL)：检查动态库文件是否加载成功，如果返回的句柄为空，则说明加载失败，打印错误信息并退出程序。\nFunc dllPro = (Func)::GetProcAddress(hLibrary, \"OUTPUT\");：通过GetProcAddress函数获取动态库中名为\"OUTPUT\"的函数的地址，并将其赋给函数指针变量dllPro。\nif (dllPro == NULL)：检查函数地址是否获取成功，如果返回的地址为空，则说明获取失败，打印错误信息并退出程序。\ndllPro(&a, &b, &sum);：通过函数指针调用函数，将a、b和sum的地址作为参数传递给被调用函数。\nprintf(\"%d + %d = %d\\n\", a, b, sum);：打印计算结果。\nFreeLibrary(hLibrary);：卸载动态库文件，释放资源。\nreturn 0;：程序正常结束返回值。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"总体而言，该代码加载了一个名为\"ForDLLCreat.dll\"的动态库文件，并通过函数指针调用了其中的\"OUTPUT\"函数，将a和b的值作为输入，计算它们的和并将结果存储在sum中，最后打印出计算结果。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/#使用Julia调用dll","page":"动态链接库(DLL)的生成与调用实操","title":"使用Julia调用dll","text":"","category":"section"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"Julia官方文档地址：Calling C and Fortran Code","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"在开始前，请务必确认Julia的位数与所用dll位数相同，否则会报错dll不是一个可用的Win32应用。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"ForDllCreate.dll与ForDllCreate.64.dll内部包含和前文相同的函数，区别是前者是32位，后者是64位。 在64位REPL上载入32位dll会报错。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"ERROR: LoadError: could not load library \"e:\\yyb\\HF_first\\ForDllCreat.dll\"\n%1 is not a valid Win32 application.\nStacktrace:\n [1] top-level scope\n   @ e:\\yyb\\HF_first\\test.jl:15\nin expression starting at e:\\yyb\\HF_first\\test.jl:15","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"如果你想在Julia中使用ccall函数来调用DLL中的函数，你可以按照以下步骤进行操作：","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"假设你有一个名为\"example.dll\"的DLL文件，其中包含一个名为\"add_numbers\"的函数，用于将两个整数相加。\n在Julia中，使用ccall函数来加载和调用DLL中的函数。以下是一个示例：","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"# 调用ccall函数加载DLL文件\nconst lib = \"example.dll\"\nconst handle = ccall((:LoadLibraryA, lib), Ptr{Cvoid}, (Cstring,), lib)\n\n# 定义要调用的函数的签名\nconst add_numbers = ccall((:add_numbers, lib), Cint, (Cint, Cint))\n\n# 调用函数并获取结果\nresult = add_numbers(5, 3)\nprintln(result)  # 输出 8\n\n# 卸载DLL\nccall((:FreeLibrary, lib), Cint, (Ptr{Cvoid},), handle)","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"在上面的示例中，我们首先使用ccall函数加载名为\"example.dll\"的DLL文件。通过指定函数名称和DLL文件的句柄，我们可以获取要调用的函数的指针。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"然后，我们定义了一个名为add_numbers的Julia函数，并使用ccall函数将其与DLL中的add_numbers函数关联起来。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"最后，我们调用add_numbers函数，并将参数5和3传递给它。返回的结果存储在result变量中，并打印到控制台。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"最后，我们使用ccall函数卸载DLL文件，以释放资源。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"请注意，示例中的函数签名和参数类型可能需要根据DLL中的实际函数进行调整。确保使用正确的参数类型和返回类型。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"使用ccall函数直接调用DLL函数时，需要小心处理内存管理和类型匹配，确保传递正确的参数和返回类型。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"以下是我们针对自己生成的dll的调用的例子：","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"#error\na = [1]\nb = [2]\nc = [0]\nccall((:OUTPUT, \".\\\\ForDllCreat.dll\"), Cvoid, (Ptr{Cint}, Ptr{Cint}, Ptr{Cint}), pointer_(a), pointer(b), pointer(c))\nprint(c)\n\n#work\na = [1]\nb = [2]\nc = [0]\nccall((:OUTPUT, \".\\\\ForDllCreat64.dll\"), Cvoid, (Ptr{Cint}, Ptr{Cint}, Ptr{Cint}), pointer_from_objref(a) + 0x40, pointer_from_objref(b) + 0x40, pointer_from_objref(c) + 0x40)\nprint(c)","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"解释：","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"在第一段代码中，使用了名为ForDllCreat.dll的 DLL 文件来执行函数调用。函数名称为OUTPUT，该函数接受三个整型指针作为参数，并将结果存储在指针c指向的位置。通过ccall函数来调用 DLL 中的函数，并传递指针参数。最后打印出指针c所指向的值。\n在第二段代码中，使用了名为ForDllCreat64.dll的 DLL 文件来执行函数调用。其他部分与第一段代码类似，但是在传递指针参数时，对每个指针都进行了偏移，即将指针从对象引用中提取后加上0x40的偏移量。最后同样打印出指针c所指向的值。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"请注意，这段代码中的部分函数和对象引用是特定于编程语言的，并且需要正确配置和具备相应的 DLL 文件才能正常运行。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"Julia可用通过ccall函数调用C和Fortran编译的dll文件，输入格式为","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"  ccall((function_name, library), returntype, (argtype1, ...), argvalue1, ...)\n  ccall(function_name, returntype, (argtype1, ...), argvalue1, ...)  \n  ccall(function_pointer, returntype, (argtype1, ...), argvalue1, ...)","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"这里通过第一种调用方法来调用我们编译的ForDllCreat64.dll，","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"function_name是调用的函数名称。引用时即可以用:OUTPUT表示，也可以用\"OUTPUT\"表示。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"C语言与Fortran输出dll时函数名不变，C++输出函数有命名粉碎，自制dll尽量采用C输出，一定要确定被调用函数的名字才能成功引用。可看此视频","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"library是被调用dll的路径，用字符串表示。调用C标准库中的函数时，library可以略去。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"#调用C标准库函数，不用写引用\nt = ccall(:clock, Int32, ())","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"returntype是被调函数的返回类型。Fortran的subroutine返回类型是空，即void，在Julia中表示为Cvoid。数据类型对应的表格可以参考下文表格，也可以查看官方文档。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"(argtype1, ...)是一个tuple，与被调函数的输入变量类型要一一对应，类似在C++中定义一个与被调函数输入变量类型一一对应的函数原型。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"argvalue1, ...  这部分是输入变量，类型要与(argtype1, ...)一一对应，并与被调函数对应。输入变量不用tuple表示。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"不同语言间调用dll，最重要的就是数据类型的匹配。下表是从Julia官方文档中复制的数据类型对应表。更多细节请查看官方文档。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"(Image: 图 1)  ","category":"page"},{"location":"CSBase/9-dll生成与调用实操/#更多julia的信息","page":"动态链接库(DLL)的生成与调用实操","title":"更多julia的信息","text":"","category":"section"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"Julia中指针的用法 （以下内容暂时不用那么细，先忽略，需用到时查julia的官方文档。）","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"数组类型基本上通过指针传递。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"Julia中，指针有两种，Ptr{T}与Ref{T}","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"Ptr表示的是从变量获得的地址，这类地址是否被销毁不由Julia管理，一般是“危险的”（unsafe)。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"Ref是由Julia分配的地址，这类地址的任何更改都由Julia进行，因此是“安全的”。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"但是Ref能用的方法似乎不多，目前为止我没学明白这个怎么用。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"Julia中获得变量地址的函数有pointer和pointerformobjref，他们获得的指针都是Ptr型的 pointer获得的地址被标明了数据类型，并且总比pointerformobjref的返回值多出一个数据类型的bit数；pointerformobjref获得的地址是无数据类型的。 在官方文档中，pointerfromobjref是对C提供接口的方法(C_Interface)","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"a=\"大家好\"\nb=pointer(a)\nc=pointer_from_objref(a)\nprintln(b)\nprintln(c)\nprintln(b-c)\n\nprintln(\"a[1]的字节数是\",sizeof(typeof(a[1])))#UInt8的字节数是1,但是Char类型的字节数是4","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"由地址获得值的方法是unsafepointerto_objref，这个函数也是官方文档中C接口的函数。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"对一个Ptr指针，用pointer获得的指针要减去一个数据类型的bit数才能获得指针内的值。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"a=[1.23]\n\nb=pointer(a)\nc=pointer_from_objref(a)\n\nd=unsafe_pointer_to_objref(b-0x40)\ne=unsafe_pointer_to_objref(c)\n\nprintln(\"d=\",d)\nprintln(\"e=\",e)","category":"page"},{"location":"Optimization/Optimization.jl/#Optimization.jl","page":"Optimization.jl","title":"Optimization.jl","text":"","category":"section"},{"location":"Optimization/Optimization.jl/#简介","page":"Optimization.jl","title":"简介","text":"","category":"section"},{"location":"Optimization/Optimization.jl/","page":"Optimization.jl","title":"Optimization.jl","text":"Optimization.jl 提供了最简便的方式来创建优化问题并解决它。它通过为超过 25 个优化库提供统一的接口，涵盖了 100 多个优化求解器，几乎包含了所有类别的优化算法，例如全局优化、混合整数优化、非凸优化、二阶局部优化、约束优化等。它允许您通过简单地传递一个参数来选择自动微分 (Automatic Differentiation, AD) 后端，从而自动生成目标函数和约束的高效导数，同时还可以根据问题的需要在不同的 AD 引擎之间切换。此外，Optimization.jl 会传递特定于问题的信息给那些可以利用它的求解器，例如海森矩阵或约束雅可比矩阵的稀疏模式和表达式图。","category":"page"},{"location":"Optimization/Optimization.jl/","page":"Optimization.jl","title":"Optimization.jl","text":"它扩展了常见的 SciML 接口，使得熟悉 SciML 生态系统的用户能够轻松使用。而且，它也非常容易扩展到新的求解器和新的问题类型。该包目前得到积极维护，定期添加新特性。","category":"page"},{"location":"Optimization/Optimization.jl/","page":"Optimization.jl","title":"Optimization.jl","text":"总体而言，Optimization.jl 提供了非常便捷的方法来进行优化问题的建模和求解。通过提供统一的接口和自动微分支持，它使得用户可以快速进行原型开发和实验，并且在语法上没有太多的负担。该库覆盖了广泛的优化算法，可以满足各种复杂的优化问题，并且非常容易扩展到新的算法和问题类型。","category":"page"},{"location":"Optimization/Optimization.jl/#核心库和模块","page":"Optimization.jl","title":"核心库和模块","text":"","category":"section"},{"location":"Optimization/Optimization.jl/","page":"Optimization.jl","title":"Optimization.jl","text":"Optimization.jl 是一个功能强大的优化库，提供了多个模块来支持不同类型的优化问题和算法。以下是对 Optimization.jl 中所有主要模块的介绍：","category":"page"},{"location":"Optimization/Optimization.jl/","page":"Optimization.jl","title":"Optimization.jl","text":"Optimization: 该模块是 Optimization.jl 的核心模块，提供了创建和求解优化问题的基本功能。其中包括 OptimizationProblem 类型的定义，用于表示优化问题，以及 optimize 函数，用于调用不同的优化器求解问题。\nOptimizationMOI: 该模块实现了 MathOptInterface 接口，这是一种通用的优化问题描述和求解接口。通过使用 MathOptInterface 接口，Optimization.jl 可以与其他优化库无缝集成，扩展了优化算法的选择范围。\nOptimizationOptimJL: 该模块提供了与 Optim.jl 库的兼容性，使得使用 Optim.jl 编写的代码可以直接在 Optimization.jl 中运行，无需进行重写。\nOptimizationSystems: 该模块提供了一种更抽象的优化问题描述方法，通过建立系统来定义变量、目标函数和约束条件，并通过各种优化器求解。\nOptimizationSolvers: 该模块包含一些特定类型的优化器，例如全局优化器、混合整数优化器等。用户可以根据需要选择不同的优化器来适应不同类型的优化问题。\nOptimizationUtilities: 该模块提供了一些实用工具函数，用于处理优化问题中的常见任务，例如处理约束条件、目标函数梯度的计算等。\nOptimizationResults: 该模块定义了优化结果的数据结构，包括最优解、最优值、收敛信息等。用户可以通过查询 OptimizationResults 对象来获取求解结果的相关信息。\nOptimizationModels: 该模块用于创建一些标准的优化问题模型，例如线性规划、二次规划等。这些模型可以用作优化问题的起点，也可以通过修改和扩展来适应特定的问题。\nOptimizationExamples: 该模块提供了一些优化问题的示例代码，帮助用户了解如何使用 Optimization.jl 来解决不同类型的优化问题。\nOptimizationAuto: 该模块提供了自动微分和自动建模工具，用于自动生成目标函数和约束函数的梯度和雅可比矩阵。这样可以简化用户在使用不同优化器时的工作。","category":"page"},{"location":"Optimization/Optimization.jl/","page":"Optimization.jl","title":"Optimization.jl","text":"Optimization.jl 的模块设计使得用户可以根据问题的具体要求和复杂程度，选择适合的模块和优化器来解决优化问题。它为用户提供了丰富的功能和灵活性，让用户能够更轻松地进行优化问题的建模和求解。同时，与其他优化库的兼容性和扩展性使得 Optimization.jl 成为一个强大的优化工具，适用于各种优化场景。更多详细内容请参考官方文档。","category":"page"},{"location":"Optimization/Optimization.jl/#特点和功能","page":"Optimization.jl","title":"特点和功能","text":"","category":"section"},{"location":"Optimization/Optimization.jl/","page":"Optimization.jl","title":"Optimization.jl","text":"统一接口：Optimization.jl 提供统一的接口，可以方便地创建和解决不同类型的优化问题，包括全局优化、混合整数优化、非凸优化、局部梯度优化、有约束优化等。\n多样化的优化器：Optimization.jl 支持多种优化器，包括 BFGS、L-BFGS、COBYLA、SLSQP、IPOPT、CMA-ES 等，覆盖了常见的优化算法和方法。\n自动微分和自动建模：Optimization.jl 提供自动微分和自动建模工具，可以自动生成目标函数和约束函数的梯度和雅可比矩阵，简化了优化问题的建模过程。\n与其他优化库兼容：Optimization.jl 实现了 MathOptInterface 接口，使其能够与其他优化库（如 Ipopt.jl、CMAEvolutionaryStrategy.jl 等）无缝集成，扩展了优化算法的选择范围。\n可扩展性：Optimization.jl 的设计考虑了扩展性，用户可以轻松地扩展新的优化器、新的问题类型，或者将现有的优化算法应用于自己的特定问题。\n科学计算生态系统：Optimization.jl 与 Julia 的科学计算生态系统（SciML）紧密集成，可以与 DifferentialEquations.jl 等库无缝合作，支持更广泛的科学计算任务。","category":"page"},{"location":"Optimization/Optimization.jl/#优化器支持","page":"Optimization.jl","title":"优化器支持","text":"","category":"section"},{"location":"Optimization/Optimization.jl/","page":"Optimization.jl","title":"Optimization.jl","text":"优化包 局部梯度优化 局部海森矩阵优化 局部无导数优化 箱约束优化 局部约束优化 全局无约束优化 全局约束优化\nBlackBoxOptim ❌ ❌ ❌ ✅ ❌ ✅ ❌ ✅\nCMAEvolutionaryStrategy ❌ ❌ ❌ ✅ ❌ ✅ ❌\nEvolutionary ❌ ❌ ❌ ✅ ❌ ✅ 🟡\nFlux ✅ ❌ ❌ ❌ ❌ ❌ ❌\nGCMAES ❌ ❌ ❌ ✅ ❌ ✅ ❌\nMathOptInterface ✅ ✅ ✅ ✅ ✅ ✅ 🟡\nMultistartOptimization ❌ ❌ ❌ ✅ ❌ ✅ ❌\nMetaheuristics ❌ ❌ ❌ ✅ ❌ ✅ 🟡\nNOMAD ❌ ❌ ❌ ✅ ❌ ✅ 🟡\nNLopt ✅ ❌ ✅ ✅ 🟡 ✅ 🟡\nNonconvex ✅ ✅ ✅ ✅ 🟡 ✅ 🟡\nOptim ✅ ✅ ✅ ✅ ✅ ✅ ✅\nQuadDIRECT ❌ ❌ ❌ ✅ ❌ ✅ ❌","category":"page"},{"location":"Optimization/Optimization.jl/","page":"Optimization.jl","title":"Optimization.jl","text":"“✅”表示支持该问题类型的优化，","category":"page"},{"location":"Optimization/Optimization.jl/","page":"Optimization.jl","title":"Optimization.jl","text":"“🟡”表示在相关其他库中已经有对应功能的支持，但是还未被添加到当前优化包中。","category":"page"},{"location":"Optimization/Optimization.jl/","page":"Optimization.jl","title":"Optimization.jl","text":"“❌”表示不支持该问题类型的优化。","category":"page"},{"location":"Optimization/Optimization.jl/","page":"Optimization.jl","title":"Optimization.jl","text":"局部梯度优化：这类问题是在目标函数可微的情况下进行优化，算法依赖目标函数的梯度信息。这类算法在每次迭代中根据当前点的梯度方向来更新搜索方向，寻找局部最优解。常见的优化器包括：L-BFGS、ConjugateGradient、BFGS、NewtonCG 等。\n局部海森矩阵优化：类似于局部梯度优化，这类问题也假设目标函数可微分，但在更新搜索方向时使用了海森矩阵信息，提供更快的收敛速度。常见的优化器包括：NewtonTR 等。\n局部无导数优化：这类问题在目标函数不可微的情况下进行优化，即目标函数没有明确的梯度信息。在这种情况下，优化器只能通过目标函数的有限次函数评估来进行优化，通常使用直接搜索或进化算法等方法。常见的优化器包括：NelderMead、SimulatedAnnealing 等。\n箱约束优化：这类问题是在搜索空间的边界上有一些限制条件（上下界）的优化问题。优化器必须在搜索过程中满足这些约束条件。大多数局部优化器可以处理箱约束优化问题，只需将上下界信息传递给优化器即可。\n局部约束优化：这类问题是在目标函数的优化过程中还有一些额外的等式或不等式约束条件。优化器在搜索过程中要同时满足这些约束条件。常见的优化器包括：L-BFGS、ConjugateGradient、BFGS、NewtonCG 等。\n全局无约束优化：这类问题是在没有约束的情况下，寻找全局最优解。这通常是一个非常复杂的问题，全局优化算法通常会采用启发式方法来搜索整个搜索空间，以找到全局最优解。常见的优化器包括：DifferentialEvolution、ParticleSwarm 等。\n全局约束优化：这类问题是在搜索空间中还有额外的约束条件，优化器要在搜索过程中满足这些约束条件，并找到全局最优解。这是一个非常具有挑战性的问题，全局优化算法通常使用启发式方法和全局搜索策略来解决。常见的优化器包括：DifferentialEvolution、ParticleSwarm 等。","category":"page"},{"location":"Optimization/Optimization.jl/","page":"Optimization.jl","title":"Optimization.jl","text":"在实际应用中，选择正确的优化器和优化算法对于获得高效和准确的优化结果非常重要。","category":"page"},{"location":"Optimization/Optimization.jl/#使用方法","page":"Optimization.jl","title":"使用方法","text":"","category":"section"},{"location":"Optimization/Optimization.jl/","page":"Optimization.jl","title":"Optimization.jl","text":"安装：在Julia中，导入 Optimization.jl ：","category":"page"},{"location":"Optimization/Optimization.jl/","page":"Optimization.jl","title":"Optimization.jl","text":"using Pkg\nPkg.add(\"Optimization\")","category":"page"},{"location":"Optimization/Optimization.jl/","page":"Optimization.jl","title":"Optimization.jl","text":"下面举例说明Optimization.jl 的使用方法：","category":"page"},{"location":"Optimization/Optimization.jl/","page":"Optimization.jl","title":"Optimization.jl","text":"导入相应包\nusing Optimization\nusing OptimizationOptimJL\nusing Optimization: 这里导入了 Optimization.jl 包，使得我们可以使用该包中的优化功能。\nusing OptimizationOptimJL: 这里导入了 OptimizationOptimJL 包，使得我们可以使用该包中的优化器。\n定义目标函数\nrosenbrock(x, p) = (p[1] - x[1])^2 + p[2] * (x[2] - x[1]^2)^2\nrosenbrock(x, p) = (p[1] - x[1])^2 + p[2] * (x[2] - x[1]^2)^2: 这是定义了一个 Rosenbrock 函数，用于优化问题的目标函数。函数的输入参数是向量 x 和参数向量 p，返回目标函数的值。\n初始化参数初,始解向量\nx0 = zeros(2)\np = [1.0, 100.0]\nx0 = zeros(2): 这里初始化了一个初始解向量 x0，包含两个元素，均为0.0。\np = [1.0, 100.0]: 这里初始化了一个参数向量 p，包含两个元素，分别是1.0和100.0。\n构建优化问题\nprob = OptimizationProblem(rosenbrock, x0, p)\nprob = OptimizationProblem(rosenbrock, x0, p): 这里使用 OptimizationProblem 函数构建了一个优化问题 prob。传递了目标函数 rosenbrock，初始解向量 x0，和参数向量 p。\n求解\nsol = solve(prob, NelderMead())\nsol = solve(prob, NelderMead()): 这里使用 solve 函数求解了之前构建的优化问题 prob，采用了 Nelder-Mead 优化器。sol 变量将存储优化结果。\n若需要更多详细内容和深入学习 Optimization.jl 的用法和功能，可以通过官方文档或社区和论坛获得详细的使用说明、示例代码和API参考。","category":"page"},{"location":"Optimization/Optimization.jl/#小结","page":"Optimization.jl","title":"小结","text":"","category":"section"},{"location":"Optimization/Optimization.jl/","page":"Optimization.jl","title":"Optimization.jl","text":"不同的优化器具有各自不同的复杂语法结构，使得优化器的使用变得繁琐。而 Optimization.jl 提供了统一接口，简化了优化问题的编写过程。","category":"page"},{"location":"Optimization/Optimization.jl/","page":"Optimization.jl","title":"Optimization.jl","text":"使用 Optimization.jl 的代码相比手动实现优化算法更简洁和易于理解。通过 Optimization.jl，我们可以使用 OptimizationProblem 函数一行代码来构建优化问题，并直接传递目标函数、初始解向量、约束等参数，不需要手动编写繁琐的构建优化问题的过程。","category":"page"},{"location":"Optimization/Optimization.jl/","page":"Optimization.jl","title":"Optimization.jl","text":"而且，使用 solve 函数时，只需要传递优化问题和选择的优化器，省略了手动实现优化算法的迭代过程，大大简化了代码。用户无需关心算法的细节，只需要关注问题的建模和求解过程。","category":"page"},{"location":"Optimization/Optimization.jl/","page":"Optimization.jl","title":"Optimization.jl","text":"Optimization.jl 还支持自动微分功能。通过选择不同的自动微分引擎，用户可以轻松获得目标函数和约束函数的导数，避免了手动计算导数的麻烦，加速了优化求解过程。","category":"page"},{"location":"Optimization/Optimization.jl/","page":"Optimization.jl","title":"Optimization.jl","text":"总的来说，使用 Optimization.jl 可以使代码更加简洁、清晰和易于理解。它提供了一种高级的优化框架，让用户可以专注于问题本身的建模和求解，而无需过多关注优化算法的细节。这样可以提高代码的可读性和可维护性，并减少出错的可能性。","category":"page"},{"location":"Tools/CSV_jl_use/#CSV.jl使用简介","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"tip: Tip\nContents：CSV文本读入Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"note: Note\nCSV.jl是一个快速灵活的纯 Julia包，用于处理带分隔符的文本文件。","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"在建立模型与模型计算的过程中，可以很好的解决数据导入问题，它能自动辨识文本数据类型，并将数据分隔。","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"它的应用场景是：使用数据之前的输入导入。","category":"page"},{"location":"Tools/CSV_jl_use/#基本实现","page":"CSV.jl使用简介","title":"基本实现","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"文件内容：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"col1,col2,col3,col4,col5,col6,col7,col8\n,1,1.0,1,one,2019-01-01,2019-01-01T00:00:00,true\n,2,2.0,2,two,2019-01-02,2019-01-02T00:00:00,false\n,3,3.0,3.14,three,2019-01-03,2019-01-03T00:00:00,true","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"使用以下代码导入文件","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\") #file为文件名，如\"data.csv\"、\"data.txt\"","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"默认情况下，CSV.File会自动检测这个文件的分隔符','，以及每列的类型。默认情况下，它将“空字段”视为missing（本示例中的整个第一列）。它还自动处理提升类型，例如第 4 列，其中前两个值为Int，但第 3 行具有Float64值 ( 3.14)。","category":"page"},{"location":"Tools/CSV_jl_use/#自定义分隔符","page":"CSV.jl使用简介","title":"自定义分隔符","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"文件内容：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"col1::col2\n1::2\n3::4","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"使用以下代码导入文件","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; delim=\"::\")","category":"page"},{"location":"Tools/CSV_jl_use/#无标题情况","page":"CSV.jl使用简介","title":"无标题情况","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"文件内容：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"1,2,3\n4,5,6\n7,8,9","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"在没有标题的情况下，会默认把第一行当作标题，可以给定参数取消，使用以下代码导入文件","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; header=false) #取消标题","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"或者也可以手动给定标题","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; header=[\"col1\", \"col2\", \"col3\"]) #手动给定标题","category":"page"},{"location":"Tools/CSV_jl_use/#指定数据行数","page":"CSV.jl使用简介","title":"指定数据行数","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"文件内容：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"col1,col2,col3\nmetadata1,metadata2,metadata3\nextra1,extra2,extra3\n1,2,3\n4,5,6\n7,8,9","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"假如我们期望的内容是从第四行开始，可以使用以下代码","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; skipto=4) #从第四行开始","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"或者","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; datarow=4)","category":"page"},{"location":"Tools/CSV_jl_use/#读取数据段","page":"CSV.jl使用简介","title":"读取数据段","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"文件内容：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"col1,col2,col3\n1,2,3\n4,5,6\n7,8,9\n10,11,12\n13,14,15\n16,17,18\n19,20,21","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"只需要读入某一段数据段","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; skipto=4，limit=1) #从第四行开始,读取1行","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"或者","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; skipto=4，footerskip=1) #从第四行开始,除去最后一行","category":"page"},{"location":"Tools/CSV_jl_use/#转置","page":"CSV.jl使用简介","title":"转置","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"文件内容：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"col1,1,2,3\ncol2,4,5,6\ncol3,7,8,9","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"用如下代码导入","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; transpose=true) #从第四行开始,读取1行","category":"page"},{"location":"Tools/CSV_jl_use/#数据操作","page":"CSV.jl使用简介","title":"数据操作","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"我们以一下文件输入为例：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"col1,col2,col3\n1,2,3\n4,5,6\n7,8,9\n10,11,12\n13,14,15\n16,17,18\n19,20,21","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"用如下代码导入","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"data = CSV.File(\"data.txt\") ","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"现在相当于把数据储存到变量data中了，data是CSV.File类型的数据，可以通过typeof函数来查看一下：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"typeof(data)","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"现在调用某一列的数字：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"println(data.col1) #显示第一列\nprintln(data.col2) #显示第二列\nprintln(data.col3) #显示第三列","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"它的结果是：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"[1, 4, 7, 10, 13, 16, 19]","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"[2, 5, 8, 11, 14, 17, 20]","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"[3, 6, 9, 12, 15, 18, 21]","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"查看一列的数据类型","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"typeof(data.col1)","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"它的结果是：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"Vector{Int64}","category":"page"},{"location":"Tools/CSV_jl_use/#小结","page":"CSV.jl使用简介","title":"小结","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"可以发现，data是CSV.File类型，但是通过data调用的每一列数据是vector类型","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"说明可以把每一列当作平常的vector来处理，相关的方法都能够匹配。","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"比如：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"sum(data.col1)\na = data.col1 .* data.col2","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"tip: Tip\n推荐一个好用的数据展示包DataFrames，它一般与CSV.jl结合起来使用在julia的包模式下安装：add DataFrames将data漂亮的输出，只需要：using DataFrames\ndisplay(DataFrame(data))","category":"page"},{"location":"StepByStep/06-goctl生成api服务/#goctl生成api代码","page":"goctl生成api代码","title":"goctl生成api代码","text":"","category":"section"},{"location":"JuliaIntro/3-julia的语法要点/#julia的语法要点","page":"julia的语法要点","title":"julia的语法要点","text":"","category":"section"},{"location":"JuliaIntro/3-julia的语法要点/","page":"julia的语法要点","title":"julia的语法要点","text":"当您开始学习Julia的基本语法时，以下是一些简单的介绍和示例：","category":"page"},{"location":"JuliaIntro/3-julia的语法要点/#变量声明和赋值","page":"julia的语法要点","title":"变量声明和赋值","text":"","category":"section"},{"location":"JuliaIntro/3-julia的语法要点/","page":"julia的语法要点","title":"julia的语法要点","text":"在Julia中，您可以使用变量来存储数据。变量名以字母或下划线开头，可以包含字母、数字和下划线。您可以使用等号=将值赋给变量。","category":"page"},{"location":"JuliaIntro/3-julia的语法要点/","page":"julia的语法要点","title":"julia的语法要点","text":"x = 10\ny = \"Hello, Julia!\"","category":"page"},{"location":"JuliaIntro/3-julia的语法要点/#基本数据类型","page":"julia的语法要点","title":"基本数据类型","text":"","category":"section"},{"location":"JuliaIntro/3-julia的语法要点/","page":"julia的语法要点","title":"julia的语法要点","text":"Julia支持多种基本数据类型，包括整数（Integers）、浮点数（Floats）、布尔值（Booleans）、字符（Characters）和字符串（Strings）。","category":"page"},{"location":"JuliaIntro/3-julia的语法要点/","page":"julia的语法要点","title":"julia的语法要点","text":"x = 10\ny = 3.14\nis_true = true\nchar = 'a'\nstr = \"Hello, Julia!\"","category":"page"},{"location":"JuliaIntro/3-julia的语法要点/#数学运算","page":"julia的语法要点","title":"数学运算","text":"","category":"section"},{"location":"JuliaIntro/3-julia的语法要点/","page":"julia的语法要点","title":"julia的语法要点","text":"Julia支持常见的数学运算，包括加法、减法、乘法、除法和取余等。","category":"page"},{"location":"JuliaIntro/3-julia的语法要点/","page":"julia的语法要点","title":"julia的语法要点","text":"x = 10\ny = 5\nsum = x + y\ndifference = x - y\nproduct = x * y\nquotient = x / y\nremainder = x % y","category":"page"},{"location":"JuliaIntro/3-julia的语法要点/#条件语句","page":"julia的语法要点","title":"条件语句","text":"","category":"section"},{"location":"JuliaIntro/3-julia的语法要点/","page":"julia的语法要点","title":"julia的语法要点","text":"您可以使用条件语句在特定条件下执行不同的操作。Julia中的条件语句使用if-else结构。","category":"page"},{"location":"JuliaIntro/3-julia的语法要点/","page":"julia的语法要点","title":"julia的语法要点","text":"x = 10\nif x > 5\n   println(\"x is greater than 5\")\nelse\n   println(\"x is less than or equal to 5\")\nend","category":"page"},{"location":"JuliaIntro/3-julia的语法要点/#循环","page":"julia的语法要点","title":"循环","text":"","category":"section"},{"location":"JuliaIntro/3-julia的语法要点/","page":"julia的语法要点","title":"julia的语法要点","text":"您可以使用循环结构重复执行特定的代码块。Julia中的循环结构包括for循环和while循环。","category":"page"},{"location":"JuliaIntro/3-julia的语法要点/","page":"julia的语法要点","title":"julia的语法要点","text":"# 使用for循环\nfor i in 1:5\n   println(i)\nend\n\n# 使用while循环\nx = 1\nwhile x <= 5\n   println(x)\n   x += 1\nend","category":"page"},{"location":"JuliaIntro/3-julia的语法要点/#函数定义","page":"julia的语法要点","title":"函数定义","text":"","category":"section"},{"location":"JuliaIntro/3-julia的语法要点/","page":"julia的语法要点","title":"julia的语法要点","text":"您可以定义自己的函数来执行特定的任务。函数由函数名、参数和函数体组成。您可以使用function关键字来定义函数，并使用return语句返回值。","category":"page"},{"location":"JuliaIntro/3-julia的语法要点/","page":"julia的语法要点","title":"julia的语法要点","text":"function greet(name)\n   println(\"Hello, $name!\")\nend\n\ngreet(\"Alice\")","category":"page"},{"location":"JuliaIntro/3-julia的语法要点/","page":"julia的语法要点","title":"julia的语法要点","text":"这些只是Julia语法的一些基础知识。Julia是一种功能强大且灵活的语言，提供了许多高级功能和数据结构，可以用于更复杂的编程任务。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/#Windows下安装gcc编译器和CLion","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"","category":"section"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/#编译器和集成开发环境简介","page":"Windows下安装gcc编译器和CLion","title":"编译器和集成开发环境简介","text":"","category":"section"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"编译器和集成开发环境（IDE）是软件开发中常用的工具。下面是对它们的概括介绍：","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"编译器： 编译器是一种将源代码转换为可执行文件的工具。它接收编写的源代码作为输入，经过一系列的词法分析、语法分析、语义分析和代码优化等过程，生成可执行的目标代码或者字节码。编译器可以将高级编程语言（如C、C++、Java等）转换为机器码或者中间代码，以便计算机能够执行。\n在Windows系统中，GCC（GNU Compiler Collection）是一个非常流行的编译器套件。它支持多种编程语言，包括C、C++、Java等，并且可以在Windows上进行安装和使用。\n集成开发环境（IDE）： 集成开发环境是为了提供一个集成的开发环境，将编码、调试和构建等开发任务整合到一个界面中。IDE通常包括代码编辑器、编译器、调试器和其他开发工具，旨在提高开发效率。\nCLion是JetBrains开发的一款跨平台C/C++集成开发环境。它提供了代码编辑器、自动完成、调试器等功能，使得C和C++开发更加便捷。CLion还集成了CMake构建系统，可以帮助您轻松管理项目的构建过程。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/#Windows下安装msys2、gcc以及CLion","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装msys2、gcc以及CLion","text":"","category":"section"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"在Windows系统下，可以通过以下步骤安装GCC和CLion并使用MSYS2：","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"安装MSYS2：\n下载MSYS2安装程序并运行它：https://www.msys2.org/\n按照安装向导的指示完成安装过程。\n安装GCC：\n打开MSYS2 Shell（通过开始菜单中的MSYS2程序组找到）。\n运行以下命令来更新MSYS2软件包管理器：\npacman -Syu\n更新完成后，运行以下命令安装GCC：\npacman -S mingw-w64-x86_64-toolchain\n安装CLion：\n下载CLion安装程序并运行它：https://www.jetbrains.com/clion/\n按照安装向导的指示完成安装过程。\n配置CLion：\n打开CLion，并按照提示进行初始化设置。\n在\"Toolchains\"设置中，选择\"MinGW\"作为编译器，并指定MSYS2的安装路径。\n创建或导入您的项目，并开始编写、调试和构建您的代码。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"这样，您就可以在Windows系统下使用GCC和CLion进行C和C++的开发了。希望这些信息对您有所帮助！","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/#msys2是什么？","page":"Windows下安装gcc编译器和CLion","title":"msys2是什么？","text":"","category":"section"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"当谈到在Windows系统上进行开发时，MSYS2是一个常用的工具，它为Windows用户提供了类似于Unix或Linux环境的开发体验。以下是对MSYS2的补充介绍：","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"MSYS2（Minimal SYStem 2）是一个开源的软件发布和管理工具，旨在为Windows提供类似于GNU/Linux系统的开发环境。它基于Cygwin（Cygwin是一个在Windows上运行的类Unix环境）并扩展了其功能。MSYS2提供了一组工具和软件包，使开发者能够在Windows上使用常见的开发工具和软件。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"主要特点和功能：","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"软件包管理器：MSYS2使用自己的软件包管理器（称为pacman），它允许您轻松地安装、更新和删除开发所需的各种工具和库。通过pacman，您可以方便地安装GCC、CMake、Python等常用的开发工具和库。\n命令行环境：MSYS2提供了一个命令行界面（称为MSYS2 Shell），类似于Linux终端。它使用Bash作为默认的Shell，并提供了一系列的命令和工具，使得在Windows上进行命令行开发变得更加方便。\nGNU工具链支持：MSYS2提供了一组GNU工具，包括GCC编译器、GNU Make构建工具和其他常用的开发工具。这使得您可以在Windows上使用这些工具进行C、C++和其他编程语言的开发。\n环境隔离：MSYS2提供了一个隔离的环境，使得开发所需的工具和库可以与系统环境相互独立。这意味着您可以使用MSYS2提供的工具链，而不会与系统环境中的工具发生冲突。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"总结起来，MSYS2为Windows用户提供了一个方便和强大的开发环境，使得在Windows上进行跨平台开发变得更加容易。通过安装和使用MSYS2，您可以轻松地获取常用的开发工具和库，并在类Unix的环境下进行命令行开发。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/#再说说mingw和mingw64","page":"Windows下安装gcc编译器和CLion","title":"再说说mingw和mingw64","text":"","category":"section"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"当谈到在Windows系统上进行C和C++开发时，MinGW和MinGW-w64是两个常用的工具集，它们提供了在Windows环境下使用GNU工具链进行编译的能力。以下是对MinGW和MinGW-w64的介绍：","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"MinGW（Minimalist GNU for Windows）： MinGW是一个开源的工具集，旨在为Windows系统提供基于GNU工具的编译能力。它包括了一系列的GNU工具，如GCC编译器、GNU Binutils（包含链接器和汇编器）以及其他辅助工具。MinGW使用Windows API来编写原生Windows应用程序。\nMinGW的目标是提供一种轻量级的方式，在Windows上进行C和C++的编译，生成可在Windows环境下运行的可执行文件。它通过使用MinGW提供的工具链，将C和C++代码编译为与Windows操作系统兼容的可执行文件。\nMinGW-w64： MinGW-w64是MinGW的一个分支，它对原始的MinGW进行了扩展和改进。MinGW-w64的主要目标是支持64位Windows系统，并提供更好的兼容性和功能。\nMinGW-w64继承了MinGW的基本功能，同时添加了对64位Windows系统的支持。它提供了一套完整的工具链，包括GCC编译器、GNU Binutils和其他开发工具，用于在64位Windows系统上进行C和C++的编译和构建。\nMinGW-w64不仅支持64位Windows系统，还可以用于开发32位应用程序。它提供了对多种目标平台和架构的支持，包括x86、x86-64、ARM等。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"总结起来，MinGW和MinGW-w64是在Windows系统上进行C和C++开发的工具集，它们提供了GNU工具链，包括GCC编译器和其他辅助工具。MinGW主要用于32位Windows系统，而MinGW-w64扩展了对64位系统的支持，并提供更多功能和兼容性。通过使用MinGW或MinGW-w64，开发者可以在Windows环境下进行C和C++代码的编译和构建。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/#也许初学者需要Gcc的介绍","page":"Windows下安装gcc编译器和CLion","title":"也许初学者需要Gcc的介绍","text":"","category":"section"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"当谈到C和C++编程时，GCC（GNU Compiler Collection）是一个常用且强大的编译器套件，特别适合初学者。下面是对GCC的介绍：","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"GCC是由GNU开发的自由软件编译器集合，支持多种编程语言，包括C、C++、Objective-C、Fortran、Ada和其他一些语言。它被广泛用于各种操作系统和架构上，包括Linux、Windows、macOS等。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"GCC的主要特点和优势包括：","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"开源自由：GCC是自由软件，具有开源的特性。这意味着您可以自由地使用、修改和分发GCC，无需支付费用。\n跨平台支持：GCC可在多个操作系统上使用，包括Linux、Windows、macOS等。这使得您可以使用相同的编译器在不同的平台上进行开发。\n多语言支持：GCC支持多种编程语言，使得您可以在同一个编译器环境下开发不同语言的程序。特别是对于C和C++开发者来说，GCC提供了广泛的语言功能和标准支持。\n优化能力：GCC具有强大的代码优化能力，可以对生成的机器码进行各种优化，提高程序的执行效率和性能。\n标准兼容性：GCC遵循C和C++的标准规范，并不断更新以支持最新的语言标准。这使得您可以编写符合标准的代码，并享受语言提供的新特性和改进。\n开发工具集成：GCC集成了一系列的开发工具，如调试器（GDB）、性能分析工具（gprof）等，使得开发者能够进行调试和性能优化。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"对于初学者来说，GCC是一个非常有价值的工具，因为它易于获取、使用和学习。您可以通过安装GCC，将C和C++源代码编译为可执行文件，从而开始学习和开发自己的程序。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"请注意，对于Windows系统，您可以使用MSYS2或MinGW-w64来安装和使用GCC。这些工具集提供了在Windows环境下使用GCC的能力，并使得在Windows上进行C和C++开发变得更加便捷。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/#GNU好像也必须提一下","page":"Windows下安装gcc编译器和CLion","title":"GNU好像也必须提一下","text":"","category":"section"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"当谈到GCC时，有必要提及GNU（GNU's Not Unix）项目，因为GCC是GNU项目的一部分。以下是对GNU的简要介绍：","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"GNU是一个由理查德·斯托曼（Richard Stallman）发起的自由软件运动，旨在创建一个自由、开放和用户可控的操作系统。GNU项目致力于为用户提供自由软件的选择，使他们能够运行、修改、分发和改进软件。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"GNU项目不仅包括GCC编译器集合，还涵盖了许多其他重要的软件和工具，如GNU核心工具（包括shell、文本编辑器等）、GNU库（提供通用的功能库）以及GNU操作系统（GNU Hurd）等。这些工具和软件都是自由软件，可以免费使用、修改和分发。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"GNU的目标是创建一个完全自由的操作系统，以替代传统的专有操作系统。尽管GNU操作系统的核心（GNU Hurd）目前还没有广泛使用，但许多GNU工具和软件被广泛地集成到各种操作系统中，包括Linux、FreeBSD等。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"通过GNU项目，许多重要的开源软件和工具得以发展和推广，为开源社区做出了重要贡献。GCC作为GNU项目的一部分，是其中最受欢迎和广泛使用的组件之一。它提供了强大的编译能力，支持多种编程语言，并在开发者社区中广泛使用。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"总结起来，GNU是一个自由软件项目，旨在为用户提供自由、开放和用户可控的软件。GCC作为GNU项目的一部分，是一个功能强大且广泛使用的编译器套件，为开发者提供了可靠和高效的编译工具。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/#最后还是补充一下编译器、连接器、调试器、集成开发环境的概述及其相互关系","page":"Windows下安装gcc编译器和CLion","title":"最后还是补充一下编译器、连接器、调试器、集成开发环境的概述及其相互关系","text":"","category":"section"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"当进行软件开发时，以下是对编译器、连接器、调试器和集成开发环境（IDE）的概述及其相互关系的补充：","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"编译器： 编译器是一种将高级编程语言（如C、C++、Java等）编写的源代码转换为机器可执行代码（二进制文件）的工具。它负责将源代码进行词法分析、语法分析、优化和代码生成等步骤，最终生成可供计算机执行的可执行文件。\n连接器： 连接器（或链接器）是将编译后的目标文件（由编译器生成）和其他所需的库文件合并在一起，形成最终的可执行文件的工具。连接器负责解析和解决代码中的符号引用，将不同模块之间的代码进行链接，并处理动态链接库等外部依赖。\n调试器： 调试器是一种开发工具，用于帮助开发者识别和修复程序中的错误（bug）。它提供了诸如断点设置、变量查看、单步执行等功能，允许开发者逐行或逐语句地执行程序，并检查其状态以进行调试和排除故障。\n集成开发环境（IDE）： 集成开发环境是一个综合的开发工具，集成了编译器、连接器、调试器以及其他辅助开发工具。IDE提供了一个统一的界面，使开发者能够在一个环境中进行代码编写、编译、调试和测试等开发活动。它通常具有代码编辑器、项目管理、自动完成、调试器集成和构建系统等功能。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"这些工具之间存在着紧密的关联和相互依赖关系。编译器将源代码转换为目标文件，连接器将目标文件和库文件链接为可执行文件，而调试器允许开发者在执行过程中检查和修改代码。IDE则集成了这些工具，并提供了一个方便的开发环境，使开发者能够在一个界面中进行代码编写、编译、调试和测试等开发活动。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"使用IDE可以极大地提高开发效率，因为它们提供了许多辅助功能，如自动代码完成、语法检查、版本控制集成等。此外，IDE还提供了项目管理和构建系统，使开发者能够更好地组织和管理他们的代码。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"总结起来，编译器、连接器、调试器和集成开发环境是软件开发中常用的工具和环境。编译器将源代码转换为可执行文件，","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"连接器将目标文件链接为最终的可执行文件，调试器帮助开发者进行代码调试和故障排除，而IDE集成了这些工具，并提供了一个便捷的开发环境。这些工具相互协作，使开发者能够更轻松地编写、构建和调试他们的代码。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/#视频地址","page":"Windows下安装gcc编译器和CLion","title":"视频地址","text":"","category":"section"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"msys2安装","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"CLion安装及Fortran插件设置","category":"page"},{"location":"AIandML/1-机器学习和人工智能/#机器学习","page":"机器学习","title":"机器学习","text":"","category":"section"},{"location":"AIandML/1-机器学习和人工智能/#机器学习范围","page":"机器学习","title":"机器学习范围","text":"","category":"section"},{"location":"AIandML/1-机器学习和人工智能/#神经网络","page":"机器学习","title":"神经网络","text":"","category":"section"},{"location":"AIandML/1-机器学习和人工智能/#深度神经网络","page":"机器学习","title":"深度神经网络","text":"","category":"section"},{"location":"AIandML/1-机器学习和人工智能/#强化学习","page":"机器学习","title":"强化学习","text":"","category":"section"},{"location":"AIandML/1-机器学习和人工智能/#统计学习","page":"机器学习","title":"统计学习","text":"","category":"section"},{"location":"AIandML/1-机器学习和人工智能/#CNN-RNN-LSTM","page":"机器学习","title":"CNN RNN LSTM","text":"","category":"section"},{"location":"AIandML/1-机器学习和人工智能/#一层又一层抽象（手动实现一个神经网络来理解）","page":"机器学习","title":"一层又一层抽象（手动实现一个神经网络来理解）","text":"","category":"section"},{"location":"Modeling/MTK_tips/#MTK常见问题","page":"MTK常见问题","title":"MTK常见问题","text":"","category":"section"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"tip: Tip\nContents：建模、MTK、外部函数Contributor: YYBEmail: 812987139@qq.com如有错误，请批评指正。","category":"page"},{"location":"Modeling/MTK_tips/#UndefVarError","page":"MTK常见问题","title":"UndefVarError","text":"","category":"section"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"目前官方在此方面可能有bug，可以关注模型边界条件尝试避开问题","category":"page"},{"location":"Modeling/MTK_tips/#key-not-found","page":"MTK常见问题","title":"key not found","text":"","category":"section"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"在structural_simplify后，有些等式条件会自动微分，导致变量数没变，但是方程增加，进而导致模型不平衡","category":"page"},{"location":"Modeling/MTK_tips/#xxx-are-missing-from-variables-map","page":"MTK常见问题","title":"xxx are missing from variables map","text":"","category":"section"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"可能是初值没有设置。建议所有模型均设置初值，动态模型初值直接输入至defaults参数。","category":"page"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"@connector function flowPortNode(; name)\n    #通流元件节点，在热力学节点上包装了体积、质量流量 \n    #如果同时需要标记connect类型，还要赋值，那么一定要括起来\n    #initialValue写作Dict或者数组都可以\n    sts = @variables begin\n        p(t)\n        T(t)\n        (qm(t), [connect = Flow])\n        (rho(t), [connect = Stream])\n        (mu(t), [connect = Stream])\n        (qv(t), [connect = Stream])\n    end\n    initialValue = [\n        p => 1.013e5\n        T => 300\n        qm => 0\n        rho => 1.2\n        mu => 1.819e-5\n        qv => 0\n    ]\n    eqs = [\n        0 ~ stateEquation(p, rho, T)\n        mu ~ 1.819e-5\n        #qm ~ rho * qv\n        qv ~ qm / rho\n    ]\n    ODESystem(eqs, t, sts, []; name=name, defaults=initialValue)\nend","category":"page"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"在生成问题前再统一传入初值。","category":"page"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"u01 = [\n    d_temp => 0\n]\n\na = ModelingToolkit.defaults(sys1)\nfor i in keys(a)\n    global u01\n    u01 = [u01; i => a[i]]\nend","category":"page"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"该问题的产生原因与DAE问题的求解算法有关。将DAE问题降指数为ODE问题后，模型可能需要更多的初始条件作为输入。","category":"page"},{"location":"Control/MTKMPC/#MTK求解MPC问题","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"","category":"section"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"tip: Tip\nContents：MTK、ControlContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"note: Note\nMPC = Model Predict ControlMTK = ModelingToolkit.jlOptimizationSystem为MTK中的系统类型之一","category":"page"},{"location":"Control/MTKMPC/#MTK中的ControlSystem","page":"MTK求解MPC问题","title":"MTK中的ControlSystem","text":"","category":"section"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"在ModellingToolkit的Optimal Control中，有关于ControlSystem的描述。但经过实验测试，ControlSystem并不能很好地求解“过程控制量”的值。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"因为MTK使用rungekuttadiscretize（龙格库塔离散）函数将问题离散。问题离散后，传入OptimizationSystem，而OptimizationSystem目前有一个缺陷——不能接受问题的约束。所以，即使用龙格库塔离散离散出控制过程中的多个状态量，在变量没有约束时，优化结果没有意义。（离散的概念在微分方程参数辨识中有提及） 在实例过后，这一点会有清晰的体现。","category":"page"},{"location":"Control/MTKMPC/#MTK中的OptimizationSystem","page":"MTK求解MPC问题","title":"MTK中的OptimizationSystem","text":"","category":"section"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"为了简单起见，手动构建一个MPC优化问题，通过OptimizationSystem来求解。通过构建优化目标方程，调用不同优化器求解该优化问题。那么从控制问题到优化问题这一过程可以看成是手动离散。相当于自己实现了rungekuttadiscretize。构建完优化问题，就可以直接把它推给OptimizationProblem求解，这是可以做到的。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"上述过程的核心就是把控制中的状态量手写出来。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"可行的做法是，通过MTK符号建模体系建立优化变量，同时构建Loss方程关于优化变量的符号表达。通过OptimizationSystem生成用符号体系构建的优化问题，把构建的OptimizationSystem推给OptimizationProblem，最后选择合适的求解器求解。","category":"page"},{"location":"Control/MTKMPC/#实例：加热器问题","page":"MTK求解MPC问题","title":"实例：加热器问题","text":"","category":"section"},{"location":"Control/MTKMPC/#问题描述","page":"MTK求解MPC问题","title":"问题描述","text":"","category":"section"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"现在有一个物体加热，它的温度由加热项和散热项决定。α是散热系数，β是加热系数，环境温度为T_out。那么控制方程: ","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"T = α*(T_out - T) + β*Q(t)","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"现在可以改变加热功率，那么我们构建一个优化问题：调节加热功率，使得物体的温度从T_0开始，迅速上升并且稳定在某一个温度（比如说58℃）。问题的数学表达为，通过优化控制变量Q(t) 使得损失函数最小:","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"Loss = sum_i 580-T(t_i)","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"而Q(t_i)就是未来一段时间域内，不同时间点上的控制量（控制科学中称为状态量）。通过改变这些值，能够控制温度的走势，这是控制的内涵。若使温度达到一个让人满意的状态（这里是维持在58℃，也可以是使温度线性上升等等），这是最优控制的内涵。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"所以，最优控制或者模型预测控制最根本的数学内涵是优化——多变量优化。这也是为什么能用OptimizationProblem来处理控制问题。","category":"page"},{"location":"Control/MTKMPC/#构建问题","page":"MTK求解MPC问题","title":"构建问题","text":"","category":"section"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"首先明确问题。现在假设以一个恒定功率（p=80）加热物体，环境温度18℃，初始温度20℃,散热系数α = 0.2,加热系数β = 0.1。先求解该问题。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"using Plots,DifferentialEquations\nTout = 18.0\nα = 0.2\nβ = 0.1\nf(x,p,t) = α*(Tout - x) + β*p\ntspan=(0.0,40.0)\nu0 = 20.0\np = 80.0\npr = ODEProblem(f,u0,tspan,p)\nsol = solve(pr)\nplot(sol,ylimit=(10,60))","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"得到的结果是： (Image: 图 1)  ","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"很清晰可以看到，温度缓慢上升最后稳定在58℃。那么作为我们拍脑袋的控制策略来说，这个控制问题很简单。我们可以先让功率在前期比较大（比如说150），等温度到了58℃附近，再把功率调回80，就可以实现“温度迅速上升并最后稳定在58度”。","category":"page"},{"location":"Control/MTKMPC/#优化求解","page":"MTK求解MPC问题","title":"优化求解","text":"","category":"section"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"using Symbolics,ModelingToolkit,GalacticOptim,Optim\nN = 20\nTout = 18.0\nT0 = 20.0\ndt = 4/N\nLoss = 0.0\nT = T0\nα = 0.2\nβ = 0.1\n@variables u[1:N]\nfor i = 1:N\n    global T = T + (α*(Tout - T) + β*u[i])*dt\n    global Loss += (T - 58.0)^2\nend","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"u是符号量，离散的个数为N，上面选择离散为20个变量。通过一个for循环，就可以迭代求解20个点上的温度值并且构建Loss方程。这里的20个变量，就是控制的核心，通过改变这20个不同时间点上的控制量（加热功率）的值，使得被控量（温度）接近“更好、更快”地接近目标——58℃。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"可以看到Loss方程的结果：","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"(Image: 图 2)  ","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"有些许复杂，但在情理之中。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"@named sys = OptimizationSystem(Loss,[u[i] for i in 1:N],[],inequality_constraints=inequ)\nu0 = [u[i] => 1.0 for i in 1:N]\nlb = [0.0 for i in 1:N]\nub = [200.0 for i in 1:N]\nprob = OptimizationProblem(sys,u0,[],lb = lb,ub = ub,grad=true,hess=true)\ns = solve(prob,Optim.LBFGS())","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"然后构建System和OptimizationProblem，给定上下限。这里功率上限设为200，最后求解！","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"结果为：","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"u: 20-element Vector{Float64}:\n 199.99999999999997\n 199.99999999999997\n 199.99999999999997\n 199.99999999999997\n 199.99999999999997\n 199.99999999999997\n 199.99999999999997\n 199.99999999999994\n 199.99999999999991\n 199.9999999999999\n 199.99999999999957\n 199.99999999996504\n  82.18673442597857\n  79.99995550035416\n  80.0000502201614\n  79.99991729083732\n  80.00001272875645\n  80.00004827285969\n  79.99999940246633\n  79.99997217751334","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"(Image: 图 3)  ","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"应该说是非常理想的。和我们设想的一样。先以最大功率加热到58℃附近，然后迅速将到稳态维持58℃的功率80，这样2s就完成了控制过程，而之前以恒定功率80加热，耗费了20s!","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"从图中可以很容易看出局限性，加热功率先猛加，以最高限度200直接加热到58，然后功率在恒定在80维持恒温58摄氏度。这种直上直下的调节，很显然不那么让人满意。可以想象，假如不给变量设置上下限，那么优化的结果一定是：第一个离散的变量加热功率上万，相当于在一瞬间使用超大且精准的功率把温度加到58摄氏度。第二个往后的状态量为80——维持恒温58摄氏度的加热功率。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"这在数学上是合理的，在实际中却没有意义。所以在控制中一般需要加一些约束，比如加热功率上下限、加热功率变化幅度。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"所以，为了处理约束，可以使用JuMP来做MPC。","category":"page"},{"location":"StepByStep/03-mysql数据库准备/#数据库准备","page":"数据库准备","title":"数据库准备","text":"","category":"section"},{"location":"StepByStep/03-mysql数据库准备/#关系数据库简介","page":"数据库准备","title":"关系数据库简介","text":"","category":"section"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"关系型数据库是最广泛使用和最经典的一种数据库。以下是关系型数据库的简要介绍：","category":"page"},{"location":"StepByStep/03-mysql数据库准备/#.-**定义**:","page":"数据库准备","title":"1. 定义:","text":"","category":"section"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"关系型数据库（RDBMS, Relational Database Management System）是基于关系模型来创建和管理的数据库。在这种数据库中，数据被组织成一个或多个表，这些表之间可以存在相关性。","category":"page"},{"location":"StepByStep/03-mysql数据库准备/#.-**特点**:","page":"数据库准备","title":"2. 特点:","text":"","category":"section"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"表格结构：数据存储在称为“表”的结构中，每个表具有唯一的名称。\n行与列：每个表由行（也称为记录或元组）和列（也称为字段或属性）组成。每列都有一个数据类型（如整数、字符串、日期等）。\n主键：每个表通常都有一个主键列，该列的值在表中是唯一的，用于唯一地标识每一行。\n外键：用于建立表与表之间的关系，确保数据之间的引用完整性。\n标准化：是一种设计技巧，用于最小化数据重复和避免数据异常。","category":"page"},{"location":"StepByStep/03-mysql数据库准备/#.-**SQL**:","page":"数据库准备","title":"3. SQL:","text":"","category":"section"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"关系型数据库使用 SQL（Structured Query Language，结构化查询语言）进行查询。SQL 是用于定义、操作和查询数据的标准语言。","category":"page"},{"location":"StepByStep/03-mysql数据库准备/#.-**事务**:","page":"数据库准备","title":"4. 事务:","text":"","category":"section"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"关系型数据库支持事务，确保数据库操作的完整性。事务是一系列操作，要么全部成功执行，要么全部不执行。","category":"page"},{"location":"StepByStep/03-mysql数据库准备/#.-**优势**:","page":"数据库准备","title":"5. 优势:","text":"","category":"section"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"数据完整性和准确性。\n灵活的查询能力。\n数据安全性和备份恢复。\n广泛的支持和成熟的技术。","category":"page"},{"location":"StepByStep/03-mysql数据库准备/#.-**常见的关系型数据库系统**:","page":"数据库准备","title":"6. 常见的关系型数据库系统:","text":"","category":"section"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"MySQL\nPostgreSQL\nOracle\nMicrosoft SQL Server\nSQLite","category":"page"},{"location":"StepByStep/03-mysql数据库准备/#.-**挑战**:","page":"数据库准备","title":"7. 挑战:","text":"","category":"section"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"在处理非常大的数据集或需要高度可扩展性的场景时，关系型数据库可能不如某些非关系型数据库那么高效。\n数据模式修改可能是困难和耗时的。","category":"page"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"尽管现在有很多非关系型数据库（如 MongoDB、Cassandra 和 Redis）受到欢迎，但关系型数据库仍然是许多应用的核心，尤其是需要高度组织和关系完整性的应用。","category":"page"},{"location":"StepByStep/03-mysql数据库准备/#mysql(mariadb)简介","page":"数据库准备","title":"mysql(mariadb)简介","text":"","category":"section"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"当我们谈到 MySQL，我们通常指的是一个广泛使用的开源关系型数据库管理系统。MariaDB 是 MySQL 的一个分支，由 MySQL 的原始开发者创建，作为对 Oracle 购买 Sun Microsystems（MySQL 的原始所有者）后可能存在的开源许可问题的回应。","category":"page"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"以下是 MySQL 和 MariaDB 的简要介绍：","category":"page"},{"location":"StepByStep/03-mysql数据库准备/#MySQL:","page":"数据库准备","title":"MySQL:","text":"","category":"section"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"概述: MySQL 是世界上最流行的开源关系型数据库之一。它的主要特点是可靠性、性能和易用性。\n特点:\n使用 SQL 作为查询语言。\n提供了多种存储引擎，如 InnoDB、MyISAM、Memory 等。\n支持 ACID 事务，尤其是在使用 InnoDB 存储引擎时。\n支持外键、触发器、视图等功能。\n有一个活跃的社区和大量的在线资源。\n使用情境: 从小型应用到大型企业解决方案，MySQL 都可以用作后端存储。它被广泛用于网站、电子商务平台和许多其他类型的应用。","category":"page"},{"location":"StepByStep/03-mysql数据库准备/#MariaDB:","page":"数据库准备","title":"MariaDB:","text":"","category":"section"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"概述: MariaDB 是 MySQL 的一个开源分支，由 MySQL 的原始开发者创建，旨在完全兼容 MySQL，同时提供新的特性和改进。\n特点:\n完全的二进制级别兼容性与 MySQL。\n新的存储引擎，如 Aria 和 TokuDB。\n更好的性能和优化。\n对新功能的更快速和更开放的开发流程。\n包含更多的存储引擎和扩展功能。\n使用情境: 因为 MariaDB 与 MySQL 完全兼容，所以它可以替代 MySQL 在任何应用中使用。","category":"page"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"最后的注意事项: 尽管 MariaDB 旨在与 MySQL 保持兼容，但随着时间的推移，两者之间可能会出现一些差异。因此，如果你正在考虑从 MySQL 迁移到 MariaDB，或者在两者之间进行选择，建议你仔细研究两者之间的差异和考虑使用哪一个更适合你的特定需求。","category":"page"},{"location":"StepByStep/03-mysql数据库准备/#使用docker-compose安装mariadb","page":"数据库准备","title":"使用docker-compose安装mariadb","text":"","category":"section"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"使用 docker-compose 安装 MariaDB 相对简单且方便。下面是使用 docker-compose 安装 MariaDB 的步骤：","category":"page"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"创建 docker-compose.yml 文件:\n在你选择的目录中，创建一个 docker-compose.yml 文件，并输入以下内容：\nversion: '3'\n\nservices:\n  mariadb:\n    image: mariadb:latest\n    container_name: my_mariadb\n    environment:\n      MYSQL_ROOT_PASSWORD: rootpassword   # 设置你的root密码\n      MYSQL_DATABASE: mydatabase          # 你可以指定一个初始数据库名称\n      MYSQL_USER: user                    # 可选: 创建一个用户\n      MYSQL_PASSWORD: userpassword        # 用户的密码\n    ports:\n      - \"3306:3306\"\n    volumes:\n      - mariadb_data:/var/lib/mysql\n\nvolumes:\n  mariadb_data:\n这个配置将会拉取最新版本的 MariaDB 镜像，设置必要的环境变量，并绑定容器的 3306 端口到宿主机的 3306 端口。\n启动 MariaDB:\n在包含 docker-compose.yml 文件的目录中，运行以下命令:\ndocker-compose up -d\n这将会启动 MariaDB 服务。-d 参数使容器在后台模式运行。\n连接到 MariaDB:\n你可以使用任何 MySQL/MariaDB 客户端来连接到数据库。使用上面的配置，你可以使用如下的连接参数：\nHost: localhost (或你的 Docker 宿主机的 IP)\nPort: 3306\nUser: root\nPassword: rootpassword (或你在 docker-compose.yml 文件中设置的密码)\n停止和启动服务:\n如果你想停止 MariaDB 服务，可以使用以下命令：\ndocker-compose down\n当你想再次启动服务时，只需再次运行 docker-compose up -d。\n数据持久化:\n在上面的配置中，我们使用了一个命名的卷 mariadb_data 为 /var/lib/mysql 路径来持久化数据。这确保即使容器被删除，数据也会保持不变。","category":"page"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"这就是使用 docker-compose 安装 MariaDB 的基本步骤。当然，你可以根据你的特定需求对 docker-compose.yml 文件进行进一步的配置和调整。","category":"page"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"以下是一个典型的 docker-compose.yml：","category":"page"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"\nversion: '3.2'\n\nservices:\n\n  ai4e-things-mariadb:\n    image: mariadb:10.6.14\n    container_name: ai4e-things-mariadb\n    environment:\n      MYSQL_ROOT_PASSWORD: rootpassword\n      MYSQL_DATABASE: ai4e_things\n      MYSQL_USER: ai4e_things\n      MYSQL_PASSWORD: password\n      TZ: Asia/Shanghai\n    ports:\n      - \"3306:3306\"\n    volumes:\n       - ./deploy/data/mariadb:/var/lib/mysql\n    restart: always\n    networks:\n      ai4e_net:\n        ipv4_address: 172.20.0.116","category":"page"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"这段 docker-compose.yml 配置详细描述了如何使用 Docker Compose 来部署一个 MariaDB 容器。","category":"page"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"version: '3.2'\n这表示 docker-compose.yml 文件的版本为 3.2。每个版本都有其特定的特性和格式。版本 3 和其子版本为现代 Docker Compose 配置提供了许多新的功能。\nservices:\n这表示接下来的部分将描述要部署的服务。\nai4e-things-mariadb:\n这是你为 MariaDB 服务定义的名称。\nimage: mariadb:10.6.14\n这指示 Docker 从 Docker Hub 获取 mariadb 镜像，并使用特定的版本 10.6.14。\ncontainer_name: ai4e-things-mariadb\n这是容器实例的名称。每次你启动这个 docker-compose 配置时，都会创建或重用这个名称的容器。\nenvironment:\n这是为容器设置的环境变量列表。\nMYSQL_ROOT_PASSWORD: MariaDB 的 root 用户的密码。\nMYSQL_DATABASE: 在首次启动容器时将创建的数据库名称。\nMYSQL_USER & MYSQL_PASSWORD: 在首次启动时将创建的新用户及其密码。\nTZ: 设置时区为 Asia/Shanghai。\nports:\n3306:3306: 这表示将容器的 3306 端口映射到宿主机的 3306 端口。\nvolumes:\n./deploy/data/mariadb:/var/lib/mysql: 这表示将宿主机的 ./deploy/data/mariadb 目录映射到容器的 /var/lib/mysql 目录。这样，数据库的数据将被持久化保存在宿主机上，即使容器被删除，数据也不会丢失。\nrestart: always\n这表示如果容器因为某种原因停止了，Docker 会自动尝试重新启动它。\nnetworks:\n这定义了容器连接的网络。\nai4e_net: 这是预先定义的网络名称。\nipv4_address: 172.20.0.116: 指定容器在这个网络上的 IP 地址为 172.20.0.116。","category":"page"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"这份配置为你提供了一个具有持久化数据、特定网络配置和预定义的数据库设置的 MariaDB 容器。","category":"page"},{"location":"StepByStep/03-mysql数据库准备/#使用adminer连接数据库","page":"数据库准备","title":"使用adminer连接数据库","text":"","category":"section"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"Adminer 是一个简单的、单文件的数据库管理工具，支持多种数据库系统，包括 MySQL/MariaDB、PostgreSQL、SQLite 等。它可以很容易地通过 Docker 运行。","category":"page"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"以下是如何使用 docker-compose 与 Adminer 来连接到 MariaDB 数据库的步骤：","category":"page"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"在 docker-compose.yml 中加入 Adminer 服务:\n在你现有的 docker-compose.yml 文件中，你可以添加一个新的服务来运行 Adminer：\nversion: '3.2'\n\nservices:\n  ai4e-things-mariadb:\n    ... # 保持你的 MariaDB 配置不变\n\n  adminer:\n    image: adminer:latest\n    container_name: adminer\n    ports:\n      - \"8080:8080\"\n\nnetworks:\n  ai4e_net:\n    ...\n在这里，我们将 Adminer 服务的 8080 端口映射到宿主机的 8080 端口。\n启动 Adminer 和 MariaDB:\n在包含 docker-compose.yml 文件的目录中，运行以下命令:\ndocker-compose up -d\n通过浏览器访问 Adminer:\n打开你的浏览器并访问 http://localhost:8080。你应该能看到 Adminer 的登录界面。\n连接到你的 MariaDB 数据库:\n在 Adminer 的登录界面：\n系统：选择 MySQL\n服务器：输入你 MariaDB 容器的名称或 IP 地址。如果 Adminer 和 MariaDB 在同一个 Docker Compose 网络中，你可以使用 MariaDB 服务的名称作为主机名，例如 ai4e-things-mariadb。\n用户名 和 密码：使用你在 docker-compose.yml 文件中为 MariaDB 设置的用户名和密码，例如 ai4e_things 和 789612543Ab1234。\n数据库：可以选择特定的数据库，如 ai4e_things，或留空以查看所有数据库。","category":"page"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"点击登录，你应该能够看到你的 MariaDB 数据库并开始管理它。","category":"page"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"注意：使用 Adminer（或任何其他数据库管理工具）时，请始终确保你的数据库设置是安全的，并且管理界面不对公众开放，以防止未经授权的访问。","category":"page"},{"location":"StepByStep/03-mysql数据库准备/#使用datagrip连接数据库","page":"数据库准备","title":"使用datagrip连接数据库","text":"","category":"section"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"DataGrip 是 JetBrains 出品的一个多数据库环境的 IDE。它支持多种数据库系统，并为用户提供了图形界面来执行查询、管理数据库结构等操作。","category":"page"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"要使用 DataGrip 来连接到你通过 Docker 或其他方式运行的 MariaDB 数据库，请按照以下步骤操作：","category":"page"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"安装 DataGrip:\n首先，如果你还没有安装 DataGrip，你需要从 JetBrains 的官方网站下载并安装它。\n启动 DataGrip:\n打开 DataGrip 应用程序。\n创建新的数据源:\n在欢迎屏幕上，选择 “New Project”。\n在左侧导航栏中，右键点击 “Database” 部分并选择 “New” -> “Data Source” -> “MySQL”。\n配置连接:\nHost: 输入你 MariaDB 容器的 IP 地址或主机名。如果你的数据库在本地运行，通常是 localhost。如果它在 Docker Compose 网络中，则可能是服务名称（例如 ai4e-things-mariadb）或分配给该服务的 IP 地址。\nPort: 默认的 MariaDB 端口是 3306，除非你已更改。\nUser: 输入你为 MariaDB 设置的用户名，例如 ai4e_things。\nPassword: 输入相应的密码，例如 789612543Ab1234。\nDatabase: 你可以选择特定的数据库，例如 ai4e_things，或留空以查看所有数据库。\n你也可以点击 “Test Connection” 按钮来确保你的设置是正确的。\n完成设置:\n点击 “OK” 保存你的设置。现在，你应该能在 DataGrip 的界面左侧看到你的数据库连接。双击它将显示数据库的内容，你可以开始执行查询和其他操作。\n执行查询:\n在 DataGrip 的主界面，你可以为所选的数据库打开一个新的查询窗口，并开始执行 SQL 语句。","category":"page"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"注意：确保你的 MariaDB 数据库对 DataGrip 使用的 IP 地址和端口开放，并且用户名和密码正确。如果你使用 Docker Compose 启动数据库，并且 DataGrip 也在同一台机器上运行，通常你应该可以使用 localhost 作为主机名。如果有防火墙或网络策略，确保它们不会阻止 DataGrip 的连接请求。","category":"page"},{"location":"StepByStep/03-mysql数据库准备/#使用vscode的数据库插件","page":"数据库准备","title":"使用vscode的数据库插件","text":"","category":"section"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"Visual Studio Code（VSCode）是一个非常灵活的代码编辑器，拥有大量的插件，使其可以支持各种开发任务。当你想在 VSCode 中直接连接到数据库时，有很多插件可以选择。以下是如何使用其中的一个受欢迎的插件——SQLTools 来连接到 MariaDB 数据库的步骤：","category":"page"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"安装 SQLTools 插件:\n打开 VSCode，转到扩展（Extensions）标签（或按 Ctrl+Shift+X），然后搜索 \"SQLTools\". 安装 \"SQLTools - Database tools\" 插件。\n为了连接到 MariaDB/MySQL 数据库，你还需要安装特定的驱动。搜索并安装 \"SQLTools MySQL/MariaDB\"。\n连接到数据库:\n在 VSCode 的左侧侧边栏中，点击 SQLTools 的图标。\n点击 \"Add New Connection\"。\n选择 \"MySQL/MariaDB\"。\n填写连接信息：\nName: 给你的连接起个名字，例如 “MyMariaDB”。\nDriver: 选择 \"MySQL/MariaDB\"。\nServer: 输入你的 MariaDB 服务器的地址。如果你的数据库是在本地机器上运行的，这通常是 localhost。\nPort: 默认的 MariaDB 端口是 3306，除非你已更改。\nUsername: 输入你为 MariaDB 设置的用户名，例如 ai4e_things。\nPassword: 输入相应的密码。\nDatabase: 你可以选择特定的数据库，例如 ai4e_things。\n点击 \"Test\" 来验证连接设置，如果一切正常，然后点击 \"Save\"。\n浏览和查询数据库:\n一旦连接建立，你就可以在 VSCode 内浏览你的数据库结构、执行查询等操作。\n断开连接:\n如果你想断开数据库连接，只需在 SQLTools 的连接管理器中右键点击你的数据库连接，然后选择 \"Disconnect\"。","category":"page"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"这就是在 VSCode 中使用 SQLTools 插件连接到 MariaDB 数据库的基本步骤。有许多其他数据库插件可供选择，因此你可能会发现其他插件更适合你的特定需求或工作流程。","category":"page"},{"location":"StepByStep/03-mysql数据库准备/#如果使用PostgreSQL","page":"数据库准备","title":"如果使用PostgreSQL","text":"","category":"section"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"如果想使用PostgreSQL并希望它在Docker Compose配置中有类似的结构，以下是一个示例docker-compose.yml文件：","category":"page"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"version: '3'\n\nservices:\n  postgres:\n    image: postgres:latest\n    container_name: my_postgres\n    environment:\n      POSTGRES_PASSWORD: rootpassword   # 设置你的root密码\n      POSTGRES_DB: mydatabase           # 你可以指定一个初始数据库名称\n      POSTGRES_USER: user               # 可选: 创建一个用户\n    ports:\n      - \"5432:5432\"\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n\nvolumes:\n  postgres_data:\n","category":"page"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"注意：","category":"page"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"PostgreSQL的默认端口是5432。\n在这个示例中，使用了PostgreSQL的官方Docker镜像，它默认支持环境变量POSTGRES_PASSWORD, POSTGRES_DB, 和POSTGRES_USER，来分别指定root密码、数据库名称和用户名。\n如果你需要为该用户指定一个密码，你可能需要自定义一个启动脚本或使用其他方式进行管理。","category":"page"},{"location":"StepByStep/03-mysql数据库准备/","page":"数据库准备","title":"数据库准备","text":"根据需要，您可以进一步配置或修改此docker-compose.yml文件。","category":"page"},{"location":"WorkFlow/DocStructure/#文档（docs）编写方法","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"","category":"section"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"tip: Tip\nContents：文档编写方法介绍Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"WorkFlow/DocStructure/#文档结构","page":"文档（docs）编写方法","title":"文档结构","text":"","category":"section"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"在包的根目录下，都有一个/docs文件夹，里面就是文档的所有内容。","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"/docs结构如下：","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"docs/\n├── src/\n│   ├── index.md\n│   ├── components/   \n│   │   ├──MTKMPC.md\n│   │   └──...\n│   └── MyApp.jl\n├── build/\n│   ├── index.html\n│   └── ...\n├── .gitignore\n├── Project.toml\n└── make.jl","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"/src里包含了文档的内容，即很多markdown文件。对应关系如下：","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"(Image: 图 1)  ","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":".gitignore里的内容是在git提交时忽略的内容。例如/build的内容就会全部忽略。","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"Project.toml是julia的环境文件，说明了docs环境中需要用到的包。","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"make.jl是生成的html页面的主文件。运行make.jl，则生成/build文件夹，在默认浏览器中打开/build/index.html就能看到文档，和网页版的一模一样。本质上也是一样的，Github部署也是部署的它。这是本地版，github提交时，会自动运行make.jl生成然后部署。所以/build不用上传。","category":"page"},{"location":"WorkFlow/DocStructure/#编写方法","page":"文档（docs）编写方法","title":"编写方法","text":"","category":"section"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"新添加文档只需要两步操作：","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"创建新的文档(.md文件)\n在make.jl中链接文档路径","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"make.jl中的page链接了全部文档。 (Image: 图 2)  ","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"图中的\"Modeling\"是子目录，在/src里可看到对应文件夹。","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"如果没有在make.jl中链接，就不会在html中显示。没链接等于没写🤣🤣🤣。","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"note: Note\n某些库会设计自动链接，如果自动链接了就不需要手动添加了。","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/#Julia换源(更换国内镜像站)","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"","category":"section"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"tip: Tip\nContents：JuliaPkgContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"打开julia的安装路径，找到文件夹 julia-1.x.x(如1.6.1) 如图","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"进入该文件夹找到etc","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"进入etc 再进入一个文件夹，有一个startup.jl","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"这个startup.jl就很方便了，在启动julia的时候，会首先自动运行里面的内容。","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"所以，打开它，在里面输入一行","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"ENV[\"JULIA_PKG_SERVER\"]=\"https://mirrors.pku.edu.cn/julia/\"","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"就像这样 (Image: 在这里插入图片描述) 保存就完事了。","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"ENV是julia的全局环境变量，能够直接在repl中修改环境变量，但不是永久的。所以放在startup.jl里。这样等价于永久改变了，因为每次启动都会repl自动执行它。","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"在repl中输入ENV如下： (Image: 在这里插入图片描述)","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"还有一些其它的比如LOADPATH 和DEPOTPATH等等，这些都是环境变量。更多可以看中文文档 (Image: 在这里插入图片描述)","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"PS: 不换也行，最新版的julia好像能自动选取一个最快的源。","category":"page"},{"location":"WorkFlow/vscodePlugin/#VScode开发环境配置","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"","category":"section"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"tip: Tip\nContents：VScode插件介绍Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"WorkFlow/vscodePlugin/#插件位置","page":"VScode开发环境配置","title":"插件位置","text":"","category":"section"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"打开插件面板，并搜索。","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 13)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/#Julia","page":"VScode开发环境配置","title":"Julia","text":"","category":"section"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"Julia官方出的Julia插件","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 1) ","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"Shift+Enter可以运行单行代码","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"Tab键补全代码","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"如：","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: )","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"体验和jupyter类似。","category":"page"},{"location":"WorkFlow/vscodePlugin/#Mardown","page":"VScode开发环境配置","title":"Mardown","text":"","category":"section"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"轻量级标记语言，文档编写必备，教程官方。","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"推荐这个3个插件，都装。","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 2)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 11)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 3)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"点击预览打开markdown预览。","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 4)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"右键 可导出PDF文件，很方便。","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 6)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/#markdown辅助贴图插件","page":"VScode开发环境配置","title":"markdown辅助贴图插件","text":"","category":"section"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 7)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"设置该扩展的图片粘贴位置，如果是Ai4E的相关开发，文档中图片的路径一般为：/docs/src/assets","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 10)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"随后右键，选择粘贴图片，自动生成markdown的图片插入语法。很方便！","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 9)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/#语言插件","page":"VScode开发环境配置","title":"语言插件","text":"","category":"section"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 12)  ","category":"page"},{"location":"Optimization/8-黑箱优化问题/#黑箱优化问题","page":"黑箱优化问题","title":"黑箱优化问题","text":"","category":"section"},{"location":"Optimization/8-黑箱优化问题/#黑箱优化概述","page":"黑箱优化问题","title":"黑箱优化概述","text":"","category":"section"},{"location":"Optimization/8-黑箱优化问题/","page":"黑箱优化问题","title":"黑箱优化问题","text":"有一些问题，优化的目标函数或者约束，并不是决策变量的显式函数。我们称这类问题为黑箱优化。","category":"page"},{"location":"Optimization/8-黑箱优化问题/","page":"黑箱优化问题","title":"黑箱优化问题","text":"在黑箱优化中，目标函数和约束并不是决策变量的显式函数，而是通过某种未知的、隐式的方式给出的。这意味着无法直接获得目标函数和约束的解析表达式或数学模型，而需要通过评估函数来获取它们的值。","category":"page"},{"location":"Optimization/8-黑箱优化问题/","page":"黑箱优化问题","title":"黑箱优化问题","text":"在黑箱优化中，通常使用试验、仿真、模拟或其他计算方法来评估目标函数和约束的值。这些评估函数将决策变量作为输入，计算相应的目标函数和约束值。通过不断尝试不同的决策变量值，并根据评估函数的返回结果进行优化搜索，以找到最优解。","category":"page"},{"location":"Optimization/8-黑箱优化问题/","page":"黑箱优化问题","title":"黑箱优化问题","text":"黑箱优化问题常见于现实世界中的工程、科学和经济领域。例如，在产品设计中，优化目标可能涉及复杂的仿真模型，需要通过运行大量的仿真实验来评估不同设计参数的性能。在这种情况下，优化算法需要利用有限的仿真实验结果来推断目标函数和约束的行为，并寻找最佳设计参数。","category":"page"},{"location":"Optimization/8-黑箱优化问题/","page":"黑箱优化问题","title":"黑箱优化问题","text":"解决黑箱优化问题的方法通常包括进化算法、元启发式算法和基于模型的优化方法。这些方法在每次迭代中通过评估函数的结果来引导搜索方向，并逐步逼近最优解。对于黑箱优化问题，选择合适的优化算法和评估函数策略至关重要，以确保有效地搜索最优解，并在有限的评估次数内获得满意的结果。","category":"page"},{"location":"Optimization/8-黑箱优化问题/#来几个例子","page":"黑箱优化问题","title":"来几个例子","text":"","category":"section"},{"location":"Optimization/8-黑箱优化问题/","page":"黑箱优化问题","title":"黑箱优化问题","text":"比如某种药物配方优化，我们评价药物的过程是临床实验。而不是简单的目标函数。","category":"page"},{"location":"Optimization/8-黑箱优化问题/","page":"黑箱优化问题","title":"黑箱优化问题","text":"对于药物配方优化这样的问题，可能涉及临床实验作为评估药物效果的过程。在这种情况下，优化目标不再是简单的数学函数，而是基于临床实验结果进行评估的复杂指标。","category":"page"},{"location":"Optimization/8-黑箱优化问题/","page":"黑箱优化问题","title":"黑箱优化问题","text":"在药物配方优化中，目标函数可以是临床指标，如疗效、安全性、副作用等。约束条件可能包括药物成分的合规性、剂量范围、禁忌症等要求。为了评估目标函数值，需要进行临床实验来测试不同配方的效果，并根据实验结果确定目标函数值和约束的满足程度。","category":"page"},{"location":"Optimization/8-黑箱优化问题/","page":"黑箱优化问题","title":"黑箱优化问题","text":"对于这种黑箱优化问题，常见的解决方法是使用元启发式算法或基于模型的优化方法。元启发式算法如遗传算法、粒子群优化等可以通过迭代地生成、评估和改进药物配方来搜索最佳解。基于模型的优化方法则可以利用已有的临床实验数据建立数学模型，从而在模型上进行优化搜索，以减少实验成本和时间。","category":"page"},{"location":"Optimization/8-黑箱优化问题/","page":"黑箱优化问题","title":"黑箱优化问题","text":"在药物配方优化中，需要仔细选择评估指标、设计合适的实验方案，并确保优化算法和实验过程的有效结合。此外，还需要注意合理的约束设置和结果的解释性，以确保优化得到的配方在临床实践中具有可行性和可接受性。","category":"page"},{"location":"Optimization/8-黑箱优化问题/","page":"黑箱优化问题","title":"黑箱优化问题","text":"总而言之，对于黑箱优化问题，如药物配方优化，临床实验是评估目标函数值的重要手段。合适的优化算法和实验设计的选择，以及对结果的解释和验证，都是解决这类问题的关键。","category":"page"},{"location":"Optimization/8-黑箱优化问题/","page":"黑箱优化问题","title":"黑箱优化问题","text":"制作一杯咖啡也是如此。","category":"page"},{"location":"Optimization/8-黑箱优化问题/","page":"黑箱优化问题","title":"黑箱优化问题","text":"即使是看似简单的任务，如制作一杯咖啡，也可以看作是一个黑箱优化问题。在咖啡制作中，优化的目标是获得口感、香味、浓度等方面最佳的咖啡，而评估的过程通常是通过尝试不同的配方和调整参数来进行主观或客观的评估。","category":"page"},{"location":"Optimization/8-黑箱优化问题/","page":"黑箱优化问题","title":"黑箱优化问题","text":"对于咖啡制作的黑箱优化问题，可以采用类似的方法。假设我们有一组决策变量，如咖啡豆的种类、研磨程度、冲泡时间、水温等。我们可以将咖啡的口感和质量作为目标函数进行评估，同时设置一些约束条件，如使用特定的咖啡豆或限定冲泡时间在合理范围内。","category":"page"},{"location":"Optimization/8-黑箱优化问题/","page":"黑箱优化问题","title":"黑箱优化问题","text":"然后，通过尝试不同的决策变量组合，制作不同的咖啡，并通过主观评价（如口味测试）或客观评估（如咖啡浓度测量）来获得目标函数的值。根据评估结果，可以调整决策变量，再次制作咖啡，直到获得满意的咖啡质量。","category":"page"},{"location":"Optimization/8-黑箱优化问题/","page":"黑箱优化问题","title":"黑箱优化问题","text":"在这个过程中，可以应用优化算法（如遗传算法、模拟退火等）来搜索最佳的决策变量组合，以获得最优的咖啡口感和质量。算法可以迭代地生成新的咖啡配方、评估其目标函数值，并根据评估结果调整决策变量，以不断改进咖啡的质量。","category":"page"},{"location":"Optimization/8-黑箱优化问题/","page":"黑箱优化问题","title":"黑箱优化问题","text":"值得注意的是，咖啡制作涉及主观性和个人口味的因素，不同的人对于最佳咖啡的定义可能有所不同。因此，在黑箱优化中，也要考虑到个人喜好和目标受众的需求，以获得最符合要求的咖啡制作方案。","category":"page"},{"location":"Optimization/8-黑箱优化问题/","page":"黑箱优化问题","title":"黑箱优化问题","text":"还有些优化的目标函数或者约束，需要调用一个外部的仿真程序来获得。","category":"page"},{"location":"Optimization/8-黑箱优化问题/","page":"黑箱优化问题","title":"黑箱优化问题","text":"有些优化问题的目标函数或约束可能需要调用外部的仿真程序或模拟工具来获得结果。这种情况下，优化算法需要与仿真程序进行集成，以实现目标函数和约束的评估。","category":"page"},{"location":"Optimization/8-黑箱优化问题/","page":"黑箱优化问题","title":"黑箱优化问题","text":"在这样的优化问题中，一般的优化算法流程如下：","category":"page"},{"location":"Optimization/8-黑箱优化问题/","page":"黑箱优化问题","title":"黑箱优化问题","text":"初始化决策变量：随机生成一组初始决策变量作为起始解。\n调用仿真程序：使用当前的决策变量作为输入参数，调用外部的仿真程序来模拟系统行为或进行特定的计算。\n仿真结果评估：从仿真程序中获取目标函数和约束的评估结果。\n更新决策变量：根据评估结果和优化算法的策略，更新决策变量的取值。\n终止条件判断：判断是否满足终止条件，如达到最大迭代次数、目标函数收敛等。\n返回结果：返回找到的最优解或近似最优解。","category":"page"},{"location":"Optimization/8-黑箱优化问题/","page":"黑箱优化问题","title":"黑箱优化问题","text":"在这个过程中，优化算法与外部仿真程序之间需要进行数据传递和交互。通常，优化算法将当前决策变量作为输入传递给仿真程序，并等待仿真程序返回评估结果。这样的集成可以通过脚本编程、API接口或其他集成方式实现。","category":"page"},{"location":"Optimization/8-黑箱优化问题/","page":"黑箱优化问题","title":"黑箱优化问题","text":"这种基于外部仿真程序的优化方法广泛应用于许多领域，如工程设计、物流规划、机器学习模型优化等。它可以帮助在复杂的系统中优化决策变量，以获得最佳的目标函数值或满足特定约束条件的解。","category":"page"},{"location":"Optimization/8-黑箱优化问题/","page":"黑箱优化问题","title":"黑箱优化问题","text":"在使用外部仿真程序进行优化时，需要确保仿真程序的准确性和可靠性，并注意优化算法与仿真程序之间的数据传递和性能效率。此外，优化算法的选择和参数调优也是确保最佳结果的关键。","category":"page"},{"location":"Optimization/8-黑箱优化问题/#基于仿真的优化","page":"黑箱优化问题","title":"基于仿真的优化","text":"","category":"section"},{"location":"Optimization/8-黑箱优化问题/","page":"黑箱优化问题","title":"黑箱优化问题","text":"像刚才提到的优化问题，其中目标函数和约束需要通过调用外部的仿真程序来获得结果，通常被称为基于仿真的优化（Simulation-Based Optimization，SBO）或基于模型的优化（Model-Based Optimization）。","category":"page"},{"location":"Optimization/8-黑箱优化问题/","page":"黑箱优化问题","title":"黑箱优化问题","text":"在基于仿真的优化中，优化算法使用仿真程序来模拟系统或过程的行为，并根据仿真结果进行优化决策。这种方法常用于复杂的实际问题，其中系统的行为和性能很难通过解析方法进行建模和分析。","category":"page"},{"location":"Optimization/8-黑箱优化问题/","page":"黑箱优化问题","title":"黑箱优化问题","text":"基于仿真的优化通常涉及以下步骤：","category":"page"},{"location":"Optimization/8-黑箱优化问题/","page":"黑箱优化问题","title":"黑箱优化问题","text":"建立仿真模型：定义系统的数学模型或仿真模型，包括输入参数、输出指标和系统的行为规律。\n选择优化算法：根据问题的特性和要求，选择适合的优化算法，如遗传算法、粒子群优化、模拟退火等。\n初始化决策变量：随机生成一组初始决策变量作为起始解。\n调用仿真程序：使用当前决策变量作为输入参数，调用外部的仿真程序来运行仿真模型，模拟系统行为。\n仿真结果评估：从仿真程序中获取目标函数和约束的评估结果。\n更新决策变量：根据评估结果和优化算法的策略，更新决策变量的取值。\n终止条件判断：判断是否满足终止条件，如达到最大迭代次数、目标函数收敛等。\n返回结果：返回找到的最优解或近似最优解。","category":"page"},{"location":"Optimization/8-黑箱优化问题/","page":"黑箱优化问题","title":"黑箱优化问题","text":"基于仿真的优化方法具有灵活性和适应性，可以应用于多个领域和复杂的优化问题。然而，它也面临一些挑战，如计算成本高、仿真模型准确性的要求、与仿真程序的集成等。因此，在使用基于仿真的优化时，需要仔细选择仿真模型、优化算法和合适的评估策略，以确保获得准确的优化结果。","category":"page"},{"location":"Simulation/MTK_parallel_computing/#MTK并行计算求解大规模电池阵列","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"","category":"section"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"tip: Tip\nContents：MTK、PDE、并行计算Contributor: HYEmail:1171006975@qq.com如有错误，请批评指正。","category":"page"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"note: Note\nMTK = ModelingToolkit.jlPDE = Partial Differential EquationModelingToolkit.jl 符号建模包","category":"page"},{"location":"Simulation/MTK_parallel_computing/#为什么使用并行计算","page":"MTK并行计算求解大规模电池阵列","title":"为什么使用并行计算","text":"","category":"section"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"传统的系统建模，往往采用0维模型进行建模(如等效电路法，集中参数法等)，计算量较小，不需要并行计算。但有时候，我们可能不仅仅想研究整个系统的输出特性，还想追踪系统内部各个组件的输出特性。当系统由很多相同的组件(组件参数不一定相同)连接而成时(如上百个电池单体组成的电池阵列，上千个燃料电池单体组成的电堆，超大规模水力管网等)，即使每个单体的计算量很小，但加起来计算量会急剧上升。","category":"page"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"如果我们使用@connector来连接各个组件，组成一个超大规模的矩阵来计算，这在单体数目较少时是可以实现的，但单体数目较多时，很可能会遇到一些瓶颈。这是因为计算时间不是与方程的维度成正比，而是与方程维度的平方成正比。例如，电池阵列中单体数目为100时，计算时间可能是1s，当电池数目为1000时，计算时间可能就变成了100s。更糟糕的是，编译时间和内存占用也是与方程维度的平方成正比！很可能会导致一个现象：编译2小时，计算5秒钟。","category":"page"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"但我们仔细观察，可以发现，系统内部各个组件的联系有时候其实没有那么紧密，例如燃料电池电堆中，各个单体流过的电流是一样的(即具有相同的边界条件)，我们完全可以先算出各个单体的电压，然后再加起来，就是整个电池电堆的电压。这个时候，我们就能采用并行计算的方法，同时计算很多个单体。","category":"page"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"接下来，我将以大规模的电池阵列为例，详细介绍如何实现MTK并行计算。","category":"page"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"","category":"page"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"MTK并行计算求解大规模电池阵列有这么几步：","category":"page"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"建立锂电池单体的P2D模型(伪三维模型，空间离散后为DAEs)\n求解各个锂电池单体模型，得到Li浓度等变量值(并行计算)。\n通过戴维南定理，将单体模型等效为一个内阻和一个电压源(并行计算)。\n求解由等效内阻和等效电压源组成的电池阵列电路方程(线性方程组)。","category":"page"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"(Image: 图 1)  ","category":"page"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"每个步骤的实现方式和原理会在下文进一步展开。","category":"page"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"","category":"page"},{"location":"Simulation/MTK_parallel_computing/#.建立锂电池单体的P2D模型","page":"MTK并行计算求解大规模电池阵列","title":"1.建立锂电池单体的P2D模型","text":"","category":"section"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"具体的P2D模型建模过程可参考该文献。","category":"page"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"本文中将P2D模型拆成两部分，一部分是固液相模型，用来求电池的空间浓度变化，为ODEs，另一部分是传输线模型，用来求电池的外特性曲线，为NonlinerEqs。在一个时间步长内，我们可以认为电池的浓度是不变的，因此电池的外特性也就固定了，我们可以根据电池外特性将其等效为一个内阻和一个电压源。在每次迭代后，电池的外特性都会发生改变，因此等效内阻和等效电压源的参数是会一直变化的。","category":"page"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"具体的代码文件为P2D_并行_固液相模型.jl和P2D_并行_电路模型.jl。","category":"page"},{"location":"Simulation/MTK_parallel_computing/#.程序初始化","page":"MTK并行计算求解大规模电池阵列","title":"2.程序初始化","text":"","category":"section"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"using Distributed\naddprocs(4)","category":"page"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"开启4个子线程，addprocs(n)表示开启n个子线程。","category":"page"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"@everywhere begin\n    #组件封装\n    using SharedArrays, Pkg, LinearAlgebra\n    include(\"../assets/P2D_并行_固液相模型.jl\")\n    include(\"../assets/P2D_并行_电路模型.jl\")\n    include(\"../assets/get_variables_index.jl\")\nend","category":"page"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"在每个线程中，都加载一下库和封装的组件。@everywhere表示在每个线程中都执行该代码。get_variables_index.jl用来找到变量对应的下标，以便于在不同Problem之间传递参数值。","category":"page"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"@everywhere begin\n    #参数设置\n    series_num = 100\n    parallel_num = 2\n    t_step = 5\n    simulate_time = 2500\n    n_mesh_neg = 8\n    n_mesh_sep = 8\n    n_mesh_pos = 8\n    Current = 20 * parallel_num\n    Current_standard = 20\n    c_s_max_neg = 31390\n    c_s_max_pos = 48390\n    filename_neg = \"../assets/neg_OCV.txt\"\n    filename_pos = \"../assets/pos_OCV.txt\"\n    r_s_neg = 6.3e-6\n    r_s_pos = 2.13e-6\n    F = 96485\n    R = 8.3145\n    T = 293.15\n    L_neg = 46.6e-6\n    L_sep = 18.7e-6\n    L_pos = 43e-6\n    eps_s_neg = 0.49\n    eps_s_pos = 0.57\n    Sa_neg = 3 * eps_s_neg / r_s_neg\n    Sa_pos = 3 * eps_s_pos / r_s_pos\n    k_ct_neg = 2e-11\n    k_ct_pos = 2e-11\n    h_neg = L_neg / n_mesh_neg\n    h_sep = L_sep / n_mesh_sep\n    h_pos = L_pos / n_mesh_pos\n    # 创建插值函数\n    data_neg = readdlm(filename_neg)\n    data_pos = readdlm(filename_pos)\n    ocv_neg = LinearInterpolation(data_neg[:, 1], data_neg[:, 2])\n    ocv_pos = LinearInterpolation(data_pos[:, 1], data_pos[:, 2])\nend","category":"page"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"设置参数，创建插值函数。","category":"page"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"@everywhere begin\n    #电化学方程\n    @named batter_chemistry = P2D_Libatter_chemistry(n_mesh_neg=8, n_mesh_sep=8, n_mesh_pos=8)\n    @named OdeFun_chemistry = ODESystem([], t)\n    @named model_chemistry = compose(OdeFun_chemistry, [batter_chemistry])\n    sys_chemistry = structural_simplify(model_chemistry)\n    prob_chemistry = ODEProblem(sys_chemistry, [], (0.0, 5.0))\n    sol_chemistry = solve(prob_chemistry, CVODE_Adams()).u[end]\n    chemistery_index = get_chemistery_index(batter_chemistry, sys_chemistry)\n    #传输线方程\n    @named batter_electric = P2D_Libatter_electric()\n    @named current = Constant(U=Current)\n    @named current_source = Current_source()\n    @named ground = Ground()\n    eqs = [\n        connect(batter_electric.n, ground.g, current_source.n)\n        connect(batter_electric.p, current_source.p)\n        connect(current.u, current_source.u)]\n    @named OdeFun_electric = ODESystem(eqs, t)\n    @named model_electric = compose(OdeFun_electric, [batter_electric, current, current_source, ground])\n    sys_electric = structural_simplify(model_electric)\n    prob_electric = NonlinearProblem(ODEProblem(sys_electric, [], (0.0, 0.0), []))\n    sol_electric = solve(prob_electric, KINSOL()).u\n    electric_index = get_electric_index(batter_electric, sys_electric)\n    electric_vi_index = get_electric_vi_index(batter_electric, sys_electric)\nend","category":"page"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"初始化固液相浓度方程(ODEs)和传输线方程(NonlinearEqs)。其中ODEs采用Sundials中的CVODE_Adams()方法,NonlinearEqs采用Sundials中的KINSOL()方法(速度非常快)。","category":"page"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"begin\n    #创建共享数组\n    electric_para_sharedarrays = SharedArray{Float64}(series_num * parallel_num, 2 * n_mesh_neg + 2 * n_mesh_pos + 4)\n    chemistry_para_sharedarrays = SharedArray{Float64}(series_num * parallel_num, 3 * n_mesh_neg + 3 * n_mesh_pos + n_mesh_sep + 5)\n    chemistry_last_stats_sharedarrays = SharedArray{Float64}(series_num * parallel_num, length(prob_chemistry.u0))\n    electric_last_stats_sharedarrays = SharedArray{Float64}(series_num * parallel_num, length(prob_electric.u0))\n    electric_fit_k_sharedarrays = SharedArray{Float64}(series_num * parallel_num, 2)\n    equivalent_vi_sharedarrays = SharedArray{Float64}(parallel_num +1)\n    electric_i_sharedarrays = SharedArray{Float64}(series_num * parallel_num,Int(floor(simulate_time/t_step+1)))\n    electric_v_sharedarrays = SharedArray{Float64}(series_num * parallel_num,Int(floor(simulate_time/t_step+1)))\n    iterations_sharedarrays = SharedArray{Int64}(1)\nend","category":"page"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"创建共享数组，该数组保存在系统底层。各个线程均能以很快的速度直接访问。","category":"page"},{"location":"Simulation/MTK_parallel_computing/#.计算初始时刻系统参数","page":"MTK并行计算求解大规模电池阵列","title":"3.计算初始时刻系统参数","text":"","category":"section"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"    time_now = 0\n    iterations_sharedarrays[1] = iterations_sharedarrays[1] + 1\n    #电化学方程\n    @sync @distributed for i in 1:series_num*parallel_num\n        chemistry_para_sharedarrays[i, 1:2*n_mesh_neg+2*n_mesh_pos+n_mesh_sep+3] = sol_chemistry[chemistery_index]\n        chemistry_last_stats_sharedarrays[i, :] = sol_chemistry\n        for j in 2*n_mesh_neg+2*n_mesh_pos+n_mesh_sep+4:3*n_mesh_neg+2*n_mesh_pos+n_mesh_sep+4\n            chemistry_para_sharedarrays[i, j] = ocv_neg(chemistry_para_sharedarrays[i, j-(2*n_mesh_neg+2*n_mesh_pos+n_mesh_sep+3)] / c_s_max_neg)\n            chemistry_para_sharedarrays[i, j+n_mesh_neg+1] = ocv_pos(chemistry_para_sharedarrays[i, j-(2*n_mesh_neg+2*n_mesh_pos+n_mesh_sep+3)+n_mesh_neg+1] / c_s_max_pos)\n        end\n        electric_fit_k_sharedarrays[i, :] = inv([-Current_standard 1.0; -Current_standard/2 1.0]) *\n                                            reshape([solve(remake(prob_electric, p=[chemistry_para_sharedarrays[i, :]..., Current_standard]), KINSOL()).u[electric_vi_index][1],\n                solve(remake(prob_electric, p=[chemistry_para_sharedarrays[i, :]..., Current_standard / 2]), KINSOL()).u[electric_vi_index][1]], (2, 1))\n    end\n    #等效电路方程\n    equivalent_vi_sharedarrays = inv([Diagonal([sum(electric_fit_k_sharedarrays[i*series_num-series_num+1:i*series_num, 1]) for i in 1:parallel_num]) -ones(parallel_num, 1);[ones(parallel_num, 1)... 0.0]]) * \n        [(-sum(electric_fit_k_sharedarrays[(i-1)*series_num+1:i*series_num, 2]) for i in 1:parallel_num)...,-Current];\n    electric_i_sharedarrays[:, iterations_sharedarrays[1]] = vcat([ones(series_num)*equivalent_vi_sharedarrays[i] for i in 1:parallel_num]...)\n    #传输线方程\n    @sync @distributed for i in 1:series_num*parallel_num\n        electric_last_stats_sharedarrays[i, :] = solve(remake(prob_electric, p=[chemistry_para_sharedarrays[i, :]..., -electric_i_sharedarrays[i, iterations_sharedarrays[1]]]), KINSOL()).u\n        electric_para_sharedarrays[i, 1:n_mesh_neg+n_mesh_pos+2] = electric_last_stats_sharedarrays[i, :][electric_index]\n        electric_v_sharedarrays[i, iterations_sharedarrays[1]] = electric_last_stats_sharedarrays[i, :][1]\n        electric_para_sharedarrays[i, n_mesh_neg+n_mesh_pos+3:2*n_mesh_neg+2*n_mesh_pos+4] = [\n            0.5 * Sa_neg * h_neg * (F * k_ct_neg * (c_s_max_neg - chemistry_para_sharedarrays[i, 1])^0.5 * chemistry_para_sharedarrays[i, 1]^0.5 * chemistry_para_sharedarrays[i, 1+n_mesh_pos+n_mesh_neg+2]^0.5) * (exp(0.5 * F * electric_para_sharedarrays[i, 1] / R / T) - exp(-0.5 * F * electric_para_sharedarrays[i, 1] / R / T)),\n            [Sa_neg * h_neg * (F * k_ct_neg * (c_s_max_neg - chemistry_para_sharedarrays[i, j])^0.5 * chemistry_para_sharedarrays[i, j]^0.5 * chemistry_para_sharedarrays[i, j+n_mesh_pos+n_mesh_neg+2]^0.5) * (exp(0.5 * F * electric_para_sharedarrays[i, j] / R / T) - exp(-0.5 * F * electric_para_sharedarrays[i, j] / R / T)) for j in 2:n_mesh_neg]...,\n            0.5 * Sa_neg * h_neg * (F * k_ct_neg * (c_s_max_neg - chemistry_para_sharedarrays[i, n_mesh_neg+1])^0.5 * chemistry_para_sharedarrays[i, n_mesh_neg+1]^0.5 * chemistry_para_sharedarrays[i, n_mesh_neg+1+n_mesh_pos+n_mesh_neg+2]^0.5) * (exp(0.5 * F * electric_para_sharedarrays[i, n_mesh_neg+1] / R / T) - exp(-0.5 * F * electric_para_sharedarrays[i, n_mesh_neg+1] / R / T)),\n            0.5 * Sa_pos * h_pos * (F * k_ct_pos * (c_s_max_pos - chemistry_para_sharedarrays[i, 1+n_mesh_neg+1])^0.5 * chemistry_para_sharedarrays[i, 1+n_mesh_neg+1]^0.5 * chemistry_para_sharedarrays[i, 1+n_mesh_pos+n_mesh_neg+2+n_mesh_neg+1]^0.5) * (exp(0.5 * F * electric_para_sharedarrays[i, 1+n_mesh_neg+1] / R / T) - exp(-0.5 * F * electric_para_sharedarrays[i, 1+n_mesh_neg+1] / R / T)),\n            [Sa_pos * h_pos * (F * k_ct_pos * (c_s_max_pos - chemistry_para_sharedarrays[i, j+n_mesh_neg+1])^0.5 * chemistry_para_sharedarrays[i, j+n_mesh_neg+1]^0.5 * chemistry_para_sharedarrays[i, j+n_mesh_pos+n_mesh_neg+2+n_mesh_neg+1]^0.5) * (exp(0.5 * F * electric_para_sharedarrays[i, j+n_mesh_neg+1] / R / T) - exp(-0.5 * F * electric_para_sharedarrays[i, j+n_mesh_neg+1] / R / T)) for j in 2:n_mesh_pos]...,\n            0.5 * Sa_pos * h_pos * (F * k_ct_pos * (c_s_max_pos - chemistry_para_sharedarrays[i, n_mesh_neg+1+n_mesh_neg+1])^0.5 * chemistry_para_sharedarrays[i, n_mesh_neg+1+n_mesh_neg+1]^0.5 * chemistry_para_sharedarrays[i, n_mesh_neg+1+n_mesh_pos+n_mesh_neg+2+n_mesh_neg+1]^0.5) * (exp(0.5 * F * electric_para_sharedarrays[i, n_mesh_neg+1+n_mesh_neg+1] / R / T) - exp(-0.5 * F * electric_para_sharedarrays[i, n_mesh_neg+1+n_mesh_neg+1] / R / T))]\n    end","category":"page"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"代码分别计算了锂电池模型的浓度，外特性，等效内阻和等效电压源。其中@distributed表示分布式计算，例如for i in 1:100，如果有四个线程，那么在各个线程中，i可能就是1:25,26:50,51:75,76:100。上文说过，各个电池单体相对独立，那么我们可以将电池阵列组装为一个数组，然后调用@distributed进行并行计算。@sync表示执行完该代码后，再执行下一行代码。因为@distributed本身是一个异步指令，子线程执行的同时，主线程会继续执行下一行代码。因此我们需要\"等等\"子线程。","category":"page"},{"location":"Simulation/MTK_parallel_computing/#.系统显式时间推进迭代计算","page":"MTK并行计算求解大规模电池阵列","title":"4.系统显式时间推进迭代计算","text":"","category":"section"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"while time_now < 2500\n    #loop\n    iterations_sharedarrays[1] = iterations_sharedarrays[1] + 1\n    time_now = time_now + t_step\n    #电化学方程\n    @sync @distributed for i in 1:series_num*parallel_num\n        chemistry_last_stats_sharedarrays[i, :] = solve(remake(prob_chemistry, u0=chemistry_last_stats_sharedarrays[i, :], p=electric_para_sharedarrays[i, :]), CVODE_Adams()).u[end]\n        chemistry_para_sharedarrays[i, 1:2*n_mesh_neg+2*n_mesh_pos+n_mesh_sep+3] = chemistry_last_stats_sharedarrays[i, :][chemistery_index]\n        for j in 2*n_mesh_neg+2*n_mesh_pos+n_mesh_sep+4:3*n_mesh_neg+2*n_mesh_pos+n_mesh_sep+4\n            chemistry_para_sharedarrays[i, j] = ocv_neg(chemistry_para_sharedarrays[i, j-(2*n_mesh_neg+2*n_mesh_pos+n_mesh_sep+3)] / c_s_max_neg)\n            chemistry_para_sharedarrays[i, j+n_mesh_neg+1] = ocv_pos(chemistry_para_sharedarrays[i, j-(2*n_mesh_neg+2*n_mesh_pos+n_mesh_sep+3)+n_mesh_neg+1] / c_s_max_pos)\n        end\n        electric_fit_k_sharedarrays[i, :] = inv([-Current_standard 1.0; -Current_standard/2 1.0]) *\n                                            [solve(remake(prob_electric, u0=electric_last_stats_sharedarrays[i, :], p=[chemistry_para_sharedarrays[i, :]..., Current_standard]), KINSOL()).u[electric_vi_index][1]\n            solve(remake(prob_electric, u0=electric_last_stats_sharedarrays[i, :], p=[chemistry_para_sharedarrays[i, :]..., Current_standard / 2]), KINSOL()).u[electric_vi_index][1]]\n    end\n    #等效电路方程\n    equivalent_vi_sharedarrays = inv([Diagonal([sum(electric_fit_k_sharedarrays[i*series_num-series_num+1:i*series_num, 1]) for i in 1:parallel_num]) -ones(parallel_num, 1);[ones(parallel_num, 1)... 0.0]]) * \n        [(-sum(electric_fit_k_sharedarrays[(i-1)*series_num+1:i*series_num, 2]) for i in 1:parallel_num)...,-Current];\n    electric_i_sharedarrays[:, iterations_sharedarrays[1]] = vcat([ones(series_num)*equivalent_vi_sharedarrays[i] for i in 1:parallel_num]...)\n    #传输线方程\n    @sync @distributed for i in 1:series_num*parallel_num\n        electric_last_stats_sharedarrays[i, :] = solve(remake(prob_electric, u0=electric_last_stats_sharedarrays[i, :], p=[chemistry_para_sharedarrays[i, :]..., -electric_i_sharedarrays[i, iterations_sharedarrays[1]]]), KINSOL()).u\n        electric_para_sharedarrays[i, 1:n_mesh_neg+n_mesh_pos+2] = electric_last_stats_sharedarrays[i, :][electric_index]\n        electric_v_sharedarrays[i, iterations_sharedarrays[1]] = electric_last_stats_sharedarrays[i, :][1]\n        electric_para_sharedarrays[i, n_mesh_neg+n_mesh_pos+3:2*n_mesh_neg+2*n_mesh_pos+4] = [\n            0.5 * Sa_neg * h_neg * (F * k_ct_neg * (c_s_max_neg - chemistry_para_sharedarrays[i, 1])^0.5 * chemistry_para_sharedarrays[i, 1]^0.5 * chemistry_para_sharedarrays[i, 1+n_mesh_pos+n_mesh_neg+2]^0.5) * (exp(0.5 * F * electric_para_sharedarrays[i, 1] / R / T) - exp(-0.5 * F * electric_para_sharedarrays[i, 1] / R / T)),\n            [Sa_neg * h_neg * (F * k_ct_neg * (c_s_max_neg - chemistry_para_sharedarrays[i, j])^0.5 * chemistry_para_sharedarrays[i, j]^0.5 * chemistry_para_sharedarrays[i, j+n_mesh_pos+n_mesh_neg+2]^0.5) * (exp(0.5 * F * electric_para_sharedarrays[i, j] / R / T) - exp(-0.5 * F * electric_para_sharedarrays[i, j] / R / T)) for j in 2:n_mesh_neg]...,\n            0.5 * Sa_neg * h_neg * (F * k_ct_neg * (c_s_max_neg - chemistry_para_sharedarrays[i, n_mesh_neg+1])^0.5 * chemistry_para_sharedarrays[i, n_mesh_neg+1]^0.5 * chemistry_para_sharedarrays[i, n_mesh_neg+1+n_mesh_pos+n_mesh_neg+2]^0.5) * (exp(0.5 * F * electric_para_sharedarrays[i, n_mesh_neg+1] / R / T) - exp(-0.5 * F * electric_para_sharedarrays[i, n_mesh_neg+1] / R / T)),\n            0.5 * Sa_pos * h_pos * (F * k_ct_pos * (c_s_max_pos - chemistry_para_sharedarrays[i, 1+n_mesh_neg+1])^0.5 * chemistry_para_sharedarrays[i, 1+n_mesh_neg+1]^0.5 * chemistry_para_sharedarrays[i, 1+n_mesh_pos+n_mesh_neg+2+n_mesh_neg+1]^0.5) * (exp(0.5 * F * electric_para_sharedarrays[i, 1+n_mesh_neg+1] / R / T) - exp(-0.5 * F * electric_para_sharedarrays[i, 1+n_mesh_neg+1] / R / T)),\n            [Sa_pos * h_pos * (F * k_ct_pos * (c_s_max_pos - chemistry_para_sharedarrays[i, j+n_mesh_neg+1])^0.5 * chemistry_para_sharedarrays[i, j+n_mesh_neg+1]^0.5 * chemistry_para_sharedarrays[i, j+n_mesh_pos+n_mesh_neg+2+n_mesh_neg+1]^0.5) * (exp(0.5 * F * electric_para_sharedarrays[i, j+n_mesh_neg+1] / R / T) - exp(-0.5 * F * electric_para_sharedarrays[i, j+n_mesh_neg+1] / R / T)) for j in 2:n_mesh_pos]...,\n            0.5 * Sa_pos * h_pos * (F * k_ct_pos * (c_s_max_pos - chemistry_para_sharedarrays[i, n_mesh_neg+1+n_mesh_neg+1])^0.5 * chemistry_para_sharedarrays[i, n_mesh_neg+1+n_mesh_neg+1]^0.5 * chemistry_para_sharedarrays[i, n_mesh_neg+1+n_mesh_pos+n_mesh_neg+2+n_mesh_neg+1]^0.5) * (exp(0.5 * F * electric_para_sharedarrays[i, n_mesh_neg+1+n_mesh_neg+1] / R / T) - exp(-0.5 * F * electric_para_sharedarrays[i, n_mesh_neg+1+n_mesh_neg+1] / R / T))]\n    end\nend","category":"page"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"没啥好说的，时间方向上的迭代推进。","category":"page"},{"location":"Simulation/MTK_parallel_computing/#最终效果","page":"MTK并行计算求解大规模电池阵列","title":"最终效果","text":"","category":"section"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"(Image: 图 2) ","category":"page"},{"location":"Simulation/MTK_parallel_computing/","page":"MTK并行计算求解大规模电池阵列","title":"MTK并行计算求解大规模电池阵列","text":"如果采用MTK直接建立电池阵列的模型，那么计算时间与(单体数目)^2乘正比，如果采用并行计算，计算时间与(单体数目)^1乘正比。","category":"page"},{"location":"StepByStep/05-gateway设置/#GateWay设置","page":"GateWay设置","title":"GateWay设置","text":"","category":"section"},{"location":"StepByStep/05-gateway设置/#网关和反向代理","page":"GateWay设置","title":"网关和反向代理","text":"","category":"section"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"我们拥有一个域名mydomain.com，并希望在其下承载多种服务。目前，我们考虑了以下两种实现方式：","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"子域名与虚拟主机：为每一项服务设置一个子域名，并在服务器上使用虚拟主机（VirtualHost）配置进行区分和管理。\n目录反向代理：将不同的服务放在mydomain.com的不同目录下，并通过反向代理配置将这些目录定向到各自的后端服务器。","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"此时我们需要一个反向代理服务器。","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"反向代理服务器将作为中介站在客户端和您的各种后端服务之间。当客户端发出请求时，反向代理服务器会根据请求的URL（特别是其目录部分）来决定将请求转发到哪个后端服务器。","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"例如，假设您有两个服务，一个是mydomain.com/serviceA，另一个是mydomain.com/serviceB。当反向代理服务器收到指向/serviceA的请求时，它会将这些请求转发到为serviceA配置的后端服务器；同理，/serviceB的请求也会被转发到对应的后端服务器。","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"反向代理服务器还可以提供其他的功能，如：","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"负载均衡：当有多个后端服务器提供相同的服务时，反向代理可以均匀地将请求分配给这些服务器，以确保每个服务器的负载都保持在合理的范围内。\nSSL/TLS 终结：如果您的服务需要加密，您可以在反向代理服务器上配置SSL/TLS，让它处理所有与加密相关的事务，而后端服务器则可以处理未加密的请求。\n缓存：反向代理可以为经常被请求的内容提供缓存功能，从而加快响应速度。","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"常见的反向代理服务器软件有Nginx、Apache、HAProxy等，您可以根据自己的需要和熟悉程度选择合适的软件进行配置。","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"我们不准备使用apisix之类的，我们只想使用nginx，使问题变得简单。","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"Nginx 是一个功能强大且性能卓越的反向代理服务器，并且在实际应用中已经被广泛采用。使用 Nginx 作为反向代理确实可以简化配置并确保稳定性。","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"APIsix 是一个高性能、实时 API 网关，提供负载均衡、动态上游、灰度发布、服务熔断、身份认证、可观测性等众多功能。它基于 Nginx 与 etcd 构建，使用 Lua 语言来实现其核心功能。APIsix 是为了满足现代微服务、云原生等复杂场景设计的 API 网关，适用于需要高度定制和扩展的场合。但是我们的需求比较简单，仅仅需要基本的反向代理功能，那么使用 Nginx 就足够了。","category":"page"},{"location":"StepByStep/05-gateway设置/#反向代理Nginx-proxy设置","page":"GateWay设置","title":"反向代理Nginx-proxy设置","text":"","category":"section"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"nginx-proxy 是一个受欢迎的 Docker 包，它为运行在 Docker 容器内的 web 应用提供自动的 Nginx 反向代理服务。这个项目利用 Docker 的 API 来自动发现需要代理的服务，并更新 Nginx 的配置。","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"使用 nginx-proxy 的主要优势：","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"自动化：只要为您的应用容器设置正确的环境变量，nginx-proxy 就会自动为您创建相应的反向代理配置。\n简洁：您不再需要手动编辑 Nginx 的配置文件来为每个新的服务创建反向代理。\nLet's Encrypt 整合：通过与 letsencrypt-nginx-proxy-companion 一同使用，nginx-proxy 可以自动为您的域名生成和续订 SSL 证书。\n适应性：它非常适合动态变化的环境，如多阶段部署或者经常有新服务上线的环境。","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"基本的使用流程是：","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"运行 nginx-proxy 容器。\n当您要运行一个新的 web 服务时，只需要在该容器的环境变量中设置 VIRTUAL_HOST（指定该服务的域名或子域名）。\nnginx-proxy 会自动检测到新的容器，并更新其 Nginx 配置以提供相应的反向代理。","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"这个项目确实简化了在 Docker 环境中设置反向代理的过程，非常适合需要快速部署和扩展的场景。","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"以下是一个使用nginx-proxy的典型docker-compose.yml:","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"version: '2'\nservices:\n  nginx-proxy:\n    image: nginxproxy/nginx-proxy\n    container_name: nginx-proxy\n    ports:\n      - \"80:80\"\n      - \"443:443\"\n    volumes:\n      - /var/run/docker.sock:/tmp/docker.sock:ro\n      - /srv/nginx-proxy/conf.d:/etc/nginx/conf.d\n      - /srv/nginx-proxy/certs:/etc/nginx/certs\n      - /srv/nginx-proxy/vhost.d:/etc/nginx/vhost.d\n      - /srv/nginx-proxy/html:/usr/share/nginx/html\n\n  whoami:\n    image: jwilder/whoami\n    expose:\n      - \"8000\"\n    environment:\n      - VIRTUAL_HOST=whoami.local\n      - VIRTUAL_PORT=8000\n\n  nginx-proxy-acme:\n    image: nginxproxy/acme-companion\n    container_name: nginx-proxy-acme\n    environment:\n      - DEFAULT_EMAIL=[YOUR_EMAIL_HERE]\n    volumes_from:\n      - nginx-proxy\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n      - /srv/nginx-proxy/acme:/etc/acme.sh\n\nnetworks:\n   default:\n       external:\n          name: mynginxgroup","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"请在 [YOUR_EMAIL_HERE] 处替换为您的邮箱地址或使用其他非敏感信息替代，以保证配置文件的完整性和功能性。","category":"page"},{"location":"StepByStep/05-gateway设置/#Backend的服务器","page":"GateWay设置","title":"Backend的服务器","text":"","category":"section"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"当您要运行一个新的服务时，我们使用这个nginx-proxy作为前哨，后端只需要启动一组docker-compose，并设置好在该容器的VIRTUAL_HOST`即可。以web服务为例，比如我们则可以启动另外一个docker-compose:","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"version: '2'\n\nservices:\n\n  web-service:\n    image: nginx:alpine\n    container_name: web-container\n    environment:\n      - VIRTUAL_PORT=80\n      - VIRTUAL_HOST=[YOUR_DOMAIN_1],[YOUR_DOMAIN_2]\n      - LETSENCRYPT_HOST=[YOUR_DOMAIN_1],[YOUR_DOMAIN_2]\n      - LETSENCRYPT_EMAIL=[YOUR_EMAIL]\n    volumes:\n      - /srv/www.yourdomain/data:/usr/share/nginx/html\n\nnetworks:\n   default:\n       external:\n          name: mynginxgroup","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"您需要在 [YOUR_DOMAIN_1], [YOUR_DOMAIN_2] 和 [YOUR_EMAIL] 的位置填入适当的信息。","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"此配置提供了一个通用的 nginx:alpine 基础的web服务，与Let's Encrypt集成以自动处理SSL证书。","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"您应该在 [YOUR_DOMAIN_1], [YOUR_DOMAIN_2] 和 [YOUR_EMAIL] 的位置填入适当的信息。","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"现在解释一下您提供的 docker-compose 文件：","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"version: 定义了 docker-compose 文件的版本，这里使用的是 '2'。\nservices:\nweb-service: 这是一个服务定义的名称，该服务运行的是基于 nginx:alpine 的镜像。nginx:alpine 是一个使用 Alpine Linux 作为基础的轻量级 nginx 容器。\ncontainer_name: 定义了容器的名称。\nenvironment: 定义了一系列的环境变量，用于配置容器。\nVIRTUAL_PORT: 为该服务定义的端口。\nVIRTUAL_HOST: 定义了此服务应该响应的域名。\nLETSENCRYPT_HOST: 定义了需要 Let's Encrypt 为其提供 SSL 证书的域名。\nLETSENCRYPT_EMAIL: 定义了用于 Let's Encrypt 证书注册和恢复的电子邮件地址。\nvolumes: 此处挂载了一个主机目录到容器的 nginx 静态文件目录，使得您可以直接在主机上编辑网站内容，而不需要重建或重启容器。\nnetworks:\ndefault: 定义了一个网络设置。此处的 external 指明该网络在 Docker 外部已经存在，并且其名称是 mynginxgroup。","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"这个配置是为 web 服务准备的，基于 nginx 的 web 服务器，同时也为其配置了 Let's Encrypt SSL。","category":"page"},{"location":"StepByStep/05-gateway设置/#基于目录的反向代理","page":"GateWay设置","title":"基于目录的反向代理","text":"","category":"section"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"即便如此，我们需要把mydomain.com/apps反向到不同的后端的时候，只需要在nginx-proxy的vhost.d目录中设置相应的文件：","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"location /apps/ {\n    # 删除/app前缀\n    rewrite ^/apps(/.*)$ $1 break;\n\n    # 反向代理到目标域名\n    proxy_pass http://apps.mysomedomain.cn;\n\n    # 以下是其他反向代理的相关设置，可以根据需求进行调整\n    proxy_set_header Host $host;\n    proxy_set_header X-Real-IP $remote_addr;\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_set_header X-Forwarded-Proto $scheme;\n}\n","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"这个配置是一个经典的 nginx 反向代理设置。这在 nginx-proxy 的上下文中特别有用，因为它允许您为特定的路径设置自定义的代理行为。","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"下面解释一下这段配置：","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"location /apps/: 这表示所有以 /apps/ 开头的请求都会进入这个配置块。\nrewrite ^/apps(/.*)$ $1 break;: 这行代码的作用是去掉 URL 中的 /apps 前缀。例如，如果有一个请求的 URL 是 mydomain.com/apps/somepath，它会被重写为 apps.mysomedomain.com/somepath。\nproxy_pass http://apps.mysomedomain.com;: 这行代码将请求转发到 apps.mysomedomain.com，这是后端服务器的地址。\nproxy_set_header: 这些指令设置代理请求的 HTTP 头部信息。例如，proxy_set_header Host $host; 保证了原始请求的 Host 头部信息被传递到后端服务器。","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"这种配置非常有用，特别是当您希望将一个域名下的多个路径反向代理到不同的后端服务时。通过将特定路径（如 /apps）代理到另一个域名或服务，您可以轻松地在同一个域名下组织和管理多个服务。","category":"page"},{"location":"StepByStep/05-gateway设置/#跨节点的代理","page":"GateWay设置","title":"跨节点的代理","text":"","category":"section"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"如果我们在网关机A上装了nginx-proxy，在同一个网段上有个服务器B，在B上启用了docker-compose，设置了virtual_host，要是想让nginx-proxy把某些服务的backend设置成B上的这个docker-compose该如何做呢？","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"如果你想要在机器A（带有 nginx-proxy）上为机器B上的容器提供代理服务，那么你需要在机器A的nginx-proxy上进行扩展配置。你可以在 nginx-proxy 上手动添加一个配置，指向机器B上的容器IP地址和端口。","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"但是这种方法不会自动更新，除非你创建一个定制版本的 nginx-proxy 来远程连接到机器B并监听其 Docker 守护程序的事件。","category":"page"},{"location":"StepByStep/05-gateway设置/","page":"GateWay设置","title":"GateWay设置","text":"在/srv/nginx-proxy/conf.d中建立foo.conf，它将被挂载在nginx-proxy的/etc/nginx/conf.d。在foo.conf中设置upstream和proxy_pass即可。","category":"page"},{"location":"Modeling/WathMTKdo/#MTK的\"前世今生\"","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"","category":"section"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"tip: Tip\nContents：建模、MTK、SymbolicsContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"note: Note\nMTK = ModelingToolkit.jlSymbolics.jl为MTK依赖的符号计算包ModelingToolkit.jl为基于符号系统的建模工具包。DifferentialEquations.jl为处理时间微分的求解建模工具包。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"MTK似乎很强大，本篇介绍MTK在建模中承担的角色。","category":"page"},{"location":"Modeling/WathMTKdo/#模块化思想","page":"MTK的\"前世今生\"","title":"模块化思想","text":"","category":"section"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"首先，我们聊一聊程序设计中的模块化思想。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"个人认为，模块化其实不单单是一种软件设计的思想。毫不夸张地说，模块化也是一种组织与架构的哲学。模块化的含义可以用一个词语概括——各司其职。若是在软件开发中，需要加上一个限定词——精细化。即，精细化的各司其职。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"模块化解决问题的核心在于，把问题分成若干个部分，每个部分由特定的对象完成。当每个对象的任务都完成之后，问题也就解决了。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"从软件开发到社会的组织架构，都由模块化的影子。课程的小组合作，每个人负责一个小部分；上市公司分为市场部、研发部、财务部...。那么在程序中，这些模块的“对象”就是函数。每个函数完成各的任务，当全部执行完成之后，问题解决了。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"例如，有一个变量var。问题是：计算10 * var + var * var + 1的结果。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"对于这样一个问题，我们习惯于直接把表达式输入得到结果：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"result = 10 * var + var * var + 1","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"但采用模块化的思想，不会这么做。模块化会把这个活分给三个函数去做——乘法函数、平方函数、求和函数。当这个三个函数完成了各自的事情之后，问题解决了。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"function mult(a,b)\n    return a * b\nend\nfunction square(a)\n    return a * a\nend\nfunction sum(a...)\n    s = 0\n    for i in 1:length(a)\n        s += a[i]\n    end\n    return s\nend\nresult = sum(mult(10,var),square(var),1) ","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"当然，对于这样一个问题非要用模块化思想那是闲的。若是针对一个复杂的系统，没有人能完成所有细节的解决方案，那么模块化思想就会变得尤为重要。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"主要有两个方面的好处：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"从自上而下的角度。作为上层的调用者，不需要关心底层函数怎样解决问题。只需要知道，传递什么数据能获得什么结果。这对于复杂问题的解决非常重要。大问题分为几个小问题，小问题再分为更小的问题。作为架构师只需要关心核心部分的拆解即可。这是高效的“各司其职”。\n从自下而上的角度。把问题细分到不能再分，那么其会具有解决任何问题的潜力。什么意思呢？如果把一个表达式作为一个整体求解，这是完全没有问题的。但如果把一个表达式拆解成四则运算分别求解，就如上面的例子。由该问题设计的四则运算函数，对它们进行合理组合能够解决任何一个求解表达式问题。孰高孰低，立见高下。也可以说，模块化后的解决方案具有普适性，解决了复杂问题中的基本共性问题（足够细分的情况下）。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"所以在软件设计领域，有这样一种说法——每一个函数编写时只需要解决一个很小的问题。","category":"page"},{"location":"Modeling/WathMTKdo/#MTK在建模仿真中的角色","page":"MTK的\"前世今生\"","title":"MTK在建模仿真中的角色","text":"","category":"section"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"在DifferentialEquations建模方法从发现问题到获得计算结果，在现代计算科学中一般分为两步：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"把问题抽象可量化、可处理的数学问题\n把数学问题设计成可用计算机处理与计算的可计算问题","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"进一步细分有：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"抽象问题\n符号建模\n模型化简\n生成迭代格式\n迭代求解","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"毫无疑问，第一步由人来完成。剩下的步骤可以由MTK完成。那么新的问题在于，从2-5是否全由MTK从零开始构建呢？答案是否定的！","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"实际上，在建模仿真这样的大问题中，仍然是模块化的思想。具体的分工如下：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"Symbolics.jl：负责符号运算\nModelingToolkit.jl：负责模型化简，生成迭代格式\nDifferentialEquations.jl：负责求解","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"ModelingToolkit的核心在于各种System，System作为一种数据结构，本质是存储的是变量以及由变量构成的方程。而变量的定义与方程的定义由Symbolics完成。所以说，Symbolics是符号计算的基石，MTK在Symbolics的基础之上进一步处理方程与变量，处理成DE能够求解的形式，传递给DE计算。最终得到结果。它们三者的关系如图：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"(Image: 图 6)  ","category":"page"},{"location":"Modeling/WathMTKdo/#Symbolics实例","page":"MTK的\"前世今生\"","title":"Symbolics实例","text":"","category":"section"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"符号定义：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"@variables t α σ(..) β[1:2]\n@variables w(..) x(t) y z(t, α, x)\n@variables A[1:5, 1:3] b[1:3]","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"方程定义：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"using Symbolics\n\n@variables x y;\n@variables A[1:3, 1:3] B[1:3, 1:3];\nx ~ y\nx - y ~ 0\nA ~ B\nA .~ 3x","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"微分运算：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"@variables t\nD = Differential(t)\nz = t + t^2\nD(z)\nexpand_derivatives(D(z)) ","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"化简与符号赋值：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"B = simplify.([t + t^2 + t + t^2  2t + 4t\n               x + y + y + 2t     x^2 - x^2 + y^2])\nsimplify.(substitute.(B, (Dict(x => y^2),)))","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"还有计算雅可比矩阵、函数符号化等等符号计算的内容可查看官方文档。","category":"page"},{"location":"Modeling/WathMTKdo/#小结与启示","page":"MTK的\"前世今生\"","title":"小结与启示","text":"","category":"section"},{"location":"Modeling/WathMTKdo/#启示：文档查询","page":"MTK的\"前世今生\"","title":"启示：文档查询","text":"","category":"section"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"从模块化的角度看待MTK，我们就能知道。MTK能做什么与不能做什么。又或者说，遇到了问题，应该找谁。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"问题类型一：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"符号数组应该如何使用与计算？\nRegister如何使用？\n如何批量处理符号？","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"这样的问题应该去看Symbolics.jl的文档。因为MTK就是在它的基础上构建的。它不支持的，MTK也没办法使用。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"问题类型二：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"求解的结果如何处理？\n如何确定精度？\nCallback如何使用？","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"这样的问题应该去看DifferentialEquations.jl的文档。因为真正的求解工作是DE完成的。solution的结果也从DE中来（MTK会提供关于符号与solution的接口，但DE中solution handling能用的功能，MTK中也一定能用）。","category":"page"},{"location":"Modeling/WathMTKdo/#启示：函数使用","page":"MTK的\"前世今生\"","title":"启示：函数使用","text":"","category":"section"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"在MTK文档没有写上的功能，但DE与Symbolics的文档中有。一般而言都能使用。例如，符号数组的矩阵运算，MTK中一定能用（某些特殊功能不一定）。DE中关于Problem类型的一些参数调用，MTK也可以使用。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"每个包有每个包的特性，包与包之间的依赖关系不是功能的交集，而是功能的并集。底层依赖包的功能在上层调用包一般都能使用。只要有了这一点认识。就能够将SCIML生态的功能充分利用起来。这是贯通的其生态的关键。","category":"page"},{"location":"StepByStep/01-docker-compose环境准备/#docker-compose环境准备","page":"docker-compose环境准备","title":"docker-compose环境准备","text":"","category":"section"},{"location":"StepByStep/01-docker-compose环境准备/#安装wsl","page":"docker-compose环境准备","title":"安装wsl","text":"","category":"section"},{"location":"StepByStep/01-docker-compose环境准备/","page":"docker-compose环境准备","title":"docker-compose环境准备","text":"启用 WSL\n作为管理员打开 PowerShell  (右键点击 Windows 徽标 -> Windows PowerShell (管理员))，并执行以下命令：\nwsl --install\n该命令将安装 WSL 和默认 Linux 发行版（通常是 Ubuntu）。\n启用虚拟机平台\n同样在管理员权限的 PowerShell 中，执行以下命令：\ndism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\n下载 Linux 内核更新包\n如果在前面的步骤中没有自动完成，您需要手动下载并安装 Linux 内核更新包。\n点击此处下载最新的 WSL2 Linux 内核更新包\n下载后，按照提示完成安装。\n设置 WSL 默认版本为 2\n再次打开管理员权限的 PowerShell 并执行以下命令：\nwsl --set-default-version 2\n安装 Linux 发行版\n如果您在第一步中已经使用 wsl --install 命令，您应该已经有了一个默认的 Linux 发行版（如 Ubuntu）。如果没有，您可以从 Microsoft Store 中选择并安装一个 Linux 发行版，例如 Ubuntu, Debian, Fedora Remix 等。\n初始化 Linux 发行版\n打开你所选择的 Linux 发行版应用程序，它将提示您设置新的用户名和密码。","category":"page"},{"location":"StepByStep/01-docker-compose环境准备/","page":"docker-compose环境准备","title":"docker-compose环境准备","text":"完成以上步骤后，WSL 2 应该已经在您的 Windows 11 计算机上安装并正确配置了。您可以通过打开命令行或 PowerShell 并输入 wsl 命令来使用它。","category":"page"},{"location":"StepByStep/01-docker-compose环境准备/#安装docker和docker-compose","page":"docker-compose环境准备","title":"安装docker和docker-compose","text":"","category":"section"},{"location":"StepByStep/01-docker-compose环境准备/","page":"docker-compose环境准备","title":"docker-compose环境准备","text":"在 WSL 2 下安装 Docker 和 Docker Compose 的过程相对简单，尤其是考虑到 WSL 2 提供了完整的 Linux 内核支持。以下是步骤：","category":"page"},{"location":"StepByStep/01-docker-compose环境准备/","page":"docker-compose环境准备","title":"docker-compose环境准备","text":"安装 Docker\n在你的 WSL 2 终端里 (比如说 Ubuntu)，执行以下命令来安装 Docker：\nsudo apt update\nsudo apt install docker.io\n启动 Docker 服务：\nsudo service docker start\n还可以将 Docker 设置为开机启动：\nsudo systemctl enable docker\n安装 Docker Compose\n首先，使用以下命令下载最新版本的 Docker Compose：\nsudo apt update\nsudo apt install docker-compose\n现在，你可以通过输入 docker-compose --version 来检查其版本。","category":"page"},{"location":"StepByStep/01-docker-compose环境准备/","page":"docker-compose环境准备","title":"docker-compose环境准备","text":"此外，请确保你的 Windows 防火墙允许 Docker 进行通信，尤其是当你需要与外部资源进行交互时。","category":"page"},{"location":"StepByStep/01-docker-compose环境准备/#docker简介","page":"docker-compose环境准备","title":"docker简介","text":"","category":"section"},{"location":"StepByStep/01-docker-compose环境准备/","page":"docker-compose环境准备","title":"docker-compose环境准备","text":"Docker 是一个开源平台，它允许开发者和系统管理员构建、部署和运行应用程序在容器内。容器允许开发者将他们的应用程序与其它所有依赖项打包到一起，确保应用程序在任何环境中都能以相同的方式运行。以下是 Docker 的一些核心概念和特点：","category":"page"},{"location":"StepByStep/01-docker-compose环境准备/","page":"docker-compose环境准备","title":"docker-compose环境准备","text":"容器化：\n容器 是轻量级、独立的、可执行的软件包，其中包含了运行某个应用所需的一切：代码、运行时、系统工具、系统库和设置。这确保了应用在任何环境中的一致性。\n镜像：\nDocker 使用 镜像 来打包应用及其依赖项。一旦创建了镜像，你就可以在任何 Docker 环境中使用这个镜像来创建容器。\n镜像是分层的，这意味着每次修改都会创建一个新的层，这样可以提高存储效率并加速部署。\nDocker Hub：\n是一个公开的注册中心，开发者可以在上面分享和存储他们的应用镜像。也有私有注册中心可用于企业或私人使用。\n声明式的设置：\nDocker 允许用户通过 Dockerfile（一个文本文件）声明性地定义应用的环境。这意味着不需要手动设置或配置环境。\n隔离：\nDocker 提供应用级的隔离。每个容器在自己独立的空间中运行，并有自己的网络接口、文件系统和依赖项。这使得容器互不干扰，增加了安全性。\n集成和自动化：\n由于 Docker 容器的一致性和可移植性，它们非常适合持续集成和持续部署 (CI/CD) 流程。\n轻量级和快速：\n与传统的虚拟机相比，Docker 容器启动得更快，占用的资源更少，因为它们共享相同的 OS 内核，而不是每个都有自己的操作系统副本。","category":"page"},{"location":"StepByStep/01-docker-compose环境准备/","page":"docker-compose环境准备","title":"docker-compose环境准备","text":"简而言之，Docker 提供了一种方法，使得开发者和运维团队可以确保他们的应用程序和服务在任何环境中都能如预期般稳定地运行，从而消除了“在我机器上是可以运行的”这种情况。","category":"page"},{"location":"StepByStep/01-docker-compose环境准备/#docker-compose简介","page":"docker-compose环境准备","title":"docker-compose简介","text":"","category":"section"},{"location":"StepByStep/01-docker-compose环境准备/","page":"docker-compose环境准备","title":"docker-compose环境准备","text":"docker-compose 是一个用于定义和运行多容器 Docker 应用程序的工具。通过一个简单的 docker-compose.yml 文件，用户可以定义一个多容器应用的服务、网络和卷，然后使用单一的 docker-compose 命令来启动和停止整个堆栈。","category":"page"},{"location":"StepByStep/01-docker-compose环境准备/","page":"docker-compose环境准备","title":"docker-compose环境准备","text":"以下是 docker-compose 的一些核心特点和概念：","category":"page"},{"location":"StepByStep/01-docker-compose环境准备/","page":"docker-compose环境准备","title":"docker-compose环境准备","text":"服务定义：\n在 docker-compose.yml 文件中，你可以定义应用程序的各个服务，每个服务都会运行在其自己的容器中。你可以定义你想要的任何数量的服务，例如数据库、API 服务、前端应用程序等。\n网络和卷：\ndocker-compose 允许你定义应用的网络和卷，这使得容器之间的通信和数据存储变得简单。\n一键部署：\n通过简单地运行 docker-compose up，所有定义在 docker-compose.yml 文件中的服务、网络和卷都会被创建并启动。\n使用 docker-compose down 可以轻松地停止并删除所有组件。\n声明式配置：\ndocker-compose.yml 文件提供了一种声明式的方式来定义你的应用组件和配置。这确保了环境的一致性和可重现性。\n环境变量和配置文件：\ndocker-compose 支持使用环境变量和 .env 文件来参数化配置，这使得开发、测试和生产环境之间的转换更加轻松。\n本地开发和测试：\ndocker-compose 是一个强大的工具，尤其对于本地开发和测试。开发者可以在他们的机器上定义和运行与生产环境相似的复杂应用，无需安装任何额外的服务或依赖。\n与 Docker CLI 相集成：\ndocker-compose 使用与 Docker 命令行相似的语法和结构，这使得从 Docker 过渡到 docker-compose 变得容易。","category":"page"},{"location":"StepByStep/01-docker-compose环境准备/","page":"docker-compose环境准备","title":"docker-compose环境准备","text":"简而言之，docker-compose 提供了一个简单而高效的方法来定义、运行和管理多容器应用，无论是在本地、测试环境还是生产环境。","category":"page"},{"location":"CSAdv/5-抽象语法树/#抽象语法树","page":"抽象语法树","title":"抽象语法树","text":"","category":"section"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"从源代码（符号）一解析就得到了模型，程序语言内部实际上是用抽象语法树来表示的。编译，就是处理这个抽象语法树模型，优化，并进行代码生成。","category":"page"},{"location":"CSAdv/5-抽象语法树/#抽象语法简介","page":"抽象语法树","title":"抽象语法简介","text":"","category":"section"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"当编译器处理源代码时，它会通过词法分析和语法分析将源代码转换为抽象语法树（Abstract Syntax Tree，AST）。抽象语法树是一种以树形结构表示代码语法结构的模型。","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"抽象语法树是源代码的抽象表示形式，它忽略了源代码中的不必要细节，只保留了语法结构和关键信息。它捕捉了源代码的层次结构、表达式的优先级和关联关系等。","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"在抽象语法树中，每个节点代表代码的一个语法结构，如表达式、语句、函数声明等。节点之间通过父子关系和兄弟关系相连接，形成一棵树的结构。每个节点都包含有关该语法结构的信息，如运算符、操作数、变量名等。","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"编译器在处理抽象语法树时，可以进行各种优化和转换操作。例如，可以通过静态分析来检测潜在的错误和优化机会，进行常量折叠、循环展开、无效代码删除等优化，以提高程序的性能和效率。此外，编译器还可以根据抽象语法树生成目标代码，将高级语言代码转换为可执行的机器码或字节码。","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"抽象语法树在编译器和解释器中扮演着重要的角色，它提供了一种便于处理和分析代码的结构化表示形式。通过使用抽象语法树，编译器可以更容易地进行代码分析、优化和生成，从而实现对程序的有效处理。","category":"page"},{"location":"CSAdv/5-抽象语法树/#一个简单的c的抽象语法树例子","page":"抽象语法树","title":"一个简单的c的抽象语法树例子","text":"","category":"section"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"下面是一个极简单的C语言代码示例及其对应的抽象语法树：","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"C语言代码示例：","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"#include <stdio.h>\n\nint main() {\n    int a = 5;\n    int b = 10;\n    int sum = a + b;\n    \n    printf(\"The sum is: %d\\n\", sum);\n    \n    return 0;\n}","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"对应的抽象语法树示意图：","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"         Program\n           |\n         Compound\n      /     |     \\\n   Decl    Decl   Decl\n    |       |      |\n   int     int    int\n    |       |      |\n   a=5     b=10   sum\n            |      |\n          Add     |\n        /     \\   |\n      a=5     b=10|\n                  |\n                 printf\n                   |\n             StringLiteral\n                   |\n           \"The sum is: %d\\n\"\n                   |\n                  sum","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"在这个示例中，抽象语法树以树的形式展示了代码的语法结构。树的根节点是Program，表示整个程序。Program节点下面是一个Compound节点，表示一个复合语句（代码块）。","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"在Compound节点下，有三个Decl节点，分别表示三个变量的声明。每个Decl节点下面是一个int节点，表示变量的类型，以及一个赋值表达式节点，表示变量的初始化。","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"在代码中，有一个加法运算表达式a + b，它被表示为一个Add节点，左侧是一个a=5的赋值表达式节点，右侧是一个b=10的赋值表达式节点。","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"最后，代码中的printf语句被表示为一个printf节点，它包含一个字符串字面量\"The sum is: %d\\n\"和一个变量引用sum。","category":"page"},{"location":"CSAdv/5-抽象语法树/#一个简单的fortran的抽象语法树的例子","page":"抽象语法树","title":"一个简单的fortran的抽象语法树的例子","text":"","category":"section"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"下面是一个简单的Fortran代码示例及其对应的抽象语法树：","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"Fortran代码示例：","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"PROGRAM HelloWorld\n  IMPLICIT NONE\n  \n  INTEGER :: a, b, sum\n  \n  a = 5\n  b = 10\n  sum = a + b\n  \n  WRITE(*,*) 'The sum is:', sum\n  \nEND PROGRAM HelloWorld","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"对应的抽象语法树示意图：","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"         Program\n           |\n      ProgramName\n           |\n       HelloWorld\n           |\n         Block\n           |\n      Declarations\n       /    |    \\\n     Decl  Decl  Decl\n      |     |     |\n   INTEGER INTEGER INTEGER\n      |     |     |\n      a     b    sum\n           |     |\n         Assign  |\n          /     \\ |\n         a       b|\n                  |\n                Assign\n                  |\n                 sum\n                  |\n                Add\n              /     \\\n             a       b\n                  |\n                 Write\n              /        \\\n             *          ,\n           /  \\       /   \\\n          *    a      *    sum\n         / \\        / \\\n        *   5      sum\n       /\n      10","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"在这个示例中，抽象语法树以树的形式展示了Fortran代码的语法结构。树的根节点是Program，表示整个程序。Program节点下面是一个ProgramName节点，表示程序的名称。","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"在Program节点的下面，有一个Block节点，表示程序的代码块。在代码块中，有一个Declarations节点，表示变量的声明。每个Decl节点下面是一个INTEGER节点，表示变量的类型。","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"在代码中，有三个赋值语句，分别是a = 5、b = 10和sum = a + b。每个赋值语句被表示为一个Assign节点，左侧是一个变量节点，右侧是一个表达式节点。在Assign节点中，使用了Add节点表示加法运算，左侧是变量节点a，右侧是变量节点b。","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"最后，代码中的WRITE语句被表示为一个Write节点，它包含一个格式控制描述符（*表示默认格式）和多个表达式节点。在这个示例中，Write节点的两个表达式分别是字符串字面量'The sum is:'和变量节点sum。","category":"page"},{"location":"CSAdv/5-抽象语法树/#交互式Fortran与LFortran","page":"抽象语法树","title":"交互式Fortran与LFortran","text":"","category":"section"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"有一个现代fortran的工具lfortran。可以使用lfotran查看fortran的抽象语法树。","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"LFortran是一个用于编译Fortran语言的开源项目，它提供了生成抽象语法树（AST）的功能。","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"要使用LFortran来查看Fortran代码的抽象语法树，您需要在本地安装LFortran并使用其命令行工具。以下是一个简单的步骤示例：","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"在您的计算机上安装Python和pip。\n打开终端（命令提示符）。\n使用pip安装LFortran：","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"pip install lfortran","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"创建一个Fortran源文件（例如example.f90）并将您的代码复制到其中。\n在终端中运行以下命令来生成Fortran代码的抽象语法树：","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"lfortran ast example.f90","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"LFortran将会解析并显示Fortran代码的抽象语法树。","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"请注意，LFortran是一个开源项目，其功能和用法可能会有所变化。建议您参考LFortran的官方文档和资源以获得更详细和最新的信息。","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"以下是一个Fortran代码示例及其对应的抽象语法树（类似LFortran生成的输出）：","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"Fortran代码示例（example.f90）：","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"PROGRAM HelloWorld\n  IMPLICIT NONE\n  \n  INTEGER :: a, b, sum\n  \n  a = 5\n  b = 10\n  sum = a + b\n  \n  WRITE(*,*) 'The sum is:', sum\n  \nEND PROGRAM HelloWorld","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"LFortran生成的抽象语法树输出示例：","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"Program\n  - name: HelloWorld\n  - block:\n      Declarations\n        - a: Integer\n        - b: Integer\n        - sum: Integer\n      Statements\n        - Assignment\n          - target: a\n          - value: 5\n        - Assignment\n          - target: b\n          - value: 10\n        - Assignment\n          - target: sum\n          - value: BinaryOp\n              - left: a\n              - right: b\n              - operator: '+'\n        - Write\n          - unit: *\n          - format: *\n          - items:\n              - 'The sum is:'\n              - sum","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"在这个示例中，抽象语法树以一种类似于树状的文本形式呈现。它展示了代码的结构和组织方式。每个节点都具有相应的属性，如变量名、类型、表达式等。","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"请注意，实际的LFortran输出可能会根据其版本和配置而有所不同。以上示例仅用于说明抽象语法树的结构和概念，并非实际的LFortran输出。如需获取真实的LFortran输出，请按照前面提到的步骤在本地运行LFortran命令。","category":"page"},{"location":"CSAdv/5-抽象语法树/#来个Julia的例子","page":"抽象语法树","title":"来个Julia的例子","text":"","category":"section"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"Julia编程语言本身提供了内置的Meta.parse函数，可用于解析Julia代码并生成抽象语法树（AST）。","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"以下是一个示例Julia代码及其对应的抽象语法树（使用Meta.parse生成）：","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"Julia代码示例：","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"function calculate_sum(a, b)\n    sum = a + b\n    println(\"The sum is: \", sum)\nend\n\ncalculate_sum(5, 10)","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"使用Meta.parse生成的抽象语法树：","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"quote\n    function calculate_sum(a, b)\n        sum = a + b\n        println(\"The sum is: \", sum)\n    end\n    calculate_sum(5, 10)\nend","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"在这个示例中，抽象语法树以Julia代码的表达形式呈现，使用quote和end包围代码块。quote和end之间是整个代码块的抽象语法树表示。","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"在代码块中，有一个function节点，表示函数定义。函数定义包含函数名称、参数列表和函数体。函数体内部有一个赋值语句节点sum = a + b和一个println语句节点，分别表示变量赋值和输出语句。","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"最后，在代码块外部调用了calculate_sum函数并传递了参数5和10，表示函数调用的抽象语法树节点。","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"请注意，实际生成和解析Julia代码的抽象语法树可能需要使用Julia编程环境或相应的工具库。以上示例仅用于说明抽象语法树的结构和概念，并非实际的Julia抽象语法树。如需获取真实的Julia抽象语法树，请参考Julia官方文档和相关资源。","category":"page"},{"location":"CSAdv/5-抽象语法树/#抽象语法树与模型","page":"抽象语法树","title":"抽象语法树与模型","text":"","category":"section"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"抽象语法树就是我们源代码符号所对应的模型。经过parser之后，就是处理我们的模型了。","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"抽象语法树（AST）可以看作是将源代码转换为一种结构化的模型。通过解析器（Parser）对源代码进行词法分析和语法分析，可以构建出抽象语法树。","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"抽象语法树是源代码的一种抽象表示形式，它忽略了源代码中的不必要细节，只保留了语法结构和关键信息。它捕捉了源代码的层次结构、表达式的优先级和关联关系等。","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"一旦我们有了抽象语法树，就可以对其进行处理和分析，进而进行编译、优化和代码生成等操作。","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"编译器通常会对抽象语法树进行各种处理，例如静态分析、优化和代码生成。静态分析可以检测潜在的错误、优化机会和代码质量问题。优化涉及对抽象语法树进行各种优化技术，例如常量折叠、循环展开和无效代码删除，以提高程序的性能和效率。代码生成阶段将抽象语法树转换为目标代码，生成可执行的机器码或字节码。","category":"page"},{"location":"CSAdv/5-抽象语法树/","page":"抽象语法树","title":"抽象语法树","text":"通过使用抽象语法树，编译器可以更方便地处理和分析代码，因为抽象语法树提供了一种结构化的表示形式。它将源代码转换为易于处理的模型，使得编译器能够进行静态分析、优化和代码生成等操作，以实现对程序的有效处理。","category":"page"},{"location":"Simulation/steadyRC/#MTK稳态系统仿真实例","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"","category":"section"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"tip: Tip\nContents：MTK、组件化建模Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"note: Note\nMTK = ModelingToolkit.jlModelingToolkit.jl Acausal Component-Based Modeling the RC Circuit介绍了组件化建模的例子","category":"page"},{"location":"Simulation/steadyRC/#动态与瞬态","page":"MTK稳态系统仿真实例","title":"动态与瞬态","text":"","category":"section"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"从内涵来说，稳态问题是动态问题的子集。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"对于稳态动态问题，当微分代数方程中对时间项的微分为0时，则由动态问题过渡为稳态问题。也就是说，稳态问题是动态问题的特殊形式，动态问题是问题的一般形式。微分在实际中代表着“变化”，当该“变化”项为0时，意味着“变化”停止，此时则进入了稳态阶段。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"例如，对于这样一个问题：","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"fracdxdt = 1-xx_0=0","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"从物理演化的角度看，初始时刻，x的变化率为1，x将会不断增大。系统发展到最后，当x增大到1的时候。fracdxdt=0，此时此刻变化就停止了。所以x将进入稳态，即x=1。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"这是因为，从物理的角度理解，微分代表一种变化趋势！上述方程的走势如下图，与分析的情况一致。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"(Image: 图 1)  ","category":"page"},{"location":"Simulation/steadyRC/#MTK的稳态求解技巧","page":"MTK稳态系统仿真实例","title":"MTK的稳态求解技巧","text":"","category":"section"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"求解以下稳态电路问题：","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"(Image: 图 4)  ","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"该问题的电路状态是确定值，不随时间而改变。而DE和MTK处理的是关于时间的微分方程，单纯的代数方程无法求解。对于这样稳态问题，应该怎样求解呢？","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"这里主要运用一个技巧——设定一个变化为0的量加入到方程中。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"什么意思呢？问题必须含有关于时间微分的微分方程，在这一基础之上，让fracdxdt=0不就实现了一种稳态么?x可以代表任何变量，电阻值、电源电压值、电流源值等等。于是，微分变为一种形式，只是让问题能够被求解器求解，对于问题的内涵并没有任何改变。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"@MTK版本：8.5.5","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"using ModelingToolkit, Plots, DifferentialEquations\n\n@variables t\n@connector function Pin(; name)\n    sts = @variables v(t) = 1.0 i(t) = 1.0 [connect = Flow]\n    ODESystem(Equation[], t, sts, []; name=name)\nend\n\nfunction Ground(; name)\n    @named g = Pin()\n    eqs = [g.v ~ 0]\n    compose(ODESystem(eqs, t, [], []; name=name), g)\nend\n\nfunction GroundDIFF(; name)\n    @named g = Pin()\n    sts = @variables v(t)\n    D = Differential(t)\n    eqs = [\n        g.v ~ 0,\n        D(v) ~ 0\n    ]\n    compose(ODESystem(eqs, t, sts, []; name=name), g)\nend\n\nfunction OnePort(; name)\n    @named p = Pin()\n    @named n = Pin()\n    sts = @variables v(t) = 1.0 i(t) = 1.0\n    eqs = [\n        v ~ p.v - n.v\n        0 ~ p.i + n.i\n        i ~ p.i\n    ]\n    compose(ODESystem(eqs, t, sts, []; name=name), p, n)\nend\n\nfunction Resistor(; name, R=1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters R = R\n    eqs = [\n        v ~ i * R\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction ConstantVoltage(; name, V=1.0)\n    @named oneport = OnePort()\n    @unpack v = oneport\n    ps = @parameters V = V\n    eqs = [\n        V ~ v\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction ConstantCurrent(; name, I=1.0)\n    @named oneport = OnePort()\n    @unpack i = oneport\n    ps = @parameters I = I\n    # D = Differential(t)\n    eqs = [\n        i ~ I\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\n\n@named resistor1 = Resistor(R=5.0)\n@named resistor2 = Resistor(R=5.0)\n@named resistor3 = Resistor(R=30.0)\n@named resistor4 = Resistor(R=20.0)\n@named Isource = ConstantCurrent()\n@named Vsource1 = ConstantVoltage(V=30.0)\n@named Vsource2 = ConstantVoltage(V=5.0)\n@named ground = GroundDIFF()\n\n\nrc_eqs = [\n    connect(Vsource1.p, resistor1.p)\n    connect(resistor1.n, resistor2.p, Isource.p)\n    connect(resistor2.n, resistor3.p, resistor4.p)\n    connect(resistor4.n, Isource.n, Vsource2.p)\n    connect(Vsource1.n, Vsource2.n, resistor3.n, ground.g)\n]\n\n@named _rc_model = ODESystem(rc_eqs, t)\n@named rc_model = compose(_rc_model,\n    [resistor1, resistor2, resistor3, resistor4,\n        Isource, Vsource1, Vsource2, ground])\n\nsys = structural_simplify(rc_model)\n\nusing Plots\n\nu0 = [\n    ground.v => 0.0\n]\nprob = ODAEProblem(sys, u0, (0, 10.0))\nsol = solve(prob, Tsit5())\nobserved(sys)\nplot(sol[resistor4.n.i])\n","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"代码中的关键在于函数GroundDIFF()，这个函数中添加的微分项为电势变化为0，即","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"fracdVdt=0","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"并且这个V没有任何意义，既不是接地的电势，也没有和电路中的任何变量产生关联。它只是为了让问题能够被求解而存在。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"最后求解的结果为：","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"(Image: 图 1)  ","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"可以看到，求解的结果在时间轴上是不变的。随然问题看似是一个动态问题，本质上其实是稳态。因为其没有任何改变，时间轴上的任何状态与其前后状态都一样。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"思想的核心其实就是——稳态是动态的一个子集，当动态过程中状态不再改变则进入稳态。这里不过是将问题设置为状态不发生变化的动态，其本质就是稳态。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"tip: Tip\n稳态电路本质是代数方程组，若加上了微分方程，则变成了微分代数方程组。代码中定义的问题是ODAEProblem而不是ODEProblem。DE只有求解微分代数方程的接口而没有求解代数方程的接口。所以需要构造成微分代数问题。","category":"page"},{"location":"Optimization/94-JuMP参数辨识/#JuMP非线性参数辨识实例","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"","category":"section"},{"location":"Optimization/94-JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"tip: Tip\nContents：参数辨识、优化、JuMPContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Optimization/94-JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"note: Note\nJuMP = JuMP.jlNLP = NonlinearnProblem，非线性问题JuMP是计算优化问题的Julia软件包。","category":"page"},{"location":"Optimization/94-JuMP参数辨识/#JuMP介绍","page":"JuMP非线性参数辨识实例","title":"JuMP介绍","text":"","category":"section"},{"location":"Optimization/94-JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"JuMP是一种特定领域的建模语言，用于嵌入Julia中的数学优化。可以用于解决各类优化问题。JuMP的指南中列出了可用的求解器，以及能够求解问题的类型。","category":"page"},{"location":"Optimization/94-JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"JuMP建模的思路主要分为3步：","category":"page"},{"location":"Optimization/94-JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"定义求解器\n明确问题\n求解","category":"page"},{"location":"Optimization/94-JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"使用MTK非线性参数辨识实例中的参数优化问题作为求解实例展开介绍","category":"page"},{"location":"Optimization/94-JuMP参数辨识/#求解实例","page":"JuMP非线性参数辨识实例","title":"求解实例","text":"","category":"section"},{"location":"Optimization/94-JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"为了优化下面模型中的参数ab：","category":"page"},{"location":"Optimization/94-JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"y = ax^2+sin(bx)a=15b=08","category":"page"},{"location":"Optimization/94-JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"人为生成数据，","category":"page"},{"location":"Optimization/94-JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"##### 生成真实数据 #####\nx = collect(-1:0.01:1)\nN = length(x)\n# 产生随机误差，范围在-0.1~0.1之间\nrands = rand(-0.1:0.01:0.1, N)\na1 = 1.5\na2 = 0.8\n# 计算y值\ny = @. a1 * x^2 + sin(a2 * x) + rands","category":"page"},{"location":"Optimization/94-JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"JuMP优化：","category":"page"},{"location":"Optimization/94-JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"首先，定义求解器：","category":"page"},{"location":"Optimization/94-JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"###### 定义求解器 #######\nmodel = Model(Ipopt.Optimizer)","category":"page"},{"location":"Optimization/94-JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"随后，定义优化变量，在参数辨识问题中，被优化的参数为ab：","category":"page"},{"location":"Optimization/94-JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"###### 定义变量 #######\n@variable(model, para[1:2])","category":"page"},{"location":"Optimization/94-JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"其次，构建优化问题的数学表达，需要用@NLexpression生成非线性优化中的中间表达Loss。使用@NLobjective，从Loss中构建最小化优化问题。参数优化问题没有变量约束，也可以说是全局优化问题。","category":"page"},{"location":"Optimization/94-JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"tip: Tip\n@NLobjective、@NLexpression与非线性优化问题有关，在线性优化问题中，使用@expression。不同问题类型使用不同的宏，是JuMP问题构建的特点。","category":"page"},{"location":"Optimization/94-JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"###### 构建问题 #######\n@NLexpression(model, Loss,\n    sum((para[1] * x[i]^2 + sin(para[2] * x[i]) - y[i])^2 for i in 1:N))\n@NLobjective(model, Min, Loss)","category":"page"},{"location":"Optimization/94-JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"最后求解","category":"page"},{"location":"Optimization/94-JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"###### 赋初值 #######\nfor i in 1:2\n    set_start_value(para[i], 0.3)\nend\n###### 求解 #######\nJuMP.optimize!(model)\nJuMP.value.(para)","category":"page"},{"location":"Optimization/94-JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"结果：","category":"page"},{"location":"Optimization/94-JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"2-element Vector{Float64}:\n 1.4989653389675912\n 0.8133014851045581","category":"page"},{"location":"Optimization/94-JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"warning: Warning\n优化的求解器不是万能的，当一个参数辨识问题无法求解时有很多原因，例如：用来描述系统的数学模型不精确上述例子中，优化数据集本身就来自于模型，所以可以肯定数据的本质一定是我们选定的模型。在实际中，面对大量的数据，数学模型准不准确往往是未知的。优化问题较为复杂多变量的复合函数，以及多优化目标的优化问题。在数学上可能有多个局部最优解。有些结果往往不太理想，典型的表现上是不同的初值获得不同的结果。或表现为初值敏感，当初值有微小改变，也能引起结果的巨大不同。面对这些数学上的难点，需要采取一些其它的策略。优化模型或者采取更加强大的求解器......","category":"page"},{"location":"Optimization/94-JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"全部代码：","category":"page"},{"location":"Optimization/94-JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"using JuMP, Ipopt\n\n##### 生成真实数据 ####\nx = collect(-1:0.01:1)\nN = length(x)\n# 产生随机误差，范围在-0.1~0.1之间\nrands = rand(-0.1:0.01:0.1, N)\na1 = 1.5\na2 = 0.8\n# 计算y值\ny = @. a1 * x^2 + sin(a2 * x) + rands\n\nmodel = Model(Ipopt.Optimizer)\n@variable(model, para[1:2])\n@NLexpression(model, Loss,\n    sum((para[1] * x[i]^2 + sin(para[2] * x[i]) - y[i])^2 for i in 1:N))\n@NLobjective(model, Min, Loss)\nfor i in 1:2\n    set_start_value(para[i], 0.3)\nend\n\nJuMP.optimize!(model)\nJuMP.value.(para)","category":"page"},{"location":"CSAdv/91-OpenFoam解构/#OpenFoam解构","page":"OpenFoam解构","title":"OpenFoam解构","text":"","category":"section"},{"location":"CSAdv/91-OpenFoam解构/#OpenFOAM简介","page":"OpenFoam解构","title":"OpenFOAM简介","text":"","category":"section"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"OpenFOAM（Open Field Operation and Manipulation）是一个开源的计算流体力学（Computational Fluid Dynamics，简称CFD）软件包。它提供了一个灵活且可扩展的框架，用于求解包括流体流动、传热和化学反应等方程组的数值模拟问题。下面是对OpenFOAM进行解构的一些关键方面：","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"开源性：OpenFOAM是一个完全开源的软件，这意味着用户可以自由地查看、修改和分发其源代码。这使得OpenFOAM具有高度的灵活性和可定制性，用户可以根据自己的需求进行定制和扩展。\n数值方法：OpenFOAM使用有限体积方法（Finite Volume Method）来离散化和求解流体力学方程。有限体积方法将计算域划分为离散的体积元素，通过对这些体积元素内的质量、动量和能量等守恒方程进行积分，得到离散方程组。通过求解这些方程组，可以获得流体流动的数值解。\n网格：在OpenFOAM中，网格是一个关键的概念。它将计算域划分为离散的单元，可以是结构化网格或非结构化网格。网格的质量和结构对数值模拟结果的准确性和收敛性具有重要影响，因此OpenFOAM提供了一些工具和方法来生成、修改和优化网格。\n物理模型：OpenFOAM支持多种物理模型的求解，包括不可压缩流动、可压缩流动、多相流、传热和化学反应等。它提供了一系列的方程和边界条件，用户可以根据具体问题选择适当的物理模型进行求解。\n求解器：OpenFOAM提供了一系列的求解器（Solver），用于求解不同类型的流体力学问题。每个求解器都基于特定的数值方法和物理模型，可以通过配置文件进行设置和调整。用户可以根据问题的特点选择适当的求解器，并对其进行自定义。\n辅助工具：OpenFOAM还提供了一些辅助工具和库，用于前后处理、结果可视化和数据分析。这些工具包括ParaView、FOAM-Extend、PyFoam等，可以帮助用户对模拟结果进行分析和展示。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"总体而言，OpenFOAM是一个功能强大、灵活且可定制的开源CFD软件包。它的模块化结构和开放的架构使得用户可以根据自己的需求进行定制和扩展，从而适应各种复杂的流体力学模拟问题。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/#OpenFOAM的编译过程","page":"OpenFoam解构","title":"OpenFOAM的编译过程","text":"","category":"section"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"编译OpenFOAM的过程可以简要概括如下：","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"设置环境变量：在开始编译OpenFOAM之前，需要设置一些环境变量以确保编译过程的顺利进行。这些环境变量包括WM_PROJECT_DIR、FOAM_INST_DIR等。通过设置这些变量，指定OpenFOAM的安装路径、项目路径以及其他必要的配置信息。\n创建和配置Build环境：OpenFOAM使用wmake作为项目管理工具，它用于自动化编译过程。在编译之前，需要创建一个Build环境来管理编译过程。可以使用foamNewApp命令创建一个新的应用程序，并使用foamSetEnv命令设置相应的环境变量。\n编译应用程序：在完成Build环境的设置之后，可以使用wmake命令来编译OpenFOAM应用程序。wmake会根据应用程序的Makefile和相关源代码进行编译，并生成可执行文件。在编译过程中，会进行依赖项检查、源代码编译、链接等操作。\n安装应用程序：编译完成后，可以使用wmake命令进行应用程序的安装。安装过程会将生成的可执行文件和其他必要的文件复制到指定的目录中，使得应用程序可以在系统中正常运行。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"以上是一个简单的OpenFOAM编译过程的概述。下面对其中的一些步骤进行解释：","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"环境变量：OpenFOAM的编译和运行依赖于一些环境变量的设置。WM_PROJECT_DIR指定了OpenFOAM的项目根目录，FOAM_INST_DIR指定了OpenFOAM的安装路径。设置这些环境变量可以确保编译和运行时能够正确地找到所需的文件和库。\nBuild环境：Build环境是一个用于管理编译过程的环境。通过使用foamNewApp命令创建一个新的应用程序，并使用foamSetEnv命令设置环境变量，可以将编译过程与其他应用程序隔离开来，使得编译环境更加清晰和可控。\nwmake：wmake是OpenFOAM的项目管理工具，它类似于传统的Make工具，但专门用于OpenFOAM应用程序的编译。它会根据Makefile中的规则和依赖关系来编译源代码，并生成可执行文件。\n应用程序安装：编译完成后，可以使用wmake进行应用程序的安装。安装过程会将生成的可执行文件和其他必要的文件复制到指定的目录中，以便应用程序可以在系统中正常运行。安装后，用户就可以使用应用程序进行流体力学模拟等操作。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"需要注意的是，编译OpenFOAM可能涉及到更多细节和配置，具体步骤可能会因系统环境、OpenFOAM版本和具体需求而有所差异。建议参考OpenFOAM的官方文档和相关资源，以获取更详细的编译指南和说明。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/#Wmake与CMake","page":"OpenFoam解构","title":"Wmake与CMake","text":"","category":"section"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"如果我们洞悉了本质，是可以改写成用CMake编译的。这样就可以CLion帮助我们查看代码，跟踪代码，等等。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"可以使用CMake来改写OpenFOAM的编译过程，以便与CLion等集成开发环境（IDE）进行更好的代码查看、调试和跟踪。CMake是一个跨平台的编译工具，可以帮助管理复杂的项目结构和编译过程。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"下面是一些步骤来使用CMake编译OpenFOAM：","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"创建CMakeLists.txt文件：在OpenFOAM项目的根目录中，创建一个名为CMakeLists.txt的文件。这个文件将包含用于描述项目结构和编译规则的CMake指令。\n添加源代码和依赖项：在CMakeLists.txt文件中，添加源代码文件和所需的依赖项。使用CMake的add_executable命令指定编译生成的可执行文件，使用target_sources命令指定源代码文件。\n配置编译选项：使用CMake的target_compile_options命令配置编译选项，例如优化级别、警告选项等。\n链接库文件：如果OpenFOAM应用程序依赖于其他库文件，可以使用CMake的target_link_libraries命令将这些库文件链接到可执行文件中。\n设置安装路径：使用CMake的install命令设置安装路径，以指定编译后的可执行文件和相关文件的安装位置。\n生成Makefile：在项目根目录中创建一个build目录，进入该目录，并运行cmake命令来生成Makefile。\n编译项目：使用生成的Makefile进行编译。可以运行make命令来编译OpenFOAM应用程序。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"通过使用CMake来编译OpenFOAM，可以利用CLion等IDE提供的强大的代码查看、调试和跟踪功能。你可以在IDE中打开整个OpenFOAM项目，查看代码、导航文件、跟踪变量等，提高开发效率和代码可读性。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"需要注意的是，CMake的使用可能需要对OpenFOAM的项目结构和编译规则进行适当的修改和调整。此外，对于大型和复杂的项目，可能需要更详细的配置和设置。因此，建议在尝试使用CMake编译OpenFOAM之前，仔细阅读OpenFOAM的文档并参考相关资源，以获得更详细的指导和说明。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"参考GitHub上的示例是学习和应用CMake来编译OpenFOAM的好方法。通过借鉴现有示例，你可以了解CMake如何与OpenFOAM项目结合，并根据需要进行适当的调整和定制。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"转换过程可能会有一些繁琐，特别是在将现有的编译系统迁移到CMake时。这涉及到理解项目的结构、编译规则以及依赖关系，并相应地进行配置和设置。但一旦你熟悉了这个过程，将来的迭代和维护将会更加简便和灵活。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"以下是一些建议，帮助你进行顺利的转换过程：","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"仔细阅读示例：详细阅读示例的README文件和相关文档，了解其项目结构、CMake配置和编译过程。这将为你提供宝贵的信息和指导。\n逐步转换：将转换过程分解为多个步骤，并逐步进行。先尝试基本的CMake配置，确保能够成功生成Makefile并编译可执行文件。然后逐渐添加和调整其他设置，如编译选项、依赖项等。\n调试和测试：在转换过程中，进行持续的调试和测试。确保生成的Makefile和编译过程与原来的编译系统一致，并验证可执行文件的功能和正确性。\n与现有系统对比：在转换过程中，与现有的编译系统进行对比，确保CMake配置和生成的Makefile与现有系统的功能和性能相当。\n持续改进和优化：一旦成功进行了基本的转换，你可以进一步改进和优化CMake配置，以提高编译过程的效率和可维护性。这可能涉及到优化编译选项、处理依赖关系、并行编译等。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"记住，转换过程可能会遇到一些挑战，特别是对于复杂的项目。这需要一些耐心和坚持。通过仔细学习示例、尝试和调试，你将能够成功地将OpenFOAM项目转换为使用CMake进行编译，并享受到CMake和集成开发环境带来的便利和好处。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/#OpenFOAM的工作流程","page":"OpenFoam解构","title":"OpenFOAM的工作流程","text":"","category":"section"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"OpenFOAM本身编译成静态链接库，用户写的则是主程序，调用它的库。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"本身，OpenFOAM是利用WMake编译为静态链接库，然后用户可以编写主程序来调用该库。这种方式可以使用户方便地使用OpenFOAM提供的功能和算法。这我们可以根据官方提供的文档走下来获得这个认识。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"我们也可以使用CMake，将OpenFOAM编译成一个静态链接库供用户使用：","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"设置环境变量：首先，设置OpenFOAM的环境变量，确保正确配置OpenFOAM的路径和依赖项。\n创建CMakeLists.txt文件：在OpenFOAM源代码的根目录中，创建一个CMakeLists.txt文件。这个文件将用于配置和描述编译过程。\n添加OpenFOAM源代码：在CMakeLists.txt中，添加OpenFOAM源代码的路径，以指定要编译的文件。\n配置编译选项：使用CMake的相关指令，配置编译选项，例如优化级别、警告选项等。\n编译生成静态库：通过CMake配置后，运行生成Makefile的命令，然后使用Makefile编译OpenFOAM。在编译过程中，将生成OpenFOAM的静态链接库。\n创建用户主程序：用户可以创建自己的主程序，并在其中调用OpenFOAM的静态链接库。主程序可以使用OpenFOAM提供的函数和类，实现所需的功能。\n链接静态库：在用户主程序的CMakeLists.txt中，将OpenFOAM的静态链接库链接到主程序中，以确保可以正确调用OpenFOAM的函数和类。\n编译用户主程序：使用CMake和Makefile编译用户的主程序，确保能够正确链接OpenFOAM的静态库。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"需要注意的是，具体的步骤和配置可能会根据OpenFOAM的版本和项目结构有所不同。因此，在进行这个过程时，建议参考OpenFOAM的官方文档、示例或相关资源，以了解特定版本和项目的编译配置要求。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"使用OpenFOAM作为静态链接库，用户可以在自己的主程序中更灵活地调用OpenFOAM的功能，并开发定制化的应用程序。这样的编译方式能够提供更好的灵活性和可维护性，同时允许用户根据需要进行扩展和定制。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/#OpenFOAM的核心组件FOAM","page":"OpenFoam解构","title":"OpenFOAM的核心组件FOAM","text":"","category":"section"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"OpenFOAM的核心是FOAM。在它基础上实现了FVM方法。我们讲清楚FOAM即可。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"在OpenFOAM中，foam是一个重要的核心库，提供了许多基本功能和类，用于处理和求解流体力学方程。它包含了一些核心的类和数据结构，以及用于网格操作、求解器、物理模型等的功能。下面是对foam的一些关键方面的解释：","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"网格（Mesh）：foam库提供了用于处理和操作网格的类和函数。它定义了一系列网格数据结构，如点（vertices）、单元（cells）、面（faces）和边（edges）。通过这些类，用户可以创建、读取、修改和操作网格，以适应具体的流体力学模拟问题。\n场（Field）：在foam中，场是指在网格上定义的物理量，如速度、压力、温度等。foam库提供了一些用于处理和操作场的类和函数。用户可以创建、初始化、读取、插值和保存场数据，并进行相应的算术和逻辑操作。\n物理模型（Physical Models）：foam库包含了一些常用的物理模型，如不可压缩流动、可压缩流动、传热和化学反应等。这些物理模型定义了相应的守恒方程和边界条件，并提供了求解器的接口。用户可以根据具体问题选择合适的物理模型，并根据需要进行定制和扩展。\n求解器（Solvers）：foam库提供了一系列求解器，用于求解各种流体力学方程。这些求解器基于有限体积方法（Finite Volume Method），通过对离散化的方程进行迭代求解，得到流体流动的数值解。用户可以选择合适的求解器，并根据需要进行配置和定制。\n边界条件（Boundary Conditions）：foam库提供了丰富的边界条件选项，用于定义网格边界上的物理条件。这些边界条件包括固体壁面、入口、出口、对称面、周期性边界等。用户可以选择合适的边界条件，并根据需要进行设置和修改。\n时间步进（Time Stepping）：在foam中，时间步进用于迭代求解流体力学方程。foam库提供了一些时间步进方法和算法，用于控制求解器的迭代过程，以获得稳定和收敛的解。用户可以选择合适的时间步进方案，并根据需要进行调整。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"以上是关于OpenFOAM核心库foam的一些基本介绍。它提供了丰富的功能和工具，用于建模、求解和分析流体力学问题。理解和熟悉foam库的结构和功能对于使用OpenFOAM进行流体力学模拟非常重要。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"它本身就是定义了基本的标量，矢量，张量，然后定义了这些量之间的多种运算符。而运算符就是函数。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"foam库提供了用于定义和操作基本数学对象（如标量、矢量、张量）的类，并定义了这些对象之间的多种运算符。这些数学对象的定义和运算符的实现是通过类和函数来完成的。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"在foam中，常见的数学对象包括标量（Scalar）、矢量（Vector）、张量（Tensor）等。这些对象在OpenFOAM中被用于表示和处理流体力学中的物理量和算子。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"运算符在foam中被实现为相应数学对象的成员函数或全局函数。例如，对于矢量对象，可以使用加法运算符 + 来进行矢量的相加操作，乘法运算符 * 用于矢量与标量的乘法操作等。这些运算符的实现以及其他各种数学运算（如点积、叉积、矩阵乘法等）都由foam库提供。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"此外，foam库还定义了一些与数学对象相关的函数，用于执行特定的数学操作。例如，可以使用mag()函数计算矢量的模长，使用dot()函数计算矢量之间的点积等。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"通过这些定义和实现，foam库提供了方便、高效的数学操作，使得用户能够在OpenFOAM中方便地处理和操作数学对象，进行各种数值计算和模拟。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"需要注意的是，foam库中定义的数学对象和运算符是OpenFOAM的基础，为用户提供了丰富的功能和灵活性。这些数学对象和运算符在OpenFOAM的求解器、边界条件、物理模型等各个方面都得到了广泛的应用。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"此外还定义了这些场量的函数，比如sin(x)，如果x是个标量的话。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"是的，foam库还定义了一些用于处理场量的函数，如sin()、cos()、exp()等，以支持在OpenFOAM中对场量进行数学操作和函数运算。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"这些函数是在foam库中实现的，可以直接应用于标量、矢量和张量场。例如，对于一个标量场，可以使用sin()函数对每个网格点上的标量值进行正弦函数的计算。类似地，对于矢量场，可以对每个网格点上的矢量分量分别应用这些函数。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"这些函数的实现旨在提供对常见数学函数的支持，使用户能够方便地进行数学运算和数值操作。这些函数可以在OpenFOAM中的求解器、边界条件、物理模型等各个部分中使用，以实现更复杂的数值模拟和流体力学分析。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"需要注意的是，这些函数的使用可能会受到特定问题和场景的限制，例如数值稳定性、边界条件等。因此，在使用这些函数时，建议参考OpenFOAM的文档和相关资源，以了解适当的使用方法和潜在的限制。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"为了要实现这些，openfoam用了很多c++的高级特性。尤其是它开发的时候c++还没有足够成熟。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"OpenFOAM在其开发过程中使用了许多C++的高级特性。OpenFOAM最早开发于20世纪90年代末和21世纪初的时期，当时C++标准库和语言特性还没有达到现在的成熟水平。然而，OpenFOAM的开发者们积极地利用C++的特性和灵活性，为其提供了许多先进的功能和可扩展性。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"以下是一些OpenFOAM使用的C++高级特性的例子：","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"类和对象：OpenFOAM通过使用类和对象的概念，将问题领域的实体和操作进行了抽象和封装。这使得OpenFOAM的代码更易于组织、管理和扩展。\n继承与多态：OpenFOAM使用继承和多态的特性，实现了许多基类和派生类的关系。这样的设计使得OpenFOAM的代码更具可重用性和灵活性，可以通过派生类来扩展和定制功能。\n模板（Templates）：OpenFOAM广泛使用模板来实现通用算法和数据结构，以适应不同类型的场量和运算。模板提供了一种参数化的方式，使得代码可以根据具体类型进行实例化，从而提供更高的灵活性和效率。\n异常处理（Exception Handling）：OpenFOAM利用C++的异常处理机制，处理和报告在运行时发生的错误和异常情况。这样的设计使得OpenFOAM可以更好地处理错误，并提供有关问题的详细信息。\n迭代器（Iterators）：OpenFOAM使用迭代器来遍历和访问数据结构中的元素。这提供了一种统一的方式来处理不同类型的数据容器，使得代码更加通用和可扩展。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"通过利用这些C++的高级特性，OpenFOAM能够更好地实现复杂的数值算法、数据结构和物理模型，提供了丰富和灵活的功能。这也是OpenFOAM在流体力学模拟领域中取得广泛应用和不断发展的原因之一。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"OpenFOAM在处理流体力学方程时，通过定义了许多运算符和操作，使得方程的表达更加直观和易读。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"在OpenFOAM中，通过使用mesh和各种标量、矢量、张量场，用户可以在代码中编写出直观易读的方程表达式。这些方程可以使用各种数学运算符，如加法、减法、乘法、除法等，以及一些高级的数学函数，如sin()、cos()等。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"这种直观易读的方程表达式的好处在于，它使得代码更接近于数学表达式或物理方程的形式，有助于用户理解和验证所模拟的流体力学过程。它使得代码更易于编写、调试和维护，并促进了开发者之间的交流和共享。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"通过定义这些运算符和操作，OpenFOAM提供了一个更高级和抽象的编程框架，使得用户能够更专注于问题的物理本质，而不必过于关注底层的数值实现细节。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"需要注意的是，OpenFOAM的运算符和操作在语法和使用上可能会有一些特殊之处，因为它们是根据OpenFOAM的库和框架进行定义的。因此，在使用这些运算符和操作时，建议参考OpenFOAM的文档和相关资源，以了解其正确的使用方法和限制。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"将方程表达式看作是一系列运算符和函数的递归调用，可以帮助理解和解读OpenFOAM中的方程。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"在OpenFOAM中，方程的表达可以通过将运算符视为函数来进行解释。每个运算符都可以看作是一个函数，接受输入参数并返回计算结果。通过递归地调用这些函数，可以构建复杂的方程表达式。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"例如，对于一个简单的方程 a + b - c == d，可以将 + 和 - 运算符视为相应的函数，并按照运算符的优先级和结合性进行递归调用。在这个过程中，可以重载 == 运算符来表示减法操作。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"这种递归调用的思路使得方程的表达更接近数学表达式的形式，提高了代码的可读性和可理解性。通过将方程表达式分解成运算符和函数的组合，可以更清晰地理解方程中各个部分的含义和作用。","category":"page"},{"location":"CSAdv/91-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"需要注意的是，OpenFOAM的运算符和函数在实现和语法上可能有一些特殊之处。因此，建议在理解和编写方程表达式时，参考OpenFOAM的文档和示例，以确保正确使用运算符和函数，并遵循OpenFOAM的约定和规范。","category":"page"},{"location":"Modeling/MTK_intro/#ModelingToolkit建模方法","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"","category":"section"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"tip: Tip\nContents：建模、MTKContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"note: Note\nMTK = ModelingToolkit.jlModelingToolkit.jl为基于符号系统的建模工具包。MTK-Version:8.5 及以上","category":"page"},{"location":"Modeling/MTK_intro/#符号计算内涵","page":"ModelingToolkit建模方法","title":"符号计算内涵","text":"","category":"section"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"符号计算的内涵很简单，其本质就是处理、简化方程的未知数。例如: (x+y)z = xy + yz 又例如: $\\frac{dy}{dt} = 2t => y = t^2 + C $ 它们本质上都是数学符号的推演，而没有涉及到数字的计算。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"一般的情况下，可以计算问题都是人为地把计算推演到数字计算的层面，中间的符号推演、化简的过程都不由计算机处理。随着计算机能力的日益强大，以及计算理论的发展。计算机也能开始进行符号计算。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"例如，(x+y)z = xy + yz就完全能由计算机计算并得到结果。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"MTK，就是这样一种符号计算包。在DE中，我们构建的是方程（function），通过方程来建立模型。而在MTK中，我们构建的是符号，通过符号建立模型。","category":"page"},{"location":"Modeling/MTK_intro/#MTK符号计算实例","page":"ModelingToolkit建模方法","title":"MTK符号计算实例","text":"","category":"section"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"考虑洛伦兹方程：","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"fracdxdt  = sigma(y-x)  fracdydt  = x(rho-z)-y  fracdzdt = xy - beta z","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"通过MTK构建：","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"using ModelingToolkit\nusing DifferentialEquations\n\n@variables t u(t)[1:3]\n@parameters p[1:3]\n\nD = Differential(t)\neqs =[\n    D(u[1]) ~ p[1]*(u[2]-u[1])\n    D(u[2]) ~ u[1]*(p[2]-u[3]) - u[2]\n    D(u[3]) ~ u[1]*u[2] - p[3]*u[3]\n]\n@named Sys = ODESystem(eqs)","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"其中：","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"t是时间变量\nu是关于时间的依赖变量向量\n参数向量p\n微分符号D\neqs本质是一个描述符号方程的数组","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"@variables定义了符号变量，@parameters p[1:3]定义了参数。方程由ODESystem结构体储存，可以看到其中描述“=”的符号为“~”。这些表明，上述代码在处理符号，这是一套符号描述体系！","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"因为是处理符号时，当然也可以更加具象，将符号定义为xyz","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"using ModelingToolkit\nusing DifferentialEquations\n\n@variables t x(t) y(t) z(t)\n@parameters  σ ρ β\nD = Differential(t)\neqs =[\n    D(x) ~ σ*(y-x)\n    D(y) ~ x*(ρ-z) - y\n    D(z) ~ x*y - β*z\n]\n@named sys = ODESystem(eqs)","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"由于符号运算的展现形式更加贴近自然语言，我们几乎可以不加处理地建立与原数学方程几乎一样的符号方程描述，这是符号计算的优势之一。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"在明确MTK的系统构建之后，与DifferentialEquations一样，最后需要明确定义的问题以及初值等要素。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"tspan = (0.0,100.0)\nu0 =[\n    x => 1.0\n    y => 0.0\n    z => 0.0\n]\np=[\n    σ => 10.0\n    ρ => 28.0\n    β => 8/3\n]\nprob = ODEProblem(sys,u0,tspan,p)\nsol = solve(prob,Tsit5())","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"与DE不同是，MTK传值时需要指定具体变量（参数的值）。 最后能得到与DE计算同样的结果。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"全部代码：","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"using ModelingToolkit\nusing DifferentialEquations\n@variables t x(t) y(t) z(t)\n@parameters  σ ρ β\nD = Differential(t)\neqs =[\n    D(x) ~ σ*(y-x)\n    D(y) ~ x*(ρ-z) - y\n    D(z) ~ x*y - β*z\n]\n@named sys = ODESystem(eqs)\ntspan = (0.0,100.0)\nu0 =[\n    x => 1.0\n    y => 0.0\n    z => 0.0\n]\np=[\n    σ => 10.0\n    ρ => 28.0\n    β => 8/3\n]\nprob = ODEProblem(sys,u0,tspan,p)\nsol = solve(prob,Tsit5())\nusing Plots\nplot(sol, idxs=(x,y,z))","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"","category":"page"},{"location":"Modeling/MTK_intro/#DE与MTK的对比","page":"ModelingToolkit建模方法","title":"DE与MTK的对比","text":"","category":"section"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"同一问题，可用MTK与DE来求解。但它们并不完全等价，异同是客观存在的：","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"不同之处：   ModelingToolkit基于符号体系描述问题，等价于在DifferentialEquations问题描述的上层添加了一层符号系统，通过求解符号系统之后，能得到真正的微分方程问题。\n相同之处：   它们最终得到的问题形式是一样的，比如说最终都会生成ODEProblem，也就是说它们可以通过同一个求解器求解。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"MTK凭借着符号计算，在模型建立时会更加方便，更加友好。符号推演功能相当于减轻了模型构造时的工作量，即在数学模型到计算机可计算的模型这个过程中，计算机又往前前进了一步。所以，MTK从某种程度上来说会比DE好用很多。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"从另一个角度来看，DE是MTK的底层求解器，意味着其比MTK更加直接，速度更快。MTK在DE基础之上构建了符号计算系统，其形式与功能上让人惊叹。但要明白的是，这种提供便捷的符号计算系统是要使用资源的，MTK需要花费更多资源去计算、化简符号。好用意味着大量的资源消耗在用户友好方面，效率高意味着资源消耗在真正的问题解决上。这是软件发展过程中始终存在的矛盾。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"note: Note\n就像Linux与Windows一样。大家在开发环境中都愿意用Windows，但在服务器端都用的是Linux。也像是Python与C之间的矛盾。Python代码易用，但运行效率却远远比不上C代码。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"关于DE与MTK的取舍，根据问题的特性选择即可。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"此外，MTK的符号系统还有更大的妙用，在后面的章节中会逐渐展开。","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/#优化问题建模之递归建模方法","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"","category":"section"},{"location":"Optimization/9-优化问题建模之递归建模方法/#递归与plasmo.jl的思想","page":"优化问题建模之递归建模方法","title":"递归与plasmo.jl的思想","text":"","category":"section"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"还记得我们之前提到过的有理数计算吗？当我们之前提到有理数计算时，我们可以构建一个结构体来表示有理数，其中有理数由分子和分母组成。我们可以定义相应的运算符函数来进行有理数的运算，并返回新的有理数类型的实例。同样地，我们在优化问题建模中也可以采用类似的思路。","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"plasmo.jl 是一个基于 Julia 语言的优化建模库，它底层使用了 JuMP.jl。plasmo.jl 的核心概念是将一个优化系统定义为一个图。图由多个子图构成，而子图可以定义决策变量、约束和优化目标。子图和子图之间可以连接，并且连接具有不同的类型。实质上，连接是为了补充子图之间的变量之间的约束关系。","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"在 plasmo.jl 中，子图的决策变量是由子图各自的决策变量的并集组成。约束是子图原有约束的并集再加上连接约束。目标函数的定义则是子图目标函数的加和，因为我们处理的是单目标优化问题。可以将子图的目标函数看作是局部目标函数对整体目标函数的贡献。例如，对于能源系统的成本计算，我们可以将各子图的成本作为局部目标函数，然后将它们相加得到整体的目标函数。","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"综上所述，plasmo.jl 提供了一个灵活的图模型来描述优化系统，其中子图代表了特定的决策变量、约束和目标函数。子图之间的连接用于约束变量之间的关系。通过这种方式，我们可以构建一个整体的图，其中决策变量是各个子图决策变量的并集，约束是原有约束的并集加上连接约束，目标函数是各子图目标函数的加和。这种建模方式能够更好地表示复杂优化问题，并利用图的结构进行优化求解。","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"递归思想","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"递归是有理数计算和优化问题建模中的核心思想之一。在有理数计算中，递归可以用于实现分数的化简、相加、相减、相乘和相除等操作。通过递归的方式，可以不断地将复杂的运算拆解为更简单的子问题，并最终得到结果。","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"类似地，在优化问题建模中，递归思想也可以应用。优化问题往往可以分解为多个子问题，并将它们通过递归的方式进行组合和求解。每个子问题可以被视为一个独立的优化子图，其中包含决策变量、约束和目标函数。然后，通过连接子图之间的变量和约束，可以形成一个更大的图，并在整体图上进行优化求解。","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"递归的优势在于它能够处理复杂的问题，并将问题分解为更小的子问题。这种分解和组合的过程可以提供更好的问题结构表示，并且可以利用问题的局部性质进行优化搜索。通过递归的思想，我们可以将复杂的优化问题分解为多个子问题，并逐步解决每个子问题，最终得到整体的优化结果。","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"总结起来，递归是有理数计算和优化问题建模中的重要思想。它能够帮助我们处理复杂的问题，并通过分解和组合子问题的方式，提供更好的问题表示和优化求解的能力。","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"建模的时候从子图开始，逐级建立，就好比列出有理数的四则运算表达式。","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"整个建模过程类似于逐级建立子图并最终构建整体优化模型的过程。这种方法可以类比于列出有理数的四则运算表达式，其中每个子图对应于运算中的一个操作或子表达式。","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"在建模过程中，我们可以从最基本的子图开始，定义决策变量、约束和目标函数。这些子图可以代表优化问题的局部部分，例如某个子系统、某个环节或某个决策变量集合。然后，我们通过连接子图之间的变量和约束，逐级构建更大的子图，直到形成整体优化模型。","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"类似于有理数的四则运算表达式，我们可以将子图之间的连接视为运算符，用于描述变量之间的关系和约束。通过连接，我们可以将不同子图的决策变量和约束进行整合，并确保它们在整个优化模型中的一致性。","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"这种逐级建立子图的方法可以帮助我们分解复杂的优化问题，并将其组织为层次结构。每个子图对应于一个局部问题，可以更容易地进行建模和分析。同时，通过连接子图，我们能够构建出整体的优化模型，以便进行综合的优化求解。","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"需要注意的是，在建立子图和连接时，我们需要考虑子图之间的相互作用和约束，以确保整体模型的准确性和一致性。合理的子图划分和连接策略可以提高问题的可解性和求解效率，并使建模过程更加简洁和可管理。","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"利用递归对整体优化问题展平","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"递归在有理数计算表达式求值和整体优化问题展平中都起着重要的作用。","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"在有理数计算中，递归可以用于对表达式进行求值。当遇到复杂的表达式时，可以通过递归的方式将其分解为更简单的子表达式，并依次对子表达式进行求值，最终得到整个表达式的结果。递归的思想允许我们逐级展开表达式，直到达到基本的有理数计算操作。","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"类似地，在整体优化问题中，递归可以用于展平问题的层次结构。当优化问题包含多个层次的子问题或子图时，我们可以通过递归的方式将其展平为单层的问题。递归地处理每个子问题，将其转化为独立的决策变量、约束和目标函数，并最终将所有子问题的变量和约束整合到一个层次的优化模型中。","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"通过递归展平优化问题，我们可以减少问题的复杂性，并将其转化为更简单的形式。这有助于更好地理解问题结构，减少建模和求解的复杂度，并提供更高效的优化算法。递归展平可以使优化问题更易于理解、分析和求解，并为问题的优化求解提供更有效的方法。","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"需要注意的是，递归展平优化问题时，需要考虑子问题之间的相互作用和约束，以确保整体模型的一致性和有效性。适当的递归策略和合理的子问题划分可以使优化问题的求解更加高效和可行。","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"综上所述，递归在有理数计算表达式求值和整体优化问题展平中都发挥着关键作用。它们都利用递归的思想将复杂的问题分解为更简单的子问题，并通过逐级处理子问题来实现问题求解。","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"我们以在操场上列队来类比一下","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"我们在操场上排队的时候，按学院、班级、宿舍的顺序进行了排队，但是在主席台上的人看来，就只有第几行第几列的队员。这就是建立模型和模型展平。","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"在操场上列队的过程可以类比为一个层次化的结构，按学院、班级和宿舍的顺序进行排队。在这个层次化的结构中，每个层次都有一定的组织和规则，例如学院内按照班级划分，班级内按照宿舍划分。","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"当我们将这个列队过程建立为一个模型时，我们可以使用层次化的方式进行建模，将学院、班级和宿舍作为模型中的子结构。每个子结构都有自己的决策变量（队员的位置）、约束（按照规则排队）和目标函数（如最小化队伍长度）。","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"然而，对于主席台上的人来说，他们只看到一排一排的队员，而不知道具体的层次结构。这就是模型展平的概念。在模型展平过程中，我们将整个层次化的结构简化为一系列队员的排列顺序。对于主席台上的人来说，他们只需要知道每个队员在队伍中的位置即可，而无需关心队员所属的学院、班级和宿舍。","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"在优化问题中，建立模型类似于操场上的层次化排队，将问题分解为多个子问题，并为每个子问题定义决策变量、约束和目标函数。然后，通过模型展平的过程，将问题简化为一个整体的优化模型，只关注决策变量的排列顺序和其相互之间的约束关系。","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"这种建模和展平的思想可以帮助我们理清复杂问题的结构，减少问题的复杂性，并将问题转化为更简单的形式进行优化求解。同时，模型展平也有助于提高求解效率，简化优化算法的实现和应用。","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"总而言之，操场上的排队过程提供了一个生动的类比，帮助我们理解建模和模型展平的概念。通过层次化建模和模型展平，我们可以更好地处理复杂问题，并为问题的优化求解提供有效的方法。","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/#Plasmo.jl的相关信息","page":"优化问题建模之递归建模方法","title":"Plasmo.jl的相关信息","text":"","category":"section"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"项目网址：https://github.com/plasmo-dev/Plasmo.jl。","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"开发组织：https://zavalab.engr.wisc.edu/。","category":"page"},{"location":"Optimization/9-优化问题建模之递归建模方法/","page":"优化问题建模之递归建模方法","title":"优化问题建模之递归建模方法","text":"博士论文: Graph-Based Modeling and Simulation of Cyber-Physical Systems。","category":"page"},{"location":"CSAdv/2-数据抽象/#数据抽象","page":"数据抽象","title":"数据抽象","text":"","category":"section"},{"location":"CSAdv/2-数据抽象/#数据抽象的概念","page":"数据抽象","title":"数据抽象的概念","text":"","category":"section"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"数据抽象是编程中非常重要的概念之一。它允许我们将复杂的数据结构和操作封装成高层次的抽象，使得程序的设计更加模块化、可维护和可扩展。通过数据抽象，我们可以隐藏数据的内部表示和实现细节，只向外部提供必要的接口和操作。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在编程中，数据抽象的核心思想是将数据和对数据的操作分离开来。这意味着我们可以定义一个数据类型（类或结构体），并为其定义一组相关的操作（方法或函数）。","category":"page"},{"location":"CSAdv/2-数据抽象/#sicp中的数据抽象的核心内容","page":"数据抽象","title":"sicp中的数据抽象的核心内容","text":"","category":"section"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在《计算机程序的构造和解释》（Structure and Interpretation of Computer Programs，简称SICP）中，数据抽象是一个核心概念，并且有几个重要的内容涉及到数据抽象：","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"数据对象和数据类型：SICP强调将数据视为抽象对象，而不仅仅是简单的位序列。数据对象可以是任何具有共同特征的实体，例如数字、字符串、列表等。数据类型则是对数据对象的集合进行分类的方式。\n数据表示和数据抽象屏障：数据的内部表示是指数据对象在计算机中的具体表示方式，而数据抽象屏障是一种限制，用于隐藏数据的内部表示细节，仅向外部提供必要的操作。这种分离使得我们可以改变数据的内部表示方式而不影响使用该数据的代码。\n数据导向的程序设计：SICP鼓励将程序设计视为数据导向的过程。这意味着我们应该根据数据的特性和需求来设计程序，而不仅仅是关注算法和过程。通过合理地定义数据类型和操作，我们可以构建更具表现力和可复用性的程序。\n抽象数据类型（ADT）：SICP中介绍了一种将数据抽象组织起来的方法，称为抽象数据类型。ADT提供了一种将数据表示和操作封装在一起的方式，以实现高层次的抽象。通过ADT，我们可以定义自己的数据类型，包括数据对象和相关的操作。\n数据导向的程序设计方法：SICP介绍了一种基于消息传递的程序设计方法，其中消息是在不同数据对象之间传递的。这种方法强调将操作封装在数据对象内部，并通过发送消息来调用对象的方法。这种方式促进了模块化和可扩展性，并使得程序更容易理解和维护。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"这些是SICP中关于数据抽象的核心内容。通过理解和应用这些概念，可以提高程序设计的灵活性、可扩展性和可维护性。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"但是我们这里不想讲那么多深奥的内容。我们可以就先讲讲有理数这样一个例子。","category":"page"},{"location":"CSAdv/2-数据抽象/#有理数计算","page":"数据抽象","title":"有理数计算","text":"","category":"section"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"我们可以通过一个简单的例子来说明数据抽象的概念。让我们以有理数（Rational Numbers）为例。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"有理数是可以表示为两个整数的比例的数，比如1/2、3/4等。在编程中，我们可以通过一个数据类型来表示有理数，并定义相应的操作。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"首先，我们可以定义一个有理数的数据类型，例如使用分子和分母来表示一个有理数：","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"class Rational:\n    def __init__(self, numerator, denominator):\n        self.numerator = numerator\n        self.denominator = denominator","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在这个例子中，我们使用分子和分母作为有理数对象的属性。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"接下来，我们可以定义有理数的一些操作，比如加法和乘法。这些操作可以被定义为类的方法：","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"class Rational:\n    # ... 省略 __init__ 方法\n    \n    def add(self, other):\n        # 实现有理数的加法操作\n        numerator = self.numerator * other.denominator + self.denominator * other.numerator\n        denominator = self.denominator * other.denominator\n        return Rational(numerator, denominator)\n    \n    def multiply(self, other):\n        # 实现有理数的乘法操作\n        numerator = self.numerator * other.numerator\n        denominator = self.denominator * other.denominator\n        return Rational(numerator, denominator)","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在这个例子中，我们定义了两个操作：add（加法）和multiply（乘法）。这些操作接受另一个有理数对象作为参数，并返回一个新的有理数对象作为结果。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"通过这种方式，我们将有理数的内部表示和操作封装在了一个数据类型中，隐藏了具体的实现细节。外部的代码只需要知道如何使用这些操作，而不需要了解有理数的具体实现。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"例如，我们可以使用定义的有理数类来执行一些操作：","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"# 创建两个有理数对象\nrational1 = Rational(1, 2)\nrational2 = Rational(3, 4)\n\n# 执行加法操作\nresult1 = rational1.add(rational2)\nprint(result1.numerator, \"/\", result1.denominator)  # 输出：10 / 8\n\n# 执行乘法操作\nresult2 = rational1.multiply(rational2)\nprint(result2.numerator, \"/\", result2.denominator)  # 输出：3 / 8","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"通过这个例子，我们展示了如何使用数据抽象来表示有理数，并定义了相应的操作。这种抽象使得我们可以直观地操作有理数，而不需要关心具体的实现细节。","category":"page"},{"location":"CSAdv/2-数据抽象/#以Julia语言举例","page":"数据抽象","title":"以Julia语言举例","text":"","category":"section"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"我们也可以通过一个示例来说明数据抽象在 Julia 中的应用。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"假设我们希望创建一个复数类型，可以表示实部和虚部。我们可以使用 Julia 的结构体（Struct）来定义这个数据类型，并定义一些操作。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"首先，我们可以定义一个名为 ComplexNumber 的结构体：","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"struct ComplexNumber\n    real::Float64\n    imaginary::Float64\nend","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在这个例子中，我们使用 real 表示实部，imaginary 表示虚部。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"接下来，我们可以定义一些操作，比如加法和乘法。这些操作可以通过函数来定义：","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"function add(a::ComplexNumber, b::ComplexNumber)\n    real_part = a.real + b.real\n    imaginary_part = a.imaginary + b.imaginary\n    return ComplexNumber(real_part, imaginary_part)\nend\n\nfunction multiply(a::ComplexNumber, b::ComplexNumber)\n    real_part = a.real * b.real - a.imaginary * b.imaginary\n    imaginary_part = a.real * b.imaginary + a.imaginary * b.real\n    return ComplexNumber(real_part, imaginary_part)\nend","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在这个例子中，我们定义了两个操作：add（加法）和multiply（乘法）。这些函数接受两个复数对象作为参数，并返回一个新的复数对象作为结果。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"现在，我们可以使用定义的复数类型和操作来执行一些操作：","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"# 创建两个复数对象\ncomplex1 = ComplexNumber(1.0, 2.0)\ncomplex2 = ComplexNumber(3.0, 4.0)\n\n# 执行加法操作\nresult1 = add(complex1, complex2)\nprintln(result1.real, \" + \", result1.imaginary, \"i\")  # 输出：4.0 + 6.0i\n\n# 执行乘法操作\nresult2 = multiply(complex1, complex2)\nprintln(result2.real, \" + \", result2.imaginary, \"i\")  # 输出：-5.0 + 10.0i","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"通过这个例子，我们展示了如何使用数据抽象来表示复数，并定义了相应的操作。这种抽象使得我们可以直观地操作复数，而不需要关心具体的实现细节。","category":"page"},{"location":"CSAdv/2-数据抽象/#使用-Julia-来实现有理数的加减乘除操作","page":"数据抽象","title":"使用 Julia 来实现有理数的加减乘除操作","text":"","category":"section"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"当然，我们可以使用 Julia 来实现有理数的加减乘除操作。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"Julia 提供了 Rational 类型来表示有理数，并且内置了一些操作符来处理有理数的加减乘除。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"首先，我们可以使用 // 运算符创建一个有理数：","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"a = 1 // 2\nb = 3 // 4","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"接下来，我们可以使用内置的操作符来执行加减乘除操作：","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"# 加法\nc = a + b\nprintln(c)  # 输出：5//4\n\n# 减法\nd = a - b\nprintln(d)  # 输出：-1//4\n\n# 乘法\ne = a * b\nprintln(e)  # 输出：3//8\n\n# 除法\nf = a / b\nprintln(f)  # 输出：2//3","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在这个例子中，我们使用 +、-、*、/ 这些操作符来执行有理数的加减乘除操作。Julia 会自动处理有理数的运算，并返回一个新的有理数作为结果。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"通过使用内置的有理数类型和操作符，我们可以方便地进行有理数的加减乘除运算，而不需要手动定义自己的数据类型和操作。","category":"page"},{"location":"CSAdv/2-数据抽象/#如果不用julia内置的而是自己写一个","page":"数据抽象","title":"如果不用julia内置的而是自己写一个","text":"","category":"section"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"让我们自己实现一个简单的有理数类型，并定义加减乘除的操作。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在 Julia 中，我们可以使用结构体来定义有理数类型，并在结构体中定义相应的操作函数。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"首先，我们定义一个名为 RationalNumber 的结构体，包含 numerator（分子）和 denominator（分母）两个字段：","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"struct RationalNumber\n    numerator::Int64\n    denominator::Int64\nend","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"接下来，我们可以为结构体定义相应的操作函数，包括加法、减法、乘法和除法：","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"# 加法操作\nfunction +(a::RationalNumber, b::RationalNumber)\n    numerator = a.numerator * b.denominator + b.numerator * a.denominator\n    denominator = a.denominator * b.denominator\n    return simplify(RationalNumber(numerator, denominator))\nend\n\n# 减法操作\nfunction -(a::RationalNumber, b::RationalNumber)\n    numerator = a.numerator * b.denominator - b.numerator * a.denominator\n    denominator = a.denominator * b.denominator\n    return simplify(RationalNumber(numerator, denominator))\nend\n\n# 乘法操作\nfunction *(a::RationalNumber, b::RationalNumber)\n    numerator = a.numerator * b.numerator\n    denominator = a.denominator * b.denominator\n    return simplify(RationalNumber(numerator, denominator))\nend\n\n# 除法操作\nfunction /(a::RationalNumber, b::RationalNumber)\n    numerator = a.numerator * b.denominator\n    denominator = a.denominator * b.numerator\n    return simplify(RationalNumber(numerator, denominator))\nend","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在这个例子中，我们定义了 +、-、*、/ 这些函数来执行有理数的加减乘除操作。我们还定义了一个 simplify 函数，用于简化有理数，即将分子和分母的公约数约简至最简形式。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"最后，我们可以使用我们自己定义的有理数类型和操作来执行一些操作：","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"# 创建两个有理数对象\na = RationalNumber(1, 2)\nb = RationalNumber(3, 4)\n\n# 执行加法操作\nc = a + b\nprintln(c)  # 输出：5//4\n\n# 执行减法操作\nd = a - b\nprintln(d)  # 输出：-1//4\n\n# 执行乘法操作\ne = a * b\nprintln(e)  # 输出：3//8\n\n# 执行除法操作\nf = a / b\nprintln(f)  # 输出：2//3","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"通过这个例子，我们展示了如何使用自定义的有理数类型和操作函数来执行有理数的加减乘除运算。我们的实现可能较为简单，但它演示了如何通过自定义类型和函数来进行数据抽象和操作。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"这里就定义了函数/和函数*等等，运算符就是函数，体现的淋漓尽致。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在很多编程语言中，运算符实际上是函数的语法糖，可以通过函数来定义运算符的行为。这种方式使得运算符看起来更加直观和易于理解。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在我们的例子中，我们使用了函数来定义有理数的加减乘除操作。在 Julia 中，运算符 +、-、*、/ 实际上就是函数 +、-、*、/ 的简化写法。通过定义这些函数，我们实际上定义了对应的运算符的行为。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"这种将运算符作为函数来定义的方式体现了函数式编程的思想，它强调将操作看作是函数应用的过程，使得代码更加模块化、可组合和可扩展。通过将运算符定义为函数，我们可以更灵活地操作数据，并可以根据需要定义自己的运算符行为。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"确实函数式编程的思想在数据抽象中扮演了重要的角色，使得代码更具表现力和可维护性。","category":"page"},{"location":"CSAdv/2-数据抽象/#能源系统建模","page":"数据抽象","title":"能源系统建模","text":"","category":"section"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在能源系统中，我们可以定义一个能源系统类型，它有变量列表，有参数列表，也有方程列表。两个能源系统连接在一起构成一个更大的能源系统。而这个连接，通常表现为方程。那我们也可以定义一种加法运算。能源系统1+能源系统2+连接，结果返回也是一个能源系统，它的变量表就是能源系统1的变量表和能源系统的变量表组织在一起，参数同样，而方程列表则是能源系统1的方程列表和能源系统2的方程列表，在还得算上连接的方程列表。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"我可以通过一个简单的示例来展示如何使用 Julia 定义能源系统类型，并实现能源系统的加法运算。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"首先，我们定义一个名为 EnergySystem 的结构体，包含变量列表、参数列表和方程列表：","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"struct EnergySystem\n    variables::Vector{Symbol}\n    parameters::Vector{Symbol}\n    equations::Vector{Function}\nend","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在这个例子中，我们使用 variables 表示变量列表，parameters 表示参数列表，equations 表示方程列表。变量和参数都以 Symbol 类型表示。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"接下来，我们可以定义一个函数来执行能源系统的加法运算：","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"function +(system1::EnergySystem, system2::EnergySystem)\n    # 合并变量列表\n    variables = union(system1.variables, system2.variables)\n    \n    # 合并参数列表\n    parameters = union(system1.parameters, system2.parameters)\n    \n    # 合并方程列表\n    equations = vcat(system1.equations, system2.equations)\n    \n    # 返回新的能源系统\n    return EnergySystem(variables, parameters, equations)\nend","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在这个函数中，我们使用 union 函数合并变量列表和参数列表，使用 vcat 函数合并方程列表，然后创建一个新的 EnergySystem 对象来存储合并后的变量、参数和方程。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"现在，我们可以使用我们定义的能源系统类型和操作来执行一些操作：","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"# 创建能源系统1\nsystem1 = EnergySystem([:var1, :var2], [:param1, :param2], [eq1, eq2])\n\n# 创建能源系统2\nsystem2 = EnergySystem([:var3, :var4], [:param3, :param4], [eq3, eq4])\n\n# 执行能源系统的加法操作\nresult = system1 + system2\n\n# 打印结果\nprintln(result.variables)  # 输出：[:var1, :var2, :var3, :var4]\nprintln(result.parameters)  # 输出：[:param1, :param2, :param3, :param4]\nprintln(result.equations)  # 输出：[eq1, eq2, eq3, eq4]","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"通过这个例子，我们展示了如何使用自定义的能源系统类型和操作来执行能源系统的加法运算。我们的实现可能是一个简化的示例，实际应用中可能涉及更复杂的能源系统模型和方程。然而，这个例子说明了如何使用 Julia 中的自定义类型和函数来实现能源系统的抽象和操作。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"我们可能需要连接类型，其本质是方程。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"连接类型可以被抽象为方程，但在实际实现中可能会有更多的细节和复杂性。这个例子中我们简化了连接类型，将其看作是能源系统加法运算的一部分。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在能源系统中，连接可以表示不同能源系统之间的关系，例如能源传输、转换或交互。连接可以通过方程来描述，方程将连接的变量和参数联系起来，形成一个更大的能源系统。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在实际应用中，连接可能涉及到更多的模型和约束条件，需要根据具体情况进行建模和定义。这可能需要更多的设计和领域知识。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"总之，通过定义能源系统类型和连接类型，并使用合适的方程描述它们之间的关系，我们可以建立一个更复杂的能源系统模型。这种抽象和建模方式可以帮助我们更好地理解和分析能源系统，以及进行系统级的优化和规划。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"再用上递归，我们就可以从简单的能源系统，逐级的构建非常复杂的能源系统了。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"使用递归可以方便地构建复杂的能源系统，通过逐级连接简单的能源系统来创建更大规模的能源系统。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"让我们通过一个示例来说明递归构建能源系统的过程。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"首先，我们定义一个能源系统的结构体 EnergySystem，包含变量列表、参数列表和方程列表，与之前的示例相同。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"struct EnergySystem\n    variables::Vector{Symbol}\n    parameters::Vector{Symbol}\n    equations::Vector{Function}\nend","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"然后，我们定义一个递归函数 buildEnergySystem，用于构建能源系统。该函数接受一个整数 n 作为参数，表示能源系统的级别。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"function buildEnergySystem(n::Int)\n    if n == 1\n        # 基础能源系统，例如单个发电机\n        variables = [:variable1]\n        parameters = [:parameter1]\n        equations = [equation1]\n        return EnergySystem(variables, parameters, equations)\n    else\n        # 构建更复杂的能源系统，递归连接\n        subsystem1 = buildEnergySystem(n - 1)\n        subsystem2 = buildEnergySystem(n - 1)\n        connection = EnergySystem([:connection_variable], [:connection_parameter], [connection_equation])\n        return subsystem1 + subsystem2 + connection\n    end\nend","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在这个函数中，我们使用条件判断来处理基础能源系统的情况，也就是级别为 1 的能源系统。对于级别大于 1 的能源系统，我们通过递归构建两个子系统，并添加一个连接系统。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"最后，我们可以调用 buildEnergySystem 函数来构建一个复杂的能源系统：","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"complexSystem = buildEnergySystem(3)","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"这将构建一个级别为 3 的复杂能源系统，它由多个能源子系统和连接组成。通过递归构建，我们可以灵活地扩展和组合简单的能源系统，从而构建出更大规模、更复杂的能源系统。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"请注意，这只是一个简化的示例，实际的能源系统模型和连接可能涉及更多的变量、参数和方程。递归构建能源系统需要根据实际需求和领域知识进行设计和建模，以确保模型的准确性和合理性。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"构建过程是从下到上。但是在获取大能源系统的变量表、参数表、方程表的时候，用到递归，递归下去推演出来。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"如果你想要从底层的能源系统递归地推演出大能源系统的变量表、参数表和方程表，可以这样进行。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在这种情况下，我们可以修改 EnergySystem 结构体，使其包含一个能源子系统的列表，以及一个连接系统的列表。然后，我们可以编写一个递归函数 flattenEnergySystem，通过递归遍历能源子系统和连接系统，将其变量、参数和方程合并成一个大能源系统。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"下面是一个示例代码：","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"struct EnergySystem\n    subsystems::Vector{EnergySystem}\n    connections::Vector{EnergySystem}\n    variables::Vector{Symbol}\n    parameters::Vector{Symbol}\n    equations::Vector{Function}\nend\n\nfunction flattenEnergySystem(system::EnergySystem)\n    variables = system.variables\n    parameters = system.parameters\n    equations = system.equations\n\n    for subsystem in system.subsystems\n        subsystem_variables, subsystem_parameters, subsystem_equations = flattenEnergySystem(subsystem)\n        variables = union(variables, subsystem_variables)\n        parameters = union(parameters, subsystem_parameters)\n        equations = vcat(equations, subsystem_equations)\n    end\n\n    for connection in system.connections\n        connection_variables, connection_parameters, connection_equations = flattenEnergySystem(connection)\n        variables = union(variables, connection_variables)\n        parameters = union(parameters, connection_parameters)\n        equations = vcat(equations, connection_equations)\n    end\n\n    return variables, parameters, equations\nend","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在这个代码中，flattenEnergySystem 函数递归地遍历能源子系统和连接系统。对于每个子系统和连接系统，它都调用 flattenEnergySystem 函数来获取其变量、参数和方程，并将其合并到当前大能源系统中。最后，函数返回整个大能源系统的变量表、参数表和方程表。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"你可以使用以下代码示例来测试这个函数：","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"# 创建能源系统1\nsubsystem1 = EnergySystem([], [], [:var1, :var2], [:param1, :param2], [eq1, eq2])\n\n# 创建能源系统2\nsubsystem2 = EnergySystem([], [], [:var3, :var4], [:param3, :param4], [eq3, eq4])\n\n# 创建连接系统\nconnection = EnergySystem([], [], [:connection_variable], [:connection_parameter], [connection_equation])\n\n# 构建大能源系统\ncomplexSystem = EnergySystem([subsystem1, subsystem2], [connection], [], [], [])\n\n# 获取大能源系统的变量表、参数表和方程表\nvariables, parameters, equations = flattenEnergySystem(complexSystem)\n\n# 打印结果\nprintln(\"Variables: \", variables)\nprintln(\"Parameters: \", parameters)\nprintln(\"Equations: \", equations)","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"通过递归的方式，我们可以从底层的能源系统开始，逐级地推演出大能源系统的变量表、参数表和方程表。请注意，这个示例代码仅用于演示基本思想，实际应用中可能需要根据具体情况进行适当的调整和扩展。","category":"page"},{"location":"CSAdv/2-数据抽象/#初等数学符号求导","page":"数据抽象","title":"初等数学符号求导","text":"","category":"section"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"我们实际上可以再进一步演示一下数学上的初等函数及其符号求导。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在数学中，初等函数是指常见的基本函数，例如幂函数、指数函数、对数函数、三角函数等。对这些函数进行符号求导是求导的一种常见操作。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"让我们以一些常见的初等函数为例，演示它们的符号求导过程。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"幂函数： 对于幂函数 f(x) = x^n，其中 n 是常数，它的导数是 f'(x) = n * x^(n-1)。\n指数函数： 对于指数函数 f(x) = a^x，其中 a 是常数且 a > 0，它的导数是 f'(x) = ln(a) * a^x。\n对数函数： 对于自然对数函数 f(x) = ln(x)，它的导数是 f'(x) = 1 / x。\n三角函数： 对于正弦函数 f(x) = sin(x)，它的导数是 f'(x) = cos(x)。 对于余弦函数 f(x) = cos(x)，它的导数是 f'(x) = -sin(x)。 对于正切函数 f(x) = tan(x)，它的导数是 f'(x) = sec^2(x)，其中 sec(x) 是 secant 函数。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"这些是一些常见初等函数的导数规则，可以根据这些规则对函数进行符号求导。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"如果你有特定的初等函数需要求导，你可以提供函数表达式，我可以帮你进行求导操作。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"首先是初等函数的求导，然后是复合函数的求导。就像sicp中的那样。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"我们可以按照要求先演示初等函数的求导，然后再演示复合函数的求导，并使用 Julia 进行实现。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"首先，我们来实现初等函数的求导。我们可以定义一个 derivative 函数，接受一个函数表达式和一个变量作为参数，然后计算该函数在给定变量处的导数。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"下面是一个示例代码，实现了幂函数、指数函数、对数函数和三角函数的求导：","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"using SymPy\n\n# 定义符号变量\nx = symbols(\"x\")\n\n# 幂函数的求导\nfunction power_derivative(f, n)\n    return diff(f, x) * n * x^(n-1)\nend\n\n# 指数函数的求导\nfunction exponential_derivative(f, a)\n    return diff(f, x) * log(a) * a^x\nend\n\n# 对数函数的求导\nfunction logarithm_derivative(f)\n    return diff(f, x) / x\nend\n\n# 三角函数的求导\nfunction trigonometric_derivative(f)\n    return diff(f, x)\nend\n\n# 示例：对函数 f(x) = x^2 求导\nf = x^2\ndf = power_derivative(f, 2)\nprintln(df)  # 输出：2*x\n\n# 示例：对函数 f(x) = exp(x) 求导\nf = exp(x)\ndf = exponential_derivative(f, MathConstants.e)\nprintln(df)  # 输出：ℯ^x\n\n# 示例：对函数 f(x) = log(x) 求导\nf = log(x)\ndf = logarithm_derivative(f)\nprintln(df)  # 输出：1/x\n\n# 示例：对函数 f(x) = sin(x) 求导\nf = sin(x)\ndf = trigonometric_derivative(f)\nprintln(df)  # 输出：cos(x)","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"通过使用 SymPy 库，我们可以定义符号变量 x，并使用 diff 函数对函数进行求导。我们定义了 power_derivative、exponential_derivative、logarithm_derivative 和 trigonometric_derivative 函数来分别计算幂函数、指数函数、对数函数和三角函数的导数。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"我们提供了一些示例，对不同的函数进行求导并打印结果。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"接下来，我们将演示复合函数的求导，即将多个函数组合起来，然后求导整个组合函数。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"现在我们来演示复合函数的求导。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在数学中，复合函数是由多个函数组合而成的函数。要计算复合函数的导数，我们可以使用链式法则。链式法则指出，如果 y 是由函数 u 和 v 组合而成的函数，即 y = u(v(x))，那么 y 对 x 的导数可以通过 u 对 v 的导数乘以 v 对 x 的导数来计算。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"下面是一个示例代码，实现了复合函数的求导：","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"using SymPy\n\n# 定义符号变量\nx = symbols(\"x\")\n\n# 复合函数的求导\nfunction composite_derivative(f, g)\n    return diff(f, g) * diff(g, x)\nend\n\n# 示例：对函数 f(x) = (2x + 1)^3 求导\nf = (2*x + 1)^3\ng = 2*x + 1\ndf = composite_derivative(f, g)\nprintln(df)  # 输出：12(2x + 1)^2\n\n# 示例：对函数 f(x) = sin(2x) 求导\nf = sin(2*x)\ng = 2*x\ndf = composite_derivative(f, g)\nprintln(df)  # 输出：2cos(2x)","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在示例中，我们定义了 composite_derivative 函数，它接受两个函数表达式作为参数，并计算它们的复合函数在给定变量处的导数。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"我们提供了一些示例，对不同的复合函数进行求导并打印结果。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"通过使用 SymPy 库的 diff 函数，我们可以方便地进行符号求导和复合函数的求导。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"请注意，以上代码仅为演示目的，并可能无法处理所有复杂的函数表达式和求导情况。在实际应用中，根据具体函数表达式和求导规则，可能需要进行更复杂的推导和处理。","category":"page"},{"location":"CSAdv/2-数据抽象/#有理数的结构体和操作","page":"数据抽象","title":"有理数的结构体和操作","text":"","category":"section"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"我们可以从有理数的数据抽象开始。有理数是可以表示为分子和分母的整数比例的数值类型。我们可以使用结构体来表示有理数，并定义相应的操作。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"以下是一个用 Julia 实现有理数的例子：","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"struct RationalNumber\n    numerator::Int64\n    denominator::Int64\nend\n\n# 定义有理数的构造函数\nfunction RationalNumber(numerator::Int64, denominator::Int64)\n    gcd_value = gcd(numerator, denominator)\n    return RationalNumber(numerator ÷ gcd_value, denominator ÷ gcd_value)\nend\n\n# 有理数的加法运算\nfunction +(a::RationalNumber, b::RationalNumber)\n    numerator = a.numerator * b.denominator + b.numerator * a.denominator\n    denominator = a.denominator * b.denominator\n    return RationalNumber(numerator, denominator)\nend\n\n# 有理数的减法运算\nfunction -(a::RationalNumber, b::RationalNumber)\n    numerator = a.numerator * b.denominator - b.numerator * a.denominator\n    denominator = a.denominator * b.denominator\n    return RationalNumber(numerator, denominator)\nend\n\n# 有理数的乘法运算\nfunction *(a::RationalNumber, b::RationalNumber)\n    numerator = a.numerator * b.numerator\n    denominator = a.denominator * b.denominator\n    return RationalNumber(numerator, denominator)\nend\n\n# 有理数的除法运算\nfunction /(a::RationalNumber, b::RationalNumber)\n    numerator = a.numerator * b.denominator\n    denominator = a.denominator * b.numerator\n    return RationalNumber(numerator, denominator)\nend\n\n# 示例：使用有理数进行计算\na = RationalNumber(1, 2)\nb = RationalNumber(3, 4)\nc = a + b\nd = a * b\nprintln(c)  # 输出：5//4\nprintln(d)  # 输出：3//8","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在这个例子中，我们定义了一个名为 RationalNumber 的结构体，表示有理数。结构体中有 numerator（分子）和 denominator（分母）两个字段。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"我们还定义了有理数的构造函数，用于创建 RationalNumber 类型的对象，并自动约简为最简形式。此外，我们还实现了有理数的加法、减法、乘法和除法运算，通过重载相应的操作符来实现。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"通过这个例子，我们可以展示数据抽象的概念，并说明如何使用结构体和函数来实现有理数的抽象和操作。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"接下来，我们可以进一步介绍类和面向对象编程的概念。如果你准备好了，我们可以继续。","category":"page"},{"location":"CSAdv/2-数据抽象/#类和面向对象","page":"数据抽象","title":"类和面向对象","text":"","category":"section"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在面向对象编程中，类是一种模板或蓝图，用于创建对象。对象是类的实例，它们包含属性（数据）和方法（操作）。类可以通过继承和多态性实现代码的组织和复用。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"让我们通过一个示例来演示类和面向对象编程的概念。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"# 定义一个有理数类\nabstract type AbstractRational end\n\nstruct RationalNumber <: AbstractRational\n    numerator::Int64\n    denominator::Int64\n\n    # 构造函数\n    function RationalNumber(numerator::Int64, denominator::Int64)\n        gcd_value = gcd(numerator, denominator)\n        new(numerator ÷ gcd_value, denominator ÷ gcd_value)\n    end\n\n    # 加法运算方法\n    function +(a::RationalNumber, b::RationalNumber)\n        numerator = a.numerator * b.denominator + b.numerator * a.denominator\n        denominator = a.denominator * b.denominator\n        RationalNumber(numerator, denominator)\n    end\n\n    # 减法运算方法\n    function -(a::RationalNumber, b::RationalNumber)\n        numerator = a.numerator * b.denominator - b.numerator * a.denominator\n        denominator = a.denominator * b.denominator\n        RationalNumber(numerator, denominator)\n    end\n\n    # 乘法运算方法\n    function *(a::RationalNumber, b::RationalNumber)\n        numerator = a.numerator * b.numerator\n        denominator = a.denominator * b.denominator\n        RationalNumber(numerator, denominator)\n    end\n\n    # 除法运算方法\n    function /(a::RationalNumber, b::RationalNumber)\n        numerator = a.numerator * b.denominator\n        denominator = a.denominator * b.numerator\n        RationalNumber(numerator, denominator)\n    end\nend\n\n# 示例：使用有理数类进行计算\na = RationalNumber(1, 2)\nb = RationalNumber(3, 4)\nc = a + b\nd = a * b\nprintln(c)  # 输出：5//4\nprintln(d)  # 输出：3//8","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在这个示例中，我们定义了一个抽象类型 AbstractRational，它作为有理数类的基类。然后，我们定义了一个 RationalNumber 类，它扩展自 AbstractRational。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在 RationalNumber 类中，我们实现了构造函数和加法、减法、乘法和除法的方法。这些方法定义了对有理数对象进行操作的行为。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"通过使用类和对象，我们可以更好地组织代码，将数据和操作封装在一起，并通过继承和多态性实现代码的复用和灵活性。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"接下来，我们可以讨论类型系统和多态性的概念。如果你准备好了，我们可以继续下一步。","category":"page"},{"location":"CSAdv/2-数据抽象/#用python和c的oop写法","page":"数据抽象","title":"用python和c++的oop写法","text":"","category":"section"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"使用 Python 和 C++ 来重新演示之前的例子，采用面向对象编程的写法。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"首先是 Python 的示例：","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"class RationalNumber:\n    def __init__(self, numerator, denominator):\n        gcd_value = self.gcd(numerator, denominator)\n        self.numerator = numerator // gcd_value\n        self.denominator = denominator // gcd_value\n\n    def gcd(self, a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def __add__(self, other):\n        numerator = self.numerator * other.denominator + other.numerator * self.denominator\n        denominator = self.denominator * other.denominator\n        return RationalNumber(numerator, denominator)\n\n    def __sub__(self, other):\n        numerator = self.numerator * other.denominator - other.numerator * self.denominator\n        denominator = self.denominator * other.denominator\n        return RationalNumber(numerator, denominator)\n\n    def __mul__(self, other):\n        numerator = self.numerator * other.numerator\n        denominator = self.denominator * other.denominator\n        return RationalNumber(numerator, denominator)\n\n    def __truediv__(self, other):\n        numerator = self.numerator * other.denominator\n        denominator = self.denominator * other.numerator\n        return RationalNumber(numerator, denominator)\n\n    def __str__(self):\n        return f\"{self.numerator}/{self.denominator}\"\n\n# 示例：使用有理数进行计算\na = RationalNumber(1, 2)\nb = RationalNumber(3, 4)\nc = a + b\nd = a * b\nprint(c)  # 输出：5/4\nprint(d)  # 输出：3/8","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"以上是使用 Python 的面向对象编程写法实现的有理数类。我们定义了一个 RationalNumber 类，其中包括构造函数和加减乘除的方法。我们还重载了 __str__ 方法，使得打印对象时能够以分数的形式显示。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"接下来是 C++ 的示例：","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"#include <iostream>\n\nclass RationalNumber {\nprivate:\n    int numerator;\n    int denominator;\n\n    int gcd(int a, int b) {\n        while (b) {\n            int temp = a;\n            a = b;\n            b = temp % b;\n        }\n        return a;\n    }\n\npublic:\n    RationalNumber(int numerator, int denominator) {\n        int gcd_value = gcd(numerator, denominator);\n        this->numerator = numerator / gcd_value;\n        this->denominator = denominator / gcd_value;\n    }\n\n    RationalNumber operator+(const RationalNumber& other) const {\n        int numerator = this->numerator * other.denominator + other.numerator * this->denominator;\n        int denominator = this->denominator * other.denominator;\n        return RationalNumber(numerator, denominator);\n    }\n\n    RationalNumber operator-(const RationalNumber& other) const {\n        int numerator = this->numerator * other.denominator - other.numerator * this->denominator;\n        int denominator = this->denominator * other.denominator;\n        return RationalNumber(numerator, denominator);\n    }\n\n    RationalNumber operator*(const RationalNumber& other) const {\n        int numerator = this->numerator * other.numerator;\n        int denominator = this->denominator * other.denominator;\n        return RationalNumber(numerator, denominator);\n    }\n\n    RationalNumber operator/(const RationalNumber& other) const {\n        int numerator = this","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"以上是使用 C++ 的面向对象编程写法实现的有理数类。我们定义了一个 RationalNumber 类，其中包括构造函数和加减乘除的方法。我们通过重载运算符来实现对有理数对象的加减乘除操作。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"这两个示例都展示了使用面向对象编程的方式来实现有理数的抽象和操作。无论是 Python 还是 C++，都可以通过类和对象来封装数据和操作，并提供统一的接口进行操作。","category":"page"},{"location":"CSAdv/2-数据抽象/#类型系统和多态性","page":"数据抽象","title":"类型系统和多态性","text":"","category":"section"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"类型系统是编程语言中重要的概念之一，它定义了变量和表达式的类型，以及这些类型之间的关系和操作。多态性是类型系统的一个特性，它允许我们在不同的类型上执行相同的操作，以增加代码的灵活性和复用性。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"首先，让我们来看一下 Julia 中的类型系统和多态性。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在 Julia 中，类型是非常灵活且动态的，它使用类型注解来指定变量和函数的类型，并且支持多态性。Julia 中的多态性可以通过参数多态性和函数重载来实现。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"以下是一个示例代码，演示了 Julia 中的类型系统和多态性：","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"# 定义一个抽象类型 AbstractRational\nabstract type AbstractRational end\n\n# 定义有理数类型 RationalNumber，并扩展自 AbstractRational\nstruct RationalNumber{T<:Integer} <: AbstractRational\n    numerator::T\n    denominator::T\n\n    # 构造函数\n    function RationalNumber{T}(numerator::T, denominator::T) where T<:Integer\n        gcd_value = gcd(numerator, denominator)\n        new(T(numerator ÷ gcd_value), T(denominator ÷ gcd_value))\n    end\nend\n\n# 重载加法运算符\nfunction +(a::RationalNumber, b::RationalNumber)\n    numerator = a.numerator * b.denominator + b.numerator * a.denominator\n    denominator = a.denominator * b.denominator\n    return RationalNumber(numerator, denominator)\nend\n\n# 重载打印函数\nfunction Base.show(io::IO, r::RationalNumber)\n    print(io, r.numerator, \"/\", r.denominator)\nend\n\n# 示例：使用有理数进行计算\na = RationalNumber(1, 2)\nb = RationalNumber(3, 4)\nc = a + b\nprintln(c)  # 输出：5/4","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在这个示例中，我们定义了一个抽象类型 AbstractRational，然后定义了一个有理数类型 RationalNumber，它扩展自 AbstractRational。在 RationalNumber 类型中，我们使用类型参数 T 来指定有理数的分子和分母的整数类型，并实现了构造函数和加法运算符的重载。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在 Julia 中，我们还重载了 Base.show 函数，用于打印有理数对象。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"通过使用类型参数和多态性，我们可以在 Julia 中实现对不同整数类型的有理数进行操作，提高代码的灵活性。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"接下来，让我们看一下 Python 中的类型系统和多态性。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在 Python 中，类型系统是动态和鸭子类型的，它允许我们在不显式声明类型的情况下，根据对象的行为进行操作。Python 中的多态性是通过鸭子类型和函数重载来实现的。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"以下是一个示例","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在 Python 中展示类型系统和多态性的示例：","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"class AbstractRational:\n    pass\n\nclass RationalNumber(AbstractRational):\n    def __init__(self, numerator, denominator):\n        gcd_value = self.gcd(numerator, denominator)\n        self.numerator = numerator // gcd_value\n        self.denominator = denominator // gcd_value\n\n    def gcd(self, a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def __add__(self, other):\n        numerator = self.numerator * other.denominator + other.numerator * self.denominator\n        denominator = self.denominator * other.denominator\n        return RationalNumber(numerator, denominator)\n\n    def __str__(self):\n        return f\"{self.numerator}/{self.denominator}\"\n\n# 示例：使用有理数进行计算\na = RationalNumber(1, 2)\nb = RationalNumber(3, 4)\nc = a + b\nprint(c)  # 输出：5/4","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在这个示例中，我们定义了一个抽象类 AbstractRational，然后定义了一个有理数类 RationalNumber，它继承自 AbstractRational。在 RationalNumber 类中，我们实现了构造函数和加法运算符的重载。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"通过使用继承和函数重载，我们可以在 Python 中实现对有理数对象的操作，并在运行时根据对象的行为进行动态的多态性。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"无论是在 Julia 还是在 Python，类型系统和多态性都是强大而灵活的工具，可以提高代码的可读性、灵活性和可维护性。","category":"page"},{"location":"CSAdv/2-数据抽象/#自动微分与符号求导","page":"数据抽象","title":"自动微分与符号求导","text":"","category":"section"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在 Julia 中，你可以使用 SymPy.jl 库来进行符号求导。SymPy.jl 是一个与 Python 中的 SymPy 库相对应的库，它提供了符号计算的功能，包括符号求导。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"下面是一个示例代码，演示了在 Julia 中使用 SymPy.jl 进行符号求导：","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"using SymPy\n\n# 定义符号变量\nx = symbols(\"x\")\n\n# 定义函数 f(x) = x^2 + 2x + 1\nf = x^2 + 2x + 1\n\n# 求导\nf_prime = diff(f, x)\n\n# 打印结果\nprintln(f_prime)  # 输出：2*x + 2","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"在这个示例中，我们首先使用 symbols 函数定义了一个符号变量 x。然后，我们定义了函数 f，它表示一个多项式函数。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"使用 diff 函数，我们对函数 f 求导，并将结果赋给 f_prime。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"最后，我们打印出求导结果 f_prime，它表示了函数 f 的导数。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"通过使用 SymPy.jl，我们可以在 Julia 中进行符号计算和符号求导，从而实现符号级别的数学运算和分析。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"以下是一个示例的 Julia 代码，实现了一个简单的符号求导器。从头开始实现最基本的符号求导，就像 Scheme 中那样。","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"abstract type Expr end\n\nstruct Number <: Expr\n    value::Float64\nend\n\nstruct Variable <: Expr\n    name::Symbol\nend\n\nstruct Plus <: Expr\n    expr1::Expr\n    expr2::Expr\nend\n\nstruct Minus <: Expr\n    expr1::Expr\n    expr2::Expr\nend\n\nstruct Times <: Expr\n    expr1::Expr\n    expr2::Expr\nend\n\nstruct Divide <: Expr\n    expr1::Expr\n    expr2::Expr\nend\n\nfunction diff(expr::Number, var::Symbol)\n    return Number(0.0)\nend\n\nfunction diff(expr::Variable, var::Symbol)\n    if expr.name == var\n        return Number(1.0)\n    else\n        return Number(0.0)\n    end\nend\n\nfunction diff(expr::Plus, var::Symbol)\n    return Plus(diff(expr.expr1, var), diff(expr.expr2, var))\nend\n\nfunction diff(expr::Minus, var::Symbol)\n    return Minus(diff(expr.expr1, var), diff(expr.expr2, var))\nend\n\nfunction diff(expr::Times, var::Symbol)\n    return Plus(Times(diff(expr.expr1, var), expr.expr2),\n                Times(expr.expr1, diff(expr.expr2, var)))\nend\n\nfunction diff(expr::Divide, var::Symbol)\n    return Divide(Minus(Times(diff(expr.expr1, var), expr.expr2),\n                        Times(expr.expr1, diff(expr.expr2, var))),\n                  Times(expr.expr2, expr.expr2))\nend\n\nfunction simplify(expr::Number)\n    return expr\nend\n\nfunction simplify(expr::Variable)\n    return expr\nend\n\nfunction simplify(expr::Plus)\n    expr1 = simplify(expr.expr1)\n    expr2 = simplify(expr.expr2)\n    if expr1 isa Number && expr2 isa Number\n        return Number(expr1.value + expr2.value)\n    else\n        return Plus(expr1, expr2)\n    end\nend\n\nfunction simplify(expr::Minus)\n    expr1 = simplify(expr.expr1)\n    expr2 = simplify(expr.expr2)\n    if expr1 isa Number && expr2 isa Number\n        return Number(expr1.value - expr2.value)\n    else\n        return Minus(expr1, expr2)\n    end\nend\n\nfunction simplify(expr::Times)\n    expr1 = simplify(expr.expr1)\n    expr2 = simplify(expr.expr2)\n    if expr1 isa Number && expr2 isa Number\n        return Number(expr1.value * expr2.value)\n    else\n        return Times(expr1, expr2)\n    end\nend\n\nfunction simplify(expr::Divide)\n    expr1 = simplify(expr.expr1)\n    expr2 = simplify(expr.expr2)\n    if expr1 isa Number && expr2 isa Number\n        return Number(expr1.value / expr2.value)\n    else\n        return Divide(expr1, expr2)\n    end\nend\n\nfunction simplify(expr::Expr)\n    return expr\nend\n\nfunction show_expr(expr::Number)\n    print(expr.value)\nend\n\nfunction show_expr(expr::Variable)\n    print(expr.name)\nend\n\nfunction show_expr(expr::Plus)\n    print(\"(\")\n    show_expr(expr.expr1)\n    print(\" + \")\n    show_expr(expr.expr2)\n    print(\")\")\nend\n","category":"page"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"以上只是部分代码，展示一下就是这么干的。","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/#JuMP混合整数线性优化实例","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"","category":"section"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"tip: Tip\nContents：优化Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/#问题简介","page":"JuMP混合整数线性优化实例","title":"问题简介","text":"","category":"section"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"Advent Of Code中有一个很有意思的问题，可用JuMP来求解。同时也是能源系统优化的一个缩影。","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"问题如下：","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"为了收获粘土，你需要专用的粘土收集机器人。要制造任何类型的机器人，你都需要矿石。收集矿石需要带大钻头的矿石收集机器人。幸运的是，你的背包中正好有一个矿石收集机器人，你可以使用它启动整个操作。","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"每个机器人每分钟可以收集1个其资源类型。机器人工厂（也在你的背包中）构建任何类型的机器人也需要一分钟，尽管它在构建开始时会消耗必要的可用资源，同时每分钟最多建造1个机器人。","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"机器人工厂有很多蓝图（问题的输入）你可以选择，但一旦你用蓝图配置好了，你就不能改变它。","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"蓝图1：\n    制造一个矿石机器人（ore robot）消耗4矿石（ore）。\n    制造一个粘土机器人（clay robot）消耗2矿石（ore）。\n    制造一个黑曜石机器人（obsidian robot）消耗3块矿石（ore）和14块粘土（clay）。\n    制造一个紫晶机器人（geode robot）消耗2个矿石（ore）和7个黑曜石（obsidian）。\n\n蓝图2：\n    制造一个矿石机器人消耗2矿石。\n    制造一个粘土机器人消耗3矿石。\n    制造一个黑曜石机器人消耗3块矿石和8块粘土。\n    制造一个紫晶机器人消耗3个矿石和12个黑曜石。","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"优化问题为：如何分配资源去建造机器人，在24分钟后获得最多的紫晶。","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"蓝图1的最优方案为最多获得9个紫晶，具体操作过程为：","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"==第1分钟==\n1台矿石收集机器人收集1个矿石；你现在有1个矿石。\n\n==第2分钟==\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n\n==第3分钟==\n花2矿石开始建造一个粘土收集机器人。\n1台矿石收集机器人收集1个矿石；你现在有1个矿石。\n\n新的粘土收集机器人准备就绪；你现在有一个了。\n\n==第4分钟==\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n1个粘土收集机器人收集1个粘土；你现在有1个粘土。\n\n==第5分钟==\n\n花2矿石开始建造一个粘土收集机器人。\n1台矿石收集机器人收集1个矿石；你现在有1个矿石。\n1个粘土收集机器人收集1个粘土；你现在有2个粘土。\n\n新的粘土收集机器人准备就绪；你现在有两个了。\n\n==第6分钟==\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n2个粘土收集机器人收集2个粘土；你现在有4块粘土。\n\n==第7分钟==\n花2矿石开始建造一个粘土收集机器人。\n1台矿石收集机器人收集1个矿石；你现在有1个矿石。\n2个粘土收集机器人收集2个粘土；你现在有6块粘土。\n\n新的粘土收集机器人准备就绪；你现在有3个了。\n\n==第8分钟==\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n3个粘土收集机器人收集3个粘土；你现在有9块粘土。\n\n==第9分钟==\n1台矿石收集机器人收集1个矿石；你现在有3个矿石。\n3个粘土收集机器人收集3个粘土；你现在有12块粘土。\n\n==第10分钟==\n1台矿石收集机器人收集1个矿石；你现在有4个矿石。\n3个粘土收集机器人收集3个粘土；你现在有15块粘土。\n\n==分钟11==\n花3块矿石和14块粘土开始建造一个黑曜石收集机器人。\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n3个粘土收集机器人收集3个粘土；你现在有4块粘土。\n\n新的黑曜石收集机器人准备就绪；你现在有一个了。\n\n==第12分钟==\n花2矿石开始建造一个粘土收集机器人。\n1台矿石收集机器人收集1个矿石；你现在有1个矿石。\n3个粘土收集机器人收集3个粘土；你现在有7块粘土。\n1个黑曜石收集机器人收集1颗黑曜岩；你现在有1个黑曜石。\n\n新的粘土收集机器人准备就绪；你现在有4个。\n\n==第13分钟==\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n4个粘土收集机器人收集4个粘土；你现在有11块粘土。\n1个黑曜石收集机器人收集1颗黑曜岩；你现在有2颗黑曜石。\n\n==第14分钟==\n1台矿石收集机器人收集1个矿石；你现在有3个矿石。\n4个粘土收集机器人收集4个粘土；你现在有15块粘土。\n1个黑曜石收集机器人收集1颗黑曜岩；你现在有3个黑曜石。\n\n==第15分钟==\n花3块矿石和14块粘土开始建造一个黑曜石收集机器人。\n1台矿石收集机器人收集1个矿石；你现在有1个矿石。\n4个粘土收集机器人收集4个粘土；你现在有5块粘土。\n1个黑曜石收集机器人收集1颗黑曜岩；你现在有4颗黑曜石。\n\n新的黑曜石收集机器人准备就绪；你现在有两个了。\n\n==第16分钟==\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n4个粘土收集机器人收集4个粘土；你现在有9块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有6颗黑曜石。\n\n==第17分钟==\n1台矿石收集机器人收集1个矿石；你现在有3个矿石。\n4个粘土收集机器人收集4个粘土；你现在有13块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有8颗黑曜石。\n\n==第18分钟==\n花2颗矿石和7颗黑曜石开始建造一个紫晶机器人。\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n4个粘土收集机器人收集4个粘土；你现在有17块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有3个黑曜石。\n\n新的紫晶机器人准备就绪；你现在有一个了。\n\n==第19分钟==\n1台矿石收集机器人收集1个矿石；你现在有3个矿石。\n4个粘土收集机器人收集4个粘土；你现在有21块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有5颗黑曜石。\n\n1个紫晶机器人收集1个紫晶；你现在有一个紫晶。\n\n==第20分钟==\n1台矿石收集机器人收集1个矿石；你现在有4个矿石。\n4个粘土收集机器人收集4个粘土；你现在有25块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有7颗黑曜石。\n\n1个紫晶机器人收集1个紫晶；你现在有2个紫晶。\n\n==第21分钟==\n花2颗矿石和7颗黑曜石开始建造一个紫晶机器人。\n1台矿石收集机器人收集1个矿石；你现在有3个矿石。\n4个粘土收集机器人收集4个粘土；你现在有29块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有2颗黑曜石。\n1个紫晶开裂机器人开裂1个大地洞；你现在有3个紫晶。\n\n新的紫晶机器人准备就绪；你现在有两个了。\n\n==第22分钟==\n1台矿石收集机器人收集1个矿石；你现在有4个矿石。\n4个粘土收集机器人收集4个粘土；你现在有33块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有4颗黑曜石。\n2个紫晶机器人收集2个紫晶；你现在有5个紫晶。\n\n==第23分钟==\n1台矿石收集机器人收集1个矿石；你现在有5个矿石。\n4个粘土收集机器人收集4个粘土；你现在有37块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有6颗黑曜石。\n2个紫晶机器人收集2个紫晶；你现在有7个紫晶。\n\n==第24分钟==\n1台矿石收集机器人收集1个矿石；你现在有6个矿石。\n4个粘土收集机器人收集4个粘土；你现在有41块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有8颗黑曜石。\n2个紫晶机器人收集2个紫晶；你现在有9个紫晶。","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"蓝图2最多获得12个紫晶。","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"对于以下蓝图，分别能获得的最多紫晶是多少？","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"Blueprint 1: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 17 clay. Each geode robot costs 4 ore and 20 obsidian.\nBlueprint 2: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 3 ore and 17 clay. Each geode robot costs 3 ore and 8 obsidian.\nBlueprint 3: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 7 clay. Each geode robot costs 4 ore and 13 obsidian.\nBlueprint 4: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 10 clay. Each geode robot costs 3 ore and 14 obsidian.\nBlueprint 5: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 17 clay. Each geode robot costs 3 ore and 16 obsidian.\nBlueprint 6: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 16 clay. Each geode robot costs 2 ore and 15 obsidian.\nBlueprint 7: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 15 clay. Each geode robot costs 2 ore and 15 obsidian.\nBlueprint 8: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 19 clay. Each geode robot costs 2 ore and 18 obsidian.\nBlueprint 9: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 7 clay. Each geode robot costs 2 ore and 19 obsidian.\nBlueprint 10: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 6 clay. Each geode robot costs 3 ore and 16 obsidian.\nBlueprint 11: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 8 clay. Each geode robot costs 3 ore and 19 obsidian.\nBlueprint 12: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 19 clay. Each geode robot costs 2 ore and 12 obsidian.\nBlueprint 13: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 14 clay. Each geode robot costs 4 ore and 17 obsidian.\nBlueprint 14: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 2 ore and 14 obsidian.\nBlueprint 15: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 10 clay. Each geode robot costs 2 ore and 11 obsidian.\nBlueprint 16: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 13 clay. Each geode robot costs 3 ore and 11 obsidian.\nBlueprint 17: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 19 clay. Each geode robot costs 3 ore and 10 obsidian.\nBlueprint 18: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 2 ore and 17 obsidian.\nBlueprint 19: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 11 clay. Each geode robot costs 4 ore and 12 obsidian.\nBlueprint 20: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 7 clay. Each geode robot costs 3 ore and 10 obsidian.\nBlueprint 21: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 13 clay. Each geode robot costs 3 ore and 7 obsidian.\nBlueprint 22: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 15 clay. Each geode robot costs 2 ore and 7 obsidian.\nBlueprint 23: Each ore robot costs 3 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 3 ore and 18 obsidian.\nBlueprint 24: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 18 clay. Each geode robot costs 4 ore and 8 obsidian.\nBlueprint 25: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 3 ore and 14 clay. Each geode robot costs 4 ore and 15 obsidian.\nBlueprint 26: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 3 ore and 9 obsidian.\nBlueprint 27: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 5 clay. Each geode robot costs 3 ore and 7 obsidian.\nBlueprint 28: Each ore robot costs 3 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 11 clay. Each geode robot costs 2 ore and 8 obsidian.\nBlueprint 29: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 12 clay. Each geode robot costs 3 ore and 15 obsidian.\nBlueprint 30: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 10 clay. Each geode robot costs 3 ore and 10 obsidian.","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/#优化问题的数学表达","page":"JuMP混合整数线性优化实例","title":"优化问题的数学表达","text":"","category":"section"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"因为涉及到时间域上的状态改变（本质就是离散），所以需要在求解时间域上的每个时间点上设置一个变量。同时，每个不同种类的矿石也需要设置变量。","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"变量设置：","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"每个种类每个时间点矿石数量，整数\n每个种类每个时间点机器人数量，整数\n每个种类每个时间点是否建造，0或1","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"所以有：","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"\nrobots_ij  in N\nisBuild_ij in 01\nobtains_ij in N\ni in ore clay obsidian geode\nj in 1232324\n","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"优化目标为第24分钟，紫晶最多：","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"\nmax obtains_geode24 \n","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"约束：","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"矿石量等于上一周期的矿石量加上本周期的产出减去本周期的消耗。","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"note: Note\ncosts的每一行是建造不同种机器人消耗的材料个数。costs =  beginbmatrix4 3 2 3  0 0 17 0  0 0 0 16  0 0 0 0endbmatrix例如，第一行为建造4中不同的机器人，分别要消耗4，3，2，3个ore；第二行为建造4中不同的机器人,分别要消耗0，0，17，0个clay：","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"obtains_ij = obtains_ij-1+robots_ij - sum_k^ costs_ik * isBulid_kj","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"上一个周期结束，矿石足够才能在本周期建造机器人","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"obtains_ij-1 geqslant sum_k^ costs_ik * isBulid_kj","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"建造机器人，数量增加","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"robots_ij =  robots_ij-1  + isBulid_ij-1","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"一次只能建造一个机器人","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"sum_k^ isBulid_kj leqslant 1","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"初值条件，没有材料且只有一台矿石机器人：","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"isBulid_i1 = 0 i in ore clay obsidian geode\nobtain_i1 = 0 i in  clay obsidian geode\nrobots_i1 = 0 i in  clay obsidian geode\nobtain_ore1 = 1 \nrobots_ore1 = 1 ","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/#JuMP求解代码","page":"JuMP混合整数线性优化实例","title":"JuMP求解代码","text":"","category":"section"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"using JuMP\nimport HiGHS\n\ninputs = \"\"\"Blueprint 1: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 17 clay. Each geode robot costs 4 ore and 20 obsidian.\nBlueprint 2: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 3 ore and 17 clay. Each geode robot costs 3 ore and 8 obsidian.\nBlueprint 3: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 7 clay. Each geode robot costs 4 ore and 13 obsidian.\nBlueprint 4: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 10 clay. Each geode robot costs 3 ore and 14 obsidian.\nBlueprint 5: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 17 clay. Each geode robot costs 3 ore and 16 obsidian.\nBlueprint 6: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 16 clay. Each geode robot costs 2 ore and 15 obsidian.\nBlueprint 7: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 15 clay. Each geode robot costs 2 ore and 15 obsidian.\nBlueprint 8: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 19 clay. Each geode robot costs 2 ore and 18 obsidian.\nBlueprint 9: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 7 clay. Each geode robot costs 2 ore and 19 obsidian.\nBlueprint 10: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 6 clay. Each geode robot costs 3 ore and 16 obsidian.\nBlueprint 11: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 8 clay. Each geode robot costs 3 ore and 19 obsidian.\nBlueprint 12: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 19 clay. Each geode robot costs 2 ore and 12 obsidian.\nBlueprint 13: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 14 clay. Each geode robot costs 4 ore and 17 obsidian.\nBlueprint 14: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 2 ore and 14 obsidian.\nBlueprint 15: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 10 clay. Each geode robot costs 2 ore and 11 obsidian.\nBlueprint 16: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 13 clay. Each geode robot costs 3 ore and 11 obsidian.\nBlueprint 17: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 19 clay. Each geode robot costs 3 ore and 10 obsidian.\nBlueprint 18: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 2 ore and 17 obsidian.\nBlueprint 19: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 11 clay. Each geode robot costs 4 ore and 12 obsidian.\nBlueprint 20: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 7 clay. Each geode robot costs 3 ore and 10 obsidian.\nBlueprint 21: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 13 clay. Each geode robot costs 3 ore and 7 obsidian.\nBlueprint 22: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 15 clay. Each geode robot costs 2 ore and 7 obsidian.\nBlueprint 23: Each ore robot costs 3 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 3 ore and 18 obsidian.\nBlueprint 24: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 18 clay. Each geode robot costs 4 ore and 8 obsidian.\nBlueprint 25: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 3 ore and 14 clay. Each geode robot costs 4 ore and 15 obsidian.\nBlueprint 26: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 3 ore and 9 obsidian.\nBlueprint 27: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 5 clay. Each geode robot costs 3 ore and 7 obsidian.\nBlueprint 28: Each ore robot costs 3 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 11 clay. Each geode robot costs 2 ore and 8 obsidian.\nBlueprint 29: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 12 clay. Each geode robot costs 3 ore and 15 obsidian.\nBlueprint 30: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 10 clay. Each geode robot costs 3 ore and 10 obsidian.\n\"\"\"\n\ninputs = IOBuffer(inputs)\n\nfunction readData(path=inputs)\n    rawData = readlines(path)\n    rawData = split.(rawData, c -> c == '.' || c == ':')\n    regs = [\n        r\"Blueprint (\\d+)\",\n        r\"costs (\\d+) ore\",\n        r\"costs (\\d+) ore\",\n        r\"costs (\\d+) ore and (\\d+) clay\",\n        r\"costs (\\d+) ore and (\\d+) obsidian\",\n    ]\n    d = Dict{Int,Vector{Vector{Int64}}}()\n    for line in rawData |> eachindex\n        c = map(x -> zeros(Int64, 4), 1:4)\n        r = Vector{Int64}[]\n        for i in 1:5\n            m = match(regs[i], rawData[line][i]).captures\n            m = map(x -> parse(Int64, x), m)\n            push!(r, m)\n        end\n        c[1][1] = r[2][1]\n        c[1][2] = r[3][1]\n        c[1][3] = r[4][1]\n        c[1][4] = r[5][1]\n        c[2][3] = r[4][2]\n        c[3][4] = r[5][2]\n        d[r[1][1]] = c\n    end\n    return d\nend\n\n\nfunction solve_1(costs, periods)\n    model = Model(HiGHS.Optimizer)\n    set_silent(model)\n    names = [\"ore\", \"clay\", \"obsidian\", \"geode\"]\n    # robots为每个机器人的数量，obtains为每个机器人每个周期的产出，isBuild为每个机器人每个周期是否建造\n    @variable(model, robots[names, periods], Int)\n    @variable(model, obtains[names, periods], Int)\n    @variable(model, isBuild[names, periods], Bin)\n    # 矿石量等于上一周期的矿石量加上本周期的产出减去本周期的消耗\n    for (p1, p2) ∈ zip(periods[1:end-1], periods[2:end])\n        @constraint(model, [ind = 1:4], obtains[names[ind], p2] == obtains[names[ind], p1] + robots[names[ind], p2] - sum(costs[ind] .* isBuild[:, p2]))\n    end\n    # 矿石足够才能建造机器人\n    for (p1, p2) ∈ zip(periods[1:end-1], periods[2:end])\n        @constraint(model, [ind = 1:4], obtains[names[ind], p1] >= sum(costs[ind] .* isBuild[:, p2]))\n    end\n    # 建造机器人\n    for (p1, p2) ∈ zip(periods[1:end-1], periods[2:end])\n        @constraint(model, [ind = 1:4], robots[names[ind], p2] == robots[names[ind], p1] + isBuild[names[ind], p1])\n    end\n    # 一次只能建造一个机器人\n    @constraint(model, [i = periods], sum(isBuild[:, i]) <= 1)\n    # 初始条件\n    @constraint(model, [ind = 2:4], robots[names[ind], 1] == 0)\n    @constraint(model, [ind = 1:1], robots[names[ind], 1] == 1)\n    @constraint(model, [ind = 2:4], obtains[names[ind], 1] == 0)\n    @constraint(model, [ind = 1:1], obtains[names[ind], 1] == 1)\n    @constraint(model, [ind = 1:4], isBuild[names[ind], 1] == 0)\n    # 目标函数\n    @objective(model, Max, obtains[\"geode\", lastindex(periods)])\n    optimize!(model)\n    return objective_value(model) |> Int\nend\n\nfunction solve_P1()\n    d = readData()\n    s = String[]\n    for (i, c) in d\n        res = solve_1(c, 1:24)\n        push!(s,\"第$(i)个结果:\"*string(res))\n    end\n    return s\nend\n\nsolve_P1()","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/#小结","page":"JuMP混合整数线性优化实例","title":"小结","text":"","category":"section"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"这个问题重要的特点为：","category":"page"},{"location":"Optimization/93-JuMP混合整数线性优化实例/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"存在时域上的状态转移（能源系统中负荷的变化等等），以及如何用变量之间的关联体现状态转移的关系\n包含整数与布尔变量（设备启停、满足最小需求的设备数量等等）","category":"page"},{"location":"Optimization/90-优化应用之参数估计与软测量/#优化应用之参数估计与软测量","page":"优化应用之参数估计与软测量","title":"优化应用之参数估计与软测量","text":"","category":"section"},{"location":"Optimization/90-优化应用之参数估计与软测量/#参数估计","page":"优化应用之参数估计与软测量","title":"参数估计","text":"","category":"section"},{"location":"Optimization/90-优化应用之参数估计与软测量/","page":"优化应用之参数估计与软测量","title":"优化应用之参数估计与软测量","text":"参数估计是最优化在实际应用中的重要领域之一。在参数估计中，我们尝试通过调整模型的参数值，使得模型计算的值与观测到的测量值之间的差异最小化。","category":"page"},{"location":"Optimization/90-优化应用之参数估计与软测量/","page":"优化应用之参数估计与软测量","title":"优化应用之参数估计与软测量","text":"这个过程可以用最优化方法来实现。最优化方法旨在找到使得某个目标函数取得最小值或最大值的参数值。在参数估计中，我们通常使用最小化目标函数来寻找使模型计算值与测量值最接近的参数。","category":"page"},{"location":"Optimization/90-优化应用之参数估计与软测量/","page":"优化应用之参数估计与软测量","title":"优化应用之参数估计与软测量","text":"常见的最优化方法包括梯度下降法、牛顿法、拟牛顿法等。这些方法根据目标函数的性质和约束条件来决定参数更新的方向和步长。通过迭代优化过程，这些方法可以逐步接近最优参数值，使得模型计算值和测量值之间的差异减小。","category":"page"},{"location":"Optimization/90-优化应用之参数估计与软测量/","page":"优化应用之参数估计与软测量","title":"优化应用之参数估计与软测量","text":"在参数估计中，还需要考虑模型的合理性和假设的准确性。选择合适的目标函数和优化方法是非常关键的，以确保参数估计结果的可靠性和准确性。","category":"page"},{"location":"Optimization/90-优化应用之参数估计与软测量/","page":"优化应用之参数估计与软测量","title":"优化应用之参数估计与软测量","text":"总而言之，最优化在参数估计中扮演着重要的角色，通过调整模型的参数，使得模型计算的值与测量值最接近，从而确定模型的参数。这种方法在许多领域中都得到了广泛应用，包括机器学习、统计建模、工程优化等。","category":"page"},{"location":"Optimization/90-优化应用之参数估计与软测量/","page":"优化应用之参数估计与软测量","title":"优化应用之参数估计与软测量","text":"当涉及参数估计时，一个常见的例子是线性回归模型。线性回归模型用于建立自变量（输入变量）和因变量（输出变量）之间的线性关系。","category":"page"},{"location":"Optimization/90-优化应用之参数估计与软测量/","page":"优化应用之参数估计与软测量","title":"优化应用之参数估计与软测量","text":"假设我们有一组观测数据，包括自变量和因变量的取值。我们希望通过线性回归模型来估计自变量与因变量之间的关系，并找到最优的模型参数。","category":"page"},{"location":"Optimization/90-优化应用之参数估计与软测量/","page":"优化应用之参数估计与软测量","title":"优化应用之参数估计与软测量","text":"首先，我们需要选择一个合适的线性回归模型形式，比如简单的一元线性回归模型：y = beta_0 + beta_1x。其中，y是因变量，x是自变量，beta_0和beta_1是模型的参数，表示截距和斜率。","category":"page"},{"location":"Optimization/90-优化应用之参数估计与软测量/","page":"优化应用之参数估计与软测量","title":"优化应用之参数估计与软测量","text":"接下来，我们需要定义一个目标函数，例如平方误差目标函数。该目标函数衡量了模型计算值与观测值之间的差异，可以表示为：J(beta_0 beta_1) = sum_i=1^n(y_i - (beta_0 + beta_1x_i))^2。其中，n是观测数据的数量，y_i和x_i分别是第i个观测数据的因变量和自变量取值。","category":"page"},{"location":"Optimization/90-优化应用之参数估计与软测量/","page":"优化应用之参数估计与软测量","title":"优化应用之参数估计与软测量","text":"然后，我们可以使用最优化方法来最小化目标函数，以找到最优的参数估计值。常见的最优化方法之一是梯度下降法。该方法通过计算目标函数关于参数的梯度，确定参数更新的方向和步长，以逐步接近最优解。","category":"page"},{"location":"Optimization/90-优化应用之参数估计与软测量/","page":"优化应用之参数估计与软测量","title":"优化应用之参数估计与软测量","text":"通过迭代优化过程，梯度下降法可以更新参数值，使得目标函数逐渐减小，直到达到收敛条件或达到最大迭代次数。","category":"page"},{"location":"Optimization/90-优化应用之参数估计与软测量/","page":"优化应用之参数估计与软测量","title":"优化应用之参数估计与软测量","text":"最终，得到的参数估计值即为使得模型计算值与观测值最接近的参数值。在线性回归模型中，最优的参数估计值表示了自变量和因变量之间的最佳线性关系。","category":"page"},{"location":"Optimization/90-优化应用之参数估计与软测量/","page":"优化应用之参数估计与软测量","title":"优化应用之参数估计与软测量","text":"这只是一个简单的例子，参数估计在实际应用中可以非常复杂，并涉及到更多的模型和目标函数选择。不同的参数估计问题可能需要不同的最优化方法和技术来解决，具体的选择取决于具体情况和应用领域。","category":"page"},{"location":"Optimization/90-优化应用之参数估计与软测量/#软测量","page":"优化应用之参数估计与软测量","title":"软测量","text":"","category":"section"},{"location":"Optimization/90-优化应用之参数估计与软测量/","page":"优化应用之参数估计与软测量","title":"优化应用之参数估计与软测量","text":"软测量（Soft Sensing）是指使用数学建模和计算机技术，基于已有过程变量数据，推断或预测无法直接测量或不易测量的过程变量的技术。","category":"page"},{"location":"Optimization/90-优化应用之参数估计与软测量/","page":"优化应用之参数估计与软测量","title":"优化应用之参数估计与软测量","text":"在许多工业过程中，有些关键的过程变量很难通过传感器直接测量，或者由于成本、技术限制或其他原因而不容易实现实时测量。这时，软测量技术就发挥了作用。","category":"page"},{"location":"Optimization/90-优化应用之参数估计与软测量/","page":"优化应用之参数估计与软测量","title":"优化应用之参数估计与软测量","text":"软测量技术利用已有的过程变量数据和数学建模方法，通过建立合适的模型和算法，推断或预测目标变量的数值。这些模型可以基于统计分析、机器学习、模型辨识等方法构建，以尽可能准确地估计无法直接测量的变量。","category":"page"},{"location":"Optimization/90-优化应用之参数估计与软测量/","page":"优化应用之参数估计与软测量","title":"优化应用之参数估计与软测量","text":"软测量在工业过程控制和优化中具有重要作用。它可以帮助监测和控制无法直接测量的关键变量，实现过程的实时监测和优化。软测量还可以用于故障诊断、异常检测和预测，以及产品质量控制等应用领域。","category":"page"},{"location":"Optimization/90-优化应用之参数估计与软测量/","page":"优化应用之参数估计与软测量","title":"优化应用之参数估计与软测量","text":"通过软测量技术，工业过程中的关键变量可以通过间接手段进行估计和预测，从而提高生产过程的可靠性、稳定性和效率。","category":"page"},{"location":"Optimization/90-优化应用之参数估计与软测量/","page":"优化应用之参数估计与软测量","title":"优化应用之参数估计与软测量","text":"需要指出的是，软测量的精度和可靠性取决于模型的建立和算法的选择，以及所使用的数据的质量和实时性。因此，在应用软测量技术时，需要仔细选择合适的方法，并进行充分的模型验证和优化，以确保软测量结果的准确性和可靠性。","category":"page"},{"location":"Optimization/90-优化应用之参数估计与软测量/","page":"优化应用之参数估计与软测量","title":"优化应用之参数估计与软测量","text":"可以将软测量视为一种应用参数估计的技术，用于获取对系统参数的认识。在软测量中，我们尝试通过已知的过程变量数据和模型来估计或推断无法直接测量的目标变量的数值。","category":"page"},{"location":"Optimization/90-优化应用之参数估计与软测量/","page":"优化应用之参数估计与软测量","title":"优化应用之参数估计与软测量","text":"为了实现软测量，我们需要建立适当的数学模型，其中包括描述过程变量和目标变量之间关系的参数。然后，我们使用参数估计的方法，根据已有的过程变量数据，通过最小化目标函数或其他优化准则来估计这些参数的值。","category":"page"},{"location":"Optimization/90-优化应用之参数估计与软测量/","page":"优化应用之参数估计与软测量","title":"优化应用之参数估计与软测量","text":"通过参数估计，我们可以获得对系统参数的认识，从而能够推断或预测无法直接测量的目标变量。这种推断或预测过程可以应用于过程控制、质量监测、故障诊断等应用中，以提高系统的效率、稳定性和可靠性。","category":"page"},{"location":"Optimization/90-优化应用之参数估计与软测量/","page":"优化应用之参数估计与软测量","title":"优化应用之参数估计与软测量","text":"需要注意的是，在软测量中，参数估计通常不仅仅涉及模型的参数，还可能涉及数据处理中的一些参数，例如滤波器的截止频率、特征提取的参数等。这些参数的估计同样是软测量中的关键步骤，用于优化数据处理过程，提高软测量结果的准确性和可靠性。","category":"page"},{"location":"Optimization/90-优化应用之参数估计与软测量/","page":"优化应用之参数估计与软测量","title":"优化应用之参数估计与软测量","text":"因此，软测量可以被看作是在参数估计的基础上，通过模型和算法的建立和优化，实现对系统参数的认识，并推断无法直接测量的目标变量。这种方法在工业过程中具有广泛的应用和重要的意义。","category":"page"},{"location":"EMS/1-能源管理信息系统/#能源管理信息系统","page":"能源管理信息系统","title":"能源管理信息系统","text":"","category":"section"},{"location":"EMS/1-能源管理信息系统/","page":"能源管理信息系统","title":"能源管理信息系统","text":"物联网 微服务 edgex mainflux 云计算 鉴权 大数据 前后端分离","category":"page"},{"location":"Optimization/96-MTK非线性参数辨识实例/#MTK非线性参数辨识实例","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"","category":"section"},{"location":"Optimization/96-MTK非线性参数辨识实例/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"tip: Tip\nContents：参数辨识、优化、MTKContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Optimization/96-MTK非线性参数辨识实例/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"note: Note\nMTK = ModelingToolkit.jlNLP = NonlinearnProblem，非线性问题OptimizationSystem为MTK中的系统类型之一","category":"page"},{"location":"Optimization/96-MTK非线性参数辨识实例/#参数辨识概念","page":"MTK非线性参数辨识实例","title":"参数辨识概念","text":"","category":"section"},{"location":"Optimization/96-MTK非线性参数辨识实例/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"系统中的参数作为优化变量，找到一组参数，使得通过模型计算结果与实际值误差最小，实际值一般为一系列数值。参数辨识本质为回归问题。数学表达如下：","category":"page"},{"location":"Optimization/96-MTK非线性参数辨识实例/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"y = f(ab)\nmin (y_real - y)^2","category":"page"},{"location":"Optimization/96-MTK非线性参数辨识实例/#实例","page":"MTK非线性参数辨识实例","title":"实例","text":"","category":"section"},{"location":"Optimization/96-MTK非线性参数辨识实例/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"考虑下面的模型：","category":"page"},{"location":"Optimization/96-MTK非线性参数辨识实例/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"y = ax^2+sin(bx)a=15b=08","category":"page"},{"location":"Optimization/96-MTK非线性参数辨识实例/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"采用生成数据的方法构造真实的数据y_real。 方法为通过模型计算出准确值并加上随机误差。","category":"page"},{"location":"Optimization/96-MTK非线性参数辨识实例/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"##### 生成真实数据 ####\nx = collect(-1:0.01:1)\nN = length(x)\n# 产生随机误差，范围在-0.1~0.1之间\nrands = rand(-0.1:0.01:0.1, N)\na1 = 1.5\na2 = 0.8\n# 计算y值\ny = @. a1 * x^2 + sin(a2 * x) + rands\n","category":"page"},{"location":"Optimization/96-MTK非线性参数辨识实例/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"因为测试数据集y_real本身即来自模型，同时添加的扰动范围不大，可以认为数据集的内涵就是模型y = ax^2+sin(bx) 接下来构建问题并且求解：","category":"page"},{"location":"Optimization/96-MTK非线性参数辨识实例/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"# 计算损失Loss\n@variables para[1:2]\nerrors = @. (para[1] * x^2 + sin(para[2] * x) - y)^2\n\n# 计算方差和，采用均方差亦可\nLoss = sum(errors)\n\n# 构建问题并求解\n@named sys = OptimizationSystem(Loss, [para[i] for i in 1:2], [])\na0 = [0.1,0.1]\nprob = OptimizationProblem(sys, a0, [], grad=true, hess=true, reltol=1e-8, abstol=1e-8)\ns = solve(prob, Optim.Newton())","category":"page"},{"location":"Optimization/96-MTK非线性参数辨识实例/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"最后的结果为:","category":"page"},{"location":"Optimization/96-MTK非线性参数辨识实例/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"u: 2-element Vector{Float64}:\n 1.502064883762093\n 0.7908724806965902","category":"page"},{"location":"Optimization/96-MTK非线性参数辨识实例/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"和我们的真实值a=15b=08比较接近。 优化成功！","category":"page"},{"location":"Optimization/96-MTK非线性参数辨识实例/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"tip: Tip\n影响优化效果的因素有初值\n生成扰动大小可以尝试修改它们并查看求解效果。","category":"page"},{"location":"Optimization/96-MTK非线性参数辨识实例/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"全部代码：","category":"page"},{"location":"Optimization/96-MTK非线性参数辨识实例/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"using ModelingToolkit, OptimizationOptimJL\n\nLoss = 0.0\n#number of samples\nypre = 0\n#y-predict\nx = collect(-1:0.01:1)\nN = length(x)\nrands = rand(-0.1:0.01:0.1, N)\na1 = 1.5\na2 = 0.8\ny = @. a1 * x^2 + sin(a2 * x) + rands\n\n\n@variables para[1:2]\nerrors = @. (para[1] * x^2 + sin(para[2] * x) - y)^2\nLoss = sum(errors)\n\n#Opt\n@named sys = OptimizationSystem(Loss, [para[i] for i in 1:2], [])\na0 = [0.1, 0.1]\nprob = OptimizationProblem(sys, a0, [], grad=true, hess=true, reltol=1e-8, abstol=1e-8)\ns = solve(prob, Optim.Newton())","category":"page"},{"location":"Tools/CoolProp/#CoolProp使用介绍","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"","category":"section"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"tip: Tip\nContents：CoolPropContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"note: Note\nCoolProp为开源物性包。 Unitful.jl为计算单位的包","category":"page"},{"location":"Tools/CoolProp/#CoolProp是什么","page":"CoolProp使用介绍","title":"CoolProp是什么","text":"","category":"section"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"这是一个开源的调用物性包，通过几行代码就可以很容易的调用流体的物性，对于需要进行工程计算的小伙伴很有帮助！因为使用这个包之后，就可以可以省去大量查表的麻烦！","category":"page"},{"location":"Tools/CoolProp/#Python使用CoolProp","page":"CoolProp使用介绍","title":"Python使用CoolProp","text":"","category":"section"},{"location":"Tools/CoolProp/#.CoolProp安装","page":"CoolProp使用介绍","title":"1.CoolProp安装","text":"","category":"section"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"打开cmd命令行，输入","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"pip install CoolProp","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"即可安装完成 (Image: 图1)","category":"page"},{"location":"Tools/CoolProp/#.-使用示例","page":"CoolProp使用介绍","title":"2. 使用示例","text":"","category":"section"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"import CoolProp.CoolProp as CP\n\na = CP.PropsSI('H','P',1.0E6,'T',500,'Water')\n\n#H代表输出的需要查找的参数，H为焓\n#P为压强，T为温度，第二个和第四个参数就是状态\n#这个例子就是查询1MPa气压与500K的温度下，水蒸气的焓（如果是液体的话就是液体性质）\n\nprint(a)\n","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"查询时，输入任意两个参数，就能够查询第三个参数。 具体的属性为可以看下表","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"状态量 参数名称 单位\n比焓 H J/kg\n比熵 S J/mol/K\n压强 P Pa\n温度 T K\n密度 D kg/m^3","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"更多参数，可以查看官网文档。","category":"page"},{"location":"Tools/CoolProp/#Julia使用Coolprop","page":"CoolProp使用介绍","title":"Julia使用Coolprop","text":"","category":"section"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"在2022的2月，Coolprop完成了Julia包的更新。可以直接在Julia中调用，而不需要通过python了！","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"using Pkg\nPkg.add(\"CoolProp\")\n\nusing CoolProp\nPropsSI(\"T\", \"P\", 101325.0, \"Q\", 0.0, \"Water\")\n373.1242958476844","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"在Julia中支持单位处理包——Unitful","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"using CoolProp\nusing Unitful: °C, Pa\n\nPropsSI(\"P\", \"T\", 100°C, \"Q\", 0.0, \"Water\")\n101417.99665788244 Pa","category":"page"},{"location":"JuliaIntro/8-julia的元编程/#julia的元编程","page":"julia的元编程","title":"julia的元编程","text":"","category":"section"},{"location":"JuliaIntro/8-julia的元编程/#简介","page":"julia的元编程","title":"简介","text":"","category":"section"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"Julia的元编程是其强大功能之一，它允许您在运行时操作和生成代码，以实现自动化、抽象化和灵活性。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"元编程是一种编程技术，它涉及编写能够生成或操作代码的代码。在Julia中，您可以使用元编程来动态创建函数、修改函数的行为、生成优化的代码等。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"以下是一些常见的元编程技术和功能：","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"宏（Macros）： Julia的宏是一种元编程的工具，允许您编写代码来自动展开和转换。通过定义宏，您可以在编译时生成代码，以根据特定的模式或规则转换代码。宏可以帮助您消除重复的代码、增加语言的表达能力，并在一些特定场景下提高性能。\n元类型（Metaprogramming）： 元类型是一种在Julia中操作和查询类型信息的能力。您可以使用元类型来检查和访问类型的属性、函数、字段等。这种能力使您能够在运行时编程，根据类型信息来生成和操作代码。\n表达式操作（Expression Manipulation）： Julia的表达式是一种数据结构，可以表示代码片段。您可以使用表达式操作技术来分析、修改和生成代码。通过操作表达式，您可以创建函数、修改函数体、生成代码片段等。\n代码生成（Code Generation）： 元编程允许您动态生成代码，以便在运行时执行。您可以生成优化的代码，根据特定的参数或条件来生成不同的代码路径，从而提高性能和灵活性。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"通过元编程，您可以根据特定的需求和场景来扩展和定制Julia的行为。它使您能够以更高级别的抽象来编写代码，减少冗余，提高代码的可维护性和可扩展性。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"虽然元编程是一个强大的工具，但也需要谨慎使用，因为复杂的元编程技术可能会增加代码的复杂性和难以理解。因此，建议在需要时使用元编程，并确保代码的可读性和可维护性。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/#Meta.Parse的例子","page":"julia的元编程","title":"Meta.Parse的例子","text":"","category":"section"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"当使用 Julia 的元编程时，可以使用 meta.parse 函数将字符串解析为 Julia 表达式。这样，您可以动态地创建和操作代码。下面是一个示例：","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"# 导入 meta.parse 函数\nusing Meta\n\n# 定义一个字符串表示的 Julia 代码\ncode_str = \"2 + 3\"\n\n# 使用 meta.parse 解析字符串为表达式\ncode_expr = Meta.parse(code_str)\n\n# 打印解析后的表达式\nprintln(code_expr)\n\n# 求值表达式\nresult = eval(code_expr)\n\n# 打印结果\nprintln(result)","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"在这个例子中，我们使用 meta.parse 函数将字符串 \"2 + 3\" 解析为一个 Julia 表达式，并将其赋值给变量 code_expr。然后，我们使用 eval 函数对表达式进行求值，并将结果打印出来。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"运行上述代码，输出如下：","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"2 + 3\n5","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"您可以根据需要动态地生成代码字符串，并使用 meta.parse 解析它们为表达式。这使得您能够以编程的方式生成和执行代码，从而实现更高级别的抽象和自动化。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"请注意，在使用 meta.parse 解析字符串时，请确保字符串中的代码是可信的，以避免潜在的安全风险。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/#Meta.show_sexpr例子","page":"julia的元编程","title":"Meta.show_sexpr例子","text":"","category":"section"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"在 Julia 中，可以使用 Meta.show_sexpr 函数来显示表达式的抽象语法树（Abstract Syntax Tree，AST）。这对于调试和了解代码的结构非常有用。下面是一个示例：","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"# 导入 Meta.show_sexpr 函数\nusing Meta\n\n# 定义一个 Julia 表达式\nexpr = :(2 + 3)\n\n# 使用 Meta.show_sexpr 显示表达式的抽象语法树\nMeta.show_sexpr(expr)","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"在这个示例中，我们使用 Meta.show_sexpr 函数来显示表达式 2 + 3 的抽象语法树。表达式被表示为 :(2 + 3)，它是一个具体的语法结构。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"运行上述代码，输出如下：","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"(:call, :+, 2, 3)","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"输出的结果是一个元组，其中第一个元素 :call 表示函数调用，第二个元素 :+ 表示加法运算符，后面的 2 和 3 是加法的操作数。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"Meta.show_sexpr 函数可以帮助您深入了解代码的结构和组织方式，特别是当您使用元编程和宏时，可以更好地理解代码的转换和展开过程。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/#宏","page":"julia的元编程","title":"宏","text":"","category":"section"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"宏（Macros）是 Julia 中强大的元编程工具，它允许您以编程的方式生成和转换代码。通过定义宏，您可以在编译时操作表达式，并在代码展开阶段对其进行转换。下面是一个简单的宏的例子：","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"# 定义一个简单的宏，将输入的表达式展示出来\nmacro show_expr(expr)\n    println(\"Expression: \", expr)\n    return esc(expr)\nend\n\n# 使用宏\n@show_expr 2 + 3","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"在上面的例子中，我们定义了一个名为 show_expr 的宏。它接受一个表达式作为输入，并将该表达式打印出来。然后，宏返回输入的表达式本身。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"最后，我们使用 @show_expr 宏来展示表达式 2 + 3。宏展开后，会首先打印出 \"Expression: 2 + 3\"，然后返回表达式本身，即 2 + 3。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"运行上述代码，输出如下：","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"Expression: 2 + 3\n5","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"这个例子展示了宏的基本用法。宏可以根据输入的表达式生成自定义的代码，以实现更高级别的抽象和自动化。您可以根据需要定义更复杂的宏，执行更复杂的代码转换。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"请注意，在使用宏时，需要小心处理输入表达式，并确保生成的代码是正确和安全的。了解宏的展开机制和作用域规则非常重要，以避免潜在的错误。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/#使用宏来改变AST","page":"julia的元编程","title":"使用宏来改变AST","text":"","category":"section"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"宏在 Julia 中的一个强大之处是可以操作抽象语法树（AST）来进行代码转换。通过访问和修改 AST，您可以在编译时对代码进行更高级别的转换。下面是一个简单的示例，演示如何使用宏来操作 AST：","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"# 定义一个宏，将表达式中的加法操作替换为乘法操作\nmacro replace_add_with_mul(expr)\n    new_expr = Expr(:call, :*, expr.args...)\n    return new_expr\nend\n\n# 使用宏\n@replace_add_with_mul 2 + 3","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"在上面的例子中，我们定义了一个名为 replace_add_with_mul 的宏。宏接受一个表达式作为输入，并将该表达式中的加法操作替换为乘法操作。宏通过创建一个新的表达式对象 new_expr 来实现替换。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"然后，我们使用 @replace_add_with_mul 宏来转换表达式 2 + 3。宏展开后，将创建一个新的表达式 2 * 3。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"运行上述代码，输出如下：","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"6","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"通过宏操作 AST，我们成功将加法操作替换为乘法操作，并获得了正确的结果。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"这个例子只是展示了宏操作 AST 的基本概念。实际上，您可以编写更复杂的宏来进行更复杂的代码转换和操作。使用 Expr 类型和其他相关函数，您可以访问和修改表达式的不同部分，以实现更灵活和高级的代码转换。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"请注意，在使用宏操作 AST 时，需要小心处理表达式的结构，并确保生成的新表达式是正确的和安全的。对于复杂的代码转换，建议详细了解 Julia 的 AST 结构和相关操作。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/#AST是啥","page":"julia的元编程","title":"AST是啥","text":"","category":"section"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"AST 是抽象语法树（Abstract Syntax Tree）的缩写，是在编译器和解释器中常用的一种数据结构。它表示了程序源代码的抽象语法结构，并以树形结构的形式展现出来。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"在编程语言中，源代码是由一系列语法规则组成的，这些规则定义了程序语法的合法结构和语义。当我们编写代码时，编译器或解释器会将源代码转换为抽象语法树，以便进行后续的分析、优化和执行。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"抽象语法树由节点组成，每个节点代表一个语法结构，比如表达式、语句、函数定义等。节点之间通过父子关系和兄弟关系来表示语法结构之间的层次关系。树的根节点表示整个程序的结构，而叶节点表示最基本的语法单元。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"通过遍历和操作抽象语法树，编译器和解释器可以进行各种操作，例如语法分析、语义分析、代码生成、代码优化等。同时，开发者也可以通过访问和修改抽象语法树来实现自定义的代码转换和元编程。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"在 Julia 中，您可以使用 dump 函数来查看表达式的抽象语法树。下面是一个简单的示例：","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"expr = :(2 + 3)\ndump(expr)","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"运行上述代码，输出如下：","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"Expr\n  head: Symbol call\n  args: Array{Any}((3,))\n    1: Symbol +\n    2: Int64 2\n    3: Int64 3","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"这个例子展示了表达式 2 + 3 的抽象语法树。树的根节点是一个 Expr 对象，其头部是 :call，表示函数调用。args 数组中的元素分别是操作符 :+，以及两个操作数 2 和 3。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"通过理解抽象语法树的结构和节点的含义，您可以更好地理解代码的组织方式，以及在元编程中操作和转换代码的能力。","category":"page"},{"location":"WorkFlow/REPL-of-Julia/#julia-的-REPL","page":"julia 的 REPL","title":"julia 的 REPL","text":"","category":"section"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"命令 julia 为我们提供了一个简易但足够强大的编程环境。这就是 REPL 环境。REPL就是Read-Eval-Print Loop，就是“读取-求值-输出-循环”，也就是julia跟我们打交道的交互式对话界面。我们启动julia后，面对的就是julia的REPL。像Python、Ruby这类现代的动态编程语言大都具备REPL环境。","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"Julia 的 REPL 环境非常有用，尤其是在我们进行试验性编程的时候。我们可以在其中试着执行一些代码片段，并在确认无误之后把这些片段在源码文件中组装起来，形成真正的程序。因此，REPL 环境绝对算得上一个优秀的编程学习助手。","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"在Julia的REPL中共有四种模式，分别是正常（交互）模式、package模式、help模式和shell模式。","category":"page"},{"location":"WorkFlow/REPL-of-Julia/#（1）help模式","page":"julia 的 REPL","title":"（1）help模式","text":"","category":"section"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"在Julia提示符下按“？”键进入help模式，该模式下可用来查询操作用法。","category":"page"},{"location":"WorkFlow/REPL-of-Julia/#（2）shell模式","page":"julia 的 REPL","title":"（2）shell模式","text":"","category":"section"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"在Julia提示符下按“;”键进入shell模式，可以在此模式下执行shell命令。linux下是执行shell命令，windows下则是执行对应的命令提示符下的命令。","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"因此，可以在该模式下使用如下代码，运行该文件夹下的“.jl”文件：","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"julia hello_julia.jl","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"也可以执行如下的代码显示当前目录下的文件列表：","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"pwd","category":"page"},{"location":"WorkFlow/REPL-of-Julia/#（3）package模式","page":"julia 的 REPL","title":"（3）package模式","text":"","category":"section"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"在Julia提示符下按“]”键进入package模式，在该模式下进行安装包和卸载包的操作。此模式是用来管理程序包的。比如，在该模式下输入add <程序包的名称>就可以安装某个新的程序包。又比如，输入update <程序包的名称>就可以更新某个已安装的程序包。还比如，仅输入up并回车就可以更新所有已安装的程序包。输入rm <程序包的名称>则可以删除某个程序包。","category":"page"},{"location":"WorkFlow/REPL-of-Julia/#（4）正常（交互）模式","page":"julia 的 REPL","title":"（4）正常（交互）模式","text":"","category":"section"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"在以上三种模式中，按“backspace”键回到正常模式。julia>是 Julia 的 REPL 环境下的提示符。在这种模式下，我们可以输入 Julia 语言的任何表达式，并让它帮我们计算结果。","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"在正常模式下，我们可以尝试运行一下如下代码看看系统的反应：","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"a = 5 * 8; println(a)","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"也可以使用“Pkg”这个包查看安装使用了哪些包，代码如下：","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"using Pkg\nPkg.status()","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"可以使用以下代码升级安装的库：","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"Pkg.update()","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"使用以下代码查看所在的文件路径，并且切换文件路径","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"pwd()\ncd(\"c:\\\\Users\\\\mingt\\\\Desktop\")","category":"page"},{"location":"IotBigdataCloud/2-消息件/#物联网的消息件","page":"物联网的消息件","title":"物联网的消息件","text":"","category":"section"},{"location":"IotBigdataCloud/2-消息件/#物联网的消息件简介","page":"物联网的消息件","title":"物联网的消息件简介","text":"","category":"section"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"物联网中的消息队列（Message Queue）是一种基于异步通信的机制，用于在物联网系统中传递和处理消息。它起到了解耦和异步处理的作用，将消息的发送者和接收者解耦开来，使它们可以独立进行工作。","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"以下是物联网中消息队列的一些关键特点和作用：","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"异步通信：消息队列实现了异步通信机制，发送者可以将消息发送到队列中，而不需要等待接收者的实时响应。这允许系统中的各个组件以异步的方式进行通信和处理，提高了系统的吞吐量和响应性能。\n解耦：消息队列解耦了发送者和接收者之间的直接依赖关系。发送者只需将消息发送到队列中，而不需要知道消息的接收者是谁。接收者则可以独立地从队列中获取消息并进行处理。这种解耦性使得系统的组件可以灵活地进行扩展和修改，而不会对其他组件产生影响。\n可靠性：消息队列通常提供持久化存储机制，确保即使在消息发送或接收过程中出现故障，消息仍然能够安全存储和传递。这提高了消息的可靠性和系统的稳定性。\n缓冲能力：消息队列充当了缓冲区的作用，可以平衡不同组件之间的速度差异。如果某个组件的处理速度较慢，消息可以在队列中积压，直到该组件准备好处理它们。这样可以避免消息丢失或过载的问题。\n扩展性：通过使用消息队列，系统可以更容易地进行扩展。新的组件可以通过订阅队列来接收消息，并独立处理它们。这种松耦合的设计使得系统更加灵活和可扩展。","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"常见的物联网消息队列协议包括MQTT（Message Queuing Telemetry Transport）和AMQP（Advanced Message Queuing Protocol）。这些协议提供了可靠的消息传递机制和语义，并广泛应用于物联网系统中。","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"总结起来，物联网中的消息队列是一种重要的通信机制，通过解耦、异步和可靠的消息传递，实现了系统的灵活性、扩展性和可靠性。它为物联网系统中的各个组件提供了高效的消息传递和处理能力。","category":"page"},{"location":"IotBigdataCloud/2-消息件/#常用的消息件","page":"物联网的消息件","title":"常用的消息件","text":"","category":"section"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"常用的消息件包括以下几种：","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"RabbitMQ：RabbitMQ是一个开源的消息队列软件，它实现了AMQP（Advanced Message Queuing Protocol）协议。它支持多种编程语言，并提供了可靠的消息传递、消息持久化和灵活的路由等功能。\nApache Kafka：Apache Kafka是一个分布式流处理平台和消息队列系统。它具有高吞吐量、持久性存储和水平扩展等特性。Kafka适用于大规模数据处理和实时流处理场景，提供了可靠的消息传递和持久化存储能力。\nActiveMQ：ActiveMQ是一个开源的消息队列软件，实现了JMS（Java Message Service）规范。它支持多种传输协议和消息模式，并提供了可靠的消息传递、消息持久化和事务支持等功能。\nMQTT（Message Queuing Telemetry Transport）：MQTT是一种轻量级的发布/订阅消息传递协议，特别适用于资源受限的物联网设备。它具有低开销、可靠性和简单性的特点，被广泛应用于物联网中的消息传递和实时数据处理。\nZeroMQ：ZeroMQ是一个开源的高性能消息库，支持多种消息传递模式和传输协议。它提供了简单的消息队列、消息路由和异步通信等功能，适用于构建高性能和可扩展的分布式系统。","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"这些消息件都具有不同的特点和适用场景，可以根据具体的需求选择适合的消息件来实现物联网系统中的消息传递和处理。","category":"page"},{"location":"IotBigdataCloud/2-消息件/#以mqtt为例，来一个发布主题、订阅主题、获得数据、转存数据的例子","page":"物联网的消息件","title":"以mqtt为例，来一个发布主题、订阅主题、获得数据、转存数据的例子","text":"","category":"section"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"我无法直接演示和运行实际的服务器和客户端代码。然而，我可以提供给你一个基本的示例代码，你可以在本地环境中运行它来实现你所描述的功能。","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"首先，你需要安装一个MQTT代理服务器。其中，Eclipse Mosquitto是一个流行的开源MQTT代理服务器，你可以从其官方网站（https://mosquitto.org/）下载并安装。","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"接下来，你可以使用Python语言和paho-mqtt库来编写客户端代码。以下是一个简单的示例：","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"客户端发布主题（publish.py）：","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"import paho.mqtt.publish as publish\n\n# MQTT代理服务器的地址和端口\nbroker = \"mqtt.example.com\"\nport = 1883\n\n# 发布主题和消息\ntopic = \"temperature\"\nmessage = \"25\"\n\n# 发布消息\npublish.single(topic, payload=message, hostname=broker, port=port)","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"客户端订阅主题并存储数据（subscribe.py）：","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"import paho.mqtt.client as mqtt\nimport sqlite3\n\n# MQTT代理服务器的地址和端口\nbroker = \"mqtt.example.com\"\nport = 1883\n\n# MQTT回调函数，处理接收到的消息\ndef on_message(client, userdata, message):\n    # 解析消息中的数据\n    data = message.payload.decode()\n\n    # 将数据存储到数据库中\n    store_data(data)\n\ndef store_data(data):\n    # 连接数据库\n    conn = sqlite3.connect('data.db')\n    c = conn.cursor()\n\n    # 创建数据表（如果不存在）\n    c.execute('''CREATE TABLE IF NOT EXISTS temperature\n                 (timestamp DATETIME, value REAL)''')\n\n    # 将数据插入数据库表中\n    c.execute(\"INSERT INTO temperature VALUES (datetime('now'), ?)\", (data,))\n\n    # 提交更改并关闭数据库连接\n    conn.commit()\n    conn.close()\n\n# 创建MQTT客户端\nclient = mqtt.Client()\n\n# 设置回调函数\nclient.on_message = on_message\n\n# 连接到MQTT代理服务器\nclient.connect(broker, port)\n\n# 订阅主题\nclient.subscribe(\"temperature\")\n\n# 保持MQTT客户端循环，处理消息\nclient.loop_forever()","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"在上述示例代码中，你需要将broker变量的值更改为你所使用的MQTT代理服务器的地址。在客户端发布主题的代码中，你可以将topic和message更改为你自己的主题和消息。在客户端订阅主题并存储数据的代码中，你需要将数据库连接的相关代码适配到你所使用的数据库系统。","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"请确保你已经安装了Python和paho-mqtt库，并根据需要进行适当的配置和修改。然后，你可以在命令行中分别运行publish.py和subscribe.py来模拟发布和订阅MQTT主题，并将接收到的数据存储到数据库中。","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"请注意，以上示例代码仅供参考，并未包含所有的","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"错误处理和完整的功能。在实际应用中，你需要根据自己的需求和具体情况进行适当的调整和优化。","category":"page"},{"location":"IotBigdataCloud/2-消息件/#更多的参考信息","page":"物联网的消息件","title":"更多的参考信息","text":"","category":"section"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"看完并实操过如下三个链接的内容，应该就能有所理解了。","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"MQTT系列教程1（基本概念介绍）","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"MQTT系列教程2（消息服务器EMQ的搭建和使用）","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"MQTT系列教程3（客户端工具MQTTBox的安装和使用）","category":"page"},{"location":"JuliaIntro/6-创建julia包/#创建julia包","page":"创建julia包","title":"创建julia包","text":"","category":"section"},{"location":"JuliaIntro/6-创建julia包/#来个例子","page":"创建julia包","title":"来个例子","text":"","category":"section"},{"location":"JuliaIntro/6-创建julia包/","page":"创建julia包","title":"创建julia包","text":"当您想要共享和分发自己的Julia代码时，可以创建一个Julia包。一个Julia包是一个具有特定结构和功能的项目，可以被其他人使用和引用。下面是创建一个简单的Julia包的步骤：","category":"page"},{"location":"JuliaIntro/6-创建julia包/","page":"创建julia包","title":"创建julia包","text":"创建包目录结构： 首先，创建一个新的文件夹作为您的包的根目录。您可以为该文件夹选择一个合适的名称，比如\"MyPackage\"。\n创建Manifest.toml和Project.toml文件： 在您的包的根目录中，使用以下命令来创建Manifest.toml和Project.toml文件：\nusing Pkg\nPkg.generate(\"MyPackage\")\n这将在包的根目录下生成两个文件：Manifest.toml和Project.toml。这些文件将用于管理包的依赖关系和配置。\n编辑Project.toml文件： 打开Project.toml文件并编辑它，添加包的元数据信息。您可以指定包的名称、版本号、作者等信息。例如，您可以在Project.toml文件中添加以下内容：\nname = \"MyPackage\"\nversion = \"0.1.0\"\nauthors = [\"Your Name <yourname@example.com>\"]\n您还可以根据需要添加其他信息，例如描述、许可证等。\n编写代码： 在您的包的根目录下，创建一个名为\"src\"的文件夹。在该文件夹中编写您的Julia代码。您可以创建多个模块文件以组织和管理代码。\n导入包的依赖关系： 如果您的包依赖于其他包，您可以在Project.toml文件的[deps]部分中添加这些依赖关系。例如，如果您的包依赖于名为\"Example\"的包，您可以添加以下行：\n[deps]\nExample = \"...\"\n在\"...\"处，您可以指定依赖包的版本号或Git仓库的URL。\n测试您的包： 在您的包的根目录中，创建一个名为\"test\"的文件夹。在该文件夹中编写测试代码，以确保您的包的功能正常。\n注册包： 如果您打算将包发布到Julia软件包注册表，您需要在https://github.com/JuliaRegistries/General 上提出一个请求。详细的步骤可以在该页面上找到。","category":"page"},{"location":"JuliaIntro/6-创建julia包/","page":"创建julia包","title":"创建julia包","text":"这些是创建一个简单的Julia包的基本步骤。完成上述步骤后，您就可以在其他Julia项目中使用和引用您的包了。","category":"page"},{"location":"StepByStep/07-goctl处理数据库模型/#goctl根据数据库生成model","page":"goctl根据数据库生成model","title":"goctl根据数据库生成model","text":"","category":"section"},{"location":"StepByStep/07-goctl处理数据库模型/#描述单位的数据表","page":"goctl根据数据库生成model","title":"描述单位的数据表","text":"","category":"section"},{"location":"StepByStep/07-goctl处理数据库模型/","page":"goctl根据数据库生成model","title":"goctl根据数据库生成model","text":"-- 创建 units 数据表\nCREATE TABLE units (\n    id SERIAL PRIMARY KEY,\n    symbol VARCHAR(50) UNIQUE NOT NULL,  -- 单位的符号\n    abbreviation VARCHAR(50),  -- 单位的简写\n    name VARCHAR(100),  -- 单位的全名\n    equivalent VARCHAR(100),  -- 单位的等效表达式或转换因子\n    uses_scientific_notation BOOLEAN,  -- 是否采用科学计数法\n    doc TEXT,  -- 英文文档或描述\n    doc_zh TEXT  -- 简体中文文档或描述\n);","category":"page"},{"location":"StepByStep/07-goctl处理数据库模型/#描述变量类型的数据表","page":"goctl根据数据库生成model","title":"描述变量类型的数据表","text":"","category":"section"},{"location":"StepByStep/07-goctl处理数据库模型/","page":"goctl根据数据库生成model","title":"goctl根据数据库生成model","text":"-- 创建变量类型表\nCREATE TABLE variable_types (\n    id SERIAL PRIMARY KEY,\n    symbol VARCHAR(50) UNIQUE NOT NULL,  -- 变量类型的符号\n    abbreviation VARCHAR(50),  -- 变量类型的简写\n    unit_id INTEGER REFERENCES units(id),  -- 关联的单位ID\n    min_value DOUBLE PRECISION,  -- 最小值\n    max_value DOUBLE PRECISION,  -- 最大值\n    default_value DOUBLE PRECISION,  -- 默认值\n    doc TEXT,  -- 英文文档或描述\n    doc_zh TEXT  -- 简体中文文档或描述\n);\n","category":"page"},{"location":"StepByStep/07-goctl处理数据库模型/#根据数据表生成对应的model","page":"goctl根据数据库生成model","title":"根据数据表生成对应的model","text":"","category":"section"},{"location":"StepByStep/07-goctl处理数据库模型/","page":"goctl根据数据库生成model","title":"goctl根据数据库生成model","text":"goctl model pg datasource --url=\"postgres://user:123@localhost:5432/testDB?sslmode=disable\" --table=\"*\"这个代码用来从postgresql数据生成model。","category":"page"},{"location":"Optimization/MIDACO/#MIDACO","page":"MIDACO","title":"MIDACO","text":"","category":"section"},{"location":"Optimization/MIDACO/#简介","page":"MIDACO","title":"简介","text":"","category":"section"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"MIDACO是一个用于解决数值优化问题的求解器。它可以应用于连续型（NLP）、离散/整数型（IP）和混合整数型（MINLP）问题，支持单目标和多目标（MO）优化。问题可以包含平等约束和/不平等约束，适用于具有数千个变量或数百个目标的问题。MIDACO采用无导数的进化混合算法，将问题视为黑盒，可以处理非凸性、不连续性或随机噪声等关键函数特性。对于耗时的应用程序，MIDACO提供了高效的并行化策略。该软件支持多种编程语言，包括Excel、VBA、Java、C#、Matlab、Octave、Python、R、Julia、C/C++和Fortran。","category":"page"},{"location":"Optimization/MIDACO/#特点","page":"MIDACO","title":"特点","text":"","category":"section"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"MIDACO是一个用于全局优化问题的求解器\n支持单目标和多目标优化\n支持连续型、离散/组合型和混合整数型变量\n可以处理有约束和无约束的问题\n采用进化混合算法（结合了进化算法和其他优化技术）\n基于蚁群优化（ACO）的元启发式算法\n内部混合了回溯线搜索，以实现快速局部收敛\n目标和约束可以是线性或非线性的（不要求可微性）\n黑盒求解器：目标和约束函数可以是未知的\n大规模数据处理能力\n可解决具有多达100,000个变量的问题\n可处理数千个约束和数百个目标\n并行化运算\n能够进行大规模并行化，利用数千个核心/线程（包括GPGPU）\n简洁普适的代码\n支持多种编程语言，如Excel、VBA、Java、C#、R、Matlab、Octave、Python、Julia、C/C++、Fortran等\n超轻量级（最小约200kb）\n完全自包含的源代码（无第三方依赖）\n在所有平台上编译和运行，包括Win/Mac/Unix和Web服务器\n易于使用和嵌入","category":"page"},{"location":"Optimization/MIDACO/#应用场景","page":"MIDACO","title":"应用场景","text":"","category":"section"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"以下是一些常见的使用MIDACO的情况：","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"数学建模和优化问题：MIDACO可用于解决数学建模和优化问题，如线性规划、非线性规划、整数规划、多目标优化等。它能够处理具有大规模变量和约束的问题，并提供高效的求解能力。\n工程设计和优化：MIDACO可用于工程领域中的设计和优化问题，例如结构优化、工艺优化、参数优化等。它能够帮助工程师在设计过程中找到最佳解决方案，以满足特定的性能指标或约束条件。\n仿真和模拟优化：对于黑盒函数、模拟器或复杂仿真模型，MIDACO可以通过最小化或最大化目标函数来优化参数设置。它能够在优化过程中调用模拟器，并通过评估输出结果来指导参数搜索，以获得最佳性能或结果。\n多目标和多约束问题：MIDACO可以处理具有多个目标函数和多个约束条件的问题。它能够在多个目标之间寻找平衡解，并在满足多个约束条件的情况下找到最优解。\n科学研究和实验设计：对于需要进行大量试验和参数调整的科学研究，MIDACO可以帮助自动化参数搜索过程，并加速实验设计。它能够帮助研究人员更快地找到最佳参数组合，以获得准确的结果。","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"综上所述，如果您面临复杂的优化问题，无论是数学建模、工程设计、仿真优化还是科学研究，MIDACO可能是一个有用的工具。它具有处理大规模问题、多目标和多约束问题的能力，并且适用于各种编程语言和平台，使其成为解决复杂问题的有效选择。","category":"page"},{"location":"Optimization/MIDACO/#安装与使用","page":"MIDACO","title":"安装与使用","text":"","category":"section"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"访问MIDACO的官方网站，在下载页面选择适合您的版本，并按照相应的提示进行安装。","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"下面以C++语言为例介绍MIDACO的安装与使用：","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"首先，您可以下载midaco.c文件，该文件包含了算法的实现和相关函数。您也可以复制文件的全部内容，使用记事本生成名为\"midaco.c\"的文件（注意文件后缀名为.c）。\n将下载的midaco.c文件与您的应用层面文件放置在同一个目录下。在下载页面上，您可以找到一些示例文件，例如example_NLP.cpp、example_NLPc.cpp等。\n打开命令行界面，并使用gcc编译器分别将midaco.c文件和应用层面的文件（例如example_MINLPc.c）编译为.o目标文件。\nrCopy codegcc -c example_MINLPc.c\ngcc -c midaco.c\n将生成的目标文件与数学库（libm）一起链接，生成最终的可执行文件\"run.exe\"。\narduinoCopy code\ngcc -o run example_MINLPc.o midaco.o -lm\n运行可执行文件\"run.exe\"，即可生成包含优化方案的文档\"MIDACOSCREEN.TXT\"和\"MIDACOSOLUTION.TXT\"。","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"除了在命令行中进行编译，您还可以选择在集成开发环境（IDE）中进行编译。更详细的信息请参考MIDACO的官方文档。如果您使用Fortran语言，可以采用类似的方法进行编译和使用。","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"以Julia语言为例介绍另一种使用方式：","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"首先，您可以下载midaco.jl文件和对应的动态链接库（例如64位Windows系统的midacoJL.dll）。\n将下载的midaco.jl文件、动态链接库以及您的应用层面文件（例如example_NLP.jl）放置在同一个目录下。\n运行您的应用层面文件，即可使用MIDACO求解优化问题。","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"对于Python语言，您可以采用类似的方法进行安装和使用MIDACO。","category":"page"},{"location":"Optimization/MIDACO/#代码编写格式","page":"MIDACO","title":"代码编写格式","text":"","category":"section"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"所有代码文件都包含以下几个部分：设置问题的维度、边界、起始点、停止准则和打印选项；定义问题和求解选项；调用MIDACO求解器解决问题。","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"通过执行源代码文件中的MIDACO求解器，并将结果存储在solution变量中。解包括目标值（solution[\"f\"]）、约束值（solution[\"g\"]）和变量值（solution[\"x\"]）。","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"不同编程语言的具体格式要求略有不同，请参考官方文档或提供的示例。","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"下面以Julia语言为例介绍如何使用MIDACO：","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"定义问题函数","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"function problem_function(x)\n  f = Array{Float64, 1}(undef, 1) # 初始化目标函数数组 F(X) \n  # 目标函数 F(X)\n  f[1] = (x[1] - 1)^2 + \n         (x[2] - 2)^2 + \n         (x[3] - 3)^2 + \n         (x[4] - 4)^2 + 1.23456789\n  # 约束\n  g = 0\n  return f, g\nend","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"授权","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"key = \"MIDACO_LIMITED_VERSION___[CREATIVE_COMMONS_BY-NC-ND_LICENSE]\"","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"这一行定义了一个名为key的字符串变量，并将其赋值为\"MIDACOLIMITEDVERSION___[CREATIVECOMMONSBY-NC-ND_LICENSE]\"。它是用于授权的密钥，用于限制MIDACO版本的使用。","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"定义问题和求解选项","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"problem = Dict()\noption = Dict()","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"这两行创建了两个空字典变量problem和option，用于存储问题定义和求解选项。","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"设置问题的类型","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"problem[\"o\"] = 1  # 目标函数数量 \nproblem[\"n\"] = 4  # 总变量数\nproblem[\"ni\"] = 0  # 整数变量数量（0 <= ni <= n） \nproblem[\"m\"] = 0  # 总约束条件数\nproblem[\"me\"] = 0  # 等式约束条件数量（0 <= me <= m）","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"这几行设置了问题的维度和约束条件。其中，o表示目标函数的数量（本例中为1），n表示变量的总数（本例中为4），ni表示整数变量的数量（本例中为0），m表示约束条件的数量（本例中为0），me表示等式约束条件的数量（本例中为0）。","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"定义问题的变量边界","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"problem[\"xl\"] = [1, 1, 1, 1]\nproblem[\"xu\"] = [4, 4, 4, 4]","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"这两行定义了问题的变量边界。xl表示下界，xu表示上界。在本例中，变量的下界为[1, 1, 1, 1]，上界为[4, 4, 4, 4]。","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"problem[\"x\"] = problem[\"xl\"]","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"这一行设置了问题的起始点。在本例中，起始点被设置为下界xl。","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"设置停止准则","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"option[\"maxeval\"] = 10000     # 最大函数评估次数（例如1000000） \noption[\"maxtime\"] = 60 * 60 * 24  # 最大时间限制（秒）（例如1天 = 60 * 60 * 24）","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"这两行设置了停止准则。maxeval表示最大函数评估次数，本例中设置为10000次。maxtime表示最大时间限制，本例中设置为1天。","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"设置打印选项","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"option[\"printeval\"] = 1000  # 当前最佳解的打印频率（例如1000） \noption[\"save2file\"] = 1     # 是否将结果保存到TXT文件（0=否/1=是）","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"这两行设置了打印选项。printeval表示当前最佳解的打印频率，本例中设置为每1000次评估打印一次。save2file表示是否将结果保存到TXT文件，本例中设置为保存（1）。","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"设置并行化选项","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"option[\"parallel\"] = 0  # 有关Julia的并行化，请参考MIDACO网站","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"这一行设置了并行化选项。在本例中，设置为禁用并行化（0）。","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"调用文件","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"include(\"midaco.jl\")","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"这一行通过包含midaco.jl文件将其导入到当前上下文中，以便后续调用其中的函数。","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"求解","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"solution = midaco(problem, option, key)","category":"page"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"这一行调用midaco函数，将问题定义、求解选项和密钥作为参数传递给该函数，并将返回的解存储在solution变量中。","category":"page"},{"location":"Optimization/MIDACO/#小结","page":"MIDACO","title":"小结","text":"","category":"section"},{"location":"Optimization/MIDACO/","page":"MIDACO","title":"MIDACO","text":"安装与使用过程涉及程序的编译、链接和调用链接库。与其他求解器相比，MIDACO统一规范了模型的编写格式，使用者只需根据不同优化问题的示例编写自己的代码。在MIDACO中，底层运算逻辑已经编写完成，使用者只需调用相应库并为problem、option和key进行赋值，从而实现优化问题的求解。黑盒优化中的\"黑盒\"指的是我们要研究的模型或问题，其中我们不知道其内部结构，但可以通过给定输入获取输出。MIDACO通过为模型提供输入并获取输出来进行优化。它将问题视为黑盒，其中目标函数和约束函数是未知的。","category":"page"},{"location":"IotBigdataCloud/1-物联网/#物联网","page":"物联网","title":"物联网","text":"","category":"section"},{"location":"IotBigdataCloud/1-物联网/#物联网简介","page":"物联网","title":"物联网简介","text":"","category":"section"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"物联网（Internet of Things，简称IoT）是指通过互联网连接和通信的智能设备网络。它将传感器、执行器、嵌入式系统、软件和网络服务等物理设备互相连接，并通过数据交换和互操作性实现智能化和自动化。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"物联网的核心思想是让物理世界与数字世界相互连接，使得物体能够感知环境、获取数据，并通过网络进行交流和协调。这些物联网设备可以是家用电器、智能手表、工业传感器、交通系统、农业设备等各种物体。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"通过物联网，我们能够实现许多便捷和智能化的功能。例如，在智能家居中，我们可以通过手机远程控制灯光、温度和安防系统；在智慧城市中，我们可以实时监测交通流量、优化能源利用和改善公共服务；在工业领域，物联网可以实现智能制造、远程监控和预测性维护等。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"物联网的实现依赖于多种技术，包括传感器技术、嵌入式系统、通信协议、云计算和人工智能等。同时，物联网也面临一些挑战，如安全和隐私问题、标准化和互操作性、数据管理等。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"总的来说，物联网正在改变我们的生活和工作方式，带来更智能、高效和便捷的体验。它有着广阔的应用前景，并在各个领域中发挥着越来越重要的作用。","category":"page"},{"location":"IotBigdataCloud/1-物联网/#传感器","page":"物联网","title":"传感器","text":"","category":"section"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"传感器将测量到的物理量（如温度、压力、湿度等）转换为电信号。在很多情况下，使用4-20mA的电流信号进行传输是一种常见的方式。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"电流信号的优势在于相对于电压信号，它对电线阻抗变化不敏感。由于电线本身具有一定的电阻，如果使用电压信号传输，电压信号会在电线上产生压降，从而引入误差。而电流信号传输则不会受到电线阻抗的影响，因为它不依赖于电路中的电压值。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"使用4-20mA的标准传输，其中4mA通常对应着测量物理量的最小值，20mA则对应着最大值。传输的电流大小表示了所测量物理量的相对大小。在接收端，数据采集仪或控制系统会根据事先定义好的规范来解析电流信号，并将其转换为相应的物理量数值，从而实现对所测量参数的准确解读和处理。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"因此，使用电流信号作为传输标准可以减少由于电阻变化而引起的误差，并提供可靠的数据采集和控制基础。","category":"page"},{"location":"IotBigdataCloud/1-物联网/#通讯协议","page":"物联网","title":"通讯协议","text":"","category":"section"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"物联网中使用的通信协议有多种，具体选择取决于应用场景、设备要求和通信需求。以下是一些常见的物联网通信协议：","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"Wi-Fi（无线保真）：Wi-Fi是一种广泛应用于家庭、办公场所和公共场所的无线局域网技术。它提供高速的无线数据传输和较长的通信距离，适用于需要高带宽和大量数据传输的应用。\n蓝牙（Bluetooth）：蓝牙是一种短距离无线通信技术，适用于设备之间的点对点连接。它广泛应用于消费电子产品、智能家居设备和低功耗传感器等领域。\nZigbee：Zigbee是一种低功耗无线通信协议，专为低速、低功耗的传感器和控制设备设计。它适用于物联网中的低功耗应用，例如智能家居、工业自动化和智慧城市。\nZ-Wave：Z-Wave是一种专门为智能家居设计的无线通信协议。它具有低功耗、高可靠性和较长的通信距离，可以实现设备之间的互联和远程控制。\nLoRaWAN：LoRaWAN（长距离低功耗广域网）是一种适用于广域物联网的无线通信协议。它具有较长的通信距离和低功耗特性，适用于远程监测和智能城市等场景。\nNB-IoT（窄带物联网）：NB-IoT是一种窄带低功耗的蜂窝网络技术，专为物联网设备提供广域覆盖和长电池寿命。它适用于大规模设备连接和低功耗要求的物联网应用。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"除了上述协议外，还有许多其他的物联网通信协议，如LTE-M、Sigfox、Thread等，每种协议都有自己的特点和适用场景。在选择通信协议时，需要考虑设备类型、功耗需求、通信距离、网络覆盖等因素，以确保最佳的通信性能和效果。","category":"page"},{"location":"IotBigdataCloud/1-物联网/#Modbus、Profibus和CAN","page":"物联网","title":"Modbus、Profibus和CAN","text":"","category":"section"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"Modbus、Profibus和CAN（Controller Area Network）是常见的工业通信协议，它们在工业自动化和控制系统中得到广泛应用。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"Modbus：Modbus是一种串行通信协议，用于在不同设备之间进行数据通信。它通常用于连接传感器、执行器、PLC（可编程逻辑控制器）和监控系统等设备。Modbus协议简单易用，支持点对点和多点通信，广泛应用于工业领域。\nProfibus：Profibus（Process Field Bus）是一种用于工业自动化领域的通信协议。它支持高速数据传输和实时控制，并且适用于连接各种设备，如传感器、执行器、PLC等。Profibus可以用于工厂自动化、过程控制和机械控制等应用。\nCAN（Controller Area Network）：CAN是一种广泛应用于汽车和工业领域的串行通信协议。它具有高可靠性、抗干扰能力和实时性能，适用于连接车辆电子系统、工业设备和控制系统。CAN协议可以支持多个设备在同一个总线上进行通信。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"这些协议都是为工业领域的通信需求设计的，它们提供了稳定、可靠和实时的数据传输，并在工业自动化、控制系统和监控领域中发挥着重要作用。它们在物联网中的应用也很常见，特别是在工业物联网中连接和集成各种工业设备和系统。","category":"page"},{"location":"IotBigdataCloud/1-物联网/#消息传递协议","page":"物联网","title":"消息传递协议","text":"","category":"section"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"在物联网中，常见的消息传递协议包括MQTT（Message Queuing Telemetry Transport）和Kafka。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"MQTT：MQTT是一种轻量级的发布/订阅消息传递协议，特别适用于资源受限的物联网设备。它采用发布/订阅模型，允许设备发布消息和订阅感兴趣的消息主题。数据可以通过MQTT协议发布到数据平台，并通过订阅者接收和处理。MQTT提供了可靠的消息传递机制和低网络开销，被广泛用于物联网中的消息传递和实时数据处理。\nKafka：Kafka是一个分布式流处理平台和消息队列系统。它具有高吞吐量、可持久化存储和水平扩展等特性。Kafka适用于大规模数据处理和实时流处理场景，包括物联网中的数据传输和存储。数据可以通过Kafka进行发布和订阅，然后存储到数据库或其他数据存储系统中。Kafka的优势在于能够处理高并发的数据流，并提供数据持久化和分布式处理能力。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"无论是MQTT还是Kafka，它们都是用于实现物联网中的消息传递和数据处理的工具。它们提供了可靠的数据传输和处理机制，将物联网设备生成的数据发送到数据平台，并通过存储到数据库或其他数据存储系统中进行后续的数据管理和分析。选择使用哪种协议取决于具体的应用需求和系统架构。","category":"page"},{"location":"IotBigdataCloud/1-物联网/#执行器","page":"物联网","title":"执行器","text":"","category":"section"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"执行器是物联网系统中的一种设备，用于执行控制命令并产生相应的动作或效果。它可以接收来自物联网平台或其他控制系统的指令，并转换为实际的动力或操作。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"执行器可以是各种形式的设备，例如电机、阀门、继电器、电磁锁、气缸等。它们可以用于自动化系统、智能家居、工业控制和机械设备等领域。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"根据应用需求，执行器可能需要实现以下功能：","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"执行控制命令：执行器接收来自物联网平台或控制系统的命令，并按照要求进行相应的动作或操作。例如，控制电机启停、开关阀门、锁定或解锁等。\n反馈状态：有些执行器具备反馈机制，可以向控制系统报告其当前状态或执行结果。这种反馈信息可以用于监控和验证执行器的操作是否成功。\n与其他设备的联动：执行器可能需要与其他设备进行联动，实现协同操作。例如，一个执行器可以与传感器进行配合，实现自动调节或响应环境变化。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"执行器的选择取决于具体的应用场景和需求。在设计物联网系统时，需要考虑执行器的类型、控制接口、通信协议和功耗等因素，以确保与其他设备的兼容性和系统的整体性能。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"总结起来，执行器在物联网系统中起着关键的作用，通过接收指令并执行相应的动作，实现远程控制和自动化操作。","category":"page"},{"location":"IotBigdataCloud/1-物联网/#物联网平台软件","page":"物联网","title":"物联网平台软件","text":"","category":"section"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"在物联网系统中，软件起着至关重要的作用，它们负责管理、控制和处理物联网设备和数据。以下是一些常见的软件组件和功能：","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"物联网平台：物联网平台是一个中央化的软件系统，用于管理和控制连接的物联网设备。它提供设备注册、身份验证、数据传输、远程配置和控制等功能。物联网平台通常具备数据存储、设备管理、安全性和可扩展性等特性。\n数据管理和分析：物联网系统生成大量的数据，这些数据需要进行收集、存储和分析。数据管理和分析软件负责处理和分析物联网设备生成的数据，提取有用的信息和洞察，并支持实时监控、数据可视化和决策支持。\n应用程序和界面：为了使用户能够与物联网系统进行交互，开发应用程序和界面是必要的。这些应用程序可以是Web应用、移动应用或桌面应用，用于远程监控、控制设备、配置设置和查看数据等功能。\n云计算和边缘计算：物联网系统通常涉及云计算和边缘计算的概念。云计算提供强大的计算和存储资源，支持物联网数据的处理和分析。而边缘计算将部分计算和数据处理移至设备的边缘，以减少数据传输和延迟。软件需要支持云计算和边缘计算架构，并确保数据的安全和高效传输。\n安全性和隐私保护：由于物联网系统涉及大量的设备和数据，安全性和隐私保护是至关重要的方面。软件需要具备安全认证、数据加密、访问控制和漏洞修补等功能，以保护物联网系统免受潜在的安全威胁。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"除了上述的软件组件和功能，物联网系统还可能涉及其他软件，如设备驱动程序、通信协议栈、数据传输协议和远程监控工具等。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"需要根据具体的物联网应用场景和需求，选择适合的软件组件和工具，以实现物联网系统的功能和目标。","category":"page"},{"location":"Control/JuMPMPC/#JuMP求解MPC问题","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"","category":"section"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"tip: Tip\nContents：JuMP、ControlContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"note: Note\nJuMP是计算优化问题的Julia软件包。","category":"page"},{"location":"Control/JuMPMPC/#MTK中的OptimizationSystem、ControlSystem","page":"JuMP求解MPC问题","title":"MTK中的OptimizationSystem、ControlSystem","text":"","category":"section"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"通过MTK中的OptimizationSystem、ControlSystem构建MPC问题都是可行的，但是其一个致命的问题是，System会忽略约束！换一句话说，System只接受Loss方程。这是MTK优化体系不完善的地方。那么，Julia中较为成熟的优化包是JuMP、Optim和NLopt。JuMP的集成度比较好，在JuMP中可以根据不同的优化问题使用不同的求解器。所以尝试用JuMP解决。","category":"page"},{"location":"Control/JuMPMPC/#实例：加热器问题","page":"JuMP求解MPC问题","title":"实例：加热器问题","text":"","category":"section"},{"location":"Control/JuMPMPC/#问题描述","page":"JuMP求解MPC问题","title":"问题描述","text":"","category":"section"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"现在有一个物体加热，它的温度由加热项和散热项决定。α是散热系数，β是加热系数，环境温度为T_out。那么控制方程: ","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"T = α*(T_out - T) + β*Q(t)","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"现在可以改变加热功率，那么我们构建一个优化问题：调节加热功率，使得物体的温度从T_0开始，迅速上升并且稳定在某一个温度（比如说58℃）。问题的数学表达为，通过优化控制变量Q(t) 使得损失函数最小:","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"Loss = sum_i 580-T(t_i)","category":"page"},{"location":"Control/JuMPMPC/#构建问题","page":"JuMP求解MPC问题","title":"构建问题","text":"","category":"section"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"首先明确问题。现在假设以一个恒定功率（p=80）加热物体，环境温度18℃，初始温度20℃,散热系数α = 0.2,加热系数β = 0.1。先求解该问题。","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"using Plots,DifferentialEquations\nTout = 18.0\nα = 0.2\nβ = 0.1\nf(x,p,t) = α*(Tout - x) + β*p\ntspan=(0.0,40.0)\nu0 = 20.0\np = 80.0\npr = ODEProblem(f,u0,tspan,p)\nsol = solve(pr)\nplot(sol,ylimit=(10,60))","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"得到的结果是： (Image: 图 1)  ","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"很清晰可以看到，温度缓慢上升最后稳定在58℃。那么作为我们拍脑袋的控制策略来说，这个控制问题很简单。我们可以先让功率在前期比较大（比如说150），等温度到了58℃附近，再把功率调回80，就可以实现“温度迅速上升并最后稳定在58度”。","category":"page"},{"location":"Control/JuMPMPC/#优化求解","page":"JuMP求解MPC问题","title":"优化求解","text":"","category":"section"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"using JuMP,Ipopt\nN = 40\nTout = 18.0\nT0 = 20.0\ndt = 8/N\nLoss = 0.0\nT = T0\nα = 0.2\nβ = 0.1\nmodel = Model(Ipopt.Optimizer)\n@variable(model, 0 <= u[1:N] <= 200)\nfor i in 1:N\n    global T = @expression(model,T + (α*(Tout - T) + β*u[i])*dt)\n    global Loss += @expression(model,(T - 58.0)^2)\nend\nfor i = 1:N-1\n    @constraint(model,-5 <= u[i]-u[i+1] <= 5)\nend\n@objective(model, Min, Loss)\noptimize!(model)\nJuMP.value.(u)","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"u是符号量，离散的个数为N，上面选择离散为40个变量。通过一个for循环，就可以迭代求解40个点上的温度值并且构建Loss方程。同时添加约束，约束的物理含义是控制加热器功率的改变幅度不能太大，这里设置为（-5，5）。","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"PS：这里的离散方法，对微分方程求解来说实际上是最简单的欧拉法，精度有待提高，后退欧拉法，亚当斯方法，龙格库塔方法等等方法都可以用来构建Loss方程，只不过方程表达式会很复杂。","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"最后我们可以看到整个定义的问题。","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"print(model)","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"表达式非常复杂，就不放图了。","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"加热功率的变化为：","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"plot([(i -1)*dt for i in 1:N],value.(u))","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"(Image: 图 2)  ","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"温度的变化为：","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"(Image: 图 3)  ","category":"page"},{"location":"Control/JuMPMPC/#调节约束","page":"JuMP求解MPC问题","title":"调节约束","text":"","category":"section"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"结果有些许波动，调一下功率变化的幅度限制，把约束范围调成（-10，10）","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"加热功率的变化为：","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"plot([(i -1)*dt for i in 1:N],value.(u))","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"(Image: 图 1)  ","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"温度的变化为：","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"(Image: 图 4)  ","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"比刚刚好多了！","category":"page"},{"location":"JuliaIntro/9-ijulia/#IJulia","page":"IJulia","title":"IJulia","text":"","category":"section"},{"location":"JuliaIntro/9-ijulia/#jupyter简介","page":"IJulia","title":"jupyter简介","text":"","category":"section"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"Jupyter是一个基于Web的交互式计算环境，它支持多种编程语言，包括Julia、Python、R等。它的名字源自三种主要编程语言的缩写：Ju（Julia）、Py（Python）和R。","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"Jupyter的主要组件是Jupyter Notebook和Jupyter Lab：","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"Jupyter Notebook： Jupyter Notebook提供了一个可交互的环境，可以在Web浏览器中创建和共享文档，其中包含代码、文本、公式、图表和可视化结果。每个文档由多个单元格组成，每个单元格可以包含代码或文本。您可以逐个单元格地执行代码，并实时查看结果。这使得Jupyter Notebook非常适合于数据分析、机器学习、报告编写和教学等领域。\nJupyter Lab： Jupyter Lab是Jupyter的下一代用户界面，它提供了更丰富的功能和更灵活的界面布局。它支持同时打开多个Notebook、文件浏览器、终端、代码编辑器等。您可以通过拖放方式调整单元格和组件的布局，以满足不同的工作流需求。","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"以下是使用Jupyter的一些主要优点和基本使用方式：","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"交互性：Jupyter提供了一个交互式环境，您可以在单元格中编写代码，并通过逐个单元格地执行代码来获取即时结果。\n文档编写：Jupyter Notebook支持Markdown标记语言，使您可以在代码单元格之间插入文本、标题、公式、链接等，创建结构化的文档。\n可视化支持：Jupyter可以集成各种数据可视化库，如Matplotlib、Plotly、Bokeh等，使您能够绘制图表、绘图和动画，并将其嵌入到文档中。\n代码共享：Jupyter Notebook可以保存为.ipynb文件，并且可以轻松共享给他人。其他人可以加载您的Notebook，并与您一起编辑、运行和修改代码。","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"要开始使用Jupyter，您需要完成以下步骤：","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"安装Jupyter：您可以使用pip或conda命令在命令行中安装Jupyter。\n启动Jupyter：在命令行中运行jupyter notebook或jupyter lab，它会在浏览器中打开Jupyter的界面。\n创建新的Notebook：在Jupyter界面中，您可以创建一个新的Notebook，并选择所需的编程语言。\n编写和执行代码：在Notebook的单元格中，您可以编写代码，并使用Shift+Enter或点击运行按钮来执行代码并查看结果。\n保存和共享Notebook：您可以将Notebook保存为.ipynb文件，并与他人","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"共享。","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"Jupyter是一个强大的工具，可以帮助您以交互和可视化的方式编写、测试和共享代码。它在数据科学、机器学习、教育和科学研究等领域广泛应用。","category":"page"},{"location":"JuliaIntro/9-ijulia/#在jupyter中的julia","page":"IJulia","title":"在jupyter中的julia","text":"","category":"section"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"当需要在Julia中创建可交互的文档、笔记本或报告时，iJulia是一个非常有用的工具。iJulia是一种Julia语言的Jupyter内核，它允许您在Web浏览器中编写和运行Julia代码，并将代码、文本和可视化结果组合成一个交互式文档。","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"以下是使用iJulia的一些主要优点和基本使用方式：","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"交互性： iJulia提供了一个交互式环境，您可以在Jupyter笔记本中编写和运行Julia代码。您可以逐个单元格地执行代码，并实时查看结果。这种交互性使得试验和调试代码变得更加方便和直观。\n文档编写： iJulia允许您在Julia代码中插入富文本、Markdown和LaTeX等标记语言。您可以使用标记语言编写说明文本、标题、列表、公式等，并与代码交替排列。这使得您可以创建丰富的文档，以便更好地记录和展示代码和结果。\n可视化支持： iJulia支持各种数据可视化库，如Plots、Gadfly和PyPlot。您可以使用这些库绘制图表、绘图和动画，并将其直接嵌入到文档中。这样，您可以通过可视化方式更好地解释和展示数据。\n资源共享： iJulia笔记本是可共享的资源，您可以将笔记本文件保存为.ipynb文件，然后与他人共享或将其发布到各种平台上，如GitHub、Jupyter Notebook Viewer等。这使得其他人可以轻松阅读、运行和修改您的代码和文档。","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"要开始使用iJulia，您需要完成以下步骤：","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"安装Jupyter Notebook：您可以使用pip命令或conda命令在命令行中安装Jupyter Notebook。\n安装iJulia内核：在Julia的REPL中，运行using Pkg; Pkg.add(\"IJulia\")来安装iJulia内核。\n启动Jupyter Notebook：在命令行中运行jupyter notebook，它将在浏览器中打开Jupyter Notebook的界面。\n创建新的Julia笔记本：在Jupyter Notebook界面中，选择Julia内核来创建一个新的Julia笔记本。然后您就可以在笔记本中编写和运行Julia代码了。","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"使用iJulia，您可以创建交互式的Julia文档，结合代码和解释，使您的学生能够更好地理解和学习Julia编程。","category":"page"},{"location":"JuliaIntro/9-ijulia/#最后介绍一下julia原生的notebook工具Pluto","page":"IJulia","title":"最后介绍一下julia原生的notebook工具Pluto","text":"","category":"section"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"当需要创建交互式、可执行的Julia文档时，Pluto.jl是一个非常有用的工具。Pluto.jl 是一个Julia语言的笔记本工具，它提供了一个可交互的环境，允许您在浏览器中编写、运行和共享Julia代码和文档。","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"以下是使用Pluto.jl的一些主要优点和基本使用方式：","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"交互性： Pluto.jl 提供了一个实时交互式环境，您可以在浏览器中编写和执行Julia代码。您可以逐个单元格地执行代码，并实时查看结果。这种交互性使得试验、调试和学习变得更加方便和直观。\n文档编写： Pluto.jl 使用可编辑的Markdown单元格，允许您在Julia代码中插入富文本、Markdown和LaTeX等标记语言。您可以使用标记语言编写说明文本、标题、列表、公式等，并与代码交替排列。这使得您可以创建结构化的文档，以便更好地记录和展示代码和结果。\n自动重新执行： Pluto.jl 可以自动重新执行依赖于前面单元格的代码，以确保所有单元格的执行顺序正确无误。这意味着您可以随时更改先前的单元格，并且后续的单元格将自动重新执行，确保结果的一致性。\n共享和协作： Pluto.jl 笔记本可以保存为.pjl 文件，并且可以轻松共享给他人。其他人可以加载您的笔记本，并与您一起编辑和运行代码。这使得团队合作和知识共享变得更加方便。","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"要开始使用Pluto.jl，您需要完成以下步骤：","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"安装 Pluto.jl 包：在Julia的REPL中，运行using Pkg; Pkg.add(\"Pluto\")来安装Pluto.jl 包。\n启动 Pluto.jl：在Julia的REPL中，运行using Pluto; Pluto.run()来启动Pluto.jl 的服务。\n在浏览器中打开Pluto.jl：在启动Pluto.jl 后，会生成一个本地链接，您可以将其复制到浏览器中打开Pluto.jl 的界面。\n创建新的Pluto.jl 笔记本：在Pluto.jl 界面中，您可以创建一个新的笔记本，并在单元格中编写和执行Julia代码。","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"使用Pluto.jl，您可以创建交互式的Julia文档，结合代码、解释和可视化结果，使您和您的学生能够更好地探索和学习Julia编程。","category":"page"},{"location":"Tools/vscode_git/#VScode中使用Git","page":"VScode中使用Git","title":"VScode中使用Git","text":"","category":"section"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"tip: Tip\nContents：VScode,GitContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"本篇介绍在vscode中使用git的方法(以码云为例，githup是同样的操作)","category":"page"},{"location":"Tools/vscode_git/#初始化仓库","page":"VScode中使用Git","title":"初始化仓库","text":"","category":"section"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"如图所示，等价于git init","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/#生成公钥","page":"VScode中使用Git","title":"生成公钥","text":"","category":"section"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"ssh-keygen -t rsa -C \"xxxxxx@qq.com\"","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"一路回车，有y/n则y。在红框中的文件夹中去找公钥文件。","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"idrsa是私钥，idrsa.pub是公钥","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"使用公钥私钥匹配就可以免去登录验证","category":"page"},{"location":"Tools/vscode_git/#配置公钥","page":"VScode中使用Git","title":"配置公钥","text":"","category":"section"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"githup与gitee是同样的方式，将id_rsa.pub的乱码复制到下图的地方。","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/#VScode中添加远程仓库","page":"VScode中使用Git","title":"VScode中添加远程仓库","text":"","category":"section"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"首先复制地址，选ssh","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"添加远程仓库","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"在框中输入复制过来的ssh地址，点击从URL添加远程仓库","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"输入仓库名字，指的是在vscode的仓库名字，随意填 (Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/#提交与推送","page":"VScode中使用Git","title":"提交与推送","text":"","category":"section"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"先暂存更改","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"在...中可以进行一系列操作，本质上就是有一个图形化的git操作界面，","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"一般选择拉取自，或推送到","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"WorkFlow/1-thinkaboutstudy/#教育与学习","page":"教育与学习","title":"教育与学习","text":"","category":"section"},{"location":"WorkFlow/1-thinkaboutstudy/#知识可教，技能可练，智慧只能启发","page":"教育与学习","title":"知识可教，技能可练，智慧只能启发","text":"","category":"section"},{"location":"WorkFlow/1-thinkaboutstudy/","page":"教育与学习","title":"教育与学习","text":"知识是指事实、信息和理论等的累积，可以通过教育和学习来获取。教育系统和教师在传授学科知识和学习技能方面发挥着重要作用。学生通过接触和学习知识，建立对事物的理解和认知。","category":"page"},{"location":"WorkFlow/1-thinkaboutstudy/","page":"教育与学习","title":"教育与学习","text":"技能是通过实践和练习培养的能力，包括实际操作、技术应用和实践技巧等。通过反复的实践和练习，学生能够逐渐掌握和提高各种技能。","category":"page"},{"location":"WorkFlow/1-thinkaboutstudy/","page":"教育与学习","title":"教育与学习","text":"然而，智慧则不同于知识和技能，它更涉及思考、洞察、判断和创造等方面。智慧包括对问题的深入思考、跨学科的综合思考、灵活的解决方案以及对复杂情境的适应能力。智慧通常是通过经验、洞察和启发来培养和发展的。","category":"page"},{"location":"WorkFlow/1-thinkaboutstudy/","page":"教育与学习","title":"教育与学习","text":"在教育中，激发学生的智慧需要提供有启发性的学习环境和教学方法。教师可以鼓励学生思考和提出问题，培养他们的批判性思维和创造性思维能力。同时，提供实际问题和情境，让学生面对挑战并尝试不同的解决方案，以培养他们的智慧。","category":"page"},{"location":"WorkFlow/1-thinkaboutstudy/","page":"教育与学习","title":"教育与学习","text":"总之，知识、技能和智慧在教育中都有重要的地位。知识和技能是构建智慧的基础，而智慧则需要通过启发性的教育和学习来培养。","category":"page"},{"location":"WorkFlow/1-thinkaboutstudy/#从抽象上升到具体","page":"教育与学习","title":"从抽象上升到具体","text":"","category":"section"},{"location":"WorkFlow/1-thinkaboutstudy/","page":"教育与学习","title":"教育与学习","text":"抽象上升到具体的过程，是将概念和思想转化为实际行动和应用的过程。","category":"page"},{"location":"WorkFlow/1-thinkaboutstudy/","page":"教育与学习","title":"教育与学习","text":"在教育中，从抽象到具体的转化是培养学生综合能力和创造力的重要环节。以下是一些关于抽象上升到具体的思考：","category":"page"},{"location":"WorkFlow/1-thinkaboutstudy/","page":"教育与学习","title":"教育与学习","text":"概念理解：学生通过学习抽象的概念和理论，理解基本原理和概念的含义。这是建立知识框架和理论基础的起点。\n联系实际：将抽象的概念与实际情境和现实世界联系起来，帮助学生理解概念的应用和意义。这可以通过案例研究、实际问题解决和实地考察等方式实现。\n创造性应用：学生通过发散思维和创造力，将抽象的概念转化为具体的实践行动。这可以通过实验、设计项目、创业计划等实践活动来实现。\n反思与迭代：学生通过反思和评估实践行动的结果，从中获取反馈和经验，并对未来的行动进行调整和改进。这有助于将具体的实践经验再次回归到抽象层面，推动学生的深入思考和学习。","category":"page"},{"location":"WorkFlow/1-thinkaboutstudy/","page":"教育与学习","title":"教育与学习","text":"在这个过程中，教育者可以充当引导者的角色，提供支持和指导，鼓励学生将抽象的概念转化为具体的实践，并帮助他们发展创造力和解决问题的能力。","category":"page"},{"location":"WorkFlow/1-thinkaboutstudy/","page":"教育与学习","title":"教育与学习","text":"抽象上升到具体是一个关键的学习和发展过程，它培养了学生的应用能力、创造力和实践经验，使他们能够更好地适应现实世界的需求和挑战。","category":"page"},{"location":"WorkFlow/1-thinkaboutstudy/#个重要因素","page":"教育与学习","title":"5个重要因素","text":"","category":"section"},{"location":"WorkFlow/1-thinkaboutstudy/","page":"教育与学习","title":"教育与学习","text":"学习中的五个重要因素：学习能力、学习驱动力、学习路径、机缘和持续努力。让我们逐个探讨每个因素的重要性：","category":"page"},{"location":"WorkFlow/1-thinkaboutstudy/","page":"教育与学习","title":"教育与学习","text":"学习能力：学习能力是指个体获取、理解和应用新知识的能力。它包括记忆力、思维能力、问题解决能力、批判性思维等方面。拥有良好的学习能力可以帮助人们更高效地学习和掌握新的知识和技能。\n学习驱动力：学习驱动力是指个体内在的、有意识的愿望和动力去学习。它可以来源于内在的兴趣、目标的设定、自我激励和追求成就感等因素。学习驱动力对于保持学习的动力和持久性非常重要。\n学习路径：学习路径是指学习者选择的学习方式、学习资源和学习环境。每个人的学习路径可能不同，可以根据自己的学习风格、目标和资源进行选择。选择合适的学习路径可以提高学习效果和效率。\n机缘：机缘是指学习中的机遇和机会。它可能来自于与他人的互动、教育机构的资源、工作经验、社交网络等方面。适时抓住机缘和机会可以为学习提供更广阔的发展和学习的环境。\n持续努力：持续努力是指坚持不懈地投入时间、精力和资源来学习和发展。学习需要长期的坚持和不断的努力，尤其是面对困难和挫折时，持续努力是取得进步和成功的关键。","category":"page"},{"location":"WorkFlow/1-thinkaboutstudy/","page":"教育与学习","title":"教育与学习","text":"这些因素相互关联，共同影响着个体的学习过程和成果。每个因素的重要性可能会因个人情况和学习环境而有所差异。理解和平衡这些因素，可以帮助学习者更好地规划和管理自己的学习，提高学习效果。 确实，这五个因素在学习中扮演着重要的角色，它们有助于培养成功的学习态度和取得良好的学习成果。让我们进一步探讨如何应用这些因素来实现学习的成功：","category":"page"},{"location":"WorkFlow/1-thinkaboutstudy/","page":"教育与学习","title":"教育与学习","text":"学习能力：发展和提高学习能力是关键，这可以通过采用有效的学习策略和技巧来实现。例如，提高记忆力的方法、培养批判性思维、学习时间管理等，都可以帮助提升学习能力。\n学习驱动力：建立明确的学习目标和动力，找到学习的乐趣和意义。内在的兴趣、设定目标、与他人的合作和互动等都可以增强学习的动力和投入程度。\n学习路径：选择适合自己的学习路径和方法。这可能包括选择适合的学习资源、参加相关培训课程、积极利用技术工具和在线学习平台等。根据自己的学习偏好和目标，找到最适合自己的学习方式。\n机缘：善于抓住学习中的机遇和机会。这可能包括参加学术活动、实习机会、社交网络等，通过与他人的互动和经验交流来拓展自己的学习机会和资源。\n持续努力：保持学习的毅力和坚持性。学习过程中会遇到挑战和困难，但通过持续努力和积极应对，可以克服障碍并取得成功。关注长期目标，保持学习的动力和投入，迈出坚实的步伐。","category":"page"},{"location":"WorkFlow/1-thinkaboutstudy/","page":"教育与学习","title":"教育与学习","text":"当这些因素得到充分应用和平衡时，学习的成功更加可期。同时，要记住每个人的学习过程和环境都是独特的，因此个体应根据自身情况和需求进行调整和定制化。","category":"page"},{"location":"WorkFlow/1-thinkaboutstudy/#其他","page":"教育与学习","title":"其他","text":"","category":"section"},{"location":"WorkFlow/1-thinkaboutstudy/","page":"教育与学习","title":"教育与学习","text":"自我反思和反馈：学习中的自我反思和接受反馈是促进个人成长和改进的重要因素。通过反思自己的学习过程和成果，寻找改进的机会，以及接受他人的反馈和指导，可以帮助提高学习效果。\n适应性和灵活性：学习过程中的适应性和灵活性是应对变化和挑战的能力。随着学习的进行，可能需要调整学习策略、应对不同的情况和需求。具备适应性和灵活性的学习者更容易应对各种学习情境和需求。\n有效沟通和合作：学习往往需要与他人进行合作和进行有效的沟通。通过与他人分享和交流，学习者可以互相借鉴和学习，提升彼此的理解和能力。","category":"page"},{"location":"WorkFlow/1-thinkaboutstudy/","page":"教育与学习","title":"教育与学习","text":"这些因素都可以对学习产生积极的影响，但它们的重要性可能因个人情况和学习环境而有所不同。因此，在制定学习计划和进行学习时，综合考虑这些因素是非常有益的。","category":"page"},{"location":"Modeling/MTK_register/#ModelingToolkit调用外部函数","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"","category":"section"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"tip: Tip\nContents：建模、MTK、外部函数Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"note: Note\nMTK = ModelingToolkit.jlModelingToolkit.jl为基于符号系统的建模工具包。MTK-Version:8.5 及以上","category":"page"},{"location":"Modeling/MTK_register/#提出问题","page":"ModelingToolkit调用外部函数","title":"提出问题","text":"","category":"section"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"在前面的ModelingToolkit建模方法中提到，符号系统是MTK的基石。那么，如果想加入一个外部函数，应该怎么解决？例如方程：","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"f(xy) + x + y = 1","category":"page"},{"location":"Modeling/MTK_register/#解决方案","page":"ModelingToolkit调用外部函数","title":"解决方案","text":"","category":"section"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"把函数的调用符号化——@register_symbolic，一切问题就解决了！","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"也就是说，把函数名称放入符号系统中去。和定义符号变量类型，对相关函数进行声明，声明该函数纳入符号系统，即可完成操作。","category":"page"},{"location":"Modeling/MTK_register/#实例","page":"ModelingToolkit调用外部函数","title":"实例","text":"","category":"section"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"考虑一个简单系统：","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"fracdydt  = u(y)  u(y)= leftbeginaligned\n10  y10 \n-10  y geq 100\nendalignedright ","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"这里函数u在编程时，需要用ifelse函数来定义， 也可以用@register_symbolic来注册一个符号函数。","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"通过MTK构建：","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"using ModelingToolkit,DifferentialEquations\n@variables t y(t)\nD = Differential(t)\nu(y) = ifelse(y>100.0, -10.0, 10.0)\n\n# u(y) = y>100.0 ? -10.0 : 10.0\n# @register_symbolic u(y)\n\neqs = [\n    D(y) ~ u(y)\n]\n@named sys = ODESystem(eqs)","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"可以看到得到的方程中，u被视为函数，它的参数为y(t)。","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"求解问题：","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"sys = structural_simplify(sys)\nu0=[y => 50.0]\ntspan = (0.0,20.0)\nprob = ODEProblem(sys,u0,tspan,[])\nsol = solve(prob)\nusing Plots\nplot(sol)","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"可以看到成功求解，并且y在100附近波动。这是我们期望的结果。","category":"page"},{"location":"Modeling/MTK_register/#实例——CoolProp","page":"ModelingToolkit调用外部函数","title":"实例——CoolProp","text":"","category":"section"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"CoolProp一个开源的调用物性包，通过几行代码就可以很容易的调用流体的物性。如何在符号系统中使用Coolprop函数调用物性呢？同样，也是使用外部函数，在外部函数中封装物性查询，将函数符号化即可。","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"测试问题：在1MPa下，求温度从300K-400K的水蒸气焓值累加和。（虽然这样做很没有意义，但是这是一种测试外部函数的有效并且简单的方法）","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"using ModelingToolkit,CoolProp,DifferentialEquations\n@variables t T(t)\nD = Differential(t)\nfunction u(t)\n    PropsSI(\"H\",\"P\",1.0E6,\"T\",t,\"Water\")\nend\n@register_symbolic u(t)\neqs = [\n    D(T) ~ u(t+300.0)\n]\n@named sys = ODESystem(eqs)\nsys = structural_simplify(sys)\nu0=[\n    T => 0.0\n]\ntspan = (0.0,100.0)\nprob = ODEProblem(sys,u0,tspan,[])\nsol = solve(prob)\nusing Plots\nplot(sol)","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"程序可以运行并且得到了结果，","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"MTK符号运算系统加上外部调用函数符号化，基本上可以解决各类仿真问题。","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"note: Note\n个人观点：从仿真层面来说，MTK具有了作为一个仿真引擎的所有功能。从程序开发层面来说，MTK具备搭建一个巨型系统的潜力。","category":"page"},{"location":"Modeling/DE_intro/#DifferentialEquations建模方法","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"section"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"tip: Tip\nContents：建模、DEContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"note: Note\nDE = DifferentialEquations.jlDifferentialEquations.jl为处理时间微分的求解建模工具包。","category":"page"},{"location":"Modeling/DE_intro/#浅谈建模内涵","page":"DifferentialEquations建模方法","title":"浅谈建模内涵","text":"","category":"section"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"在研究各类系统时（上至电力、能源系统、交通系统，下至RC电路、水利管网系统），当我们需要对系统进行处理时，我们都会一件相同的事情——把系统抽象成我们能够处理的对象！","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"从发现问题到获得计算结果，在现代计算科学中一般分为两步：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"把问题抽象可量化、可处理的数学问题\n把数学问题设计成可用计算机处理与计算的可计算问题","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"在这个过程中，大脑在这个过程充当了“解释器”的角色。把实际的问题层层抽象，最后让问题变得可计算。不得不感叹，人类“编译”能力之强大。也许人类在计算速度上远远不及计算机。但在深度与广度层面，远远超过计算机。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"从前牛顿等巨人的时代开始，科学家研究的主体内容，主要是是第一步的内容。近40年，计算机科学技术呈爆炸式增长。依托于计算机，社会生产的智能化日益提高。于是基于第2步的问题也发展出许多学科分支，作为科研领域重要的方向之一。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"这是一件很奇妙的事情，巨量1与0的加减运算产生了无穷的能力！就好像神经元虽然简单，只要数量够，也能组合成产生无数想法的大脑！","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"言归正传，在第一步中，描述对象的数学形式有微分方程（组）、代数方程（组）、图等等。针对对象进行计算的数学形式有求解方程问题、寻优问题、计算图等等。DifferentialEquations.jl就是处理基于时间微分的微分方程（组）求解软件包！","category":"page"},{"location":"Modeling/DE_intro/#DE使用实例","page":"DifferentialEquations建模方法","title":"DE使用实例","text":"","category":"section"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"现有洛伦兹方程为例：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"fracdxdt  = sigma(y-x)  fracdydt  = x(rho-z)-y  fracdzdt = xy - beta z","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"微分方程在DifferentialEquations.jl中含有5个要素：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"方程描述\n求解时间域\n初值（边界条件）\n方程参数\n问题类型","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"在方程定义中，有4个参数：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"function lorenz!(du,u,p,t)\n    du[1] = p[1]*(u[2]-u[1])\n    du[2] = u[1]*(p[2]-u[3]) - u[2]\n    du[3] = u[1]*u[2] - p[3]*u[3]\nend","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"其中，","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"du为微分变量向量\nu为变量向量\np为参数\nt为时间变量","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"剩下要素的定义：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"p = [10.0,28.0,8/3]\nu0 = [1.0;0.0;0.0]\ntspan = (0.0,100.0)\nprob = ODEProblem(lorenz!,u0,tspan,p)","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"其中，","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"p为参数\nu0变量的初始值\ntspan为求解时间域\nprob为通过方法ODEProblem()定义的ODE问题","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"tip: Tip\nODEProblem = Ordinary Differential Equations Problem(常微分方程)beginarrayl\nfracd xd t=sigma(y-x) \nfracd yd t=x(rho-z)-y \nfracd zd t=x y-beta z\nendarray除此之外，还有：DAEProblem = Differential Algebraic Equations Problem（微分代数方程）beginalignedfracd y_1d t =-004 y_1+10^4 y_2 y_3 fracd y_2d t =004 y_1-10^4 y_2 y_3-3 * 10^7 y_2^2 1 =y_1+y_2+y_3endalignedDDEProblem = Delay Differential Equations Problem（随机微分）beginaligned\nd x_0 =fracv_01+beta_0left(x_2(t-tau)right)^2left(p_0-q_0right) x_0(t)-d_0 x_0(t) d x_1 =fracv_01+beta_0left(x_2(t-tau)right)^2left(1-p_0+q_0right) x_0(t) +fracv_11+beta_1left(x_2(t-tau)right)^2left(p_1-q_1right) x_1(t)-d_1 x_1(t) d x_2 =fracv_11+beta_1left(x_2(t-tau)right)^2left(1-p_1+q_1right) x_1(t)-d_2 x_2(t)endaligned更多方程种类可查官方文档。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"求解并画图","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"sol = solve(prob, Tsit5())\nplot(sol,vars=(1,2,3))","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"(Image: 图 4)  ","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"全部代码：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"using DifferentialEquations,Plots\nfunction lorenz!(du,u,p,t)\n        du[1] = p[1]*(u[2]-u[1])\n        du[2] = u[1]*(p[2]-u[3]) - u[2]\n        du[3] = u[1]*u[2] - p[3]*u[3]\nend\np = [10.0,28.0,8/3]\nu0 = [1.0;0.0;0.0]\ntspan = (0.0,100.0)\nprob = ODEProblem(lorenz!,u0,tspan,p)\nsol = solve(prob, Tsit5())\nplot(sol,vars=(1,2,3))","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/#DE的Callback特性","page":"DifferentialEquations建模方法","title":"DE的Callback特性","text":"","category":"section"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"Callback的含义为，当系统运行到某个状态时，人为介入改变系统参量的值，随后继续求解。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"下面以弹球系统为例，介绍Callback的用法。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"弹球系统的特点是，当弹球碰到地面时，需要弹起。所以在模拟弹球系统时，需要考虑求解过程中速度的方法变化，这时候就用到callback。碰地的数学的描述为，弹球速度变量变为它的相反数。也就是说当弹球高度x变为0时，速度u需要变成-u。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"其数学表达为：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"x = v  v = -g","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"DE问题构建：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"function f(du,u,p,t)\n    du[1] = u[2]\n    du[2] = -p\nend","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"其中，","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"u1为x，即弹球高度\nu2为v，即弹球速度","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"建立Callback函数：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"function condition(u,t,integrator) # Event when event_f(u,t) == 0\n    u[1]\nend\nfunction affect!(integrator)\nintegrator.u[2] = -integrator.u[2]\nend\ncb = ContinuousCallback(condition,affect!)","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"condition为系统调用callback时应该满足的条件，默认为函数返回值为0（false）时的情况。即u[1]=0。 affect!为系统调用callback时的处理动作，这里为将速度变负。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"定义剩余要素并求解，在solve中需要传递callback。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"u0 = [50.0,0.0]\ntspan = (0.0,15.0)\np = 9.8\nprob = ODEProblem(f,u0,tspan,p)\nsol = solve(prob,Tsit5(),callback=cb)\nplot(sol)","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"可以得到如下结果：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"(Image: 图 5)","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"如果考虑反弹损失（每次反弹速度损失20%）：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"function affect!(integrator)\nintegrator.u[2] = -integrator.u[2]*0.8\nend","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"(Image: 图 6)  ","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"也能够得到相应的结果，妙啊！！！","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"全部代码：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"using DifferentialEquations,Plots\nfunction f(du, u, p, t)\n    du[1] = u[2]\n    du[2] = -p\nend\nfunction condition(u, t, integrator) # Event when event_f(u,t) == 0\n    u[1]\nend\nfunction affect!(integrator)\n    integrator.u[2] = -integrator.u[2]\nend\ncb = ContinuousCallback(condition, affect!)\nu0 = [50.0, 0.0]\ntspan = (0.0, 15.0)\np = 9.8\nprob = ODEProblem(f, u0, tspan, p)\nsol = solve(prob, Tsit5(), callback=cb)\nplot(sol)","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"tip: Tip\nDE中有许多特性，例如求解结果的处理（Solution Handle）、回调函数（Callback）等等。更多特性可以在官方文档中查看。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/#make和Makefile介绍","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/#程序的编译和链接","page":"make和Makefile介绍","title":"程序的编译和链接","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/#程序的编译和链接过程","page":"make和Makefile介绍","title":"程序的编译和链接过程","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"当编写C语言程序时，需要将源代码转换为可执行程序的过程包括编译和链接两个主要阶段。下面是以GCC编译器为例的程序的编译和链接过程：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"预处理（Preprocessing）： 在编译过程开始之前，预处理器会处理源代码文件（以.c为扩展名）。它执行包括宏展开、头文件包含、条件编译等任务。预处理器会根据包含的头文件和宏定义进行文本替换，生成一个被称为预处理后的源代码文件（通常以.i或.ii为扩展名）。\n编译（Compilation）： 在这一阶段，编译器会将预处理后的源代码文件转换为汇编语言代码文件（以.s为扩展名），即将C语言代码转化为特定机器平台上的汇编指令。编译器负责检查语法错误和类型错误，并进行相应的优化。\n汇编（Assembly）： 汇编器（如GNU as）将汇编语言代码文件转换为目标文件（以.o为扩展名），其中包含了机器指令和数据。目标文件是二进制文件，仍然是机器相关的。\n链接（Linking）： 在链接阶段，链接器（如GNU ld）将目标文件与所需的库文件进行合并，生成最终的可执行程序。链接器解决了符号引用的问题，它将不同目标文件中引用的函数和变量的定义连接在一起，生成一个可执行程序文件。链接器还负责处理库的链接，包括静态库和动态库。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"在链接过程中，可能会涉及两种类型的链接：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"静态链接（Static Linking）： 在静态链接中，链接器会将所有被引用的库文件的代码和数据复制到最终的可执行文件中。这样，可执行文件就包含了所有所需的库的代码，可以独立运行，而不依赖于系统上是否存在相应的库文件。\n动态链接（Dynamic Linking）： 在动态链接中，可执行文件只包含对库函数的引用，而实际的库代码和数据存储在共享库文件中。在程序运行时，操作系统的动态链接器将库文件加载到内存，并将引用与实际地址进行关联，以完成链接。这样可以实现代码的共享，减小可执行文件的大小，并允许共享库的更新和替换。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"GCC编译器将上述过程整合在一起，可以直接将源代码编译成最终的可执行程序。你可以使用GCC命令来进行整个编译和链接过程，例如：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"gcc main.c -o program","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"其中，main.c","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"是源代码文件，program是生成的可执行程序的名称。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"了解程序的编译和链接过程对于理解make和makefile的工作原理非常重要，因为make工具主要用于自动化构建过程，根据源代码的变化和依赖关系进行编译和链接。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/#分步编译和链接","page":"make和Makefile介绍","title":"分步编译和链接","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"当使用GCC编译器进行程序编译和链接时，可以将编译和链接过程分为两步来演示。我们将使用一个简单的C语言程序来进行示例，包含两个源代码文件：main.c和helper.c。main.c文件包含程序的入口函数，helper.c文件包含一个辅助函数。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"以下是演示编译和链接的步骤：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"编译（Compilation）： 首先，我们使用GCC编译器将每个源代码文件编译为目标文件（.o文件），并生成对应的汇编代码（.s文件）。\n编译main.c文件：\ngcc -c main.c -o main.o\n编译helper.c文件：\ngcc -c helper.c -o helper.o\n这将生成main.o和helper.o两个目标文件。\n链接（Linking）： 接下来，我们使用GCC编译器将目标文件链接在一起，生成最终的可执行程序。\n链接目标文件生成可执行程序：\ngcc main.o helper.o -o program\n这将生成名为program的可执行文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"完成上述步骤后，你将得到一个名为program的可执行程序，可以通过执行./program来运行它。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"需要注意的是，上述示例中的程序较简单，只包含两个源文件。对于更复杂的项目，可能涉及多个源文件和库文件，并可能需要更复杂的编译和链接规则。在这种情况下，使用make和makefile来自动化构建过程会更加方便和灵活。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/#来个例子吧","page":"make和Makefile介绍","title":"来个例子吧","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"我需要给学生展示：写个c语言源代码，然后手动编译，一步一步的编译连接生成可执行程序这个过程。使用msys2，mingw64工具链。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"当然，我可以帮你完成这个任务。以下是一个示例的C语言源代码，以及一步一步的编译连接过程，使用MSYS2和MinGW-w64工具链。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"首先，你需要安装MSYS2和MinGW-w64。你可以从官方网站下载并按照说明进行安装。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"然后，创建一个名为 hello.c 的文本文件，将以下代码复制并粘贴进去：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"#include <stdio.h>\n\nint main() {\n    printf(\"Hello, World!\\n\");\n    return 0;\n}","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"保存并关闭文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"接下来，打开MSYS2终端，进入你保存 hello.c 文件的目录。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"执行以下命令来安装所需的编译工具：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"pacman -S mingw-w64-x86_64-toolchain","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"安装完成后，执行以下命令来编译 hello.c 文件：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"gcc -o hello hello.c","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"这将使用GCC编译器将 hello.c 文件编译为可执行文件 hello.exe。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"最后，执行以下命令来运行可执行文件：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"./hello","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"终端将输出 Hello, World!。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"这就是使用MSYS2和MinGW-w64工具链编译和运行C语言程序的过程。你可以将这些步骤展示给学生，让他们了解C语言程序的编译和执行过程。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"先编译到汇编代码，然后编译到目标代码，再连接，分步展示。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"非常抱歉，我误解了你的要求。下面是一个逐步展示编译到汇编代码、编译到目标代码，以及连接的过程。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"假设你已经按照之前提到的步骤安装了MSYS2和MinGW-w64工具链。接下来，我们将使用以下C语言源代码作为示例，并命名为 hello.c：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"#include <stdio.h>\n\nint main() {\n    printf(\"Hello, World!\\n\");\n    return 0;\n}","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"请按照以下步骤逐步编译、连接和运行代码：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"步骤 1: 编译到汇编代码","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"在MSYS2终端中，进入 hello.c 文件所在的目录。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"执行以下命令，将C源代码编译为汇编代码：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"gcc -S -o hello.s hello.c","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"这将生成一个名为 hello.s 的汇编代码文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"步骤 2: 编译到目标代码","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"继续执行以下命令，将汇编代码编译为目标代码：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"gcc -c -o hello.o hello.s","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"这将生成一个名为 hello.o 的目标代码文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"步骤 3: 连接生成可执行程序","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"最后，执行以下命令将目标代码文件连接起来生成可执行程序：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"gcc -o hello hello.o","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"这将生成一个名为 hello 的可执行文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"步骤 4: 运行程序","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"执行以下命令运行可执行程序：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"./hello","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"终端将输出 Hello, World!。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"通过按照以上步骤，你可以逐步展示将C语言源代码编译到汇编代码，再编译到目标代码，最后连接生成可执行程序的过程。学生可以观察每个阶段生成的文件，以及最终的输出结果。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"请使用分立的两个源文件，便于理解连接。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"当然，我理解了你的要求。下面是一个示例，使用两个分离的源文件来展示编译、汇编、目标代码生成以及连接的过程。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"首先，创建一个名为 main.c 的文件，包含以下代码：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"#include <stdio.h>\n\nextern void printHello();\n\nint main() {\n    printHello();\n    return 0;\n}","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"接下来，创建一个名为 hello.c 的文件，包含以下代码：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"#include <stdio.h>\n\nvoid printHello() {\n    printf(\"Hello, World!\\n\");\n}","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"现在，我们将逐步展示编译、汇编、目标代码生成和连接的过程。请按照以下步骤进行：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"步骤 1: 编译到汇编代码","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"在MSYS2终端中，进入包含 main.c 和 hello.c 文件的目录。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"执行以下命令，将 main.c 编译为汇编代码 main.s：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"gcc -S -o main.s main.c","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"执行以下命令，将 hello.c 编译为汇编代码 hello.s：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"gcc -S -o hello.s hello.c","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"步骤 2: 汇编到目标代码","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"继续执行以下命令，将 main.s 和 hello.s 文件汇编为目标代码：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"gcc -c -o main.o main.s\ngcc -c -o hello.o hello.s","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"这将生成 main.o 和 hello.o 两个目标代码文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"步骤 3: 连接生成可执行程序","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"最后，执行以下命令将 main.o 和 hello.o 文件连接起来生成可执行程序：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"gcc -o hello main.o hello.o","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"这将生成一个名为 hello 的可执行文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"步骤 4: 运行程序","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"执行以下命令运行可执行程序：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"./hello","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"终端将输出 Hello, World!。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"通过按照以上步骤，你可以展示将两个分离的源文件编译为汇编代码，然后汇编为目标代码，并最终将它们连接为可执行程序的过程。这将帮助学生更好地理解连接的概念和过程。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/#小结一下","page":"make和Makefile介绍","title":"小结一下","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"不论是C还是C++，通常我们首先将源文件编译成中间代码文件，Windows下为.obj文件，UNIX下为.o文件，也被称为目标文件（Object File）。这个过程称为编译（compile）。然后，我们将大量的目标文件链接在一起，生成可执行文件，这个过程称为链接（link）。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"在编译阶段，编译器需要确保语法的正确性以及函数和变量的声明正确。对于后者，通常需要告诉编译器头文件的位置（头文件中应该只包含声明，而定义应放在C/C++文件中）。只要所有语法正确，编译器就能生成中间目标文件。一般来说，每个源文件对应一个中间目标文件（.o文件或.obj文件）。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"在链接阶段，主要是链接函数和全局变量。因此，我们可以使用这些中间目标文件（.o文件或.obj文件）来链接我们的应用程序。链接器不关心函数所在的源文件，只关心函数的中间目标文件（Object File）。通常情况下，由于源文件较多，编译生成的中间目标文件也很多，而在链接时需要明确指出中间目标文件的名称，这对编译非常不方便。因此，我们需要将中间目标文件打包。在Windows下，这种打包方式称为“库文件”（Library File），即.lib文件；而在UNIX下，称为Archive File，即.a文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"总结一下，源文件首先会生成中间目标文件，然后使用这些中间目标文件生成可执行文件。在编译阶段，编译器只检查程序的语法和函数、变量的声明。如果函数未被声明，编译器会给出警告，但仍可以生成Object File。而在链接阶段，链接器会在所有的Object File中寻找函数的实现。如果找不到，就会报告链接错误（Linker Error）。在VC（Visual C++）下，这种错误通常为Link 2001错误，表示链接器无法找到函数的实现。你需要指定函数的Object File。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/#make和Makefile","page":"make和Makefile介绍","title":"make和Makefile","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/#为什么需要make和Makefile","page":"make和Makefile介绍","title":"为什么需要make和Makefile","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"如果我们的程序依赖成千上万的源代码，而且分布在不同的目录，我们能不能自动化的进行我们程序的构建？我们修改了某个文件，依赖这个文件的所有文件都应该重新编译，而不依赖它的文件应该不需要重新编译。有没有工具实现这一点？","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"当然有了。Makefile是一个用于自动化构建过程的文件，它定义了源代码文件的编译规则和依赖关系。尽管Windows的集成开发环境（IDE）通常会为程序员处理这些工作，但了解Makefile对于成为一名优秀和专业的程序员仍然很重要，就像了解HTML标签对于成为一名专业的前端开发人员一样。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"特别是在Unix系统下的软件编译过程中，你不能不自己编写Makefile。会不会编写Makefile从某种程度上反映了一个人是否具备完成大型工程的能力，因为Makefile涉及整个工程的编译规则。在一个工程中，源文件数量众多，按照类型、功能和模块分别存放在多个目录中。Makefile定义了一系列规则，指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至可以执行更复杂的功能操作，因为Makefile就像一个Shell脚本，可以执行操作系统命令。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"Makefile的好处在于实现了\"自动化编译\"。一旦编写完成，只需要运行一个make命令，整个工程将完全自动编译，大大提高了软件开发的效率。make是一个命令工具，用于解释Makefile中的指令。通常情况下，大多数集成开发环境都提供了make命令，例如Delphi的make、Visual C++的nmake，以及Linux下的GNU make。因此，Makefile已成为工程编译的一种常用方法。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"不同厂商的make工具语法各有不同，但它们的本质都是在处理\"文件依赖性\"。下面将主要介绍GNU make，因为它是应用最广泛、使用最多的make工具，并且符合IEEE 1003.2-1992标准（POSIX.2）。我们将以C/C++源码为基础，涉及一些与C/C++编译相关的知识。关于这方面的内容，请参考相关编译器的文档。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"Makefile定义就是依赖关系和生成规则。为什么我们没有采用上文的编译规则。因为Makefile定义的是更广泛的生成规则，例如文件A从它所依赖的文件B如何生成出来，而不仅仅是程序源文件的编译。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/#Makefile的一个例子","page":"make和Makefile介绍","title":"Makefile的一个例子","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"当涉及到分步编译和链接的过程时，Makefile可以帮助我们自动化这个过程。下面是一个简单的Makefile示例，展示了如何使用Makefile来编译和链接一个简单的C程序：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"# 定义编译器和编译选项\nCC = gcc\nCFLAGS = -Wall -g\n\n# 定义目标文件和依赖关系\nTARGET = myprogram\nOBJS = main.o utils.o\n\n# 默认目标，即执行make命令时的默认动作\nall: $(TARGET)\n\n# 链接目标文件生成可执行文件\n$(TARGET): $(OBJS)\n\t$(CC) $(CFLAGS) $^ -o $@\n\n# 编译每个源文件生成目标文件\n%.o: %.c\n\t$(CC) $(CFLAGS) -c $< -o $@\n\n# 清理生成的目标文件和可执行文件\nclean:\n\trm -f $(OBJS) $(TARGET)","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"在这个示例中，我们定义了以下几个内容：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"CC：编译器的名称，这里使用gcc。\nCFLAGS：编译选项，这里使用-Wall和-g，表示开启所有警告并生成调试信息。\nTARGET：目标可执行文件的名称，这里设为myprogram。\nOBJS：目标文件的名称列表，这里包括main.o和utils.o。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"Makefile中的规则包括：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"all：默认目标，执行make命令时的默认动作，依赖于TARGET。\n$(TARGET)：链接目标文件生成可执行文件，依赖于OBJS。\n$(OBJS)：编译每个源文件生成目标文件，依赖于对应的.c文件。\n%.o：通配符规则，用于编译每个源文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"最后，Makefile还包括了一个清理规则：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"clean：用于删除生成的目标文件和可执行文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"要使用这个Makefile，将其保存为名为\"Makefile\"（注意大小写）的文件，并将其与源文件放在同一目录下。然后在命令行中运行make命令即可自动编译和链接程序。如果需要清理生成的文件，可以运行make clean命令。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"请注意，该示例中的Makefile只是一个简单的示例，实际项目中可能需要更复杂的Makefile来处理更多的源文件和依赖关系。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/#时间戳是Make和Makefile决定哪些文件需要重新构建的依据","page":"make和Makefile介绍","title":"时间戳是Make和Makefile决定哪些文件需要重新构建的依据","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"时间戳是Make和Makefile决定哪些文件需要重新构建的依据之一。Make工具会比较目标文件和依赖文件的时间戳，根据时间戳的差异确定是否需要重新构建目标文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"在Makefile中，每个目标都有一组依赖文件，表示生成该目标所需要的源文件或其他中间文件。当执行make命令时，Make会检查目标文件和依赖文件的时间戳，如果依赖文件的时间戳比目标文件的时间戳更新，或者目标文件不存在，那么Make就会执行相应的规则重新构建目标文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"通过比较时间戳，Make可以避免无需重新构建的部分，从而提高编译的效率。只有在源文件或依赖文件发生了变化，或者目标文件不存在时，Make才会重新构建目标文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"需要注意的是，时间戳并不是唯一的依据，Make还会根据文件的依赖关系、规则和命令等进行判断。但时间戳是其中一个重要的判断因素，用于确定哪些文件需要重新构建。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/#make的一些变种","page":"make和Makefile介绍","title":"make的一些变种","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"除了传统的Makefile，还有一些Makefile的变种工具，每个工具都有自己的特点和使用场景。下面是一些常见的Makefile变种工具：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"QMake：QMake是Qt框架提供的一个构建工具。它使用一种简化的语法来描述项目的构建过程，并能够自动生成传统Makefile。QMake主要用于Qt项目的构建，可以跨平台使用。\nNMake：NMake是微软提供的用于Windows平台的构建工具。它使用一种类似于Makefile的语法，并支持Windows平台上的命令和工具。NMake通常与Microsoft Visual Studio一起使用，用于构建Windows平台上的C/C++项目。\nWmake：WMake是OpenFOAM（开源计算流体力学软件）项目中自定义的构建工具，用于管理和构建OpenFOAM的源代码和应用程序。OpenFOAM是一个开源的数值计算软件库，用于模拟流体动力学问题。\nCMake：CMake是一个跨平台的构建工具，它可以生成不同平台上的原生构建脚本（如Makefile、Visual Studio项目等）。CMake使用一种类似于脚本的语法描述项目的构建过程，并具有很高的可移植性和灵活性。CMake广泛应用于C/C++项目的构建。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"这些变种工具都是为了简化和自动化项目的构建过程，并提供特定平台或框架的支持。根据项目的需求和开发环境的不同，可以选择合适的构建工具来管理和构建项目。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/#关于cmake再多说一点","page":"make和Makefile介绍","title":"关于cmake再多说一点","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"CMake是一个跨平台的开源构建工具，用于管理和自动生成用于构建项目的原生构建脚本，例如Makefile、Visual Studio项目等。它旨在简化跨平台项目的构建过程，提供高度可移植性和灵活性。CMake使用一种名为CMakeLists.txt的文本文件来描述项目的构建规则。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"CMakeLists.txt是CMake的配置文件，其中包含了项目的构建规则和指令。下面是一个简单的CMakeLists.txt示例：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"cmake_minimum_required(VERSION 3.12)  # 指定所需的最低CMake版本\n\nproject(MyProject)  # 设置项目名称\n\n# 添加源文件\nset(SOURCES\n    src/main.cpp\n    src/foo.cpp\n    src/bar.cpp\n)\n\n# 添加可执行目标\nadd_executable(myapp ${SOURCES})\n\n# 添加头文件搜索路径\ninclude_directories(include)\n\n# 添加链接库\ntarget_link_libraries(myapp mylib)","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"在CMakeLists.txt中，首先使用cmake_minimum_required指令指定所需的最低CMake版本。然后使用project指令设置项目名称。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"接下来，通过使用set指令定义一个变量（这里是SOURCES），用于存储源文件的路径。可以根据项目的实际情况添加更多的源文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"使用add_executable指令创建一个可执行目标，将变量SOURCES中的源文件编译为可执行文件（这里是myapp）。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"使用include_directories指令添加头文件搜索路径，以便编译器能够找到所需的头文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"最后，使用target_link_libraries指令添加链接库（这里是mylib）到目标可执行文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"CMakeLists.txt还支持其他各种指令和选项，可以根据项目的需求进行配置。CMake具有丰富的文档和社区支持，可以更深入地了解其功能和用法。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"要构建项目，可以在命令行中使用CMake来生成适用于特定构建系统的构建文件（例如Makefile或Visual Studio项目），然后使用生成的构建文件来进行编译和构建。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"总的来说，CMake提供了一种简洁而强大的方式来管理项目的构建过程，使得在不同平台和构建系统上的项目构建变得更加灵活和可维护。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"注意：CMake可以根据CMakeLists.txt生成Makefile或者Visual studio的项目文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"关于make和Makefile可以参考这里获得更多的信息。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#以CoolProp为例的实操","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/#引言","page":"以CoolProp为例的实操","title":"引言","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"热力学图表是所有能动学生都会要用到的工具。通常是在学习工程热力学时发的热力学图表。图表主要是用来查水的物性，焓、熵等。水会发生相变。热力学图表的知识参考工程热力学教材。现在学生们都用纸本的，远远落后于时代。我们要是能做个网页，可以在网页上查看不同的图多酷啊，要是还能导出相应的数值就更好了，而且提供api调用就完美了。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"理解从背后计算到前台漂亮的页面是如何实现的，这是我们此篇文档的目的。至于物性到底如何计算，那则是能动学院科研工作之一。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#RefProp是什么","page":"以CoolProp为例的实操","title":"RefProp是什么","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"Refprop 是一个流体物性计算程序，用于计算和估算各种流体的热力学和传输性质。它由美国国家标准技术研究所（NIST）开发，旨在提供精确和可靠的流体物性数据。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"Refprop 可以计算多种流体的性质，包括气体、液体和超临界流体。它可以计算的性质包括密度、压力、温度、比热容、粘度、导热系数、表面张力等。这些性质对于工程领域中的设计和分析非常重要，特别是在化学工程、能源系统和制冷空调等领域。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"Refprop 使用的基础是经过验证和广泛接受的热力学模型和实验数据。它包含了大量的流体物性数据，可以用于估算各种温度、压力和组分条件下的性质。用户可以通过输入流体的组分、温度和压力等参数，获得所需的物性计算结果。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"Refprop 还提供了一个用户友好的界面，使用户能够轻松地进行输入和输出。它支持多种编程语言，如Fortran、C++、Python等，可以与其他软件和模拟工具集成使用。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"需要注意的是，Refprop 是一款商业软件，需要购买和许可才能使用。NIST 提供了关于 Refprop 的详细文档和支持，帮助用户正确使用和理解软件的功能和限制。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"总而言之，Refprop 是一款流体物性计算程序，可用于计算和估算各种流体的热力学和传输性质。它是工程领域中重要的工具，用于设计和分析化学工程、能源系统和制冷空调等领域的应用。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#CoolProp又是什么","page":"以CoolProp为例的实操","title":"CoolProp又是什么","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"CoolProp 是一个开源的流体物性计算库，用于计算和估算各种流体的热力学和传输性质。它由一组开发者在多个国家合作开发，旨在提供高精度、可靠且易于使用的流体物性数据。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"与 Refprop 不同，CoolProp 是一个免费的开源软件，可以在各种操作系统上使用，包括 Windows、Linux 和 macOS。它支持多种编程语言，如Python、C++、Matlab 等，可以与其他软件和模拟工具进行集成。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"CoolProp 提供了广泛的流体物性计算功能，可以计算包括气体、液体、超临界流体在内的多种流体的性质。它可以计算的性质包括密度、压力、温度、比热容、粘度、导热系数、表面张力等。除了常见的单组分流体，CoolProp 还支持混合物和多组分流体的计算。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"CoolProp 的优势之一是它提供了多种流体物性模型和方程式，以适应不同流体和应用的需求。它包括了广泛验证的热力学模型和实验数据，以提供准确的计算结果。此外，CoolProp 还提供了适用于不同工程领域的专用函数和接口，简化了复杂流体系统的建模和分析过程。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"CoolProp 的开源特性使得用户可以自由地使用、修改和分享代码。同时，它也有一个活跃的社区，用户可以通过论坛和邮件列表获取支持和交流。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"总结起来，CoolProp 是一个免费的开源流体物性计算库，用于计算和估算各种流体的热力学和传输性质。它提供了广泛的计算功能和模型选择，并支持多种编程语言和操作系统。CoolProp 在工程领域中被广泛应用于化学工程、能源系统、制冷空调等领域的设计和分析。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#Step-by-Step","page":"以CoolProp为例的实操","title":"Step by Step","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"找本工程热力学书看一看，找一本热力学图表看一看，理解一下热力学图表。\n看一看这里, 看看网页形式如何呈现。\n看一看CoolProp的在线接口https://ibell.pythonanywhere.com/， 了解如何通过网页查取相应的数据。\n编译RefProp，生成相应的dll。（此篇覆盖）\n使用julia安装一下CoolProp，使用一下其julia界面。（此篇不覆盖）\n使用http.jl把coolprop封装成一个服务。（此篇不覆盖）\n用JavaScript做个前端页面。（此篇不覆盖）","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#编译RefProp生成dll","page":"以CoolProp为例的实操","title":"编译RefProp生成dll","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/#获取RefProp安装包","page":"以CoolProp为例的实操","title":"获取RefProp安装包","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"获取RefProp的安装包。（通过baidu搜索）","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"Refprop 是一款商业软件，需要购买和许可才能获取安装包。您可以通过以下步骤获取 Refprop 的安装包：","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"访问美国国家标准技术研究所（NIST）的网站：https://www.nist.gov/srd/refprop\n在 NIST 网站上，您可以找到关于 Refprop 的详细信息和文档。阅读相关信息，了解软件的功能、价格和许可方式。\n在 NIST 网站上选择 \"Order Refprop\" 或类似的选项，该选项将引导您到购买页面。\n根据您的需求选择合适的许可类型（例如个人、教育或商业许可）和版本（例如 Windows 或 Linux），然后点击 \"Add to Cart\"（添加到购物车）。\n跟随购买流程，提供所需的信息，并完成支付。购买后，您将收到许可证和相关的安装文件。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"请注意，购买 Refprop 是需要支付费用的，具体费用和许可方式可能因版本和许可类型而有所不同。建议在购买前仔细阅读 NIST 网站上的相关信息，确保了解软件的使用限制和许可条款。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"如果您需要更详细的购买指南或有其他问题，建议直接与 NIST 或 Refprop 的官方联系，以获取准确的购买信息和支持。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#安装RefProp","page":"以CoolProp为例的实操","title":"安装RefProp","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"安装 Refprop 需要购买该商业软件并获得许可证。一旦您购买了 Refprop 的许可证，并收到了安装文件，可以按照以下步骤安装 Refprop：","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"下载安装文件：从获得许可证的来源（通常是 NIST）下载 Refprop 的安装文件。确保下载与您的操作系统兼容的版本。\n解压安装文件：将下载的安装文件解压缩到您选择的目标位置。这将创建一个包含 Refprop 安装所需文件的文件夹。\n运行安装程序：进入解压后的文件夹，并找到安装程序。根据您的操作系统，可能是一个可执行文件（.exe）或脚本文件。双击运行该程序。\n跟随安装向导：安装程序会启动一个安装向导，引导您完成安装过程。按照屏幕上的指示逐步进行，选择安装选项、目标文件夹和其他配置选项。\n完成安装：安装程序将复制所需的文件并配置系统设置。完成安装后，您将收到安装成功的确认消息。\n激活许可证：根据您的许可证要求，可能需要在安装过程中或安装完成后激活许可证。按照提供的指南和说明进行操作，确保许可证被正确激活。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"请注意，Refprop 是一款专业的流体物性计算软件，使用前需要购买合法的许可证。确保遵守相关许可协议和使用条款。如果您在安装过程中遇到问题或需要更多支持，请联系 Refprop 的官方渠道或与购买许可证的机构进行联系。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#RefProp如何使用？","page":"以CoolProp为例的实操","title":"RefProp如何使用？","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"Refprop提供了基于图形用户界面（GUI）的安装程序，用于在Windows系统上使用。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"以下是使用Refprop GUI界面的一般步骤：","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"安装Refprop：按照之前提到的步骤购买和安装Refprop软件。确保您选择了适合您操作系统的版本。\n启动Refprop GUI：安装完成后，在您的计算机上找到Refprop安装目录。在该目录中，您应该能够找到一个可执行文件（.exe），通常命名为Refprop.exe。双击运行该文件以启动Refprop GUI。\n导入或输入数据：在Refprop GUI中，您可以通过导入数据文件或手动输入数据来定义要计算的流体和条件。根据Refprop的界面设计，提供相关的输入框、下拉菜单和按钮等，以便您输入组分、温度、压力等参数。\n运行计算：配置完输入数据后，通过点击运行按钮或相关选项启动计算。Refprop将使用您提供的输入数据进行流体物性计算。\n查看和分析结果：一旦计算完成，Refprop GUI将提供计算结果的可视化和分析选项。您可以查看计算得到的物性数据、图表或其他结果。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"请注意，Refprop GUI的界面和操作方式可能会因不同版本和更新而有所不同。确保参考Refprop的文档、帮助文件或相关指南，以了解如何使用特定版本的GUI界面。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"如果您在使用Refprop GUI过程中遇到任何问题，我建议您查阅Refprop的文档、联系Refprop的支持团队或查找相关的用户社区和论坛，以获取更详细的指导和支持。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#RefProp的编程语言调用接口","page":"以CoolProp为例的实操","title":"RefProp的编程语言调用接口","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"Refprop 提供了几种编程语言的调用接口，使开发者能够在自己的程序中集成和调用 Refprop 的功能。以下是一些常用的编程语言调用接口：","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"C/C++ 接口：Refprop 提供了 C/C++ 的接口，允许开发者使用 C/C++ 语言调用 Refprop 的函数和子程序。这种接口允许直接的编程访问和控制 Refprop 的计算过程。\nFortran 接口：Refprop 还提供了 Fortran 的接口，允许开发者使用 Fortran 语言调用 Refprop 的子程序。这个接口与 Fortran 语言的特性和调用约定相匹配，方便 Fortran 开发者集成 Refprop。\nMATLAB 接口：Refprop 还提供了用于 MATLAB 的接口。这个接口允许 MATLAB 用户在 MATLAB 环境中直接调用 Refprop 的函数和计算物性。\nPython 接口：Refprop 提供了用于 Python 的接口，允许开发者使用 Python 调用 Refprop。这个接口使用了 Python 的 C API，并提供了 Pythonic 的接口风格，方便 Python 开发者进行流体物性计算。\nExcel 接口：Refprop 还提供了用于 Excel 的接口，使用户能够在 Excel 中使用自定义的函数和公式来调用 Refprop 进行计算。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"这些接口提供了调用 Refprop 功能的便捷方式，使开发者能够在自己的程序中利用 Refprop 的流体物性计算能力。通过使用这些接口，开发者可以按照自己的需要调用 Refprop 的函数，传递输入参数并获取计算结果。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"具体使用每种编程语言的接口时，需要参考 Refprop 的官方文档和相关的编程指南，以了解接口的具体用法和调用方法。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"请注意，不同的编程语言接口可能有所不同，并且在使用这些接口之前，您需要确保正确配置和连接 Refprop 的库和头文件，并遵循相应的调用约定和接口规范。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"参考这里获得官方的例子","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#RefProp的编译","page":"以CoolProp为例的实操","title":"RefProp的编译","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"官方的说明在这里。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"我们进入REFPROP安装目录，可以看到有个FORTRAN文件夹， 这里就是RefProp的源代码。看到有个REFPROP.EXE，这就是RefProp的可执行文件。还有个refprop.dll，这就是计算内核，是一个动态链接库。还有个REFPRP64.DLL是64位的动态链接库。我们编译RefProp就是从fortran源文件生成这个dll。至于想学它的fortran代码是如何写的，可以打开FORTRAN 文件夹中的文件，研究一下。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"RefProp的编译流程如下：","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"克隆 REFPROP-cmake 仓库：通过执行以下命令来克隆 REFPROP-cmake 仓库到本地：","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"git clone --recursive https://github.com/usnistgov/REFPROP-cmake.git","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"复制 REFPROP 安装目录下的 FORTRAN 文件夹：将 REFPROP 安装目录下的 FORTRAN 文件夹复制到克隆的代码库的根目录中。\n打开命令行终端：在克隆的代码库根目录下打开命令行终端。\n创建 build 目录：执行以下命令创建一个名为 build 的目录：","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"mkdir build","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"进入 build 目录：执行以下命令进入 build 目录：","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"cd build","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"配置 CMake 构建系统：执行以下命令配置 CMake 构建系统：","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"cmake .. -DCMAKE_BUILD_TYPE=Release","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"这将使用 Release 模式配置 CMake 构建系统，生成 Release 版本的库。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"构建 RefProp：执行以下命令开始构建 RefProp 库：","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"cmake --build .","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"这将根据 CMake 配置文件开始构建 RefProp，并生成相应的库文件。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"完成上述步骤后，将生成的共享库文件放置在操作系统能够找到的位置。在 Windows 上，可以将库文件添加到 PATH 环境变量中。在 macOS 上，可以放置在默认的共享库位置之一。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"请注意，在不同的操作系统上可能会有一些特定的配置步骤和注意事项。如果遇到问题，建议查阅 RefProp 的官方文档和相关的编译指南，以获取更详细的指导和解决方案。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#到底如何调用呢？","page":"以CoolProp为例的实操","title":"到底如何调用呢？","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"我们写的文档已经说过了如何调用dll，这个问题逻辑上已经解决。而且RefProp官方提供了不同的语言调用的例子。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"再说一次，参考这里获得官方的例子","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#最后再多说一句","page":"以CoolProp为例的实操","title":"最后再多说一句","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"我们发现好多东西都在github上啊。请自行学习github是啥，如何使用。","category":"page"},{"location":"CSAdv/9-Ascend等解构/#能源领域一些仿真软件解构","page":"能源领域一些仿真软件解构","title":"能源领域一些仿真软件解构","text":"","category":"section"},{"location":"CSAdv/9-Ascend等解构/","page":"能源领域一些仿真软件解构","title":"能源领域一些仿真软件解构","text":"像Ascend啊、modelica啊等等。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/#Windows的命令提示符简介","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"","category":"section"},{"location":"CSBase/1-Windows命令提示符介绍/#命令提示符初接触","page":"Windows的命令提示符简介","title":"命令提示符初接触","text":"","category":"section"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"很多同学计算机方面一上来接触的就是Windows系统，很容易认为计算机就是拿鼠标点点点。即使学了编程入门的一些课程（如C语言、Fortran语言等），也只是在集成开发环境（IDE，Integrated Development Environment）上点点鼠标，难以理解系统是如何工作的。那我们就非常简要的介绍一下命令行界面（Command Line Interface，CLI）和图形用户界面（Graphical User Interface，GUI）。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"我们刚接触计算机那会儿，微软的操作系统还是DOS系统，就是命令行界面。就是要做什么事都通过打一条命令告诉电脑。后来微软进一步开发了图形用户界面系统（Windows），此时看起来就很友好，并且很多事情可以通过鼠标点击来完成。实际上，Windows系统保留了对命令行界面的兼容，可以在开始菜单找到命令提示符（本质就是cmd.exe）。我们打开命令提示行程序，可以看到它长这样：","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"(Image: 图 1)","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"我们可以在这个界面里头输入dir回车，就会显示当前目录下的内容列表。我们可以用cd切换目录。我们可以用copy进行文件复制。具体这些都是DOS的基本命令，可以查看相应的手册获得更多的认识。在DOS时代，我们会区分内部命令和外部命令。内部命令常驻内存，而外部命令是一条单独的可执行文件。这样说来可能有点抽象。我们可以以一个例子来说明。我们平时使用的浏览器如Edge, 它本质是一个命令msedge.exe，这是一个文件提供的，在我的系统里是\"C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe\"。这可以认为是一个外部命令。而之前提到的dir、cd等可以认为是内部命令，就是有命令提示符自己就提供了的。那我们的外部写的程序实际上都可以通过命令行启动。如上面提到的msedge.exe，我们在命令提示符下输入msedge.exe回车。系统会提示找不到'msedge.exe'不是内部或外部命令。这是因为系统找不到msedge.exe这个文件。那我们可以给全路径，输入C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe 这个来定位，这里因为路径中有空格，我们再使用\"\"把它包起来，输入\"C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe\"回车就启动了Edge浏览器。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"我们的桌面上或者开始菜单里头有很多的快捷方式，供我们点它的时候启动对应的程序。实际上我们在这些快捷方式上右键，选择属性，在“目标”那里就可以看到具体的启动命令。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/#CMD简介","page":"Windows的命令提示符简介","title":"CMD简介","text":"","category":"section"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"Windows 的命令提示符（Command Prompt，简称 CMD）是一种在 Windows 操作系统上使用的命令行界面。它允许用户通过键入特定命令来与计算机进行交互和执行各种任务。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"CMD 提供了一种以文本形式输入和执行命令的方式，可以控制文件和文件夹的操作，管理系统设置，运行脚本和程序等。下面是一些 CMD 命令的常见用途和示例：","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"目录操作：\ncd：改变当前目录。例如，cd Documents 将当前目录更改为 \"Documents\"。\ndir：列出当前目录中的文件和文件夹。\nmkdir：创建新文件夹。例如，mkdir MyFolder 将创建名为 \"MyFolder\" 的文件夹。\n文件操作：\ncopy：复制文件。例如，copy file1.txt file2.txt 将文件 \"file1.txt\" 复制到 \"file2.txt\"。\ndel：删除文件。例如，del file.txt 将删除名为 \"file.txt\" 的文件。\nrename：重命名文件。例如，rename old.txt new.txt 将文件名从 \"old.txt\" 改为 \"new.txt\"。\n系统信息：\nsysteminfo：显示关于计算机系统的详细信息，如操作系统版本、安装日期等。\nipconfig：显示网络配置信息，如 IP 地址、子网掩码等。\ntasklist：列出当前正在运行的进程。\n网络操作：\nping：测试与特定 IP 地址的连接。例如，ping www.example.com 将向 \"www.example.com\" 发送网络请求并显示响应时间。\ntracert：跟踪数据包的路径，显示从源到目的地经过的网络节点。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"这只是 CMD 命令的一小部分，还有许多其他命令可用于不同的任务。您可以在命令提示符窗口中键入 help 或 /? 来获取关于特定命令的更多帮助信息。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"请记住，在使用 CMD 时要小心，确保您了解您要执行的命令的含义和影响，以免意外删除或更改了重要文件。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/#如何进入CMD","page":"Windows的命令提示符简介","title":"如何进入CMD","text":"","category":"section"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"您可以按照以下步骤在 Windows 中进入 CMD（命令提示符）：","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"打开开始菜单：单击桌面左下角的 Windows 图标或按下键盘上的 Windows 键。\n打开 CMD：在开始菜单的搜索栏中，键入 \"cmd\"（不包括引号）。\nWindows 10 及更高版本：在搜索结果中，点击 \"命令提示符\" 或 \"Command Prompt\"。\nWindows 8 和 8.1：在开始菜单中，直接输入 \"cmd\"，然后点击 \"命令提示符\"。\nWindows 7：在开始菜单中，点击 \"所有程序\"，找到 \"附件\" 文件夹，然后点击 \"命令提示符\"。\n运行 CMD：点击打开的 \"命令提示符\" 程序，将打开一个新的命令提示符窗口。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"另外，还有一种快捷方式是使用键盘快捷键：","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"按下 Windows 键 + R 组合键，将打开 \"运行\" 对话框。\n在 \"运行\" 对话框中，键入 \"cmd\"（不包括引号）并按下回车键。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"无论您使用哪种方式，都将打开一个命令提示符窗口，您可以在其中输入和执行各种命令。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/#快捷方式与命令行启动程序的关系","page":"Windows的命令提示符简介","title":"快捷方式与命令行启动程序的关系","text":"","category":"section"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"快捷方式和命令行启动程序是两种不同的方式来打开应用程序或执行命令。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"快捷方式是一个指向特定应用程序或文件的快速访问方式。它通常是一个图标，您可以在桌面、开始菜单、任务栏或文件夹中找到。通过点击快捷方式，您可以快速启动相应的应用程序或打开文件。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"命令行启动程序是通过在命令提示符（CMD）或终端窗口中输入特定命令来启动应用程序或执行命令的过程。通过在命令提示符中键入应用程序的可执行文件的路径和参数，您可以直接启动应用程序，而无需依赖图形界面中的快捷方式。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"虽然快捷方式提供了一种图形化的、可视化的方式来打开应用程序，但命令行启动程序提供了更灵活和精确的控制。通过命令行，您可以指定特定的参数、选项和路径，从而自定义应用程序的行为。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"例如，在快捷方式上，您可以单击图标来启动文本编辑器应用程序并打开一个文件。而通过命令行，您可以在命令提示符中输入编辑器的可执行文件路径以及文件的路径和名称，实现同样的效果。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"总而言之，快捷方式提供了一种直观、可视化的方式来访问应用程序，而命令行启动程序则提供了一种更直接、可自定义的方式来控制应用程序的启动和行为。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/#如何查看快捷方式的实质？","page":"Windows的命令提示符简介","title":"如何查看快捷方式的实质？","text":"","category":"section"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"要查看快捷方式的实质（即指向的目标），您可以执行以下步骤：","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"找到要查看的快捷方式。它可能位于桌面、开始菜单、任务栏或文件夹中。\n右键单击该快捷方式，然后从弹出菜单中选择 \"属性\"（或类似的选项）。这将打开快捷方式属性对话框。\n在属性对话框的 \"快捷方式\" 选项卡中，您将看到一些关于该快捷方式的信息。\n\"目标\" 字段显示了快捷方式指向的实际目标文件或应用程序的路径。例如，对于一个指向 \"C:\\Program Files\\Example\\app.exe\" 的快捷方式，\"目标\" 字段将显示该路径。\n\"起始位置\" 字段指示快捷方式所在的文件夹路径。\n\"快捷键\" 字段显示了为快捷方式设置的热键组合（如果有的话）。\n\"运行\" 字段允许您选择以何种方式运行该快捷方式，如普通窗口、最大化、最小化等。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"通过查看 \"目标\" 字段，您可以确定快捷方式实际指向的文件或应用程序的位置。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"请注意，某些快捷方式可能指向其他快捷方式，而不是直接指向目标文件。在这种情况下，您可以重复上述步骤来查看目标快捷方式的属性，直到找到最终的目标文件或应用程序。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"此外，您还可以直接右键单击快捷方式，然后选择 \"打开文件位置\" 或类似的选项，以在资源管理器中打开快捷方式所在的文件夹。从文件夹中，您可以进一步探索目标文件或应用程序的位置和属性。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/#视频地址","page":"Windows的命令提示符简介","title":"视频地址","text":"","category":"section"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"命令提示符和环境变量","category":"page"},{"location":"CSBase/3-环境变量及其设置/#环境变量简介","page":"环境变量简介","title":"环境变量简介","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/#环境变量初接触","page":"环境变量简介","title":"环境变量初接触","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"我们都听过环境、环境变量等等名词。那么，它的本质到底是什么呢？","category":"page"},{"location":"CSBase/3-环境变量及其设置/#命名","page":"环境变量简介","title":"命名","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"假设现在有一个程序对象：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"akdhihei","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"你知道这是个什么高级语法吗？","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"对的，这就是我胡乱打的，我也不知道它是什么。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"那么再看一个对象：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"path","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"这可能就有些熟悉了，配置过环境的同学都知道，path是我们的环境变量。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"再看：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"a","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"a又是什么呢？与上面的path类比，那么a就是一个变量呗！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"那么这个变量有什么含义吗？没有！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"那么现在再反问，上面的path有意义吗？","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"你可能说：有！它是环境变量！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"但是上面那个path是谁的环境变量，它又指向了谁！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"你可能有一点点明白了！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"这些变量：akdhihei、path、a他们都是变量，本质可以说是容器可以存放值，也可以说是一个程序的对象，它本身没有意义！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"它就是一个名称罢了，我们称之为命名。","category":"page"},{"location":"CSBase/3-环境变量及其设置/#环境","page":"环境变量简介","title":"环境","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"那么，怎样才能让命名有意义呢？","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"没错，就是给他赋值！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"也可以说，没有值的变量并没有存在的意义","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"（你是不是联想到了，你写Python，Java的时候，当你没有使用某个变量，没有赋值，只是定义的时候，编辑器会有小波浪，向你提出warnings！）","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"现在你应该明白了，定而不用，就是没有意义，没有价值，浪费内存资源。因为这个内存（地址）就被占了。用一句话概括就是，占着茅坑不拉屎！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"为了让它有意义，应该干嘛？赋值！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"比如:","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"#define a 5\n\n#define akdhihei 8","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"那么现在可以说，这些被命名的对象们有了意义。它们和某一个具体的值联系起来了，后面的程序中，你看到a就知道它代表5！看到akdhihei就知道它代表8！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"print(a + 1)","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"你一定知道这个程序的结果是什么。而在a被赋值之前，你并不知道！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"那么这个操作的本质是什么呢？","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"是值与符号进行关联，关联之后，又可以通过符号提取数值。那么这是怎么做到的呢？解释器会维护着这样一种储存能力，以便保持着有关的名字-值对偶的关联！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"而这种存储，就被称之为环境，（更加准确是，全局环境），那么局部变量，和其它不同作用域，就是不同的环境！这就是环境的本质！","category":"page"},{"location":"CSBase/3-环境变量及其设置/#path环境变量","page":"环境变量简介","title":"path环境变量","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"刚刚所说的是广义的环境。那么以path代表的环境变量是环境概念下的子集。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"以python环境为例，在没有配置python环境之前，你在CMD终端中输入python，会显示","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"'python' 不是内部或外部命令，也不是可运行的程序或批处理文件。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"而你把python环境配置一下之后，就可以了。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"那其中到底干了什么呢？","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"其本质就是，path是一个变量，里面储存着一些文件的路径。在CMD命令行中输入命令的时候，系统会去path里面找相应的程序（或者在写程序的时候对调用path的路径等等）。比如说你的python.exe 路径为\"E:/\"，你把\"E:/\"加入到环境变量path中，那么就可以找到了，就可以在终端中运行了。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"那么，这个概念依旧是名字-值的关联。path是名字，文件路径是\"E:/\"，环境变量这个狭义概念的赋予是因为，在windows系统中，CMD会通过path中提供的路径去搜寻，如果没有在path中配置（把路径赋值给path），就找不到，就可以通过CMD执行（你手动进入那个文件夹，鼠标点击运行是一点问题也没有的！）。这相当于在Windows下的一个CMD运行环境path，CMD是系统级别的，所以这个环境比较高级。上面的a=5这个环境就很不重要了！但他们的本质都是一样的——","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"那就是字符（名称）-值的关联。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"配置环境=把变量（path）和值（文件路径）关联上这一行为过程","category":"page"},{"location":"CSBase/3-环境变量及其设置/#再解释一下","page":"环境变量简介","title":"再解释一下","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"我们在命令提示符下输入msedge.exe时提示不是内部或者外部命令，而输入全路径（目录）的时候就没有问题。实际上，我们输入命令的时候，系统会在一些目录里去寻找是否有对应的命令。如果有就执行它，如果没有就冒出上面的提示。而如果输入全路径，则在给定的路径（目录）里去寻找对应的命令。这里说到的“一些目录”就是有系统的一个环境变量（PATH）所记录的目录。Windows下的PATH环境变量是以\";\"分割的若干个值，每个值是一个目录。Windows下的PATH环境变量可以通过\"此电脑\"->\"属性\"->\"高级系统设置\"->\"环境变量\"打开，选中Path，再点\"编辑\"就可以修改Path环境变量了。如果我们新建一条，把msedge.exe所在的目录加进去，然后确认退出。那再在命令提示符下就可以直接以msedge.exe启动浏览器了，而不需要再输入全路径。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"Linux下的PATH环境变量是以\":\"分割的若干个值，每个值就是一个目录。如果使用的是bash，可以以export PATH=/new/directory:\\$PATH命令临时修改PATH环境变量。也可以放在~/.bashrc里使得每次登录Linux的时候对PATH的修改都是有效。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"linux下最重要的几个环境变量是PATH、INCLUDE_PATH 和 LD_LIBRARY_PATH。PATH决定命令到哪里去找（目录间有优先级哦，越靠近前面优先级越高），INCLUDE_PATH 决定编译程序的时候系统到哪里去找那些被包含的头文件，LD_LIBRARY_PATH 决定系统到哪里去找加载的共享链接库。Windows下类似。","category":"page"},{"location":"CSBase/3-环境变量及其设置/#到底什么是环境变量","page":"环境变量简介","title":"到底什么是环境变量","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"环境变量是操作系统中存储和管理配置信息的一种机制。它们是在操作系统中定义的命名值对，用于指定应用程序、脚本和系统组件之间的通信和交互。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"在Windows和Linux系统中，环境变量包含一些重要的配置信息，如系统路径、程序的安装路径、临时文件夹路径等。这些变量可以在系统的任何位置被访问和使用，而不需要硬编码在应用程序或脚本中。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"环境变量在操作系统和应用程序之间起到了桥梁的作用。它们提供了一种标准化的方法，使不同的程序能够共享配置信息，而不必直接修改源代码。通过使用环境变量，可以轻松地更改系统的配置，而无需重新编译或重新安装应用程序。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"在Windows系统中，可以使用图形界面或命令行工具（如系统属性、控制面板或set命令）来管理环境变量。在Linux系统中，可以通过命令行工具（如export、setenv等）来设置和修改环境变量。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"一些常见的环境变量包括：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"PATH：指定可执行程序的搜索路径，当我们在命令行中输入命令时，操作系统会按照PATH变量指定的路径搜索可执行程序。\nHOME：指定当前用户的主目录路径。\nJAVA_HOME：指定Java开发环境的安装路径。\nTEMP（或TMP）：指定用于存储临时文件的目录路径。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"通过设置环境变量，可以方便地配置系统和应用程序的行为，提高应用程序的灵活性和可移植性，并简化系统管理和部署的过程。","category":"page"},{"location":"CSBase/3-环境变量及其设置/#Windows下如何设置环境变量","page":"环境变量简介","title":"Windows下如何设置环境变量","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"在Windows系统中，有多种方法可以设置环境变量。下面我将介绍两种常用的方法：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"方法一：使用系统属性设置环境变量","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"右键点击计算机（或此电脑）图标，选择\"属性\"。\n在打开的窗口中，点击\"高级系统设置\"。\n在\"系统属性\"窗口中，点击\"环境变量\"按钮。\n在\"用户变量\"或\"系统变量\"部分，可以分别对当前用户或整个系统设置环境变量。选择对应的部分，点击\"新建\"按钮。\n输入环境变量的名称和值，然后点击\"确定\"。\n完成后，点击\"确定\"关闭所有打开的窗口。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"方法二：使用命令行设置环境变量","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"打开命令提示符（按Win+R，输入\"cmd\"，然后点击\"确定\"）或者使用PowerShell。\n使用以下命令设置用户级环境变量：\nsetx 变量名 \"变量值\"\n例如，要设置名为\"JAVA_HOME\"的环境变量，可以使用以下命令：\nsetx JAVA_HOME \"C:\\Java\\jdk\"\n如果要设置系统级环境变量，需要使用管理员权限运行命令提示符或PowerShell。\n执行命令后，将显示一个成功的消息。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"请注意，使用第一种方法设置的环境变量不会立即在已经打开的命令提示符或PowerShell窗口中生效。需要重新启动窗口或打开新的窗口才能使用新设置的环境变量。使用第二种方法设置的环境变量只会在当前回话中有效。","category":"page"},{"location":"CSBase/3-环境变量及其设置/#Linux下如何设置环境变量","page":"环境变量简介","title":"Linux下如何设置环境变量","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"在Linux系统中，可以通过在bash shell的配置文件中设置环境变量。以bash为例，下面是一种常用的方法：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"打开终端，进入到当前用户的主目录。\n使用文本编辑器（如vi、nano等）打开.bashrc文件，这是bash的配置文件之一。\nvi ~/.bashrc\n在文件的末尾添加你想要设置的环境变量，例如：\nexport JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64\n这里将JAVA_HOME环境变量设置为Java安装路径。\n保存并关闭文件。\n在终端中执行以下命令，使配置生效：\nsource ~/.bashrc\n或者直接注销并重新登录。\n验证环境变量是否设置成功，可以使用以下命令：\necho $JAVA_HOME\n如果显示了设置的路径，则说明环境变量设置成功。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"通过在.bashrc文件中设置环境变量，每次打开新的终端窗口时，bash shell都会自动加载这些变量。这样，你就可以在终端中使用这些环境变量，或者在脚本中引用它们。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"请注意，如果你需要在系统级别设置环境变量，可以编辑/etc/environment文件或在/etc/profile.d/目录下创建一个.sh文件，并在其中设置环境变量。但这些操作可能需要管理员权限。","category":"page"},{"location":"CSBase/3-环境变量及其设置/#有哪些重要的环境变量","page":"环境变量简介","title":"有哪些重要的环境变量","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"以下是其中一些常见的重要环境变量：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"PATH：指定可执行程序的搜索路径。当你在终端中输入命令时，系统会按照PATH变量指定的路径搜索可执行程序。\nINCLUDE_PATH: 指定编译器在编译过程中查找头文件（header files）的路径。头文件包含了程序中所需的函数和数据结构的声明。\nLD_LIBRARY_PATH：指定动态链接库（shared libraries）的搜索路径。当你运行依赖于动态链接库的可执行程序时，系统会在该路径下查找所需的库文件。\nHOME：指定当前用户的主目录路径。通常在命令行中使用波浪符（~）表示该路径。\nUSER：当前登录用户的用户名。\nSHELL：指定当前用户所使用的Shell程序的路径。\nPS1：定义命令行提示符的格式。你可以自定义命令行提示符的外观，例如设置为显示当前目录或用户名。\nLANG：指定系统默认的语言环境。\nLC_ALL：指定所有区域设置（Locale）的设置。它会覆盖其他与区域设置相关的环境变量，如LC_COLLATE、LC_TIME等。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"这只是一小部分常见的重要环境变量。实际上，系统和应用程序可以定义和使用许多其他环境变量，以满足特定的需求和配置要求。","category":"page"},{"location":"CSBase/3-环境变量及其设置/#PATH","page":"环境变量简介","title":"PATH","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"PATH是一个非常重要的环境变量，用于指定可执行程序的搜索路径。当你在终端或命令提示符中输入命令时，系统会按照PATH变量指定的路径来查找可执行程序。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"操作系统会按照PATH环境变量中指定的路径顺序逐个搜索命令，直到找到匹配的可执行程序或搜索完所有路径。如果找到匹配的可执行程序，系统将执行该程序；如果没有找到匹配的程序，系统将显示\"命令未找到\"（Command not found）的错误。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"在PATH环境变量中，不同的路径由冒号（Linux、Unix系统）或分号（Windows系统）分隔开。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"示例：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"上述示例中的PATH环境变量包含了5个路径，每个路径都是可执行程序的搜索路径。当你在终端中输入一个命令时，系统会按照这些路径的顺序依次搜索命令。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"可以通过修改PATH环境变量来添加或修改可执行程序的搜索路径。这对于安装新的软件、使用自定义的脚本或工具以及管理系统的执行环境非常有用。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"注意，为了避免安全风险，应小心管理PATH环境变量，确保只包含可信任的路径，并避免在PATH中包含当前目录（.）或不受信任的目录。这可以减少恶意软件或攻击者利用恶意程序替代系统命令的风险。","category":"page"},{"location":"CSBase/3-环境变量及其设置/#INCLUDE_PATH","page":"环境变量简介","title":"INCLUDE_PATH","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"INCLUDE_PATH是一个常见的环境变量，用于指定编译器在编译过程中查找头文件（header files）的路径。头文件包含了程序中所需的函数和数据结构的声明。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"当编译源代码时，编译器需要访问相关的头文件来了解函数和数据结构的定义。如果头文件位于非标准位置，编译器默认不会自动查找它们。这时，可以通过设置INCLUDE_PATH环境变量告诉编译器额外的头文件搜索路径。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"具体的设置方式因编译器而异。在常见的C/C++编译器中，如GCC（GNU Compiler Collection）或Clang，可以通过以下方式设置INCLUDE_PATH环境变量：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"在bash shell中：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"export INCLUDE_PATH=/path/to/include","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"在Windows的命令提示符中：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"set INCLUDE_PATH=C:\\path\\to\\include","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"请注意，上述命令中的/path/to/include或C:\\path\\to\\include应替换为实际的头文件所在目录路径。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"设置了INCLUDE_PATH环境变量后，编译器将在指定的路径下搜索头文件，使其可被源代码正确引用。这样可以更方便地组织头文件的位置，特别是在项目中使用了自定义的头文件或第三方库的头文件时。","category":"page"},{"location":"CSBase/3-环境变量及其设置/#LD_LIBRARY_PATH","page":"环境变量简介","title":"LD_LIBRARY_PATH","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"LD_LIBRARY_PATH是一个用于指定动态链接库（shared libraries）搜索路径的环境变量。在Linux系统中，可执行程序在运行时可能需要依赖某些共享库，而LD_LIBRARY_PATH变量可以告诉系统在哪些目录中搜索这些共享库。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"当你运行一个可执行程序时，操作系统会使用预定义的默认路径搜索共享库。然而，有时共享库可能位于非标准位置，或者你希望在运行时使用其他版本的共享库。这时，可以通过设置LD_LIBRARY_PATH环境变量来指定额外的共享库搜索路径。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"具体的设置方式如下：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"在bash shell中：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"export LD_LIBRARY_PATH=/path/to/lib","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"在Windows的命令提示符中：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"set LD_LIBRARY_PATH=C:\\path\\to\\lib","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"请注意，上述命令中的/path/to/lib或C:\\path\\to\\lib应替换为实际的共享库所在目录路径。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"设置了LD_LIBRARY_PATH环境变量后，可执行程序在运行时将在指定的路径下搜索共享库。这样可以方便地使用自定义的共享库或指定特定版本的共享库，而不必将其放置在默认的系统库路径下。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"需要注意的是，LD_LIBRARY_PATH是一个影响系统范围的环境变量，所以在设置时要谨慎。错误的设置可能导致系统出现问题或安全风险。一般建议仅在特定需求下使用LD_LIBRARY_PATH，并避免滥用。","category":"page"},{"location":"CSBase/3-环境变量及其设置/#视频地址","page":"环境变量简介","title":"视频地址","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"命令提示符和环境变量","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/#容器化和k8s","page":"容器化和k8s","title":"容器化和k8s","text":"","category":"section"},{"location":"IotBigdataCloud/5-容器化和k8s/#容器化","page":"容器化和k8s","title":"容器化","text":"","category":"section"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"容器化是一种将应用程序及其所有依赖项打包在一起的技术，以创建可移植、一致和可重复部署的环境。容器化将应用程序与其运行环境隔离开来，使应用程序能够在不同的计算环境中以相同的方式运行。容器化技术如Docker使用容器来封装应用程序、库和其他依赖项，从而实现更高效、可扩展和可移植的应用程序部署。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"当从虚拟机转向容器化时，有几个关键的变化和逻辑转变：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"虚拟机的隔离性与资源占用：在虚拟机中，每个虚拟机都是一个完整的操作系统实例，它们互相隔离，并且每个虚拟机需要独立的操作系统、内核和资源。这导致了较高的资源消耗和较慢的启动时间。\n容器的轻量级隔离与资源共享：相比之下，容器是在宿主操作系统上的轻量级隔离环境。它们共享宿主操作系统的内核和资源，可以更高效地运行，并且启动时间更快。容器之间通过命名空间和控制组等机制进行隔离，使得它们能够相互独立运行。\n容器镜像的概念：虚拟机使用基于磁盘映像的方式进行部署，而容器使用容器镜像。容器镜像是一个只读的文件，包含了应用程序及其运行所需的依赖项和配置。容器镜像可以在不同的环境中进行快速部署和复制，确保了环境的一致性。\n管理工具和编排：在容器化环境中，管理工具如Docker、Kubernetes等被广泛使用。它们提供了容器的构建、部署、管理和编排的功能，简化了容器化应用程序的生命周期管理。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"通过容器化，可以实现更快速、高效、可伸缩和可移植的应用程序部署和管理。容器化技术使得开发人员和运维团队能够更好地管理应用程序的依赖项、版本控制和资源利用，从而提高开发和交付效率，并降低了应用程序的运行成本。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/#docker简介","page":"容器化和k8s","title":"docker简介","text":"","category":"section"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"现在让我们来介绍一下 Docker。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"Docker 是一个开源的容器化平台，它以容器的形式打包和运行应用程序及其所有依赖项。Docker 的核心概念是容器镜像和容器实例。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"容器镜像是一个只读的模板，其中包含了运行应用程序所需的文件系统、库、依赖项和配置等。镜像可以从一个基础镜像构建，通过添加或修改文件系统的层来创建一个新的镜像。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"容器实例是基于容器镜像创建的运行实体。它可以被启动、停止、重启和销毁。每个容器实例是相互隔离的，拥有自己的文件系统、进程空间和网络接口。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"Docker 提供了一系列命令和工具，使得容器的管理和操作变得简单和高效。使用 Docker，您可以快速构建、部署和扩展应用程序，无论是在开发、测试还是生产环境中。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"以下是一些常用的 Docker 命令：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"docker build：基于 Dockerfile 构建镜像。\ndocker run：创建并运行一个新的容器实例。\ndocker stop：停止一个运行中的容器实例。\ndocker start：启动一个已停止的容器实例。\ndocker rm：删除一个容器实例。\ndocker images：列出本地的镜像。\ndocker pull：从镜像仓库拉取一个镜像。\ndocker push：将一个镜像推送到镜像仓库。\ndocker exec：在运行中的容器实例中执行命令。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"除了基本的命令之外，Docker 还有其他高级功能，如容器网络、数据卷、容器编排等，可以帮助您更好地管理和扩展容器化应用程序。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"通过 Docker，您可以实现应用程序的快速交付、环境的一致性以及资源的高效利用，从而加快开发和部署的速度，简化应用程序的管理和维护。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/#docker实操","page":"容器化和k8s","title":"docker实操","text":"","category":"section"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"让我们在WSL2里启用systemd，再来个docker实操吧。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"在WSL2中启用systemd需要进行一些额外的配置。以下是启用systemd的步骤：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"打开WSL2终端。\n创建一个新的文件 /etc/wsl.conf（如果不存在）并打开它。\nsudo nano /etc/wsl.conf\n在 wsl.conf 文件中添加以下内容：\n[wsl2]\nkernelCommandLine = systemd.unified_cgroup_hierarchy=1\n保存文件并退出编辑器。\n重新启动WSL2分发版。\nwsl --shutdown\n打开WSL2终端，检查是否已启用systemd。\nsystemctl","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"现在您应该能够在WSL2中使用systemd。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"关于Docker的实操，请提供一些具体的操作场景或需求，我将尽力提供相应的指导。例如，构建镜像、运行容器、管理容器等。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"下面我们用docker运行一个hello world。 要在 Docker 中运行 \"Hello World\"，请按照以下步骤进行操作：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"打开终端或命令行窗口。\n检查您的 Docker 是否已经安装并正确配置。可以运行以下命令检查 Docker 版本：\ndocker version\n如果 Docker 尚未安装，请根据您的操作系统和环境，按照 Docker 官方文档提供的说明进行安装。\n确认 Docker 运行正常后，执行以下命令来拉取并运行 \"Hello World\" 镜像：\ndocker run hello-world\nDocker 将从 Docker Hub 上下载 \"Hello World\" 镜像并创建一个容器实例。容器将执行一些测试操作并输出一条 \"Hello from Docker!\" 消息以及一些其他信息。\n您可以在终端或命令行窗口中看到输出结果。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"通过执行以上步骤，您将成功运行 \"Hello World\" 容器。这是一个简单的示例，您可以使用类似的方式运行其他 Docker 镜像和容器。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"docker运行nginx 要在 Docker 中运行 Nginx Web 服务器，您可以按照以下步骤进行操作：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"打开终端或命令行窗口。\n确保您已经安装并正确配置了 Docker。可以运行以下命令检查 Docker 版本：\ndocker version\n如果 Docker 尚未安装，请根据您的操作系统和环境，按照 Docker 官方文档提供的说明进行安装。\n执行以下命令来拉取并运行 Nginx 镜像：\ndocker run -d -p 80:80 nginx\n-d 参数表示以后台（守护进程）模式运行容器。\n-p 80:80 参数表示将主机的 80 端口映射到容器的 80 端口，使得可以通过主机的 IP 地址访问 Nginx。\nDocker 将从 Docker Hub 上下载 Nginx 镜像并创建一个容器实例。容器将在后台运行 Nginx Web 服务器。\n确认容器是否正在运行，可以执行以下命令：\ndocker ps\n您应该看到类似如下的输出，表示 Nginx 容器正在运行：\nCONTAINER ID   IMAGE   COMMAND                  CREATED        STATUS       PORTS                                   NAMES\n<ContainerID>  nginx   \"/docker-entrypoint.…\"   <Time ago>     Up <Time>     0.0.0.0:80->80/tcp, :::80->80/tcp       <ContainerName>\n在您的 Web 浏览器中，通过访问 http://localhost 或 http://主机IP地址，应该能够看到 Nginx 的欢迎页面。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"通过执行以上步骤，您将成功运行一个 Nginx 容器，并可以通过浏览器访问 Nginx 欢迎页面。您可以使用类似的方式运行其他 Docker 镜像和容器，以扩展和定制您的应用程序环境。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"下面我来解释一下docker。 docker根据镜像模板（image）构建容器（container），然后运行这个容器。这些image就像洋葱一样，有的人构建了一个内部小洋葱，比如设置好了linux基本系统，构建一个镜像a，有的人又在它的上面安装了一些必要的软件，构建了镜像b。一层一层的。这些镜像可以都存在镜像仓库中，并且是以delta的方式存储，以减小磁盘空间。然后我们要运行容器的时候，先拉取这个镜像，然后构建容器。容器中的改变也可以commit到本地的镜像。容器中改变了，但是容器一旦销毁，内部的内容也就随之丢失。为了能永久保存在容器里的改变，我们可以设置volume，就是类似于磁盘挂载，把host的某个目录映射成容器的某个目录。在容器里存到这个目录中的文件实际上是存到了host的目录。当销毁容器的时候，存储的内容因为在host的目录里而得以保留。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"镜像（Image）是一个不可变的文件，它包含了运行一个应用程序所需的所有文件系统、库、依赖项和配置等。镜像可以通过一层一层的方式构建，每一层都是在前一层的基础上进行修改或添加。这种分层的结构使得镜像在构建和传输时更加高效，并且可以共享和复用。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"镜像可以存储在镜像仓库（例如 Docker Hub）中，以便其他人可以拉取和使用。镜像仓库可以存储大量的镜像，并且它们可以以增量的方式存储，这意味着只需要存储每个镜像层的差异部分，可以节省存储空间。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"当您要创建一个容器（Container）时，会使用镜像作为模板。容器是镜像的一个运行实例，它可以被启动、停止、重启和销毁。容器提供了一个隔离的运行环境，包括自己的文件系统、进程空间和网络接口。容器中的任何更改都只影响该容器本身，不会影响其他容器或镜像。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"可以通过将容器中的更改提交（commit）为一个新的镜像来永久保存容器中的更改。这样可以创建一个新的镜像，其中包含了容器的修改，以便后续可以基于这个镜像再次创建容器。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"为了在容器中永久保存数据或文件，可以使用数据卷（Volume）。数据卷可以将主机的某个目录或文件挂载到容器中的特定位置，使得容器中的数据可以持久保存在主机上。这样即使容器被销毁，数据卷中的内容仍然保留。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"总结来说，Docker 的工作流程是使用镜像构建容器，容器中的更改可以提交为新的镜像，而数据卷则用于在容器和主机之间实现数据的持久化存储。这种方式使得应用程序的开发、测试和部署更加方便和高效。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"当使用 Docker 构建镜像时，可以使用 Dockerfile 文件来定义构建镜像的步骤和配置。以下是一个简单的 Dockerfile 示例：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"# 使用官方的 Python 镜像作为基础镜像\nFROM python:3.9\n\n# 设置工作目录\nWORKDIR /app\n\n# 复制当前目录下的所有文件到容器的 /app 目录\nCOPY . /app\n\n# 安装应用程序的依赖项\nRUN pip install --no-cache-dir -r requirements.txt\n\n# 暴露容器的端口\nEXPOSE 8000\n\n# 定义容器启动时运行的命令\nCMD [\"python\", \"app.py\"]","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"上述 Dockerfile 的示例展示了一个用于构建 Python 应用程序镜像的简单示例。以下是每个指令的作用：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"FROM：指定基础镜像，这里使用官方的 Python 3.9 镜像作为基础。\nWORKDIR：设置工作目录为 /app，后续的命令将在该目录下执行。\nCOPY：将当前目录下的所有文件复制到容器的 /app 目录下。\nRUN：在容器中执行命令，这里是安装应用程序的依赖项。\nEXPOSE：声明容器将监听的端口号，这里是将容器的 8000 端口暴露出来。\nCMD：定义容器启动时运行的命令。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"通过使用以上 Dockerfile 文件，您可以使用 docker build 命令构建镜像。例如，假设 Dockerfile 文件位于当前目录下，可以执行以下命令来构建镜像：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"docker build -t myapp .","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"上述命令将使用 Dockerfile 构建一个名为 \"myapp\" 的镜像，. 表示 Dockerfile 文件所在的当前目录。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"这只是一个简单的 Dockerfile 示例，实际的 Dockerfile 可以更复杂，可以包含更多的指令和配置，以满足具体的应用程序构建需求。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"对于更多的 Docker 命令和用法，建议参考 Docker 官方文档或者使用 Docker 命令行工具的 --help 选项获取更详细的信息。此外，您也可以随时向 ChatGPT 提问有关 Docker 的问题，我会尽力提供帮助和回答您的疑问。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/#集群简介","page":"容器化和k8s","title":"集群简介","text":"","category":"section"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"我们以高性能计算集群为例说明一下。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"\"Beowulf 集群\" 是一个计算集群的名称，它以 Beowulf 史诗中的角色命名。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"Beowulf 集群是一种高性能计算（HPC）集群，通常由多个普通计算机节点组成，这些节点通过网络连接在一起。这些节点共同工作以提供并行计算能力和更高的计算性能。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"Beowulf 集群通常使用开源软件和技术，例如 Linux 操作系统、MPI（Message Passing Interface）等，以实现任务的并行处理和分布式计算。这种集群架构可以用于高性能计算、科学研究、数据分析和其他需要大规模计算能力的应用领域。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"Beowulf 集群是一种基于普通计算机节点组成的计算集群，旨在通过并行计算和分布式计算来提供更高的计算性能和处理能力。这种集群模型的概念起源于1994年由 Thomas Sterling 和 Donald Becker 提出的 Beowulf 架构。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"Beowulf 集群通常由以下组件和特点组成：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"节点：集群由多个普通计算机节点组成，每个节点都是标准的个人计算机或服务器。这些节点通过局域网或高速网络连接在一起，形成一个共享资源的计算环境。\n网络通信：节点之间通过网络进行通信和协调。高速网络（如以太网）通常用于实现低延迟和高带宽的数据传输，以支持节点之间的并行计算和数据交换。\n分布式计算：Beowulf 集群利用节点的并行计算能力，将计算任务分割为多个子任务，并在各个节点上同时执行这些子任务，从而实现任务的并行处理和加速。\n软件和工具：集群使用开源的软件和工具来管理和协调节点之间的计算任务。常见的软件包括 Linux 操作系统、MPI（Message Passing Interface）库用于节点间的消息传递、作业调度器（如 Slurm、PBS）用于任务调度和资源管理等。\n可扩展性：Beowulf 集群通常具有良好的可扩展性，可以根据需要增加或减少节点的数量，以适应不同规模和复杂度的计算任务。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"Beowulf 集群的设计目标是通过组合普通计算机节点的计算能力来实现高性能计算，并提供灵活的计算环境，使科学、工程和其他领域的研究人员能够有效地进行大规模计算和数据处理。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"请注意，Beowulf 集群只是一个通用的概念和架构模型，具体的实现和配置可能因组织、应用领域和技术选择而有所不同。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"假如我有5台一样配置的电脑。它们有2个不同的交换机相连，1个是千兆网，1个是infiniband。请来个step by step的设置这个集群的过程。首先是安装linux系统。然后安装nis用户认证。然后头结点设置nfs。计算节点挂载nfs。然后设置infiniband网络，接下来设置一下任务调度器。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"下面是一个基本的步骤指南来设置您描述的集群环境：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"安装 Linux 系统：\n在每台计算机上安装所选择的 Linux 操作系统，可以是常见的发行版如 Ubuntu、CentOS 等。\n确保每台计算机都安装了相同版本的操作系统和软件包。\n安装 NIS 用户认证：\n在头结点（Master 节点）上设置和配置 NIS 服务器，用于提供集中化的用户认证和授权管理。\n在每个计算节点上设置并加入 NIS 域，以实现节点之间的统一身份验证和访问控制。\n头结点设置 NFS：\n在头结点上安装和配置 NFS 服务器，用于提供共享文件系统。\n在头结点上创建共享目录，并设置正确的权限和访问控制。\n配置 NFS 服务器以允许计算节点挂载共享目录。\n计算节点挂载 NFS：\n在每个计算节点上安装 NFS 客户端软件包。\n配置计算节点以挂载头结点上的共享目录，使其可在计算节点上访问。\n设置 InfiniBand 网络：\n安装和配置适当的 InfiniBand 驱动程序和软件栈，以支持 InfiniBand 网络连接。\n在每台计算机上设置 InfiniBand 网络接口，并确保网络适配器驱动程序正确加载。\n设置任务调度器：\n在头结点上安装和配置任务调度器，例如 Slurm、PBS 或其他适合您的需求的调度器。\n配置调度器以管理集群中的计算资源和作业分发。\n在计算节点上安装适当的调度器客户端，以便节点可以与调度器通信并接收任务分配。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"请注意，上述步骤只是一个大致的指南，实际的设置过程可能因为您的特定环境、软件选择和网络配置而有所不同。建议您在进行实际设置之前参考相关的文档、手册和指南，以确保正确配置和操作您的集群环境。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"当涉及网络通信和互联网连接时，理解公网 IP 地址、内网 IP 地址和网络地址转换（NAT）是很重要的。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"公网 IP 地址：\n公网 IP 地址是在互联网上唯一标识一个设备或网络的地址。它可以用于在全球范围内与其他设备进行通信。\n公网 IP 地址由互联网服务提供商（ISP）分配给用户或组织，以使其设备能够直接与互联网通信。\n内网 IP 地址：\n内网 IP 地址是在私有网络（如家庭网络、企业网络或局域网）中使用的地址，用于在局域网内部进行设备之间的通信。\n内网 IP 地址是在私有地址空间中分配的，这些地址不在全球互联网上路由，而是在局域网内部进行本地通信使用。\n常见的内网 IP 地址范围包括 10.0.0.0 到 10.255.255.255、172.16.0.0 到 172.31.255.255、192.168.0.0 到 192.168.255.255。\n网络地址转换（NAT）：\n网络地址转换是一种网络技术，用于将内网设备使用私有 IP 地址与互联网上的公网 IP 地址进行通信。\nNAT 允许多个内网设备通过共享单个公网 IP 地址与互联网通信。\nNAT 通过在网络设备（如路由器或防火墙）上维护转换表和端口映射来实现。\n当内网设备与外部服务器通信时，网络地址转换会将内网设备的私有 IP 地址映射为公网 IP 地址。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"网络地址转换（NAT）的使用允许在具有有限数量公网 IP 地址的情况下连接多个内网设备到互联网，这在家庭网络和企业网络中非常常见。通过使用 NAT，内网设备可以在局域网内部共享公共互联网连接。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/#容器编排之docker-compose","page":"容器化和k8s","title":"容器编排之docker-compose","text":"","category":"section"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"docker-compose编排容器，就好比是虚拟化的集群。我这样说对吧？","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"部分正确。Docker Compose 是一个用于定义和运行多个 Docker 容器的工具，可以简化容器的编排和部署过程。它可以将多个容器定义为一个应用程序，并协调它们之间的通信和依赖关系。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"与虚拟化的集群不同，Docker Compose 并没有直接实现虚拟化。它更侧重于在单个主机上创建一个容器化的应用程序环境，其中不同的容器可以协同工作以提供所需的功能。Docker Compose 提供了一个简洁的方式来定义和管理这些容器之间的关系，以及它们如何相互交互。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"虚拟化集群通常指的是在物理主机上运行多个虚拟机，每个虚拟机都可以运行独立的操作系统和应用程序。而 Docker Compose 是在容器级别进行编排，将多个容器组合成一个应用程序，并提供一种简化的方式来管理容器之间的通信和依赖关系。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"因此，虽然 Docker Compose 提供了一种类似于虚拟化集群的编排方式，但它并不是直接实现虚拟化。它更关注于容器化应用程序的管理和部署。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"那你来一步一步的说一说，docker-compose的安装和使用吧。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"当您安装和使用 Docker Compose 时，可以按照以下步骤进行操作：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"安装 Docker Compose：\n确保您已经安装了 Docker。Docker Compose 是 Docker 的一个独立组件，但它通常与 Docker 一起安装。\n访问 Docker Compose 官方文档的安装页面：https://docs.docker.com/compose/install/\n根据您的操作系统，按照文档中的说明进行安装。官方文档提供了各种操作系统的安装指南。\n创建 Docker Compose 文件：\n在您的项目目录中创建一个名为 docker-compose.yml 的文件。\n在该文件中定义您的容器服务。使用 YAML 格式来描述每个服务的配置、依赖关系、映射端口等。\n编写 Docker Compose 配置：\n在 docker-compose.yml 文件中，定义您的服务。每个服务都应该有一个唯一的名称，并指定使用的镜像、映射的端口、环境变量等。\n您还可以定义服务之间的依赖关系，以确保它们按正确的顺序启动。\n启动 Docker Compose 服务：\n打开终端或命令提示符，导航到包含 docker-compose.yml 文件的目录。\n运行命令 docker-compose up 来启动所有定义的服务。\nDocker Compose 将会下载所需的镜像（如果不存在）并启动相应的容器。\n停止和清理服务：\n若要停止 Docker Compose 中的服务，可以在终端中使用 Ctrl+C 组合键。\n要完全停止并删除服务的容器和网络，可以运行 docker-compose down 命令。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"这些步骤提供了一个基本的概述来安装和使用 Docker Compose。在实际使用中，您可以根据需要进一步探索 Docker Compose 的功能和选项，例如映射卷、环境变量管理、容器间的网络通信等。您可以参考 Docker Compose 的官方文档（https://docs.docker.com/compose/）以获取更多详细信息和示例。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"你给个简单的docker-compose.yml，演示一遍啊。并且请解释一下docker-compose.yml文件。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"当然，以下是一个简单的示例 docker-compose.yml 文件的内容：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"version: '3'\nservices:\n  web:\n    image: nginx:latest\n    ports:\n      - 80:80\n    volumes:\n      - ./html:/usr/share/nginx/html\n    restart: always","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"解释 docker-compose.yml 文件的各个部分：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"version：指定 Docker Compose 文件的版本。这里使用的是版本 3。\nservices：定义了要运行的服务列表。\nweb：服务的名称，您可以根据需要自定义。\nimage：指定服务使用的 Docker 镜像。这里使用的是官方的 nginx 镜像，并指定使用最新版本。\nports：将主机的端口映射到容器的端口。这里将主机的 80 端口映射到容器的 80 端口，以便通过浏览器访问。\nvolumes：将容器内的目录或文件与主机上的目录或文件进行映射。这里将主机的 ./html 目录映射到容器的 /usr/share/nginx/html 目录，以便持久化存储网页内容。\nrestart：指定容器在退出后的重启策略。这里设置为 always，表示容器将始终自动重启。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"这个示例的 docker-compose.yml 文件定义了一个名为 web 的服务，它使用 nginx 镜像并将主机的 80 端口映射到容器的 80 端口。此外，它还将主机上的 ./html 目录与容器内的 /usr/share/nginx/html 目录进行映射，以便持久化存储网页内容。每次容器退出后，它都会自动重启。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"通过使用 docker-compose up 命令，可以根据上述配置启动服务，并根据定义的镜像和配置创建并运行容器。您可以根据需要在此基础上进行更复杂的配置，例如添加其他服务、设置环境变量、配置网络等。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"我需要有2个容器的例子。 如果您需要在 docker-compose.yml 文件中定义两个容器，可以按照以下示例进行编写：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"version: '3'\nservices:\n  web:\n    image: nginx:latest\n    ports:\n      - 80:80\n    volumes:\n      - ./html:/usr/share/nginx/html\n    restart: always\n\n  db:\n    image: mysql:latest\n    ports:\n      - 3306:3306\n    environment:\n      - MYSQL_ROOT_PASSWORD=secret\n    volumes:\n      - ./data:/var/lib/mysql\n    restart: always","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"在上面的示例中，我们添加了一个名为 db 的服务，使用了 mysql 镜像，并将主机的 3306 端口映射到容器的 3306 端口。同时，我们设置了 MySQL 的 root 密码为 \"secret\"。还使用了一个数据卷将容器内的 /var/lib/mysql 目录与主机上的 ./data 目录进行映射，以便持久化存储数据库文件。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"通过使用 docker-compose up 命令，可以启动这两个服务，并在单个主机上运行两个容器。这样，您就可以同时运行一个 nginx 容器和一个 MySQL 容器。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"您可以根据需要在此基础上进行更多的配置，例如添加其他服务、设置网络连接等。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"docker-compose down -v 命令用于停止并删除通过 Docker Compose 启动的容器，并删除相关的网络和数据卷。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"具体的操作如下：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"打开终端或命令行界面。\n进入包含 docker-compose.yml 文件的目录。\n运行以下命令：\n$ docker-compose down -v\n这将停止并删除通过 docker-compose up 启动的容器，并删除相关的网络和数据卷。选项 -v 是用来删除关联的数据卷。\n注意：这个命令会完全清理掉由 docker-compose up 创建的容器、网络和数据卷。请确保在使用该命令之前已经备份了您需要保留的数据。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"通过运行 docker-compose down -v 命令，您可以轻松地清理掉通过 Docker Compose 启动的容器及其关联的资源，以便重新开始或清理环境。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"端口映射，类似于nat，没错吧？","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"是的，端口映射的概念类似于网络地址转换（NAT）。在 Docker 中，使用端口映射可以将主机上的端口映射到容器内部的端口，从而使得可以通过主机的 IP 地址和指定的端口访问运行在容器内的应用程序。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"类比于网络地址转换（NAT），端口映射的过程可以理解为将主机上的公网 IP 地址和指定的端口（公共端口）转换为容器的 IP 地址和内部的端口（私有端口）。这样，通过在主机上的特定端口访问，可以将流量传递到容器中运行的应用程序。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"使用端口映射，您可以在一个主机上运行多个容器，并通过不同的端口映射，使得这些容器中的应用程序可以通过不同的端口进行访问，避免了端口冲突的问题。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"总结起来，端口映射在 Docker 中起到了类似于网络地址转换（NAT）的作用，将主机上的公网 IP 地址和指定的端口映射到容器内部的 IP 地址和端口，实现对容器内应用程序的访问。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/#在云服务器上运行容器","page":"容器化和k8s","title":"在云服务器上运行容器","text":"","category":"section"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"当您在阿里云的 ECS（Elastic Compute Service）上运行 Docker Compose，您需要确保已经完成以下几个步骤：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"在 ECS 实例上安装 Docker：在 ECS 实例上执行适合您操作系统版本的 Docker 安装步骤。您可以参考 Docker 官方文档或阿里云提供的文档进行安装。\n安装 Docker Compose：在 ECS 实例上安装 Docker Compose，可以通过以下步骤进行：\n下载 Docker Compose 二进制文件：\n$ sudo curl -L \"https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose\n授予执行权限：\n$ sudo chmod +x /usr/local/bin/docker-compose\n验证安装是否成功：\n$ docker-compose --version\n编写 docker-compose.yml 文件：创建一个适合您的应用程序的 docker-compose.yml 文件，定义服务、映射端口、设置环境变量等。确保文件中的镜像名称和其他配置正确。\n在 ECS 实例上创建一个网络：通过使用 Docker Compose，您可以创建自定义网络以供容器之间进行通信。在 docker-compose.yml 文件中添加网络配置，如下所示：\nnetworks:\n  mynetwork:\n在 ECS 实例上运行 Docker Compose：使用以下命令在 ECS 实例上启动 Docker Compose：\n$ docker-compose up -d\n这将根据 docker-compose.yml 文件中的配置启动容器，并将它们以守护进程方式运行。\n验证容器是否正常运行：通过运行以下命令检查容器的状态：\n$ docker-compose ps\n它将显示您在 docker-compose.yml 文件中定义的服务，并列出每个服务运行的容器的状态。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"这样，您就可以在阿里云的 ECS 实例上使用 Docker Compose 运行和管理多个容器。请确保已经在阿里云上创建了相应的 ECS 实例，并按照上述步骤进行操作。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/#k8s","page":"容器化和k8s","title":"k8s","text":"","category":"section"},{"location":"IotBigdataCloud/5-容器化和k8s/#k8s简介","page":"容器化和k8s","title":"k8s简介","text":"","category":"section"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"Kubernetes（通常简称为K8s）是一个开源的容器编排和管理平台，用于自动化部署、扩展和管理容器化应用程序。它提供了一个强大的工具集，使您能够轻松地管理容器化应用程序的生命周期，从应用程序的部署到伸缩、负载均衡、自愈能力和滚动更新等。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"以下是 Kubernetes 的一些关键概念和特点：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"集群：Kubernetes 由多个节点组成，这些节点可以分布在不同的物理机器上，形成一个集群。每个节点可以是物理机或虚拟机，它们一起协同工作来运行和管理应用程序。\n容器编排：Kubernetes 提供了强大的容器编排功能，可以自动调度和管理容器的部署。它可以根据资源需求和可用性将容器放置在适当的节点上，并确保容器按预期方式运行。\n服务发现和负载均衡：Kubernetes 具有内置的服务发现和负载均衡功能。它可以为应用程序提供稳定的网络地址和服务名称，并将流量动态分发到容器化应用程序的多个实例之间。\n自动扩展：Kubernetes 允许根据应用程序的负载情况自动扩展容器实例的数量。根据定义的规则，Kubernetes 可以根据负载情况自动增加或减少容器实例，以确保应用程序的高可用性和性能。\n滚动更新：Kubernetes 支持滚动更新，可以逐步替换应用程序的旧版本。这样可以避免中断或服务不可用，并实现无缝的应用程序更新。\n健康检查和自愈能力：Kubernetes 提供了健康检查机制，可以定期检查容器的状态并响应任何故障。如果容器不健康或出现故障，Kubernetes 可以自动重启容器或替换不可用的容器实例。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"总的来说，Kubernetes 是一个功能强大的容器编排和管理平台，可以帮助您简化和自动化容器化应用程序的部署、扩展和管理。它具有丰富的特性和弹性，适用于构建和管理复杂的容器化环境，并提供高可用性、可扩展性和自愈能力。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/#从docker-compose到k8s","page":"容器化和k8s","title":"从docker-compose到k8s","text":"","category":"section"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"可不可以说，docker和docker-compose是去拉取（pull）任务，而k8s是推送任务（push）？k8s推送的是pod，其实就是一组容器？","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"在 Docker 和 Kubernetes 中，有一个概念上的区别可以与“拉取”和“推送”相关联，尽管这个比喻并不完全准确。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"Docker：当使用 Docker 时，您可以通过拉取（pull）镜像来获取应用程序的容器镜像。Docker 镜像通常存储在镜像仓库中，例如 Docker Hub。当您运行容器时，Docker 引擎会从镜像仓库拉取所需的镜像，并在本地构建和运行容器。\nDocker Compose：Docker Compose 是一个工具，用于定义和运行多个相关容器组成的应用程序。通过编写 docker-compose.yml 文件，您可以定义多个容器及其相互之间的关系和依赖关系。然后，通过运行 docker-compose up 命令，Docker Compose 将根据定义的配置拉取所需的镜像，并创建和管理容器。\nKubernetes：Kubernetes 是一个容器编排平台，其中的工作单元被称为“Pod”。Pod 是一个抽象概念，它可以包含一个或多个容器，并作为最小的可部署单元。当您在 Kubernetes 上运行应用程序时，Kubernetes 控制器会根据定义的 Pod 规范创建和管理 Pod 实例。Kubernetes 并不是直接推送 Pod 到节点，而是根据 Pod 的定义和调度策略来动态创建和调度 Pod。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"总体而言，Docker 和 Docker Compose 是通过拉取容器镜像来创建和管理容器的工具，而 Kubernetes 则是一个容器编排平台，可以根据定义的规范和策略创建和管理一组容器，这组容器被组织为一个或多个 Pods。因此，可以说 Kubernetes 是在一定程度上基于推送任务的概念，即根据定义的规范推送 Pod 到集群中的节点。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/#小结一下","page":"容器化和k8s","title":"小结一下","text":"","category":"section"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"容器很好用，把服务都放到不同的容器中，隔离。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"容器又可以互相配合。构成集群。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"容器编排可以自动化，使用docker-compose或者k8s之类的。","category":"page"},{"location":"CSAdv/3-再说说递归/#再说说递归","page":"再说说递归","title":"再说说递归","text":"","category":"section"},{"location":"CSAdv/3-再说说递归/#递归简介","page":"再说说递归","title":"递归简介","text":"","category":"section"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"递归很有用。我们会用递归来说一下加减乘除四则混合运算，再说一说符号求导。说一说碳足迹的计算，再说说能源系统组件化建模。覆盖以下内容：","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"递归的概念：递归是一种通过在函数或算法中调用自身来解决问题的方法。它基于将大问题分解成更小的相似子问题，并通过递归调用来解决这些子问题，最终达到解决整个问题的目的。\n加减乘除运算中的递归：在数学运算中，可以使用递归来实现加法、减法、乘法和除法。例如，加法可以通过递归地进行累加实现，减法可以通过递归地进行递减实现，乘法可以通过递归地进行累加实现，除法可以通过递归地进行递减实现。\n符号求导中的递归：在符号求导（Symbolic Differentiation）中，可以使用递归的方式来求取表达式的导数。通过将表达式按照不同的规则进行分解，并对分解后的子表达式求导，最终得到原始表达式的导数表达式。\n算碳足迹的递归：在计算碳足迹时，可以使用递归的思想来进行计算。通过将整个系统划分为不同的组成部分，并对每个组成部分计算其碳排放量，然后将这些部分的排放量进行累加，最终得到整个系统的碳足迹。\n能源系统构建中的递归思想：\n从下到上构建：在能源系统构建中，可以采用从下到上的递归思想。先从最基本的组件或单元开始构建，然后逐步将这些组件组合成更大的系统或单元，最终构建出完整的能源系统。\n展平的递归：在能源系统构建中，展平的递归思想指的是将复杂的层次结构转化为扁平的结构。通过递归地将系统的层级关系展平，将不同层级的组件或单元转化为同一级别的组件或单元，以简化系统的描述和分析。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"这些是递归在你提到的不同领域中的应用示例。递归的思想在问题求解和系统构建中具有广泛的应用，希望对你的启蒙有所帮助！","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"递归是计算机科学中一个重要的概念。它指的是在一个函数或算法的定义中，调用自身来解决更小规模的问题。递归是一种强大的工具，常用于解决可以分解成相同类型子问题的问题。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"让我们以一个经典的例子来说明递归：计算阶乘。阶乘是指从1到一个给定的正整数（通常用符号\"!\"表示）的连乘积。例如，5的阶乘（表示为5!）等于5 * 4 * 3 * 2 * 1，结果为120。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"现在我们可以使用递归来计算阶乘。我们可以定义一个函数 factorial(n)，该函数接受一个正整数 n 作为参数，并返回 n 的阶乘。递归地，如果 n 等于1，我们知道1的阶乘为1，因此返回1。否则，我们将问题分解为更小的规模，即计算 (n-1) 的阶乘，并将结果乘以 n。这个过程可以用如下的伪代码表示：","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"function factorial(n):\n    if n equals 1:\n        return 1\n    else:\n        return n * factorial(n-1)","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"让我们以计算 5! 为例来演示这个递归过程：","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"首先调用 factorial(5)。\n由于 n 不等于1，所以调用 factorial(4)。\n同样，由于 n 不等于1，所以调用 factorial(3)。\n这个过程继续，直到 n 等于1。此时，函数返回1。\n接着回到 factorial(2)，它返回 2 * 1，即2。\n再回到 factorial(3)，它返回 3 * 2，即6。\n最后，factorial(4) 返回 4 * 6，即24。\n最终，factorial(5) 返回 5 * 24，即120。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"递归的关键是要定义好递归的终止条件，也就是基本情况。在阶乘的例子中，基本情况是 n 等于1，此时我们知道阶乘的结果为1。如果没有正确定义基本情况，递归可能会无限地调用自身，导致栈溢出等问题。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"虽然递归是一个强大的工具，但它也需要小心使用。递归可能会导致额外的计算开销和堆栈空间的消耗，而且在某些情况下可能会导致性能下降。因此，在使用递归时需要考虑问题的规模和性能方面的因素。","category":"page"},{"location":"CSAdv/3-再说说递归/#用递归处理加减乘除的例子","page":"再说说递归","title":"用递归处理加减乘除的例子","text":"","category":"section"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"我们用一个递归函数来处理包含加减乘除操作的表达式，并且在表达式的左叶或右叶是一个子表达式时，递归调用自身。以下是一个使用Julia实现的示例：","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"# 递归计算表达式\nfunction evaluate_expression(expr)\n    if typeof(expr) == Symbol\n        # 如果是操作符，则递归计算左右叶子节点\n        op = expr\n        left = evaluate_expression(rand_expression())\n        right = evaluate_expression(rand_expression())\n        \n        # 根据操作符计算结果\n        if op == :+\n            return left + right\n        elseif op == :-\n            return left - right\n        elseif op == :*\n            return left * right\n        elseif op == :/\n            return left / right\n        end\n    else\n        # 如果是数字或子表达式，则直接返回\n        return expr\n    end\nend\n\n# 生成随机表达式\nfunction rand_expression()\n    if rand() < 0.5\n        return rand(1:10)  # 50%的概率生成一个数字\n    else\n        return Symbol(rand([:+, :-, :*, :/]))  # 50%的概率生成一个操作符\n    end\nend\n\n# 示例\nexpression = rand_expression()\nprintln(\"Expression: \", expression)\nresult = evaluate_expression(expression)\nprintln(\"Result: \", result)","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"在这个示例中，rand_expression()函数用于生成随机的表达式，可以是数字或四种操作符（加法、减法、乘法、除法）之一。evaluate_expression(expr)函数递归地计算表达式的结果，如果表达式是一个操作符，则递归计算其左右叶子节点，并根据操作符进行相应的计算。如果表达式是一个数字或子表达式，则直接返回其值。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"您可以多次运行示例代码，生成不同的随机表达式并计算结果。请注意，由于这是一个随机生成的过程，每次运行结果可能会不同。","category":"page"},{"location":"CSAdv/3-再说说递归/#再来个Python的例子","page":"再说说递归","title":"再来个Python的例子","text":"","category":"section"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"当然，以下是一个使用Python实现的类似递归处理包含加减乘除操作的表达式的示例代码：","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"import random\n\n# 递归计算表达式\ndef evaluate_expression(expr):\n    if isinstance(expr, str):\n        # 如果是操作符，则递归计算左右叶子节点\n        op = expr\n        left = evaluate_expression(rand_expression())\n        right = evaluate_expression(rand_expression())\n        \n        # 根据操作符计算结果\n        if op == '+':\n            return left + right\n        elif op == '-':\n            return left - right\n        elif op == '*':\n            return left * right\n        elif op == '/':\n            return left / right\n    else:\n        # 如果是数字或子表达式，则直接返回\n        return expr\n\n# 生成随机表达式\ndef rand_expression():\n    if random.random() < 0.5:\n        return random.randint(1, 10)  # 50%的概率生成一个数字\n    else:\n        return random.choice(['+', '-', '*', '/'])  # 50%的概率生成一个操作符\n\n# 示例\nexpression = rand_expression()\nprint(\"Expression:\", expression)\nresult = evaluate_expression(expression)\nprint(\"Result:\", result)","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"在这个示例中，rand_expression()函数用于生成随机的表达式，可以是数字或四种操作符（加法、减法、乘法、除法）之一。evaluate_expression(expr)函数递归地计算表达式的结果，如果表达式是一个操作符，则递归计算其左右叶子节点，并根据操作符进行相应的计算。如果表达式是一个数字或子表达式，则直接返回其值。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"您可以多次运行示例代码，生成不同的随机表达式并计算结果。","category":"page"},{"location":"CSAdv/3-再说说递归/#自然数的产生","page":"再说说递归","title":"自然数的产生","text":"","category":"section"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"递归在自然数的产生过程和加减运算中确实起到了重要的作用。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"首先，让我们来看看自然数的产生过程。自然数是从1开始无限地向上递增的整数序列。我们可以使用递归来定义自然数的生成过程。假设我们有一个函数 generate_natural_numbers(n)，它可以生成从1到第n个自然数的序列。递归地，当 n 等于1时，我们知道序列只有一个元素1。否则，我们可以生成前 (n-1) 个自然数序列，并将结果追加上 n。这个过程可以用如下的伪代码表示：","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"function generate_natural_numbers(n):\n    if n equals 1:\n        return [1]\n    else:\n        previous_sequence = generate_natural_numbers(n-1)\n        return previous_sequence + [n]","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"通过不断地调用自身，我们可以生成自然数序列。例如，generate_natural_numbers(5) 将生成序列 [1, 2, 3, 4, 5]。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"接下来，我们再来看看加减运算。加法和减法是常见的算术运算，我们可以使用递归来定义这两种运算。假设我们有一个函数 add(a, b)，它返回 a 和 b 的和。递归地，当 b 等于0时，我们知道任何数与0相加结果为其本身，所以返回 a。否则，我们可以将问题转化为求 (a+1) 和 (b-1) 的和，然后将结果加上 1。这个过程可以用如下的伪代码表示：","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"function add(a, b):\n    if b equals 0:\n        return a\n    else:\n        return add(a+1, b-1)","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"类似地，我们可以定义减法运算。假设我们有一个函数 subtract(a, b)，它返回 a 减去 b 的结果。递归地，当 b 等于0时，我们知道任何数减去0结果为其本身，所以返回 a。否则，我们可以将问题转化为求 (a-1) 减去 (b-1) 的结果，然后将结果加上 1。这个过程可以用如下的伪代码表示：","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"function subtract(a, b):\n    if b equals 0:\n        return a\n    else:\n        return subtract(a-1, b-1)","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"通过递归，我们可以在加法和减法中实现简单的运算。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"递归的思想在数学和计算机科学中有广泛的应用，能够解决许多问题。","category":"page"},{"location":"CSAdv/3-再说说递归/#Julia实现自然数生成","page":"再说说递归","title":"Julia实现自然数生成","text":"","category":"section"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"以下是使用Julia实现自然数的生成和加减运算的递归示例代码：","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"# 生成自然数序列\nfunction generate_natural_numbers(n)\n    if n == 1\n        return [1]\n    else\n        previous_sequence = generate_natural_numbers(n-1)\n        return vcat(previous_sequence, [n])\n    end\nend\n\n# 加法\nfunction add(a, b)\n    if b == 0\n        return a\n    else\n        return add(a + 1, b - 1)\n    end\nend\n\n# 减法\nfunction subtract(a, b)\n    if b == 0\n        return a\n    else\n        return subtract(a - 1, b - 1)\n    end\nend\n\n# 示例\nnatural_numbers = generate_natural_numbers(5)\nprintln(\"Natural Numbers: \", natural_numbers)  # 输出：[1, 2, 3, 4, 5]\n\nresult_add = add(5, 3)\nprintln(\"Addition: \", result_add)  # 输出：8\n\nresult_subtract = subtract(10, 4)\nprintln(\"Subtraction: \", result_subtract)  # 输出：6","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"在这个示例中，generate_natural_numbers(n)函数使用递归生成自然数序列。当 n 等于1时，返回只包含1的数组。否则，递归地生成前 (n-1) 个自然数序列，并将结果与 n 组合。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"add(a, b)函数使用递归来实现加法运算。当 b 等于0时，返回 a。否则，递归地将 a 增加1， b 减少1，直到 b 等于0。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"subtract(a, b)函数使用递归来实现减法运算。当 b 等于0时，返回 a。否则，递归地将 a 减少1， b 减少1，直到 b 等于0。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"您可以运行示例代码并观察结果。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"自然数是由1和加1产生的","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"当谈论自然数时，通常我们将1作为起始点，然后通过不断地应用\"后继\"操作来生成其他的自然数。\"后继\"操作是将一个自然数加1，得到下一个自然数的过程。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"基于这个定义，我们可以通过递归来生成自然数序列，其中每个自然数都是前一个自然数的后继。具体地，我们可以定义一个函数 successor(n)，它返回 n 的后继。然后，我们可以通过递归调用 successor() 函数来生成自然数序列。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"以下是使用Julia实现的代码示例：","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"# 后继操作\nfunction successor(n)\n    return n + 1\nend\n\n# 生成自然数序列\nfunction generate_natural_numbers(n)\n    if n == 1\n        return [1]\n    else\n        previous_sequence = generate_natural_numbers(n-1)\n        current_number = successor(previous_sequence[end])\n        return vcat(previous_sequence, [current_number])\n    end\nend\n\n# 示例\nnatural_numbers = generate_natural_numbers(5)\nprintln(\"Natural Numbers: \", natural_numbers)  # 输出：[1, 2, 3, 4, 5]","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"在这个示例中，successor(n) 函数将给定的自然数 n 加1，并返回结果。然后，generate_natural_numbers(n) 函数使用递归生成自然数序列。当 n 等于1时，函数返回只包含1的数组作为基本情况。否则，它通过递归地生成前 (n-1) 个自然数序列，然后通过应用 successor() 函数来计算当前数值。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"通过运行示例代码，您可以观察到自然数序列 [1, 2, 3, 4, 5] 的生成过程，其中每个数都是前一个数的后继。这展示了递归如何在自然数的产生中发挥作用。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"希望这个解释对您有帮助！如果您还有其他问题，请随时提问。","category":"page"},{"location":"CSAdv/3-再说说递归/#符号求导也可用递归实现","page":"再说说递归","title":"符号求导也可用递归实现","text":"","category":"section"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"符号求导可以使用递归实现，并且《计算机程序的构造和解释》（Structure and Interpretation of Computer Programs，简称SICP）中的例子是经典的递归求导的示例。让我来解释一下。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"在SICP中，递归求导的例子是基于表达式的语法树来定义的。我们可以用一棵树来表示一个表达式，其中树的叶子节点是操作数，而内部节点是操作符。通过对这棵树进行递归处理，我们可以实现符号求导的功能。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"让我们以一个简单的例子来说明，假设我们有一个表达式 (* (+ x 3) (- x 2))，表示 (x + 3) * (x - 2)。我们的目标是对该表达式进行求导。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"首先，我们需要定义表达式的语法树。在这个例子中，+ 和 - 是内部节点，x、3、2 是叶子节点。我们可以用列表来表示语法树，每个列表的第一个元素是操作符，后面的元素是操作数。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"(define expression '(* (+ x 3) (- x 2)))","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"然后，我们定义一个递归函数 derive，它接受一个表达式和一个变量作为参数，并返回对表达式关于该变量的导数表达式。该函数的实现如下：","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"(define (derive expr var)\n  (cond ((number? expr) 0) ; 对常数的导数为0\n        ((eq? expr var) 1) ; 对变量的导数为1\n        ((eq? (car expr) '+) ; 对加法的导数为两个操作数的导数之和\n         (list '+ (derive (cadr expr) var) (derive (caddr expr) var)))\n        ((eq? (car expr) '-) ; 对减法的导数为两个操作数的导数之差\n         (list '- (derive (cadr expr) var) (derive (caddr expr) var)))\n        ((eq? (car expr) '*) ; 对乘法的导数使用乘法法则\n         (list '+\n               (list '* (derive (cadr expr) var) (caddr expr))\n               (list '* (cadr expr) (derive (caddr expr) var))))\n        ; 其他情况忽略，可以扩展实现更多的运算符\n        (else 'undefined)))\n\n(display (derive expression 'x)) ; 输出：(+ (* (+ x 3) 1) (* (- x 2) 1))","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"在上述代码中，我们使用 cond 表达式对表达式的类型进行匹配，并根据不同的类型进行不同的处理。如果是一个常数，其导数为0；如果是变量，其导数为1。对于加法和减法，我们递归地计算操作数的导数，并将结果组合起来。对于乘法，我们使用乘法法则计算导数。对于其他运算符，我们可以根据需要扩展实现。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"最后，我们输出导数的表达式，得到 (+ (* (+ x 3) 1) (* (- x 2) 1))，即 (x + 3) * 1 + (x - 2) * 1。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"这个示例展示了递归在符号求导中的应用。通过对表达式的语法树进行递归处理，我们能够实现对表达式的导数求解。","category":"page"},{"location":"CSAdv/3-再说说递归/#Julia实现符号求导","page":"再说说递归","title":"Julia实现符号求导","text":"","category":"section"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"以下是将SICP中的递归求导示例翻译为Julia表达的代码：","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"# 定义表达式\nexpression = :(*, (:+, :x, 3), (:-, :x, 2))\n\n# 定义递归求导函数\nfunction derive(expr, var)\n    if expr isa Number\n        return 0  # 对常数的导数为0\n    elseif expr == var\n        return 1  # 对变量的导数为1\n    elseif expr[1] == :+\n        return Expr(:+, derive(expr[2], var), derive(expr[3], var))  # 对加法的导数为两个操作数的导数之和\n    elseif expr[1] == :-\n        return Expr(:-, derive(expr[2], var), derive(expr[3], var))  # 对减法的导数为两个操作数的导数之差\n    elseif expr[1] == :*\n        return Expr(:+,\n                    Expr(:*, derive(expr[2], var), expr[3]),\n                    Expr(:*, expr[2], derive(expr[3], var)))  # 对乘法的导数使用乘法法则\n    else\n        return :undefined  # 其他情况忽略，可以扩展实现更多的运算符\n    end\nend\n\n# 示例\nresult = derive(expression, :x)\nprintln(result)  # 输出：:((:x + 3) * 1 + (:x - 2) * 1)","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"在这个示例中，我们使用Julia的表达式来表示表达式和导数。定义了 derive(expr, var) 函数，它接受一个表达式和一个变量作为参数，并返回对表达式关于该变量的导数表达式。在函数内部，我们使用 if 条件语句来判断表达式的类型，并根据不同的类型进行不同的处理。返回的导数表达式也是使用Julia的表达式构造的。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"通过运行示例代码，我们可以看到导数表达式 :((:x + 3) * 1 + (:x - 2) * 1)，即 (x + 3) * 1 + (x - 2) * 1。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"这个示例展示了递归在符号求导中的应用。通过对表达式的语法树进行递归处理，我们能够实现对表达式的导数求解。","category":"page"},{"location":"CSAdv/3-再说说递归/#能源系统建模，碳足迹计算都可以用到","page":"再说说递归","title":"能源系统建模，碳足迹计算都可以用到","text":"","category":"section"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"递归在能源系统建模和碳足迹计算等领域都有广泛的应用。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"在能源系统建模中，递归可以用于建立复杂的能源流程模型。例如，可以使用递归定义能源系统中各个组件（例如发电厂、输电线路、用电设备等）之间的关系，从而模拟整个能源系统的运行。递归可以帮助我们处理能源在不同组件之间的传递、转换和损耗等问题。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"在碳足迹计算中，递归可以用于跟踪和计算各个环节的碳排放量。例如，可以使用递归来考虑一个产品的整个生命周期，从原材料采集、生产制造、物流运输、使用阶段到废弃处理，以及这些环节中可能存在的子环节。递归可以帮助我们将碳排放量沿着整个供应链和生命周期进行累积和计算。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"递归在这些应用中的优势在于能够处理复杂的系统结构和嵌套关系。通过递归地处理问题，我们可以将复杂的问题分解为更小的子问题，并逐步解决它们。递归还可以提供灵活性和可扩展性，使我们能够适应不同规模和复杂度的系统。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"当然，在应用递归时，需要仔细考虑问题的规模、终止条件以及性能方面的因素，以确保递归的正确性和效率。","category":"page"},{"location":"CSAdv/3-再说说递归/#Greet模型与递归","page":"再说说递归","title":"Greet模型与递归","text":"","category":"section"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"Greet（Greenhouse gases, Regulated Emissions, and Energy use in Transportation）模型是一个用于计算交通工具（包括汽车）在制造、使用和报废过程中的碳排放和能源消耗的模型。它是一种生命周期评估工具，用于综合考虑交通工具的整个生命周期对环境的影响。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"在汽车的生命周期评估中，主要包括两个阶段：制造周期和使用周期。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"制造周期：制造周期包括从原材料采集、零部件制造、车辆组装等过程中产生的碳排放和能源消耗。在制造过程中，需要考虑原材料的开采、运输、加工等环节，以及零部件制造的过程。制造周期的碳排放和能源消耗通常以单位车辆的碳排放量（gCO2/km）或能源消耗量（MJ/km）表示。\n使用周期：使用周期是指汽车在正常使用过程中产生的碳排放和能源消耗。它涵盖了燃料的消耗、行驶里程、尾气排放等因素。使用周期的碳排放和能源消耗通常以单位行驶距离的碳排放量（gCO2/km）或能源消耗量（MJ/km）表示。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"为了计算汽车的整个生命周期的碳排放和能源消耗，需要综合考虑制造周期和使用周期的数据，并进行相应的加权平均。这样可以得到一个更全面和准确的汽车碳排放和能源消耗评估结果。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"请注意，具体的Greet模型的实现涉及大量的数据和算法，并超出了简要说明的范围。如果你对此有进一步的兴趣，我建议查阅相关的研究论文或专业文献，以了解更多关于汽车生命周期评估和Greet模型的细节。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"在Greet模型中，制造周期的碳排放计算通常间接使用了递归。制造周期的碳排放量是通过对每个制造阶段的过程进行建模和计算得出的。这些制造阶段包括原材料开采、物流运输、零部件制造、组装等。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"在这些制造阶段中，通常会涉及到复杂的供应链网络和多个环节。为了计算碳排放量，需要考虑每个环节的能源消耗、化石燃料使用以及排放因子等因素。这些计算通常是基于数据和模型进行的，基于递归的方法进行。","category":"page"},{"location":"CSAdv/3-再说说递归/#能源系统的从下到上构建和从上到下展开","page":"再说说递归","title":"能源系统的从下到上构建和从上到下展开","text":"","category":"section"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"当谈到能源系统的构建时，从下到上构建和从上到下展开是两种常见的思维方式。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"从下到上构建：从下到上构建是指从能源系统的基本组成部分开始，逐步组合这些组件来构建整个系统。这种方法注重细节和组件的功能，并逐步将这些组件整合为更大的单元，直到构建出完整的能源系统。\n例如，考虑一个电力系统。从下到上构建的过程可能从电源、变压器、电线、开关等基本组件开始。然后逐步将这些组件连接起来，形成电力分配系统，最终形成一个完整的电力供应网络。\n这种方法的优点是可以更好地理解和管理系统的细节，并确保各个组件的可靠性和功能性。然而，它可能需要更多的时间和资源来逐步构建系统。\n从上到下展开：从上到下展开是指从整体系统的高层结构开始，逐步展开和细化系统的组成部分。这种方法着重于整体架构和系统的整体性能，然后逐步分解系统为更小的子系统或组件。\n以能源系统为例，从上到下展开的过程可能从整体能源需求开始，然后分解为不同类型的能源（如电力、石油、天然气等）。然后进一步展开为各个能源供应链，包括发电、输电、储能、配送等子系统。\n这种方法的优点是能够更好地理解系统的整体性能和相互关系，并在系统设计和优化时提供指导。然而，它可能需要更多的系统层面的考虑和抽象，可能会忽略一些细节和局部问题。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"无论是从下到上构建还是从上到下展开，两种思维方式都可以用于能源系统的设计、规划和优化。选择哪种方式取决于具体情况、目标和需求。通常，在实践中，两种方式可能会结合使用，以确保系统的完整性和细节的考虑。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"以下是使用Julia语言示例来说明能源系统的从下到上构建和从上到下展开的思维方式：","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"从下到上构建的示例：","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"# 从下到上构建能源系统的示例\nstruct PowerSource\n    name::String\n    capacity::Float64\nend\n\nstruct Transformer\n    name::String\n    capacity::Float64\nend\n\nstruct PowerLine\n    name::String\n    length::Float64\nend\n\nfunction build_energy_system()\n    power_source = PowerSource(\"Solar\", 1000.0)  # 基础能源\n    transformer = Transformer(\"Transformer A\", 500.0)  # 变压器\n    power_line = PowerLine(\"Power Line 1\", 10.0)  # 电线\n\n    # 将组件连接起来\n    println(\"Building energy system...\")\n    println(\"Power source: \", power_source.name)\n    println(\"Transformer: \", transformer.name)\n    println(\"Power line: \", power_line.name)\n    println(\"Energy system built successfully!\")\nend\n\n# 示例调用\nbuild_energy_system()","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"从上到下展开的示例：","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"# 从上到下展开能源系统的示例\nstruct EnergySystem\n    name::String\n    demand::Float64\nend\n\nstruct PowerSupplyChain\n    name::String\n    capacity::Float64\nend\n\nstruct PowerGeneration\n    name::String\n    capacity::Float64\nend\n\nfunction expand_energy_system()\n    energy_system = EnergySystem(\"Electricity\", 1000.0)  # 整体能源系统\n    power_supply_chain = PowerSupplyChain(\"Power Supply Chain A\", 500.0)  # 能源供应链\n    power_generation = PowerGeneration(\"Solar Power\", 300.0)  # 发电\n\n    # 将系统分解为子系统和组件\n    println(\"Expanding energy system...\")\n    println(\"Energy system: \", energy_system.name)\n    println(\"Power supply chain: \", power_supply_chain.name)\n    println(\"Power generation: \", power_generation.name)\n    println(\"Energy system expanded successfully!\")\nend\n\n# 示例调用\nexpand_energy_system()","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"这些示例演示了能源系统的从下到上构建和从上到下展开的思维方式。你可以根据具体的需求和系统结构进行相应的调整和扩展。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"请注意，这些示例仅用于说明思维方式，并不涉及真实的能源系统的实现细节。在实际应用中，能源系统的构建和展开可能更加复杂，涉及更多的组件、算法和数据。","category":"page"},{"location":"CSAdv/3-再说说递归/#更多递归的内容","page":"再说说递归","title":"更多递归的内容","text":"","category":"section"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"当讲解递归时，以下是一些重要的内容可以被涵盖：","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"递归的概念：解释递归是一种通过在函数内部调用自身的方法来解决问题的编程技巧。可以解释递归的基本思想和工作原理。\n递归的基本要素：\n递归函数：定义一个函数，在函数内部调用自身。\n基本情况（Base Case）：在递归函数内部定义一个或多个停止递归的条件。\n递归调用：在递归函数内部调用自身来解决更小规模的问题。\n递归的执行流程：描述递归函数的执行过程，包括递归调用、递归深入和递归返回的过程。可以使用树形图或堆栈的概念来解释递归的执行流程。\n递归与迭代的比较：解释递归和迭代之间的区别和相似之处。讨论递归的优点和限制，并提供什么时候使用递归和什么时候使用迭代的准则。\n递归的应用场景：介绍递归在编程中的常见应用场景，如树和图的遍历、阶乘、斐波那契数列、快速排序等。\n递归的复杂性分析：讨论递归算法的时间复杂性和空间复杂性，并提供一些分析递归算法复杂性的方法，如递归树和主定理。\n递归的陷阱和注意事项：指出递归编程中常见的错误和陷阱，并提供一些建议和注意事项，如确保基本情况的正确性、递归深度的限制等。","category":"page"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"这些是递归的一些关键内容，可以帮助你理解和应用递归编程技巧。请注意，递归是一个广泛而深入的主题，以上内容仅为简要概述，你可以进一步深入研究递归以获取更全面的理解。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/#写个库还是创个语言","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"","category":"section"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"对于我们来说，当然是写个库啦。可以借助host语言的强大威力。不用管语言的自洽和完整。多好。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/#DSL与库的区别和联系","page":"写个库还是创个语言","title":"DSL与库的区别和联系","text":"","category":"section"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"当我们讨论DSL（领域特定语言）和库时，我们实际上在谈论两种不同的软件开发概念。它们在设计和使用方式上有一些区别和联系。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"DSL是一种专门为解决特定领域问题而设计的编程语言。它被用来描述或解决特定领域中的问题，通常具有高度的表达能力和领域特定的语法。DSL的目标是提供一种更接近问题领域的表达方式，使得问题的描述和解决方法更加直观和简洁。DSL可以分为内部DSL和外部DSL两种类型。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"内部DSL：内部DSL是嵌入在主要编程语言中的DSL。它利用主语言的语法和结构，通过创建特定的API或语法扩展来提供领域特定的表达能力。内部DSL的编写通常更容易，因为它们直接建立在主语言的基础上，使用主语言的工具和生态系统。\n外部DSL：外部DSL是独立于主要编程语言的DSL。它具有自己的语法和解释器，可以单独编写和执行。外部DSL可以使用自定义的语法和规则，更适合特定领域的问题描述和解决方法。外部DSL的编写可能需要更多的工作，因为需要定义和实现自己的语法和解释器。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"库（Library）是一组预先编写好的代码和功能集合，可以在软件开发中重复使用。库通常提供了一组函数、类或模块，可以通过调用库中的函数来实现特定的功能。库提供了一种封装和抽象的方式，使得开发者可以利用已经实现的功能来快速构建应用程序。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"下面是DSL和库之间的一些区别和联系：","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"设计目标：DSL的设计目标是为了解决特定领域中的问题，并提供更直观和简洁的表达方式。库的设计目标是提供可重用的代码和功能集合，用于构建应用程序。\n表达能力：DSL通常具有更高的表达能力，因为它们专门为解决特定领域问题而设计。DSL的语法和语义更接近问题领域，使得问题描述更加直观和易于理解。库提供了一组函数或功能，可以在主语言中调用，但不一定能够提供与DSL相同的表达能力。\n代码重用：库的主要目的是代码重用。通过使用库中提供的函数和功能，开发者可以在应用程序中快速实现特定功能，减少了重复编写代码的工作。DSL通常不会直接用于代码重用，因为它们更关注问题领域的描述和解决方法。\n编写和学习成本：编写DSL可能需要更多的工作，因为需要定义和实现自己的语法和解释器。库的编写相对简单，因为它可以直接建立在主语言的基础上。学习DSL可能需要更多的学习成本，因为开发者需要了解DSL的语法和规则。学习使用库通常相对容易，因为它们是在主语言的范围内使用的。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"在实际开发中，DSL和库可以相互结合使用。DSL可以用于描述领域问题和解决方法，而库可以提供实现这些解决方法所需的功能和代码重用。这样的组合可以提高开发效率和代码的可读性。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/#创建一个语言需要考虑的太多了","page":"写个库还是创个语言","title":"创建一个语言需要考虑的太多了","text":"","category":"section"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"在创建一门新的语言时需要考虑很多因素。下面是一些常见的考虑点，帮助你更好地了解创建一门语言的复杂性：","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"设计目标：明确你创建语言的目的和目标。你是为了解决特定领域的问题还是为了提供一种通用的编程语言？你希望语言具有什么样的特性和表达能力？\n语法和语义：定义语言的语法和语义规则。这涉及到语言的关键词、语句结构、变量声明、函数定义、运算符等等。语法和语义的设计对于语言的可读性、表达能力和易用性至关重要。\n类型系统：决定语言是否需要一个类型系统，以及类型是如何工作的。类型系统可以提供静态类型检查、类型推断、多态性等特性。\n执行模型：选择语言的执行模型，包括解释执行、编译执行或两者的结合。不同的执行模型会影响语言的性能、可移植性和调试能力。\n标准库和生态系统：决定是否需要提供一个标准库以及如何组织和设计它。标准库可以包含常见的功能和数据结构，以方便开发者使用。同时，考虑如何促进社区和第三方库的发展，以建立一个丰富的生态系统。\n工具链和开发环境：为语言提供必要的工具链和开发环境，例如编译器、解释器、调试器、集成开发环境（IDE）等。这些工具对于开发者的便利性和开发体验非常重要。\n学习曲线：考虑语言的学习曲线和易用性。语言应该有足够的文档、教程和示例，使得新的开发者可以快速上手和理解语言的概念。\n社区和支持：鼓励建立一个活跃的社区，并提供支持和资源，以便开发者能够互相交流、分享经验和解决问题。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"请注意，创建一门新的语言是一个复杂的任务，需要深入的计划和设计。在开始之前，建议你进行详细的调研和了解现有的编程语言，以及它们的设计思想和优缺点。这将帮助你更好地理解语言设计的挑战和决策。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/#创建库可利用host语言的一些强大之处","page":"写个库还是创个语言","title":"创建库可利用host语言的一些强大之处","text":"","category":"section"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"创建一个库来利用主语言的强大之处是一种常见的做法，它可以充分利用主语言的生态系统、工具和特性。下面是一些步骤和考虑点，帮助你创建一个库并发挥主语言的优势：","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"确定库的目标和用途：明确库的目标和用途，确定它解决的问题领域和提供的功能。这将有助于你在设计和实现库时保持专注并满足用户需求。\n设计库的API：设计库的应用程序接口（API），即库暴露给用户的函数、类或模块。考虑用户的使用方式和预期的使用场景，设计清晰、简洁和易于理解的API。\n利用主语言的特性：熟悉主语言的特性和功能，充分利用它们来提供库的功能。这可以包括使用主语言的高级数据结构、模块化特性、并发处理、反射机制等等。\n兼容性和依赖管理：确保库与主语言的版本兼容，并遵循主语言的最佳实践和规范。如果库依赖于其他第三方库或工具，建议使用主语言的依赖管理机制来管理这些依赖关系。\n文档和示例：编写清晰、详细的文档，并提供示例代码和用法说明。文档应该包括库的功能、API参考、使用指南和常见问题解答，以帮助用户快速上手和使用你的库。\n测试和质量保证：实施全面的测试策略，包括单元测试、集成测试和性能测试，以确保库的质量和稳定性。遵循主语言的测试框架和最佳实践，保证库的正确性和可靠性。\n社区和支持：鼓励用户反馈和贡献，并提供支持渠道，例如邮件列表、论坛或社交媒体。建立一个活跃的社区有助于库的发展、改进和推广。\n发布和版本管理：选择适当的方式发布你的库，例如发布到包管理系统、代码仓库或云服务。使用版本管理工具对库进行版本控制，并遵循主语言的版本管理约定和流程。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"创建一个库可以大大提高代码的可重用性和开发效率。通过利用主语言的强大之处，你可以利用其丰富的生态系统和工具来构建高质量的库。同时，积极参与社区并与其他开发者互动，可以帮助你不断改进和提升你的库。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/#Julia可以利用meta.parser和eval","page":"写个库还是创个语言","title":"Julia可以利用meta.parser和eval","text":"","category":"section"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"Julia是一门功能强大的编程语言，具有许多强大的特性和工具。在Julia中，你可以利用meta.parser和eval来执行动态代码生成和求值。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"meta.parser是Julia中的一个模块，它提供了用于解析Julia代码的函数和工具。你可以使用它将字符串形式的代码转换为可执行的Julia表达式或抽象语法树（AST）。通过解析代码，你可以检查和操作代码的结构，从而实现动态代码生成。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"eval函数是Julia的内置函数，它用于执行Julia代码。你可以将解析得到的表达式或AST传递给eval函数，它会在当前的执行环境中动态地求值和执行代码。这使得你可以在运行时生成和执行代码，实现动态编程的能力。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"下面是一个简单的示例，演示了如何使用meta.parser和eval在Julia中进行动态代码生成和求值：","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"using meta.parser\n\n# 解析代码并生成表达式\ncode = \"println(\\\"Hello, World!\\\")\"\nexpr = Meta.parse(code)\n\n# 执行表达式\neval(expr)  # 输出：Hello, World!","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"上述示例中，我们使用meta.parser模块中的Meta.parse函数将字符串代码解析为表达式，然后通过eval函数在运行时执行该表达式，打印出\"Hello, World!\"。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"需要注意的是，动态代码生成和求值是一项强大但潜在危险的功能。在使用eval执行动态代码时，应谨慎处理用户输入和防止代码注入等安全问题。确保只执行可信任的代码，并对外部输入进行适当的验证和过滤，以避免潜在的安全风险。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"总之，Julia的meta.parser和eval提供了强大的动态代码生成和求值功能，使你能够在运行时动态地生成和执行代码，从而增强了语言的灵活性和表达能力。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/#我们倾向于写库而不非创立dsl","page":"写个库还是创个语言","title":"我们倾向于写库而不非创立dsl","text":"","category":"section"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"创建DSL需要投入更多的时间和精力，因为它涉及到设计和实现一个全新的编程语言。而编写库则可以利用现有的主语言和工具，更加便捷地实现特定领域的功能。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"编写库有以下一些优势：","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"利用主语言的生态系统：主语言通常拥有庞大的生态系统，有丰富的第三方库、工具和社区支持。通过编写库，你可以直接利用这些现有的资源，加快开发速度和提高代码质量。\n更容易上手和学习：相比于学习和使用全新的DSL，使用库通常更加容易上手，因为它们借助了主语言的语法和约定。开发者可以更快地理解和使用你的库，从而提高开发效率。\n提供代码的可重用性：编写库可以将常用的功能和模块封装起来，使得开发者可以在不同的项目中重复使用。这样可以减少代码重复，提高代码的可维护性和可测试性。\n更好的与主语言集成：由于库是使用主语言编写的，因此它们与主语言之间的集成更加紧密。开发者可以轻松地在主语言的代码中调用库的函数和类，无需额外的集成工作。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"当然，选择编写库还是创建DSL取决于你的具体需求和目标。如果你的需求更偏向于提供一组通用的功能，与现有的主语言和工具集成，那么编写库可能是一个更合适的选择。而如果你的需求更加特定，需要解决特定领域的问题，并希望提供一种更直观和简洁的表达方式，那么创建DSL可能更适合。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"无论你选择编写库还是创建DSL，都需要考虑到使用者的需求和学习成本，提供清晰的文档和示例，并积极参与社区和提供支持。这样可以增加你的代码被广泛使用和接受的机会。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/#对于系统仿真DAEtools就是个库","page":"写个库还是创个语言","title":"对于系统仿真DAEtools就是个库","text":"","category":"section"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"前面说到的gproms和modelica都是语言。而DAEtools则是个库。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"DAE Tools是一个开源的动态系统建模和仿真工具，用于解决微分代数方程（DAE）和差分代数方程（DDAE）等动态系统的建模和求解问题。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"DAE Tools提供了一个图形化的用户界面，使得用户可以方便地构建和配置复杂的动态系统模型。它支持各种建模元素，包括方程、变量、参数、初始条件、边界条件等。用户可以使用方便的界面来定义系统的结构和行为。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"在模型构建完成后，DAE Tools可以自动生成模型的数学描述，并提供多种数值方法和求解器来求解模型。它支持不同的求解策略和算法，包括隐式和显式方法、变步长方法、混合方法等，以适应不同类型和复杂度的动态系统模型。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"DAE Tools还提供了数据可视化和结果分析的功能，使用户能够直观地观察和分析仿真结果。它支持绘制曲线、制作图表、导出数据等功能，帮助用户深入理解和分析系统的动态行为。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"总的来说，DAE Tools是一个功能丰富的动态系统建模和仿真工具，为用户提供了一种方便和直观的方式来建立、求解和分析动态系统模型。它可以在各种领域中应用，如工程、科学、控制系统等。由于其开源的特性，用户还可以根据自己的需求对其进行定制和扩展。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"它内部就是类，表达变量的、程的，等等各种类。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"DAE Tools的内部结构是基于类和对象的，它使用不同的类来表示模型的各个组成部分，如变量、方程等。下面是DAE Tools的一些核心类和它们的功能：","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"Model（模型类）：Model类是DAE Tools中表示整个系统模型的主要类。它包含了系统中的所有变量、方程、参数等元素的集合，并提供了模型的配置和求解功能。\nVariable（变量类）：Variable类用于表示系统模型中的变量。它包含了变量的名称、初始值、边界条件等属性，并提供了访问和修改变量值的方法。\nEquation（方程类）：Equation类用于表示系统模型中的方程。它包含了方程的数学表达式和约束条件，并提供了对方程进行求解和评估的方法。\nParameter（参数类）：Parameter类用于表示系统模型中的参数。它包含了参数的名称、取值范围等属性，并提供了对参数进行设置和访问的方法。\nSolver（求解器类）：Solver类用于选择和配置模型的求解方法和策略。它提供了各种数值方法和求解算法，如隐式和显式方法、变步长方法等，以便根据模型的特性选择合适的求解器。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"除了上述类之外，DAE Tools还提供了其他辅助类和函数，用于数据处理、结果可视化、模型配置等功能。它们共同协作，使得用户可以方便地构建、求解和分析动态系统模型。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"在使用DAE Tools时，用户通常需要创建一个Model对象，并在该对象上添加变量、方程和参数。然后，通过配置求解器和运行仿真来求解模型。用户可以访问变量和方程的属性，设置初始条件和边界条件，并根据需要进行结果分析和可视化。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"需要注意的是，上述类和其功能的描述只是对DAE Tools的内部结构的简要概述。实际使用时，可能还涉及到更多的类和功能，具体的细节和用法可以参考DAE Tools的官方文档和示例。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/#构建模型获得一个类似于抽象语法树的模型树","page":"写个库还是创个语言","title":"构建模型获得一个类似于抽象语法树的模型树","text":"","category":"section"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"可以将DAE Tools中构建的模型视为一个类似于抽象语法树（AST）的模型树。模型树是一个表示系统模型结构和关系的层次化数据结构。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"在DAE Tools中，你可以使用类来表示模型的各个组成部分，如变量、方程、参数等。这些类之间的关系可以通过组合、引用或其他方式来建立。这样的组织结构形成了一个层次化的模型树，反映了系统模型的结构和依赖关系。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"例如，模型类（Model）可以包含多个变量类（Variable），每个变量类可能包含多个方程类（Equation）。变量和方程之间的关系可以通过在类中的引用或其他方式进行表示。这样的嵌套结构可以反映出模型中的层次关系和依赖关系。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"类似于抽象语法树，模型树提供了一种将系统模型以树状结构组织起来的方式，使得可以方便地遍历、分析和操作模型的各个部分。它可以用于构建、修改和优化模型，以及进行模型验证和求解等操作。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"需要注意的是，尽管模型树在某种程度上类似于抽象语法树，但它们的目的和表示方式可能存在差异。模型树更侧重于描述系统模型的结构和关系，而抽象语法树更侧重于描述源代码的语法结构。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"总的来说，通过将DAE Tools中构建的模型看作一个类似于抽象语法树的模型树，你可以更好地理解和操作系统模型的组织结构和关系，从而更方便地进行建模和仿真。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/#抽象语法树与模型","page":"写个库还是创个语言","title":"抽象语法树与模型","text":"","category":"section"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"理解抽象语法树，理解编程语言的解析与编译，有助于我们构建我们的模型树，处理我们的模型树。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"理解抽象语法树（AST）以及编程语言的解析和编译过程对于构建和处理模型树非常有帮助。抽象语法树是在解析源代码时生成的一种数据结构，它以树状形式表示了源代码的语法结构，从而方便进行语法分析、语义分析和代码生成等操作。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"当你构建模型树时，可以借鉴编程语言解析和编译的一些概念和技术，例如：","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"语法分析：语法分析是将源代码解析为抽象语法树的过程。它涉及到词法分析（将源代码拆分为词法单元）和语法分析（根据语法规则构建抽象语法树）。你可以借助现有的语法分析器或编写自己的解析器来将模型描述转换为模型树。\n语义分析：语义分析是对抽象语法树进行验证和处理的过程。在模型树的构建过程中，你可以进行类似的操作，验证模型的合法性、处理模型的约束条件、检查变量和方程之间的关系等。\n代码生成：代码生成是将抽象语法树转换为可执行代码或其他形式的输出的过程。在处理模型树时，你可能需要将模型树转换为某种可执行的形式，例如生成数值求解器所需的方程描述、生成可视化代码等。\n优化和转换：编程语言编译过程中的优化和转换步骤也可以在模型树中应用。你可以对模型树进行优化，如简化表达式、减少计算量、消除冗余等，以提高模型的效率和求解速度。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"通过借鉴抽象语法树和编程语言解析编译的概念，你可以更好地理解和处理模型树，设计和实现相应的工具和算法，以实现模型的构建、验证、处理和优化等操作。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"需要注意的是，虽然抽象语法树的概念和技术对于构建模型树是有帮助的，但模型树的结构和语义可能与编程语言的抽象语法树略有不同，因为它们服务于不同的目标和领域。因此，在设计和处理模型树时，需要根据具体需求和模型的特性进行适当的调整和扩展。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/#DSL的IDE一般不多","page":"写个库还是创个语言","title":"DSL的IDE一般不多","text":"","category":"section"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"像modelica，虽然是一门相对成熟且使用广泛的dsl，但毕竟小众，强大的ide工具不多。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"Modelica是一门相对成熟和广泛使用的DSL，用于建模和仿真复杂的物理系统。然而，与一些主流编程语言相比，Modelica在IDE工具方面的支持相对较少，这可能是因为Modelica是一门领域特定语言，其使用范围相对较窄，导致工具生态系统的发展相对有限。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"尽管如此，仍然有一些强大的IDE工具可用于Modelica的开发和建模，例如：","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"Dymola：Dymola是一款专门为Modelica设计的商业化IDE工具，提供了丰富的功能，包括模型编辑、仿真、优化和结果分析等。Dymola是Modelica语言的参考实现之一，具有强大的仿真性能和广泛的物理模型库。\nOpenModelica：OpenModelica是一个开源的Modelica建模和仿真环境，提供了跨平台的IDE工具。它支持Modelica的语法高亮、模型编辑、仿真、优化和结果可视化等功能，并具有可扩展性和自定义性。\nJModelica.org：JModelica.org是一个开源的Modelica建模和仿真平台，它提供了一个Python接口和相关工具。它可以与Python生态系统进行集成，并提供强大的模型编译、仿真和优化功能。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"此外，一些通用的编程IDE工具，如Visual Studio Code（使用Modelica插件）、Eclipse（使用OpenModelica插件）等，也可以用于Modelica的开发和编辑。虽然这些通用IDE工具可能不具备特定的Modelica功能，但它们提供了一些基本的编辑和调试功能。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"尽管Modelica的IDE工具相对较少，但随着Modelica的发展和应用，工具生态系统正在逐渐扩展。未来可能会出现更多的IDE工具和插件，以提供更丰富和便捷的Modelica建模和仿真体验。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/#modelica路径太长","page":"写个库还是创个语言","title":"modelica路径太长","text":"","category":"section"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"modelica内嵌了编译、连接、运行等等，路径太长，一般人理解不易。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"Modelica在语言设计和实现上涵盖了编译、连接和运行等多个环节，使得整个过程变得复杂而庞大。这使得对于一般用户来说，理解和掌握Modelica的完整工作流程可能具有一定的挑战性。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"以下是一些导致Modelica路径较长且难以理解的主要原因：","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"多个环节的耦合：Modelica涵盖了多个环节，如模型编写、模型编译、连接生成、仿真运行等。这些环节相互耦合，各自的过程和要求相互依赖，导致整个过程较为复杂。\n系统建模的复杂性：Modelica的主要目标是用于建模和仿真复杂的物理系统。由于这些系统本身的复杂性，对于模型的编写和建模要求也较高，使得整个工作流程变得更加复杂和冗长。\n编译和连接过程的细节：Modelica模型在编译和连接过程中会涉及到许多细节，如变量解析、模型实例化、方程求解、模型连接等。这些细节对于一般用户来说可能较为晦涩，使得整个过程难以理解和跟踪。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"为了帮助减轻这些问题，一些Modelica开发工具和环境提供了用户友好的界面和工作流程，以简化模型的编写和仿真过程。这些工具提供了可视化建模、自动化编译和连接、交互式调试等功能，使得用户能够更方便地使用Modelica进行建模和仿真。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"此外，与Modelica相关的教育和培训资源可以帮助用户更好地理解Modelica的工作原理和应用。通过学习和实践，用户可以逐渐掌握Modelica的工作流程，并更好地应用于实际项目中。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"尽管Modelica路径较长且难以理解，但它仍然是一个强大和广泛应用的建模语言，提供了丰富的功能和建模能力。通过适当的学习和使用，用户可以充分利用Modelica进行复杂系统的建模和仿真。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/#深度继承弊端凸显","page":"写个库还是创个语言","title":"深度继承弊端凸显","text":"","category":"section"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"深度继承指的是类之间多层次的继承关系，这可能导致代码结构复杂、维护困难以及潜在的耦合性问题。相比之下，Go语言采用了一种嵌入式（embedding）的方式，这使得代码结构更简洁、易于理解和维护。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"Go语言的嵌入式是通过类型组合来实现的，它允许一个类型将另一个类型作为其成员，从而获得了被嵌入类型的方法和属性。这种方式避免了深层次的继承链，同时仍然提供了代码重用和扩展的能力。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"使用Go语言的嵌入式方式，你可以实现类似继承的效果，同时避免了深度继承的问题。通过嵌入其他类型，你可以将其方法和属性合并到当前类型中，实现代码的复用和扩展，同时保持代码的简洁性。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"以下是一个简单的示例，演示了Go语言中的嵌入式：","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"type Animal struct {\n    name string\n}\n\nfunc (a *Animal) Speak() {\n    fmt.Printf(\"%s is speaking\\n\", a.name)\n}\n\ntype Dog struct {\n    Animal\n    breed string\n}\n\nfunc main() {\n    d := Dog{\n        Animal: Animal{\n            name: \"Buddy\",\n        },\n        breed: \"Labrador\",\n    }\n\n    d.Speak()  // 输出：Buddy is speaking\n}","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"在上述示例中，Animal类型被嵌入到了Dog类型中。这使得Dog类型自动继承了Animal类型的Speak()方法，并可以直接调用。这样，Dog类型可以访问和使用Animal类型的属性和方法，实现了代码的复用和扩展。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"使用Go语言的嵌入式方式，你可以更灵活地组织和扩展代码，同时避免了深度继承带来的复杂性和耦合性问题。这种方式使得代码结构更清晰，易于理解和维护。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/#modelica继承经常很深","page":"写个库还是创个语言","title":"modelica继承经常很深","text":"","category":"section"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"Modelica中的继承关系有时候可能会很深。Modelica支持多层次的继承，这意味着一个模型可以继承自另一个模型，而被继承的模型又可以继承自其他模型，从而形成深度继承的结构。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"深度继承在某些情况下可能会导致代码结构复杂、可读性降低和维护困难。这是因为深层次的继承关系可能会引入大量的继承链，使得代码结构变得复杂并增加了理解和调试的难度。此外，深度继承还可能导致模型的耦合性增加，使得修改和扩展变得困难。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"对于避免深度继承的问题，你可以考虑使用其他的设计模式或技术来组织和构建模型。一些常见的方法包括：","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"组合和接口：使用组合和接口来替代深层次的继承关系。通过将模型组件化，并使用接口定义它们的行为和交互，可以实现更灵活、可组合的模型结构。\n模型分解和模块化：将大型复杂的模型分解为较小的模块，每个模块负责特定的功能或子系统。这样可以降低模型的复杂性，并更容易理解和维护各个模块。\n基于组件的建模：采用基于组件的建模方法，将模型看作是由各个独立组件组成的网络。每个组件负责特定的功能，并通过连接和交互来实现整体系统的行为。\n参数化建模：使用参数化建模的方式，将模型中的参数和配置与继承关系解耦。通过参数化，可以根据需要对模型进行灵活的配置和扩展，而无需依赖深度继承关系。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"这些方法可以帮助你在Modelica中更好地组织和构建模型，降低复杂性，并提高代码的可读性和可维护性。根据具体的建模需求和系统特性，选择适合的设计模式和技术，以优化模型的结构和开发流程。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/#Ascend也是一个DSL","page":"写个库还是创个语言","title":"Ascend也是一个DSL","text":"","category":"section"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"ASCEND（Advanced System for Process Engineering and Control），它是一个开源的流程模拟和优化工具。ASCEND专注于处理化工、过程工程和系统控制等领域的模型建模、仿真和优化问题。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"ASCEND提供了一种声明式建模语言，使用户能够通过描述系统的方程和约束来定义模型。它支持多种数学方程的表示，如代数方程、微分方程、优化问题等。用户可以使用ASCEND的语言和工具来构建复杂的流程模型，并进行仿真和优化。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"ASCEND的特点和功能包括：","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"声明式建模语言：ASCEND提供了一种基于方程和约束的建模语言，使得用户可以直观地描述系统的行为和约束条件。\n强大的求解能力：ASCEND集成了多种数值方法和求解器，可以处理包括非线性方程、代数方程组、优化问题等在内的复杂数学模型。\n灵活的参数估计和优化：ASCEND支持参数估计和优化，用户可以通过设定目标函数和约束条件，利用内置的优化算法来优化模型的设计和性能。\n可视化和结果分析：ASCEND提供了可视化工具和图形界面，用于展示模型的结构、运行结果和优化结果。用户可以直观地观察和分析模型的行为和性能。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"ASCEND的目标是为化工和过程工程领域提供一个灵活且功能强大的工具，用于模型建模、仿真和优化。它是一个开源项目，因此用户可以根据自己的需求进行定制和扩展。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"需要注意的是，ASCEND在流程模拟和优化领域是相对小众的工具，与一些商业化的流程模拟软件相比，其用户社区和生态系统可能较小。然而，它作为一个开源项目，为用户提供了自由定制和扩展的能力，并且在特定的应用场景中可能具有一定的优势和适用性。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"ASCEND可以被视为一种领域特定语言（DSL），专门用于处理化工、过程工程和系统控制等领域的模型建模、仿真和优化问题。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"DSL是一种针对特定领域或特定问题的编程语言，旨在提供更高层次的抽象和表达能力，以便更容易地解决该领域或问题的挑战。ASCEND的建模语言是为流程模拟和优化而设计的，提供了方便和直观的方式来描述和解决化工和过程工程的模型问题。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"与通用编程语言相比，DSL通常更关注于特定领域的问题和概念，提供了更直接的语法和语义来表达和处理相关的概念。DSL的设计目标是使领域专家能够更容易理解和编写与其领域相关的代码。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"ASCEND的DSL提供了一种声明式的建模方式，以方程和约束为基础，表达了化工和过程工程系统的行为和约束条件。它的语法和语义特定于这些领域，使得用户能够以直观且自然的方式表达模型，并能够使用内置的求解器和优化算法求解模型问题。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"通过使用DSL，ASCEND提供了一个专门用于流程模拟和优化的环境，使得建模者能够更专注于领域问题而不必关注底层的技术细节。这种针对特定领域的DSL设计有助于提高模型的可读性、可维护性和可扩展性。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"总结来说，ASCEND可以被看作是一种用于化工和过程工程的领域特定语言（DSL），它提供了专门解决这些领域模型建模、仿真和优化问题的语法和工具。通过使用DSL，ASCEND简化了模型的描述和求解过程，提高了领域专家的建模效率和可表达性。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/#在多数场景DSL不如库","page":"写个库还是创个语言","title":"在多数场景DSL不如库","text":"","category":"section"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"DSL（领域特定语言）和库在软件开发中具有不同的作用和优势。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"DSL是一种专门针对特定领域或问题而设计的语言，目的是提供一种更高级、更直观的抽象层，以解决该领域或问题的挑战。DSL可以提供专门的语法和语义，使领域专家能够更容易地表达和处理特定领域的概念和逻辑。它的设计目标是简化领域特定问题的解决，提高开发效率和可读性。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"库（Library）则是一组可重用的代码和函数的集合，提供了一系列功能和工具，用于解决通用或特定的编程问题。库通常由一组API（应用程序编程接口）组成，开发者可以调用其中的函数和方法，以实现特定功能。库的优势在于提供了广泛的功能和灵活性，使开发者能够根据需要选择和组合不同的库，构建出适合自己需求的解决方案。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"在比较DSL和库时，以下是一些可以考虑的观点：","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"领域特定性：DSL更适用于解决特定领域或问题的挑战，因为它可以提供特定领域的语法和语义。而库更通用，可以用于解决各种编程问题。\n可读性和可表达性：DSL的设计目标是提供更高级和直观的抽象，使领域专家能够更容易理解和编写相关代码。而库的使用可能需要更多的编程知识和理解。\n灵活性和扩展性：库通常提供了一系列功能和工具，使开发者能够自由组合和扩展库的功能，以满足特定需求。DSL则更注重在特定领域内提供一种固定的语法和语义。\n学习和开发成本：使用DSL可能需要一定的学习成本，因为开发者需要熟悉DSL的语法和概念。而使用库可能更容易上手，因为开发者可以直接调用库的API，利用已有的知识和经验进行开发。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"需要注意的是，DSL和库并不是相互排斥的选择，而是在不同的场景和需求下可能更适合的工具。在某些情况下，使用DSL可以提供更直观和高效的解决方案；而在其他情况下，使用库可以提供更广泛和灵活的功能。","category":"page"},{"location":"CSAdv/8-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"最终选择使用DSL还是库，取决于具体的需求、领域特点和开发团队的技术能力。在决策时，可以根据需求进行评估，并综合考虑开发成本、可维护性和可扩展性等因素。","category":"page"},{"location":"Simulation/MTK_heattran/#MTK手动空间离散求解PDE","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"tip: Tip\nContents：MTK、PDE、手动空间离散Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"note: Note\nMTK = ModelingToolkit.jlPDE = Partial Differential EquationModelingToolkit.jl 符号建模包","category":"page"},{"location":"Simulation/MTK_heattran/#MTK的PDE求解技巧","page":"MTK手动空间离散求解PDE","title":"MTK的PDE求解技巧","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"在之前介绍的例子中，所有的微分都是基于时间的微分。从数学的角度来说，微分变量只有一个。而对于有多个微分变量的PDE问题，能否通过MTK手动求解呢？例如，对时间对空间微分的PDE问题。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"答案是肯定的。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"求解PDE的数值方法有这么几步：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"建立数学描述方程\n对变量进行离散\n迭代求解","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"MTK用法中，提供了基于时间的一条龙求解。至于多变量的PDE，也有对应的PDESystem。但是目前来说，PDESystem还不是很完善。其离散方法涉及NeuralPDE.jl的相关内容。就MTK.jl本身来说，没有打通PDE的建模与求解过程。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"所以，使用MTK求解PDE的缺口在于，没有针对其它变量的离散——空间离散。那么，如果我们能够手动完成空间离散，这个问题就解决了。事实上，手动空间离散是可行的。","category":"page"},{"location":"Simulation/MTK_heattran/#数值传热学实例","page":"MTK手动空间离散求解PDE","title":"数值传热学实例","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"考虑一个正方形铸件的散热过程，正方形铸件初始温度1000℃，环境温度为0℃。如图","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"(Image: 图 1)  ","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"传热的控制方程为：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"rho c_p fracpartial Tpartial t=lambda(fracpartial^2 Tpartial x^2 +fracpartial^2 Tpartial y^2)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"将参数统一在等式右端，即","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"fracpartial Tpartial t=a(fracpartial^2 Tpartial x^2+fracpartial^2 Tpartial y^2)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"其中，","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"rho密度单位为frackgm^3","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"c_p物体热容单位为fracJkgcdot k","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"lambda导热系数单位为fracWmcdot k","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"a热扩散系数单位为fracm^2s","category":"page"},{"location":"Simulation/MTK_heattran/#内部节点空间离散","page":"MTK手动空间离散求解PDE","title":"内部节点空间离散","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"对方程进行空间离散，采用二阶中心差分，有：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"fracpartial T_ijpartial t=a (fracT_i+1 j^n- 2 T_i j^n+T_i-1 j^nDelta x^2+fracT_i j+1^n- 2 T_i j^n+T_i j-1^nDelta y^2)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"若使用化简表达，","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"Delta x = Delta y = deltaT_i j=T_PT_i+1 j=T_WT_i-1 j=T_ET_i j-1=T_NT_i j+1=T_S","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"则有内部节点的空间离散：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"fracpartial Tpartial t=fracadelta^2(T_W^n+T_E^n+T_N^n+T_S^n - 4T_P^n)","category":"page"},{"location":"Simulation/MTK_heattran/#边边界空间离散","page":"MTK手动空间离散求解PDE","title":"边边界空间离散","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"下面考虑边界条件。以W边为例。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"(Image: 图 2)  ","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"边界条件使用第三类边界条件。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"delta h(T_f-T_W^n)=delta lambda fracT_W^n-T_P^nfracdelta2","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"为了消去T_W^n，考虑该式子的等比式：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"frac(T_f-T_W^n)frac1h=fracT_W^n-T_P^nfracdelta2 lambda=frac(T_f-T_P^n)frac1h+fracdelta2 lambda taga","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"note: Note\n当对流散热系数h足够大时，frac2lambdadelta happrox0，即T_W approx T_f。第三类边界条件可以近似为第一类边界条件——壁温恒定为环境温度，如下式推导：T_W=frach T_f+frac2 lambdadelta T_P^nh+frac2 lambdadelta=fracT_f+frac2 lambdadelta h T_P^n1+frac2 lambdadelta h approx T_f这是从数学上的一种理解，后面并没使用到该近似。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"对边界采用附加源法进行分析。T_W为边界点温度，T_P节点的能量守恒方程为：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"beginarraycdelta lambda fracT_E^n-T_P^ndelta+delta lambda fracT_N^n-T_P^ndelta+delta lambda fracT_S^n-T_P^ndelta+delta lambda fracT_W^n-T_P^nfracdelta2=rho c delta^2 fracpartial T_Ppartial tendarray","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"将式(a)的第三项代入上式中的T_W-T_P项并化简，最终能得到边边界的边界方程：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"beginarraycfracpartial T_Ppartial t=fraca delta^2(T_E^n+T_N^n + T_S^n)-(fracafraclambda deltah+fracdelta^22+frac3 a delta^2) T_P^n+fraca fraclambda deltah+fracdelta^22 T_fendarray","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"同理可得其它3个边的边边界方程。","category":"page"},{"location":"Simulation/MTK_heattran/#角边界空间离散","page":"MTK手动空间离散求解PDE","title":"角边界空间离散","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"最后考虑角边界。以铸件左上角为例进行分析，下如图所示的角边界。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"(Image: 图 3)  ","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"分析方法同边边界的分析方法，最后可得：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"fracpartial T_Ppartial t=fracadelta^2(T_E^n+T_N^n+T_S^n)-(fracafraclambda deltah+fracdelta^22+frac2adelta^2) T_P^n+frac2afraclambda deltah+fracdelta^22 T_f","category":"page"},{"location":"Simulation/MTK_heattran/#离散方程汇总","page":"MTK手动空间离散求解PDE","title":"离散方程汇总","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"经过以上推导，得到了内节点表达式、边边界表达式和角边界表达式。为了方便程序表达，对方程的系数进行化简，令，","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"A = fracadelta^2B = fracafraclambdadeltah+fracdelta^22","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"note: Note\n当h很大时，fraclambda deltahapprox 0，所以B approx 2A。和前面边界条件的理解相似。同样的，这只是一种理解方式，并没有使用。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"内节点：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"fracpartial T_Ppartial t=A(T_W^n+T_E^n+ T_N^n+T_S^n - 4T_P^n)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"边边界节点：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"fracpartial T_Ppartial t=A(T_W^n+T_N^n+T_S^n)-(B+3A)T_P^n+BT_f","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"角边界节点：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"fracpartial T_Ppartial t=A(T_E^n + T_N^n )-(2B+2A)T_P^n+2BT_f","category":"page"},{"location":"Simulation/MTK_heattran/#求解实例","page":"MTK手动空间离散求解PDE","title":"求解实例","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"求解的全部代码如下：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"using ModelingToolkit, DifferentialEquations\n\n# 参数设定\na = 1.27E-5\nn = 10\nL = 0.2\nδ = L / n\nλ = 50\nh = 1.0E9\nTf = 0.0\nA = a / δ^2\nB = a / (δ^2 / 2 + δ * λ / h)\n\n@variables t (T(t))[1:n, 1:n]\n\nD = Differential(t)\n\n# 内节点代码\ninsides = [\n    D(T[i, j]) ~ A * (T[i+1, j] + T[i-1, j] + T[i, j+1] + T[i, j-1] - 4 * T[i, j])\n    for i in 2:n-1 for j in 2:n-1]\n\n# 边边界代码\nWb = [\n    D(T[i, 1]) ~ A * (T[i+1, 1] + T[i-1, 1] + T[i, 2]) - (3B + A) * T[i, 1] + B * Tf\n    for i in 2:n-1\n]\nEb = [\n    D(T[i, n]) ~ A * (T[i+1, n] + T[i-1, n] + T[i, n-1]) - (3B + A) * T[i, n] + B * Tf\n    for i in 2:n-1\n]\nNb = [\n    D(T[1, i]) ~ A * (T[1, i+1] + T[1, i-1] + T[2, i]) - (3B + A) * T[1, i] + B * Tf\n    for i in 2:n-1\n]\nSb = [\n    D(T[n, i]) ~ A * (T[n, i+1] + T[n, i-1] + T[n-1, i]) - (3B + A) * T[1, i] + B * Tf\n    for i in 2:n-1\n]\n\n# 4 corner boundary\ncorner = [\n    D(T[1, 1]) ~ A * (T[2, 1] + T[1, 2]) - (2B + 2A) * T[1, 1] + 2B * Tf,\n    D(T[n, n]) ~ A * (T[n-1, n] + T[n, n-1]) - (2B + 2A) * T[n, n] + 2B * Tf,\n    D(T[n, 1]) ~ A * (T[n, 2] + T[n-1, 1]) - (2B + 2A) * T[n, 1] + 2B * Tf,\n    D(T[1, n]) ~ A * (T[2, n] + T[1, n-1]) - (2B + 2A) * T[1, n] + 2B * Tf\n]\n\neqs = append!(insides, Wb, Eb, Nb, Sb, corner)\n\n@named sys = ODESystem(eqs, t)\n\nsys = structural_simplify(sys)\n\n# u0 = [1000.0 for i in 1:n for j in 1:n]\nu0 = Dict(T[i, j] => 1000.0 for i in 1:n for j in 1:n)\nprob = ODEProblem(sys, u0, (0, 100), [], saveat=0.1)\nsol = solve(prob, Tsit5())\n","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"值得一提的是：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"MTK变量定义:","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"这是有效的变量数组（矩阵）的定义方式，也就是说MTK支持变量数运算。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"@variables t (T(t))[1:n, 1:n]","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"ODESystem定义","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"ODESystem定义时，既没有传递变量，也没有传递参数，甚至连t也可以不用传递，这都是可行的。ODESystem定义时能够自动检查（check）方程结构，从方程中获得变量信息。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"@named sys = ODESystem(eqs, t)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"tip: Tip\nODESystem定义时，若传递变量数组或者参数数组，check时不能通过。目前来说这是一个bug，所以可以不写。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"MTK初值设定","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"初值或者参数传递时，以下两种方式都可以。但也有区别。在符号计算中，符号在数组中的位置是不确定的。假如以数组的形式传递进去，那么就不知道哪个初值传递给了哪个变量（如果初值或参数都相同那就无所谓）。所以，初值传递需要精确到变量时，最好使用Dict。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"\nu0 = [1000.0 for i in 1:n for j in 1:n]\n\nu0 = Dict(T[i, j] => 1000.0 for i in 1:n for j in 1:n)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"saveat","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"saveat是solution handle中的内容。其作用是使sol中结果存储结果的时间步长为给定步长。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"当然，也可以使用sol()获得任意时刻的值。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"sol(2.5)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"但是这样会丢失变量的顺序，就是无法得知变量与数值的对应关系了。能否解决这个问题，这里还有许多可测试与探索的空间。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"page"},{"location":"Simulation/MTK_heattran/#可视化","page":"MTK手动空间离散求解PDE","title":"可视化","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"tip: Tip\nJulia生态中，可视化也是很强的！Plots.ji远比想象的强大！","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"最后，动画走你！","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"an_len= length(sol[T[1,1]])\nusing Plots, GR\nres = rand(n,n,an_len)\nfor t in 1:an_len\n    for i in 1:n\n        for j in 1:n\n            res[i,j,t] = sol[T[i,j]][t]\n        end\n    end\nend\nxs = LinRange(0.0, L, n)\nys = LinRange(0.0, L, n)\ncontourf!(xs, ys, res[:,:,10])\nanim = @animate for i ∈ 1:50\n    contourf!(xs, ys, res[:,:,i])\nend\ngif(anim, \"anim.gif\", fps = 24)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"(Image: )","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"物体温度是下降的，在不断散热。","category":"page"},{"location":"#Ai4EDocs","page":"Home","title":"Ai4EDocs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: 图 4)  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"tip: Tip\n智慧能源：从概念到实践 \nOptControl.jl 对MTK中ODESystem的最优控制支持包。\nAi4ELab 虚拟仿真实验室\nAi4EComponentLib.jl 组件库\nAi4EMetaPSE.jl 微分方程的Json文件解析器\nAi4Server 基于Genie.jl架构的Ai4E后端服务框架。","category":"page"},{"location":"#Ai4EDocs简介","page":"Home","title":"Ai4EDocs简介","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ai4EDocs是Ai4E小组在学习中整理的一些可操作案例。案例的核心主要与建模仿真优化控制相关。文档主要特点为：","category":"page"},{"location":"","page":"Home","title":"Home","text":"既有数学层面的探究，也包含了应用层面的案例。\n包含大量Julia生态中软件包的使用\n兼顾建模仿真优化控制核心与拓展\n分享对理论抽象问题的认识\n分享软件使用过程中的技巧\n分享学习的心路历程与对库使用的理解\nAi4Energy组的合作开发流程","category":"page"},{"location":"","page":"Home","title":"Home","text":"供学习参考。","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable)","category":"page"},{"location":"","page":"Home","title":"Home","text":"欢迎贡献文档！","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable)","category":"page"},{"location":"#文档内容","page":"Home","title":"文档内容","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"dirs = [\"Frameworks\",\"Modeling\",\"Simulation\",\"Optimization\",\"Control\",\"CSBase\",\"JuliaIntro\",\"IotBigdataCloud\",\"CSAdv\",\"AIandML\",\"Tools\",\"WorkFlow\"]\n\n\"总篇数：$(sum(map(file -> length(readdir(joinpath(@__DIR__,\"..\",\"src\",file))), dirs)))\"","category":"page"},{"location":"#编程基础入门知识","page":"Home","title":"编程基础入门知识","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"CSBase\", file), readdir(\"CSBase\"))","category":"page"},{"location":"#Julia入门","page":"Home","title":"Julia入门","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"JuliaIntro\", file), readdir(\"JuliaIntro\"))","category":"page"},{"location":"#理解计算进阶","page":"Home","title":"理解计算进阶","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"CSAdv\", file), readdir(\"CSAdv\"))","category":"page"},{"location":"#建模","page":"Home","title":"建模","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"Modeling\", file), readdir(\"Modeling\"))","category":"page"},{"location":"#仿真","page":"Home","title":"仿真","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"Simulation\", file), readdir(\"Simulation\"))","category":"page"},{"location":"#优化","page":"Home","title":"优化","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"Optimization\", file), readdir(\"Optimization\"))","category":"page"},{"location":"#控制","page":"Home","title":"控制","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"Control\", file), readdir(\"Control\"))","category":"page"},{"location":"#人工智能与机器学习","page":"Home","title":"人工智能与机器学习","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"AIandML\", file), readdir(\"AIandML\"))","category":"page"},{"location":"#物联网、大数据和云计算","page":"Home","title":"物联网、大数据和云计算","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"IotBigdataCloud\", file), readdir(\"IotBigdataCloud\"))","category":"page"},{"location":"#Ai4Energy系统框架","page":"Home","title":"Ai4Energy系统框架","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"Frameworks\", file), readdir(\"Frameworks\"))","category":"page"},{"location":"#Golang简介","page":"Home","title":"Golang简介","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"GolangIntro\", file), readdir(\"GolangIntro\"))","category":"page"},{"location":"#StepByStep练习","page":"Home","title":"StepByStep练习","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"StepByStep\", file), readdir(\"StepByStep\"))","category":"page"},{"location":"#附录之工具准备","page":"Home","title":"附录之工具准备","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"Tools\", file), readdir(\"Tools\"))","category":"page"},{"location":"#附录之工作流程","page":"Home","title":"附录之工作流程","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"WorkFlow\", file), readdir(\"WorkFlow\"))","category":"page"},{"location":"#附录之Julia资源传送门","page":"Home","title":"附录之Julia资源传送门","text":"","category":"section"},{"location":"#基础文档","page":"Home","title":"基础文档","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia中文文档\nJulia官方文档\nSciml总站","category":"page"},{"location":"#数值计算","page":"Home","title":"数值计算","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DifferentialEquations.jl（常微分方程求解包）\nNeuralPDE.jl（偏微分方程求解包）\nJuMP.jl（优化求解器包）\nDiffEqParamEstim.jl（基于DE的参数辨识包）\nFlux.jl Julia机器学习包(The Julia Machine Learning Library)\nEquationsSolver 自制的小型方程（组）求解器\nOptimization.jl(Sciml优化包)","category":"page"},{"location":"#符号计算","page":"Home","title":"符号计算","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ModelingToolkit.jl（符号建模包）\nSymbolics.jl（MTK依赖的符号求解包）\nSymPy.jl 符号计算包（可求方程解析解），与Matlab中的符号工具包类似","category":"page"},{"location":"#计算图形学","page":"Home","title":"计算图形学","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Meshes.jl 纯Julia的CGAL（计算图形学算法库）实现\nGmsh.jl gmsh的Julia接口","category":"page"},{"location":"#数据处理","page":"Home","title":"数据处理","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FileIO.jl Julia中不同类型文件读入的统一接口（包括MeshIO）\nCSV.jl\nDataFrames.jl（大规模数据批量处理包）\nUnitful（单位计算包）\nJSON3.jl JSON到类型的读入\nJSON.jl","category":"page"},{"location":"#可视化","page":"Home","title":"可视化","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Plots.ji（可视化包）\nPkg.jl 包管理\nMakie.jl 高性能绘图包。\nPlotlyJS.jl 网页绘图，图可拖动。","category":"page"},{"location":"#WEB框架","page":"Home","title":"WEB框架","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Geine.jl and Stipple.jl Julia Web 框架Geine和Stipple的文档\nHTTP.jl","category":"page"},{"location":"#附录之其它资源传送门","page":"Home","title":"附录之其它资源传送门","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CoolProp\nAPMonitor-github\nAPMonitor\nGreet\nMqtt系列教程\nMixed Integer Distributed Ant Colony Optimization(midaco-solver)","category":"page"},{"location":"Optimization/4-优化问题的求解过程/#优化问题的求解过程","page":"优化问题的求解过程","title":"优化问题的求解过程","text":"","category":"section"},{"location":"Optimization/4-优化问题的求解过程/","page":"优化问题的求解过程","title":"优化问题的求解过程","text":"优化问题的求解过程是一个复杂而动态的过程，可以根据具体问题和实践经验进行不同的改进和优化。以下是一些更深入的认识和注意事项：","category":"page"},{"location":"Optimization/4-优化问题的求解过程/","page":"优化问题的求解过程","title":"优化问题的求解过程","text":"决策变量的选择： 决策变量的选择对于问题的建模和求解至关重要。合理的决策变量选择可以简化问题的复杂性、提高求解效率，并确保决策变量与问题的实际需求相匹配。\n约束条件的建模： 约束条件的正确建模对问题的可行性和解的质量至关重要。约束条件应该准确地描述问题的限制，并尽量避免冗余或不必要的约束。合适的约束条件建模可以提高求解效率和精度。\n目标函数的定义： 目标函数的定义应准确反映问题的优化目标，并与约束条件相一致。在定义目标函数时，需要权衡不同的优化目标，并根据实际需求选择合适的目标函数形式。\n优化算法的选择： 不同的优化问题可能需要不同的优化算法来求解。在选择优化算法时，需要考虑问题的性质（如线性、非线性、凸性等）、约束条件的复杂性、求解时间要求等因素。了解各种优化算法的优劣势，并结合问题的特点进行选择。\n初始解和参数设置： 优化算法的求解结果很大程度上依赖于初始解和参数设置。提供一个合适的初始解可以加速求解过程，并有助于避免陷入局部最优解。此外，合适的参数设置也可以提高算法的收敛性和稳定性。\n结果分析和验证： 在获得优化结果后，对结果进行详细的分析和验证是十分重要的。验证结果是否满足约束条件，对决策变量的物理可行性进行检查，并评估结果的合理性和可行性。结果分析的准确性和深入程度可以提供更全面的洞见和决策支持。\n敏感性分析和场景分析： 通过敏感性分析和场景分析，可以评估决策变量对目标函数的敏感性，了解参数变化对结果的影响，并帮助识别问题的脆弱性和潜在风险。这有助于制定鲁棒和可持续的决策方案。","category":"page"},{"location":"Optimization/4-优化问题的求解过程/","page":"优化问题的求解过程","title":"优化问题的求解过程","text":"总之，优化问题的求解是一个迭代的过程，需要不断优化和改进。随着对问题的理解和经验的积累，可以更好地把握求解过程中的关键要素，并获得更准确、可行的解决方案。","category":"page"},{"location":"JuliaIntro/91- julia-binary-wrappers/#julia对外部程序的加壳","page":"julia对外部程序的加壳","title":"julia对外部程序的加壳","text":"","category":"section"},{"location":"JuliaIntro/91- julia-binary-wrappers/","page":"julia对外部程序的加壳","title":"julia对外部程序的加壳","text":"前面我们讲了julia可以很方便的调用外部的动态链接库中的函数。有很多的外部的库都可以编译成动态链接库，然后写个julia函数去调用。但是编译这些外部库，在不同的环境下还是要做很多的设置的。julia的JuliaBinaryWrappers组织做了很多基础的工作，维护很多外部程序编译的要求。","category":"page"},{"location":"JuliaIntro/91- julia-binary-wrappers/","page":"julia对外部程序的加壳","title":"julia对外部程序的加壳","text":"比如https://github.com/JuliaBinaryWrappers/CoolPropjll.jl，在其src/wrappers目录中是不用的平台（linux、windows、macosx）和不同的编译器组合对应的编译规则文件。实际上我们不用管那么多，只需要知道我们如果add CoolPropjll包就会调用合适脚本去抓取源码，然后编译成对应的动态链接库。实际上这些代码也都是由BinaryBuilder.jl自动产生的，不是手动维护的。","category":"page"},{"location":"JuliaIntro/91- julia-binary-wrappers/","page":"julia对外部程序的加壳","title":"julia对外部程序的加壳","text":"进一步的则可以写一个wrapper把所要的函数写个接口暴露出来。如https://github.com/CoolProp/CoolProp.jl，就是依赖了CoolProp_jll，把libcoolprop给加载了，然后写好了函数的接口。仅此而已。","category":"page"},{"location":"JuliaIntro/91- julia-binary-wrappers/","page":"julia对外部程序的加壳","title":"julia对外部程序的加壳","text":"类似的做法还有很多， 比如SCIP、Ipopt等等。他们的编译设置文件也都是由BinaryBuilder.jl自动产生的，不是手动维护的。","category":"page"},{"location":"JuliaIntro/91- julia-binary-wrappers/","page":"julia对外部程序的加壳","title":"julia对外部程序的加壳","text":"核心要义是理解这个工作方式和流程。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#PowerShell和Windows-Terminal","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#PowerShell初印象","page":"PowerShell和Windows Terminal","title":"PowerShell初印象","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"新时代，Windows也在向Linux学习。它现在有了新的强大命令行工具，PowerShell。并且微软现在赋予了它强大的命令行下管理能力。很多修改电脑的设置都可以在PowerShell下使用命令来完成。比如说在Windows下安装WSL（Windows Subsystem for Linux）就可以用管理员打开PowerShell，通过wsl --install命令来完成。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"另外，PowerShell可以 先以管理员执行Set-ExecutionPolicy RemoteSigned，再在配置文件中设置Set-PSReadLineOption -EditMode emacs来开启Emacs键绑定，从而可以使用ctrl+e等命令进行光标快速移动。这一点仅仅是可以提高输入效率，可以先忽略。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#PowerShell简介","page":"PowerShell和Windows Terminal","title":"PowerShell简介","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"PowerShell 是一种强大的命令行工具和脚本语言，由 Microsoft 开发并广泛用于管理和自动化 Windows 系统和任务。与传统的命令提示符（CMD）相比，PowerShell 提供了更丰富的功能和更直观的语法，使系统管理员和开发人员能够更高效地管理和操作计算机系统。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"以下是一些 PowerShell 的特点和功能：","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"对象导向：PowerShell 基于对象导向的编程模型，可以使用和操作.NET Framework 中的对象。这使得在 PowerShell 中处理数据和执行操作更加灵活和直观。\n强大的命令和模块：PowerShell 提供了大量的内置命令，称为 cmdlet，用于执行各种系统管理任务。这些 cmdlet 具有一致的命名约定和参数结构，使得编写和执行命令更加简单和可预测。此外，PowerShell 还支持模块化，您可以导入和使用其他人编写的模块来扩展其功能。\n脚本和自动化：PowerShell 是一种脚本语言，可以编写和执行脚本文件以自动化重复的任务或进行批量操作。使用 PowerShell 脚本，您可以创建复杂的工作流程，处理和转换数据，访问系统资源，管理用户和权限等。\n远程管理：PowerShell 提供了强大的远程管理功能，可以通过网络远程管理其他计算机或服务器。您可以在本地计算机上使用 PowerShell 命令来执行远程计算机上的任务，访问远程计算机的文件和注册表，或者执行远程会话。\n跨平台支持：除了 Windows 系统外，PowerShell 还提供了跨平台支持，可以在 macOS、Linux 和其他操作系统上运行。这使得使用 PowerShell 进行系统管理和自动化成为跨平台环境中的一种强大工具。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"PowerShell 是一项功能强大且灵活的技术，可以用于各种任务，从简单的命令执行到复杂的系统管理和自动化。它是系统管理员、开发人员和 IT 专业人员的重要工具之一，提供了更高效、一致和可编程的方式来管理计算机系统。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#如何打开PowerShell","page":"PowerShell和Windows Terminal","title":"如何打开PowerShell","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"在 Windows 操作系统中，有几种方式可以打开 PowerShell。以下是其中一些常见的方法：","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"使用开始菜单：\n单击桌面左下角的 Windows 图标来打开开始菜单。\n在开始菜单中，找到 \"Windows PowerShell\" 或 \"PowerShell\" 的文件夹。在该文件夹中，您将找到不同版本的 PowerShell，如 PowerShell、PowerShell 7、PowerShell 5.1 等。\n点击所需的 PowerShell 版本，将打开 PowerShell 窗口。\n使用快捷键：\n按下 Windows 键 + R 组合键，将打开 \"运行\" 对话框。\n在 \"运行\" 对话框中，键入 \"powershell\"（不包括引号）并按下回车键，将打开 PowerShell 窗口。\n使用 CMD 启动 PowerShell：\n打开命令提示符（CMD）窗口。您可以按下 Windows 键 + R，然后键入 \"cmd\"（不包括引号）并按下回车键，或者按照我之前所述的步骤在开始菜单中找到并打开命令提示符。\n在命令提示符窗口中，键入 \"powershell\"（不包括引号）并按下回车键，将从 CMD 切换到 PowerShell。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"无论您选择哪种方法，都将打开一个 PowerShell 窗口，您可以在其中输入和执行 PowerShell 命令、编写和运行 PowerShell 脚本，以及进行系统管理和自动化任务。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#PowerShell可以执行Windows管理任务吗？","page":"PowerShell和Windows Terminal","title":"PowerShell可以执行Windows管理任务吗？","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"PowerShell 是一种功能强大的工具，可以执行大部分 Windows 系统管理任务，但并不是所有任务都可以完全由 PowerShell 完成。大多数 Windows 管理任务都可以通过 PowerShell 来实现，因为它提供了广泛的系统管理 cmdlet 和功能。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"以下是 PowerShell 可以执行的常见任务：","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"文件和文件夹操作：PowerShell 可以创建、复制、移动和删除文件和文件夹，以及管理文件和文件夹的权限和属性。\n进程和服务管理：PowerShell 可以列出、启动、停止和监控正在运行的进程和服务。\n注册表操作：PowerShell 可以读取、修改和删除 Windows 注册表中的键值。\n网络配置和管理：PowerShell 可以配置网络适配器、查看和修改网络设置，以及执行网络诊断任务。\n用户和组管理：PowerShell 可以创建、修改和删除用户账户和组，管理用户权限和访问控制。\n远程管理：PowerShell 提供了强大的远程管理功能，可以通过网络远程管理其他计算机或服务器。\n脚本编写和自动化：PowerShell 是一种脚本语言，可以编写脚本来自动化重复的任务，批量操作和工作流程。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"尽管 PowerShell 能够处理大多数 Windows 管理任务，但仍有一些特定任务可能需要使用其他工具或界面。一些特定的系统配置、管理工具或应用程序可能具有自己的命令行界面或API，需要使用专门的工具或命令来执行相关任务。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"综上所述，PowerShell 是一个非常强大和全面的工具，能够执行大部分 Windows 系统管理任务。但对于某些特定的任务，您可能需要使用其他工具或结合多种工具来实现所需的功能。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#Windows-Terminal简介","page":"PowerShell和Windows Terminal","title":"Windows Terminal简介","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"Windows Terminal 是一款新一代的命令行工具，由 Microsoft 开发并在 Windows 操作系统中提供。它为用户提供了一个现代化、高度可定制的命令行界面，使得同时使用多个命令行工具和 Shell 变得更加方便和强大。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"下面是 Windows Terminal 的一些特点和功能：","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"多标签和分屏：Windows Terminal 支持多个标签页和分屏布局，您可以在同一个窗口中同时打开多个命令行会话，方便同时进行多个任务或操作。\n支持多种 Shell：Windows Terminal 可以同时运行多个不同的 Shell，如 PowerShell、命令提示符（CMD）、Windows Subsystem for Linux (WSL)、Azure Cloud Shell 等。这使得用户可以根据需要选择不同的 Shell，而无需切换窗口或应用程序。\n高度可定制：Windows Terminal 允许用户自定义外观、颜色主题、字体、快捷键等，以满足个人偏好和风格需求。用户可以根据自己的喜好创建和应用自定义配置文件，定制 Terminal 的外观和行为。\n支持 Unicode 和 Emoji：Windows Terminal 全面支持 Unicode 字符和 Emoji 表情符号，使得在命令行界面中可以正确显示和处理各种语言字符和图形符号。\nGPU 加速和图形效果：Windows Terminal 基于 Windows 的 Universal Windows Platform (UWP) 技术，可以利用 GPU 加速和硬件加速，提供流畅的滚动、动画效果和图形渲染。\n快速启动和分层渲染：Windows Terminal 采用了快速启动机制和分层渲染技术，使得打开和切换会话更加迅速和高效。\n扩展性和开放性：Windows Terminal 是开源项目，允许开发人员通过扩展来增加新的功能和定制选项。用户可以从社区贡献的插件和扩展中获益，或者自己开发和分享自定义的扩展。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"总体而言，Windows Terminal 是一个现代化、可定制化和功能丰富的命令行工具，为用户提供了更好的命令行体验和更高效的工作环境。它是 Windows 平台上命令行操作的新选择，可以满足开发人员、系统管理员和技术爱好者对于命令行工具的需求。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#如何安装Windows-Terminal","page":"PowerShell和Windows Terminal","title":"如何安装Windows Terminal","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"要安装 Windows Terminal，您可以按照以下步骤进行操作：","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"打开 Microsoft Store：在 Windows 10 操作系统中，可以通过点击任务栏上的 \"Microsoft Store\" 图标来打开 Microsoft Store 应用商店。\n搜索 Windows Terminal：在 Microsoft Store 的搜索框中输入 \"Windows Terminal\"，然后按下回车键或点击搜索按钮。\n选择 Windows Terminal 应用：在搜索结果中，找到 Windows Terminal 应用，并点击它的图标以打开应用页面。\n安装 Windows Terminal：在 Windows Terminal 应用页面上，点击 \"获取\"（或 \"安装\"）按钮。系统会开始下载和安装 Windows Terminal 应用。\n启动 Windows Terminal：安装完成后，您可以在开始菜单或任务栏中找到 Windows Terminal 图标。点击图标即可启动 Windows Terminal。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"注意：为了安装 Windows Terminal，您的计算机必须运行 Windows 10 1903 或更高版本。如果您的操作系统版本较旧，请考虑更新到最新版本以获得更好的兼容性和功能支持。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"另外，Windows Terminal 也可以从 GitHub 上的源代码进行构建和安装，这需要更高级的技术知识和步骤。如果您对此感兴趣，可以访问 Windows Terminal 的 GitHub 仓库（https://github.com/microsoft/terminal）获取更多详细信息和指南。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#如何使用PowerShell的emacs键绑定？","page":"PowerShell和Windows Terminal","title":"如何使用PowerShell的emacs键绑定？","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"Set-PSReadLineOption 是 PowerShell 的一个命令，用于设置和自定义 PowerShell 的交互式命令行编辑器 PSReadLine 的选项。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"PSReadLine 是一个用于 PowerShell 的增强型命令行编辑器，提供了更强大的命令行编辑和自动完成功能。Set-PSReadLineOption 命令允许您配置和调整 PSReadLine 的各种选项，以适应个人偏好和需求。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"以下是一些常用的 Set-PSReadLineOption 命令的选项和用法示例：","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"更改提示符样式：\nSet-PSReadLineOption -Prompt 'PS> '\n这将将 PowerShell 的提示符更改为 'PS> '。\n启用语法高亮显示：\nSet-PSReadLineOption -Colors @{Command = 'Green'}\n这将启用命令的绿色语法高亮显示。\n启用自动完成：\nSet-PSReadLineOption -PredictionSource HistoryAndFileSystem\n这将启用从历史记录和文件系统中自动完成命令和路径的功能。\n修改键绑定：\nSet-PSReadLineKeyHandler -Key Tab -Function Complete\n这将将 Tab 键绑定到自动完成功能。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"这只是一些 Set-PSReadLineOption 命令的示例，您可以根据需要使用其他选项来自定义和配置 PSReadLine。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"请注意，Set-PSReadLineOption 命令只会影响当前 PowerShell 会话中的 PSReadLine 设置。如果您希望在每次启动 PowerShell 时自动应用这些设置，可以将它们添加到 PowerShell 配置文件（$PROFILE）中。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"Set-PSReadLineOption -EditMode 是用于设置 PowerShell PSReadLine 编辑模式的命令。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"在 PowerShell 中，PSReadLine 提供了多种编辑模式，用于自定义命令行的编辑行为。通过 Set-PSReadLineOption -EditMode 命令，您可以指定所需的编辑模式。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"以下是一些常见的 PSReadLine 编辑模式：","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"Emacs 模式：这是默认的 PSReadLine 编辑模式，它基于 Emacs 文本编辑器的键绑定方式。\nWindows 模式：该模式模仿了 Windows 命令行的键绑定方式，类似于 CMD 的编辑行为。\nVi 模式：该模式模仿了 Vi/Vim 文本编辑器的键绑定方式，允许您使用 Vi 风格的编辑命令。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"要设置 PSReadLine 的编辑模式，请使用以下命令示例：","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"# 设置为 Emacs 模式\nSet-PSReadLineOption -EditMode Emacs\n\n# 设置为 Windows 模式\nSet-PSReadLineOption -EditMode Windows\n\n# 设置为 Vi 模式\nSet-PSReadLineOption -EditMode Vi","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"通过运行上述命令中的任何一个，您可以在当前 PowerShell 会话中设置 PSReadLine 的编辑模式。请注意，这只会影响当前会话，不会在其他会话中生效。如果您希望每次启动 PowerShell 时都使用特定的编辑模式，请将相应的命令添加到 PowerShell 配置文件（$PROFILE）中。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#我碰到了执行策略不允许的错误","page":"PowerShell和Windows Terminal","title":"我碰到了执行策略不允许的错误","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"Set-ExecutionPolicy 命令用于设置 PowerShell 脚本的执行策略。执行策略是一种安全措施，用于限制 PowerShell 脚本的执行，以防止恶意脚本的运行。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"具体而言，Set-ExecutionPolicy 命令中的参数 RemoteSigned 是一种执行策略级别。当执行策略设置为 RemoteSigned 时，意味着在本地计算机上的脚本必须由信任的发布者签名，但在远程计算机上执行的脚本不需要签名。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"设置执行策略为 RemoteSigned 的目的是增加 PowerShell 脚本的安全性，确保只有经过签名的脚本或本地编写的脚本可以在本地计算机上执行。这样可以减少潜在的恶意脚本或未经授权的脚本对系统的影响。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"需要注意的是，执行策略是一个系统级别的设置，适用于整个计算机。因此，更改执行策略可能需要管理员权限。在执行 Set-ExecutionPolicy RemoteSigned 命令之前，您需要以管理员权限运行 PowerShell 会话。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"请注意，执行策略仅提供了一层基本的安全保护，并不能完全阻止所有潜在的安全风险。在运行任何脚本之前，仍然需要审查和确保脚本的来源和内容是可信的。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#EditMode的emacs键绑定有什么好处？","page":"PowerShell和Windows Terminal","title":"EditMode的emacs键绑定有什么好处？","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"在 Windows Terminal 中，EditMode 是一个配置选项，用于设置 PowerShell 的 PSReadLine 编辑模式。当 EditMode 设置为 \"emacs\" 时，Windows Terminal 将使用 Emacs 键绑定来提供编辑功能。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"Emacs 键绑定是基于 Emacs 文本编辑器的经典键盘快捷键，它提供了丰富的命令和编辑操作，使您可以更高效地编辑和处理文本。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"下面是一些常用的 Emacs 键绑定示例：","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"移动光标：\nCtrl + B：向后移动一个字符（相当于箭头左键）。\nCtrl + F：向前移动一个字符（相当于箭头右键）。\nCtrl + P：向上移动一行（相当于箭头上键）。\nCtrl + N：向下移动一行（相当于箭头下键）。\nCtrl + A：移到行首。\nCtrl + E：移到行尾。\nAlt + B：向后移动一个单词。\nAlt + F：向前移动一个单词。\n编辑操作：\nCtrl + D：删除光标处的字符。\nCtrl + K：删除光标到行尾的内容。\nCtrl + Y：粘贴删除的文本。\nCtrl + W：删除光标前的单词。\nCtrl + T：交换光标前后的字符。\n撤销和重做：\nCtrl + /：撤销上一次操作。\nCtrl + _：撤销上一次操作（类似于撤销）。\nCtrl + Shift + -：重做上一次操作。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"这只是一小部分 Emacs 键绑定的示例，Windows Terminal 中的 Emacs 编辑模式提供了更多的键盘快捷键，以及其他类似于 Emacs 的编辑命令和操作。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"通过在 Windows Terminal 中设置 EditMode 为 \"emacs\"，您可以在 PowerShell 会话中使用这些 Emacs 键绑定来进行编辑和操作，提高您的命令行效率和体验。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#Linux下的shell","page":"PowerShell和Windows Terminal","title":"Linux下的shell","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"在linux操作系统下，类似的也有命令行模式，而且是更常用的模式。尽管很多ubuntu用户首先接触到的是其gui界面，但是事实上cli更为常用一些。大多数的系统默认的是bash。操作系统内部管理文件、设备的是kernel。我们用户通过shell来跟kernel打交道。而这个bash就是shell的一种。跟Windows下的命令提示符类似，我们在shell的提示符下可以输入不同的命令来完成一些工作。比如ls是列出当前文件夹下的内容。cp是复制文件的命令。cd是改变目录的命令等等。具体这些内容可以参考linux入门书看一看，或者看一看linux cheatsheet。","category":"page"},{"location":"GolangIntro/01-golang的安装/#golang的安装","page":"golang的安装","title":"golang的安装","text":"","category":"section"},{"location":"GolangIntro/01-golang的安装/#golang安装","page":"golang的安装","title":"golang安装","text":"","category":"section"},{"location":"GolangIntro/01-golang的安装/","page":"golang的安装","title":"golang的安装","text":"以下是一个在 Windows 11 上直接解压并配置 Golang 的详细步骤。首先，你需要下载一个 Go 的 ZIP 压缩包，而不是 .msi 安装包。","category":"page"},{"location":"GolangIntro/01-golang的安装/","page":"golang的安装","title":"golang的安装","text":"以下是步骤：","category":"page"},{"location":"GolangIntro/01-golang的安装/","page":"golang的安装","title":"golang的安装","text":"下载 Go 二进制包:\n访问 Go 官方下载页面 https://golang.org/dl/\n在页面中找到 Windows 下的 .zip 文件，下载它。例如，go1.17.windows-amd64.zip（版本号可能会根据时间有所不同）。\n解压文件:\n找到你下载的 .zip 文件。\n右键点击文件，选择解压到适当的位置。例如，你可以解压到 C:\\Go。这样你就有了 C:\\Go\\bin，这是所有 Go 的可执行文件的位置。\n配置环境变量:\n按下 Win + X，然后选择 系统。\n点击 高级系统设置。\n在系统属性窗口中，点击 环境变量 按钮。\n在系统变量部分，找到 Path 变量并点击编辑。\n在编辑环境变量窗口中，点击新建，然后添加 C:\\Go\\bin（如果你把 Go 解压到了其他位置，请确保此路径与你的解压位置相匹配）。\n确认所有的对话框。\n配置 GOPATH（如果需要）:\n虽然从 Go 1.11 开始，GOPATH 默认设置为用户目录下的 go 文件夹，但如果你想指定一个不同的工作区，你可以设置 GOPATH 环境变量。\n在上述的环境变量窗口，点击 新建，变量名为 GOPATH，变量值为你的工作区路径，例如 C:\\Users\\YourName\\go-workspace。\n验证安装:\n打开命令提示符或 PowerShell。\n输入 go version。如果显示了 Go 的版本信息，说明你已经成功安装并配置了 Go。","category":"page"},{"location":"GolangIntro/01-golang的安装/","page":"golang的安装","title":"golang的安装","text":"现在你应该已经成功地在 Windows 11 上通过解压方式安装了 Golang！","category":"page"},{"location":"GolangIntro/01-golang的安装/#GO111MODULE-开启","page":"golang的安装","title":"GO111MODULE 开启","text":"","category":"section"},{"location":"GolangIntro/01-golang的安装/","page":"golang的安装","title":"golang的安装","text":"要在 Go 中开启模块支持，你需要设置 GO111MODULE 环境变量。从 Go 1.11 开始，Go 介绍了此模块支持，并在后续的版本中得到了改进和完善。从 Go 1.13 开始，模块支持已经成为了默认选项，但你仍然可以使用 GO111MODULE 环境变量来明确控制其行为。","category":"page"},{"location":"GolangIntro/01-golang的安装/","page":"golang的安装","title":"golang的安装","text":"下面是如何开启 GO111MODULE：","category":"page"},{"location":"GolangIntro/01-golang的安装/","page":"golang的安装","title":"golang的安装","text":"命令行临时开启:\n你可以在命令行中临时为当前会话开启 GO111MODULE，只需执行以下命令：\nset GO111MODULE=on\n在 PowerShell 中，你应使用：\n$env:GO111MODULE = \"on\"\n这种方式仅在当前的命令行会话中有效。\n永久开启:\n如果你想永久地在你的系统上开启 GO111MODULE，你可以将其添加到环境变量中。\n按下 Win + X，然后选择 系统。\n点击 高级系统设置。\n在系统属性窗口中，点击 环境变量 按钮。\n在用户变量部分，点击 新建，并为其设置变量名为 GO111MODULE 和变量值为 on。","category":"page"},{"location":"GolangIntro/01-golang的安装/","page":"golang的安装","title":"golang的安装","text":"而命令 go env -w GO111MODULE=on 是一个更简单、直接的方法，用于设置 Go 的环境变量。从 Go 1.13 版本开始，你可以使用 go env -w 来永久地设置 Go 环境变量，而不是通过系统设置或修改 shell 配置文件。","category":"page"},{"location":"GolangIntro/01-golang的安装/","page":"golang的安装","title":"golang的安装","text":"以下是使用步骤：","category":"page"},{"location":"GolangIntro/01-golang的安装/","page":"golang的安装","title":"golang的安装","text":"打开命令提示符或 PowerShell。\n输入以下命令：\ngo env -w GO111MODULE=on\n执行后，GO111MODULE 将被设置为 on。这意味着你在任何地方运行 Go 命令时，都会使用模块支持。","category":"page"},{"location":"GolangIntro/01-golang的安装/","page":"golang的安装","title":"golang的安装","text":"如果你想查看已设置的 Go 环境变量，只需运行 go env。","category":"page"},{"location":"GolangIntro/01-golang的安装/","page":"golang的安装","title":"golang的安装","text":"使用 go env -w 的好处是它直接修改了 Go 的配置，这样你无需在各种 shell 或操作系统环境中手动设置。当然，要确保你使用的 Go 版本是 1.13 或更高，否则这个命令可能不可用。","category":"page"},{"location":"GolangIntro/01-golang的安装/","page":"golang的安装","title":"golang的安装","text":"这样，无论何时你使用 Go 命令，模块支持都将开启。如果你想禁用它，可以将 GO111MODULE 的值设置为 off。","category":"page"},{"location":"GolangIntro/01-golang的安装/#配置-Proxy","page":"golang的安装","title":"配置 Proxy","text":"","category":"section"},{"location":"GolangIntro/01-golang的安装/","page":"golang的安装","title":"golang的安装","text":"在某些情况下，由于网络限制或其他原因，直接访问 Go 的模块存储库可能会遇到困难。为了解决这个问题，你可以配置 Go 使用一个代理。","category":"page"},{"location":"GolangIntro/01-golang的安装/","page":"golang的安装","title":"golang的安装","text":"https://goproxy.cn 是一个在中国大陆受欢迎的 Go 模块代理服务。","category":"page"},{"location":"GolangIntro/01-golang的安装/","page":"golang的安装","title":"golang的安装","text":"以下是如何配置 Go 使用 goproxy.cn：","category":"page"},{"location":"GolangIntro/01-golang的安装/","page":"golang的安装","title":"golang的安装","text":"打开命令提示符或 PowerShell。\n输入以下命令：\ngo env -w GOPROXY=https://goproxy.cn,direct","category":"page"},{"location":"GolangIntro/01-golang的安装/","page":"golang的安装","title":"golang的安装","text":"这个命令做了以下事情：","category":"page"},{"location":"GolangIntro/01-golang的安装/","page":"golang的安装","title":"golang的安装","text":"GOPROXY=https://goproxy.cn,direct：这告诉 Go 先尝试从 goproxy.cn 获取模块。如果 goproxy.cn 无法访问或模块在代理上不存在，它会直接从源存储库获取，这就是 ,direct 的作用。","category":"page"},{"location":"GolangIntro/01-golang的安装/","page":"golang的安装","title":"golang的安装","text":"完成上述操作后，每次你使用 go get 或任何涉及下载模块的 Go 命令时，Go 都会尝试从 goproxy.cn 获取模块。","category":"page"},{"location":"GolangIntro/01-golang的安装/","page":"golang的安装","title":"golang的安装","text":"如果你需要取消代理设置，可以使用以下命令：","category":"page"},{"location":"GolangIntro/01-golang的安装/","page":"golang的安装","title":"golang的安装","text":"go env -w GOPROXY=direct","category":"page"},{"location":"GolangIntro/01-golang的安装/","page":"golang的安装","title":"golang的安装","text":"这将指示 Go 直接从源存储库获取模块，而不使用任何代理。","category":"page"},{"location":"GolangIntro/01-golang的安装/#配置检查","page":"golang的安装","title":"配置检查","text":"","category":"section"},{"location":"GolangIntro/01-golang的安装/","page":"golang的安装","title":"golang的安装","text":"要查看 Go 的当前环境配置，你可以使用以下两个命令：","category":"page"},{"location":"GolangIntro/01-golang的安装/","page":"golang的安装","title":"golang的安装","text":"查看所有 Go 环境变量: 执行以下命令：\ngo env\n这会列出所有的 Go 环境变量及其当前值。\n查看特定的 Go 环境变量: 如果你只关心 GOPROXY 的值，可以执行：\ngo env GOPROXY\n这将仅显示 GOPROXY 的当前值。","category":"page"},{"location":"GolangIntro/01-golang的安装/","page":"golang的安装","title":"golang的安装","text":"这两个命令对于快速检查和调试 Go 的配置非常有用，特别是当你想确认你的代理设置或其他环境变量是否正确配置时。","category":"page"},{"location":"Optimization/7-启发式算法简介/#启发式算法简介","page":"启发式算法简介","title":"启发式算法简介","text":"","category":"section"},{"location":"Optimization/7-启发式算法简介/#启发式算法概述","page":"启发式算法简介","title":"启发式算法概述","text":"","category":"section"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"启发式算法是一类基于经验和启发式规则的优化算法，用于在大规模、复杂或难以求解的优化问题中寻找近似最优解。启发式算法通过模拟自然、社会或人类行为中的启发式策略，采用搜索和优化技术来引导解空间的探索。以下介绍几种常见的启发式算法：","category":"page"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"遗传算法（Genetic Algorithm）： 遗传算法模拟了自然界的进化过程，通过基因编码、选择、交叉和变异等操作，通过代际交换和适应度评估来搜索优化空间。遗传算法具有全局搜索能力和并行计算特性，适用于解决复杂的优化问题。\n模拟退火算法（Simulated Annealing）： 模拟退火算法受到固体退火过程的启发，通过模拟材料退火过程中的原子运动，通过接受劣解和随机跳出局部最优解的策略，逐步降低温度以搜索最优解。\n蚁群算法（Ant Colony Optimization）： 蚁群算法模拟了蚂蚁在寻找食物过程中的行为，通过模拟蚂蚁的觅食、信息素释放和信息素更新等机制，通过信息素的正反馈来引导搜索，以找到最优解。\n粒子群优化算法（Particle Swarm Optimization）： 粒子群优化算法模拟了鸟群或鱼群等群体在搜索食物或资源时的行为，通过模拟粒子在解空间中的移动和信息共享，通过个体最优解和群体最优解的综合作用来搜索最优解。\n蜂群算法（Bee Algorithm）： 蜂群算法受到蜜蜂在寻找花朵和采蜜过程中的行为启发，通过模拟蜜蜂的觅食、信息传递和局部搜索等策略，以寻找最优解。","category":"page"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"这些启发式算法都具有一定的全局搜索能力和适应性，可以在复杂的优化问题中搜索到近似最优解。它们通常不保证找到全局最优解，但能够在可接受的时间内找到高质量的解。启发式算法在组合优化、调度问题、机器学习等领域得到了广泛应用，成为求解复杂问题的有效工具之一。","category":"page"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"还有很多，鲸鱼算法等等，不一一列举了。","category":"page"},{"location":"Optimization/7-启发式算法简介/#遗传算法","page":"启发式算法简介","title":"遗传算法","text":"","category":"section"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"遗传算法（Genetic Algorithm，GA）是一种启发式优化算法，模拟了自然界中的遗传和进化过程。它通过模拟遗传操作（选择、交叉和变异）和适应度评估来搜索优化问题的解空间，寻找近似最优解。","category":"page"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"遗传算法的基本思想是将问题的解表示为染色体（基因组）的形式，其中每个基因代表解空间中的一个可能解。初始时，生成一组随机的个体（种群），每个个体由一个染色体构成。染色体通常使用二进制编码，但也可以使用其他编码方式。","category":"page"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"遗传算法的运行过程包括以下步骤：","category":"page"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"初始化种群：生成一组随机的个体作为初始种群，每个个体表示一个潜在解。\n适应度评估：对每个个体计算适应度值，评估其优劣程度，适应度值通常由目标函数确定。\n选择操作：根据适应度值选择一部分个体作为父代，选择策略通常采用轮盘赌选择、锦标赛选择等。\n交叉操作：对选出的父代个体进行交叉操作，产生新的子代个体。交叉操作通过基因重组，将父代个体的染色体信息交换，并生成新的染色体。\n变异操作：对子代个体进行变异操作，以引入新的基因组变化。变异操作可以是随机的，通过改变个体染色体中的部分基因。\n更新种群：将父代和子代个体合并为新的种群，并进行下一代的遗传操作。\n终止条件判断：判断是否满足终止条件，如达到最大迭代次数、达到预定的适应度阈值等。\n返回结果：返回最优个体作为近似最优解。","category":"page"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"遗传算法的优点包括对复杂、高维、非线性问题的适应能力强、全局搜索能力好、具有并行计算的潜力等。它被广泛应用于组合优化、机器学习、进化计算等领域，在求解复杂问题和优化设计中具有重要作用。","category":"page"},{"location":"Optimization/7-启发式算法简介/#粒子群算法","page":"启发式算法简介","title":"粒子群算法","text":"","category":"section"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"粒子群算法（Particle Swarm Optimization，PSO）是一种基于群体智能的优化算法，模拟了鸟群或鱼群等群体在搜索食物或资源时的行为。它通过模拟个体（粒子）在解空间中的移动和信息共享来搜索最优解。","category":"page"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"粒子群算法的基本思想是通过不断更新粒子的位置和速度来搜索解空间。每个粒子表示一个解的候选，并具有自己的位置和速度。算法通过根据粒子的历史最优位置（个体最优解）和全局最优位置（群体最优解）来引导粒子的移动。","category":"page"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"粒子群算法的运行过程包括以下步骤：","category":"page"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"初始化粒子群：随机生成一组粒子，每个粒子具有随机的位置和速度。\n评估适应度：计算每个粒子的适应度值，通常由目标函数确定。\n更新个体最优解：根据当前的适应度值，更新每个粒子的个体最优位置。\n更新群体最优解：从所有粒子的个体最优解中选择最优解作为群体最优位置。\n更新速度和位置：根据个体最优解和群体最优解，更新每个粒子的速度和位置。\n终止条件判断：判断是否满足终止条件，如达到最大迭代次数、达到预定的适应度阈值等。\n返回结果：返回群体最优解作为近似最优解。","category":"page"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"粒子群算法的核心在于粒子的速度和位置更新过程。速度更新考虑了粒子的历史速度、个体最优位置和群体最优位置的影响，以调整粒子的移动方向和速度。位置更新根据速度更新计算出的新速度来更新粒子的位置。","category":"page"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"粒子群算法具有全局搜索能力和对局部搜索的自适应性，可以在复杂的优化问题中找到较好的近似最优解。它被广泛应用于连续优化、组合优化、神经网络训练等领域，尤其适用于无约束、非线性和多峰优化问题。","category":"page"},{"location":"Optimization/7-启发式算法简介/#模拟退火算法","page":"启发式算法简介","title":"模拟退火算法","text":"","category":"section"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"模拟退火算法（Simulated Annealing）是一种基于物理退火过程的全局优化算法，用于在搜索空间中寻找最优解。它受到固体退火过程的启发，通过模拟材料退火过程中的原子运动，通过接受劣解和随机跳出局部最优解的策略，逐步降低温度以搜索最优解。","category":"page"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"模拟退火算法的基本思想是通过模拟高温下材料的热涨落和温度逐渐降低的过程来改善解的质量。算法通过在解空间中随机产生邻域解，并根据目标函数和当前温度接受或拒绝新解。随着温度的降低，算法逐渐趋于接受更优解的概率增大，从而朝着最优解靠近。","category":"page"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"模拟退火算法的运行过程包括以下步骤：","category":"page"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"初始化解：随机生成一个初始解作为当前解。\n初始化温度：设置初始温度，并定义温度下降的策略。\n在当前温度下，迭代进行以下操作：\n生成邻域解：通过在当前解的邻域中随机选择一个新解。\n计算目标函数差值：计算新解与当前解的目标函数值之差。\n接受或拒绝新解：根据目标函数差值、当前温度和一定的概率策略，决定是否接受新解。较好的解更容易被接受，但在一定概率下，劣解也有可能被接受，以避免陷入局部最优解。\n更新当前解：根据接受或拒绝策略，更新当前解为新解或保持不变。\n降低温度：根据设定的温度下降策略，降低当前温度。\n终止条件判断：判断是否满足终止条件，如达到最大迭代次数、温度降低到阈值等。\n返回结果：返回搜索过程中找到的最优解或近似最优解。","category":"page"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"模拟退火算法的优点在于其全局搜索能力和对局部最优解的跳出性质，能够在复杂的优化问题中找到较好的解。它适用于连续优化和离散优化问题，不受约束、非线性和多峰性等问题的限制。然而，算法的性能和搜索结果高度依赖于初始解、温度策略和邻域定义等参数的选择。因此，在使用模拟退火算法时需要进行参数调优和合适的问题建模。","category":"page"},{"location":"Optimization/7-启发式算法简介/#蚁群算法","page":"启发式算法简介","title":"蚁群算法","text":"","category":"section"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"蚁群算法（Ant Colony Optimization，ACO）是一种启发式优化算法，受到蚂蚁觅食行为的启发。它模拟了蚂蚁在寻找食物过程中的行为和信息传递方式，用于解决组合优化问题，特别适用于求解旅行商问题（Traveling Salesman Problem，TSP）等离散优化问题。","category":"page"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"蚁群算法的基本思想是通过模拟蚂蚁的觅食行为和信息素的释放与更新来寻找最优解。蚂蚁通过释放信息素来标记路径，并在选择下一步行动时根据信息素浓度和启发式信息（如距离、可行性等）做出决策。信息素的浓度受到蚂蚁行动和问题求解过程中的反馈影响。","category":"page"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"蚁群算法的运行过程包括以下步骤：","category":"page"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"初始化信息素：为问题中的路径或决策变量分配初始信息素值。\n蚂蚁的移动：\n每只蚂蚁根据信息素浓度和启发式信息选择下一步行动。\n蚂蚁根据选定的路径或决策变量更新信息素。\n信息素的更新：\n所有蚂蚁完成移动后，根据问题的特性和目标函数，更新信息素的浓度。\n通过蒸发和新信息素的释放来更新信息素值。\n终止条件判断：判断是否满足终止条件，如达到最大迭代次数或找到满足要求的解等。\n返回结果：返回找到的最优解或近似最优解。","category":"page"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"蚁群算法的关键在于信息素的更新和蚂蚁的移动策略。信息素的更新考虑了蚂蚁的路径质量和全局最优解的影响，有助于引导蚂蚁向更优的解靠近。蚂蚁的移动策略通常基于概率模型，其中信息素浓度和启发式信息被用于计算转移概率，以选择下一步的行动。","category":"page"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"蚁群算法具有一定的全局搜索能力、对局部最优解的跳出性质以及适应复杂环境的能力。它在解决TSP、路径规划、图着色等离散优化问题方面表现出色。然而，蚁群算法的性能高度依赖于参数的设置和信息素的更新策略。因此，对于不同的问题，需要进行参数调优和合适的问题建模，以获得最佳性能和解的质量。","category":"page"},{"location":"Optimization/7-启发式算法简介/#蜂群算法","page":"启发式算法简介","title":"蜂群算法","text":"","category":"section"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"蜂群算法（Bee Algorithm）是一种基于蜜蜂觅食行为的启发式优化算法，用于解决组合优化问题。它模拟了蜜蜂在寻找花朵和采蜜过程中的行为，通过模拟蜜蜂的觅食、信息传递和局部搜索等策略来搜索最优解。","category":"page"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"蜂群算法的基本思想是通过模拟蜜蜂的行为和信息传递方式来搜索最优解。算法中包括三类蜜蜂：工蜂、侦查蜂和觅食蜂。","category":"page"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"工蜂： 工蜂负责在解空间中进行局部搜索，通过选择当前位置周围的邻域解来改善当前解。它们利用局部搜索策略来挖掘局部最优解并发现新的潜在解。\n侦查蜂： 侦查蜂负责在解空间中进行全局搜索，通过随机选择未被工蜂访问的位置进行探索。它们的目标是发现更多的潜在解，以避免陷入局部最优解。\n觅食蜂： 觅食蜂是负责采集花蜜的蜜蜂，它们通过选择最优解和与其他蜜蜂进行信息传递来引导整个蜂群向更优解靠近。","category":"page"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"蜂群算法的运行过程包括以下步骤：","category":"page"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"初始化蜜蜂群：随机生成一组蜜蜂作为初始蜜蜂群，每个蜜蜂表示一个潜在解。\n评估适应度：计算每个蜜蜂的适应度值，通常由目标函数确定。\n工蜂阶段：\n工蜂根据局部搜索策略选择当前位置周围的邻域解，并通过比较适应度值来更新当前解。\n如果更新后的解比当前解更优，则将其保留，否则丢弃。\n侦查蜂阶段：\n侦查蜂随机选择未被工蜂访问的位置，以发现新的潜在解。\n对于发现的新解，进行评估并更新蜜蜂群。\n觅食蜂阶段：\n觅食蜂选择适应度值最好的解作为最优解，并通过与其他蜜蜂进行信息传递来引导整个蜂群向最优解靠近。\n终止条件判断：判断是否满足终止条件，如达到最大迭代次数或找到满足要求的解等。\n返回结果：返回找到的最优解或近似最优解。","category":"page"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"蜂群算法具有一定的全局搜索能力和对局部最优解的跳出性质，能够在复杂的优化问题中找到较好的解。它适用于组合优化、连续优化、路径规划等问题，尤其适用于大规模和复杂问题的求解。然而，蜂群算法的性能和搜索结果高度依赖于参数的选择和问题的建模。因此，在使用蜂群算法时需要进行参数调优和适当的问题建模，以获得最佳性能和解的质量。","category":"page"},{"location":"Optimization/7-启发式算法简介/#要注意的问题","page":"启发式算法简介","title":"要注意的问题","text":"","category":"section"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"在使用启发式算法或其他优化算法时，需要注意以下两个方面：适应性和约束处理。","category":"page"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"适应性（Fitness Function）： 在优化问题中，适应性函数（也称为目标函数或评价函数）用于评估每个解的质量。适应性函数的设计应该能够准确地度量解的好坏，并且与问题的优化目标一致。合理选择适应性函数可以帮助算法有效地搜索和优化解空间。\n约束处理（Constraint Handling）： 在许多优化问题中，存在一些约束条件，限制了解的可行性空间。约束可以是等式约束或不等式约束，如资源约束、容量约束等。在应用优化算法时，需要考虑如何处理约束条件，以确保生成的解满足约束要求。一种常见的方法是将约束条件纳入适应性函数中，将违反约束的解分配较高的适应度值，从而将其排除在搜索过程之外。另一种方法是使用罚函数（Penalty Function）或约束处理技术，通过对适应性函数引入罚项来对违反约束的解进行惩罚，以鼓励生成满足约束的解。","category":"page"},{"location":"Optimization/7-启发式算法简介/","page":"启发式算法简介","title":"启发式算法简介","text":"综上所述，选择合适的适应性函数和有效的约束处理方法对于蚁群算法的性能和解的质量非常重要。需要根据具体问题的特点和约束要求进行适当的设计和调整。","category":"page"},{"location":"WorkFlow/gitworkflow/#Ai4E组织合作开发流程","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"tip: Tip\nContents：基于Gitkraken的合作开发流程Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"note: Note\nGitkraken为Git图形化软件。预计实践时间：60min - 120min","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"Pages = [\"gitworkflow.md\"]","category":"page"},{"location":"WorkFlow/gitworkflow/#开发流程简介","page":"Ai4E组织合作开发流程","title":"开发流程简介","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"Github是一个非常流行的代码托管平台，上面有许许多多的前辈与“他们的牛逼代码”。为了充分与国际接轨，我们（Ai4Energy）组织也选择Github。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"Ai4Energy组织可以视为一个大的代码仓库，每个人都可以向组织中贡献代码。Github基于Git，有完善且高效的多人协作的开发流程（所谓开发流程其实就是如何向Ai4Energy组织中提交代码做贡献）。","category":"page"},{"location":"WorkFlow/gitworkflow/#准备工作","page":"Ai4E组织合作开发流程","title":"准备工作","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"Github注册账户\n下载Gitkraken\n用Github账户登录Gitkraken（重要），然后建立Gitkraken的profile（个人形象，不重要）\n建立SSH登录验证方式（点击下面的绿色按钮，Gitkraken自动生成并且上传），如下图。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"(Image: 图 3)  ","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"tip: Tip\n稳定连接Github，推荐一个免费加速器Watt Toolkit，在微软应用商店。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"接下来是开发的逻辑介绍。","category":"page"},{"location":"WorkFlow/gitworkflow/#开发逻辑","page":"Ai4E组织合作开发流程","title":"开发逻辑","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"应用场景是这样的：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"在某师兄云盘里有一份报告，师兄给2个师弟说你们合作把这份报告改一改（假设两位师弟一个在美国一个在日本，且不认识，只有云盘的地址）。小师弟先改第一版，大师弟改第二版。他们需要干以下的操作：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"小师弟把文件先添加到自己的云盘资源里\n假设云盘没有在线编辑功能，小师弟修改文件只有一种选择：把文件下载到本地修改。\n小师弟修改报告\n小师弟把修改完成的报告上传至自己的云盘。\n修改完成之后，小师弟就可以对师兄说：我改完了，文件在我自己的云盘里，如果可以的话，我就把你的那一份原来的报告覆盖了。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"接下来的选择就有两种：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"师兄说：改的不错，覆盖吧。然后大师弟重复1-5步骤\n师兄说：改的不行，重改吧。然后小师弟重复2-5步骤","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"以上，就是我们工作流程的实际内涵：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"1: 这个行为叫Fork。Fork的意思是在自己的个人账号下建立一个一样的别人的仓库，而且会显示你这个仓库是fork别人的。 (Image: 图 1)","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"2: 这个行为叫Pull。一般而言，第一次在本地建仓时，会自动Pull。本地仓库建好了，若云端仓库文件有更新，这个时候本地文件要更新的话，就有相应的Pull操作。 (Image: 图 2)","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"3: 这个行为叫开发🤣。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"4: 这个行为叫Push。 (Image: 图 3)","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"5: 这个行为叫Pull Request（合并到主分支）。为要先推送到自己仓库的副本而不是直接覆盖别人的那个仓库呢？🤣","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"整体的逻辑图如下：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"(Image: 图 2)  ","category":"page"},{"location":"WorkFlow/gitworkflow/#操作步骤与方法","page":"Ai4E组织合作开发流程","title":"操作步骤与方法","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"方法对应以上5个步骤。","category":"page"},{"location":"WorkFlow/gitworkflow/#Step1:-Fork","page":"Ai4E组织合作开发流程","title":"Step1: Fork","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"(Image: 图 4)  ","category":"page"},{"location":"WorkFlow/gitworkflow/#Step2:-Pull","page":"Ai4E组织合作开发流程","title":"Step2: Pull","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"首先是本地建仓：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"(Image: 图 2)","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"拉取之后点击Open Now，我们就能看到操作页面。同时在左侧需要点击Add。GitKraken自动检测到我们Fork了一个包，它会认为你可能需要通过修改别人的代码然后上传到你自己的库里，所以它给了一个添加自己Fork的库的一个选项（如果点上，也可以手动添加远程仓库）。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"(Image: 图 5)","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"note: Note\n在Step2中，如果是从自己Fork的仓库地址建立本地仓库，也可以，只不过要手动添加Ai4的远程地址了。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"中间的蓝色绿色圈是啥呢？是文件修改的记录。","category":"page"},{"location":"WorkFlow/gitworkflow/#Step3:-本地进行内容编辑——开发","page":"Ai4E组织合作开发流程","title":"Step3: 本地进行内容编辑——开发","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/#Step4:-Push","page":"Ai4E组织合作开发流程","title":"Step4: Push","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"编辑完成之后（任何改动都会被检测到）有几个关键步骤：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"给本次修改命名，表示干了什么（例如：add a file）\n右边上方暂存修改\n右边底下提交更改\n在修改的圈那里右键，点击UpStream，修改推送地点。一定要选择自己的库，组织的库没有权限推送上去。\n最后点击Push","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"(Image: 图 6)","category":"page"},{"location":"WorkFlow/gitworkflow/#Step5:-Pull-Request（合并到主分支）","page":"Ai4E组织合作开发流程","title":"Step5: Pull Request（合并到主分支）","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"Gitkraken有图形化的方式创建Pull Request。如下：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"(Image: 图 7)","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"Pull Request就是申请将你做的修改合并到Ai4的某个仓库（任何别人的仓库）。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"tip: Tip\n为什么能合并呢？因为首先把别人的库给拉取过来了，只是做了一些修改（增加或删减内容），仓库的“根”是一致的所以能合并。就类似，小师弟把师兄的文件复制过来了，在它的基础上改，改完之后把自己的内容复制，在师兄的文件中覆盖粘贴，这是没有问题的。 所以，如果选择两个不同“根”的仓库去Pull Request，那是行不通的。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"完成之后，就等“师兄审核”吧！","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"这是一套基于Gitkraken的简版Git合作开发流程，如果有兴趣，可以去了解原汁原味的Git。相关的资料很多！","category":"page"},{"location":"WorkFlow/gitworkflow/#实践","page":"Ai4E组织合作开发流程","title":"实践","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"Ai4Energy中有一个test.jl。完成以下内容：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"完成一次上述开发过程，形成具象认知。\n开发内容：在test.jl库中的src文件夹中，添加编辑一个xxx.jl的文件，（xxx为自己的名字，中文，便于\"师兄审核\"）\n文件内容任意。期望针对文档给出改进建议，也可以是一段Julia代码。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"以上是一个简单的流程，对于Git或Gitkraken来说只是冰山一角。遇到任何疑问与问题，积极思考原因，可以自行查阅相关资料，也可以积极的和Ai4组的同学交流。","category":"page"},{"location":"Control/OptimControl/#最优控制理论与应用","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"tip: Tip\nContents：JuMP、Control、EquationsSolverContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"note: Note\nJuMP是计算优化问题的Julia软件包。Symbolics.jl为符号计算包EquationsSolver自制的小型方程（组）求解器。","category":"page"},{"location":"Control/OptimControl/#问题描述","page":"最优控制理论与应用","title":"1 问题描述","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"本篇通过一个机器人的控制问题，介绍最优控制的相关理论与求解方式。问题如下：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 1)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"题目信息总结如下：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"这是一个含有三个关节的机器人。\n机器人身体的三部分与垂直方向的夹角分别为theta=theta_1theta_2theta_3。\n机器人的三个关节能够提供使机器人运动的扭矩：Q=Q_1Q_2Q_3。\n机器人关节的扭矩与夹角之间的关系（控制方程）为：Jmathbfddottheta=Ktheta+BQ。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"扭矩对夹角的控制方程的推导方法，我们并不关心。知晓它是通过动力学学分析得出即可。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"它最重要的信息是揭示了Q与theta之间的控制关系。通过该方程，我们可以知道，如果控制量Q发生了改变，被控量theta会发生何种变化。控制方程的物理含义是，夹角变化的角加速度与夹角的位置以及关节扭矩相关。具体的系数值见上图所示。","category":"page"},{"location":"Control/OptimControl/#.1-（最优）控制内涵","page":"最优控制理论与应用","title":"1.1 （最优）控制内涵","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"从这个问题中，我们可以抽象出“控制”一般性内涵：通过改变控制量来操作被控量。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"那么什么是最优控制的内涵呢？","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"假如，机器人初始状态是斜站着（theta=fracpi4fracpi4fracpi4，弧度制单位），现在要让机器人站直（theta=000）。我们可以改变关节扭矩Q。那么问题来了，Q应该：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"是否是一个随时间不变的常数？\n如果是常数，取何值？\n是否是一个随时间变化的函数？\n如果是函数，怎样变化？","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"我们从方程中可以发现，假若对Q不加限制。只是要机器人站直，那么我可以通过改变Q，让机器人可以慢慢的站、快快的站、先蹲后站，先躺后站，先俯卧撑再站，先整几个深蹲再站 :)。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"最优的含义则体现在这些“限制”里。一般而言，若对控制的效果加以限制，使控制的某种指标最大（最小），则是最优控制。例如，让机器人最快的站直，最省力的站直。在这些“最”的限制下，Q就不是任意的了（要最快的站直就不能先做个俯卧撑再站，那样就慢了 :) ），而是仅有一组最符合要求的。在数学上，最符合要求的Q则是这个最优化问题的解。这就是最优化控制的内涵。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"综上，其关键的要素有两点：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"控制方程\n控制过程中的最优化目标","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"在以上2点关键要素之下，最优控制问题的本质是优化问题：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"优化目标：控制最优化\n优化约束：控制方程代表的变量约束以及起点终点约束等。","category":"page"},{"location":"Control/OptimControl/#状态方程","page":"最优控制理论与应用","title":"2 状态方程","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"状态空间方程是控制学中非常重要的一个概念。控制学中，把变量视为状态。其本质还是将数学上的变量赋予了物理含义。状态方程的矩阵形式为：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"dotmathbfx=mathbfA(t)mathbfx+mathbfB(t)mathbfu","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"其特征如下：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"上述mathbfx为状态向量\n上述mathbfu为系统的输入向量（控制量向量）\n上述mathbfAB为系统系数矩阵，描述内部量之间的联系。\n统一以一阶导数的形式描述。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"若把机器人的控制方程写成状态方程，则有：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"leftbeginmatrixdotmathbfx_1=mathbfx_2dotmathbfx_2=mathbfJ^-1Kmathbfx_1+mathbfJ^-1BmathbfuendmatrixrightRightarrow dotmathbfx=beginbmatrix01mathbfJ^-1K0endbmatrixmathbfx+beginbmatrix0mathbfJ^-1Bendbmatrixmathbfu","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"其中，","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"mathbfA=beginbmatrix01mathbfJ^-1K0endbmatrixmathbfB=beginbmatrix0mathbfJ^-1Bendbmatrix","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"上述mathbfx_1代表角速度向量，有三个角速度分量。\n上述mathbfx_2代表角加速度向量，有三个角加速度分量。\n上述mathbfu代表扭矩向量，有三个扭矩分量。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"如此则统一了控制问题的方程描述。状态方程也好，控制方程也好，其本质是描述系统的方程。它们只是形式上的区别，在数学本质上是一致的。统一为状态方程的好处是，能够对控制问题进行普适性的推导与计算，使得状态方程下的数学推论具有普遍意义。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"note: Note\n状态方程的定义为:描述系统状态变量与输入变量之间关系的一阶微分方程组，称为系统的状态方程。状态方程表征了系统由输入量引起的内部状态变量的变化情况。","category":"page"},{"location":"Control/OptimControl/#最优控制问题解析解","page":"最优控制理论与应用","title":"3 最优控制问题解析解","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"首先，介绍系统一般性数学描述：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"系统状态方程","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"dotx(t)=Ax(t)+Bu(t)=fx(t)u(t)t","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"由于状态量都是关于时间的因变量，所以都写成关于时间的函数。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"系统始端与终端","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"x(t_0)=x_0x(t_f)=x_f ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"系统性能指标","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"J=int_t_o^t_fLx(t)u(t)tdt","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"其次，把它写优化问题的数学形式则为：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"beginmatrix\n min int_t_o^t_fLx(t)u(t)tdtsthspace6cmdotx(t)=fx(t)u(t)tx(t_0)=x_0x(t_f)=x_f \nendmatrix","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"一般的优化问题的解是数。不同于一般的优化问题，该优化的问题的解是函数。这就涉及到数学中的变分概念。这里不过多介绍，只给结论。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"tip: Tip\n一般最优化问题中，是找到相应的数值使得优化目标最小。最优化控制问题中，是找到相应的控制函数，使得优化目标最小。一个是找数值，一个是找函数。相当于自变量变为了函数。这是泛函分析解决的问题。","category":"page"},{"location":"Control/OptimControl/#.1-端点固定问题的解法","page":"最优控制理论与应用","title":"3.1 端点固定问题的解法","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"端点固定问题即t_f的数值确定。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"求解析解的方法是拉格朗日乘子法在泛函分析中的体现。首先令，","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"H = Lx(t)u(t)t + lambda(t)^Tfx(t)u(t)t","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"上式中，H称为哈密尔顿函数，lambda(t)为伴随方程。最优控制函数存在的必要条件为：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"beginmatrix\n dotlambda = -fracpartial Hpartial x\nfracpartial Hpartial u=0\nendmatrix","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"再结合控制方程与边界方程，则可以解得分析解。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"tip: Tip\n最优控制问题中有多种边界条件。端点固定问题只是其中一种。它们分别为：终端时刻t_f固定，终端向量x(t_f)自由\n终端时刻t_f固定，终端向量x(t_f)约束\n终端时刻t_f自由，终端向量x(t_f)约束在约束中，数值确定是也是约束的一种。不同的边界条件，添加不同的边界方程，在此不过多介绍，有兴趣可以翻看《最优控制理论》。","category":"page"},{"location":"Control/OptimControl/#机器人控制问题求解实例","page":"最优控制理论与应用","title":"4 机器人控制问题求解实例","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"机器人问题的状态方程为：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"beginmatrix\n dotmathbfx=mathbfAmathbfx+mathbfBmathbfu  \nmathbfA=beginbmatrix01mathbfJ^-1K0endbmatrixmathbfB=beginbmatrix0mathbfJ^-1Bendbmatrix\nendmatrix","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"设优化目标如下，可以理解为最省力的站直方式。因为其物理含义是时间域上的扭矩平方和最小。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"J=int_t_o^t_fu^2dt","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"可以得到哈密尔顿方程为：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"H=u^2+Alambda_2x_1+lambda_1x_2+lambda_2Bu","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"代入解析解存在的必要条件：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"beginmatrix\n dotlambda_1 = -fracpartial Hpartial x_1=-lambda_2x_2 dotlambda_2 = -fracpartial Hpartial x_2=-lambda_1fracpartial Hpartial u=2u+lambda_2B=0\nendmatrix","category":"page"},{"location":"Control/OptimControl/#.1-SymPy求状态方程解析解","page":"最优控制理论与应用","title":"4.1 SymPy求状态方程解析解","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"化简伴随方程，结合控制方程，可以得到：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"beginmatrix\n ddotlambda_2 - Alambda_2= 0 u=-05*lambda_2Bddotx_1=Ax_1+Bu\nendmatrix","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"为了求得上述问题的解析解，采用SymPy。SymPy是基于python的符号计算包，其开发了julia的调用接口。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"using SymPy\n@syms t A B λ() x() #定义函数及符号变量\ndiffeq = Eq(λ(t).diff(t, 2), A * λ(t)) # 定义需要求解的方程\nλt = dsolve(diffeq, λ(t)).__pyobject__.rhs # 求解得到λ\nut = -1//2 * B * λt # 计算得到u\ndiffeq2 = Eq(x(t).diff(t, t), A * x(t) + B * ut)# 定义关于x(t)的微分方程\ndsolve(diffeq2, x(t))  # 求解","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"warning: Warning\n在上述代码中，0.5需要用1//2，这样x(t)才能求得解析解，否则会报错。因为0.5是浮点数。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"得到结果如下：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 2)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"即：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"x_1(t)=(C_3+C_1fracB^2t4sqrtA)exp^-sqrtAt+(C_4-C_2fracB^2t4sqrtA)exp^sqrtAt","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"同时，对x_1(t)进行求导，得到x_2(t)。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"dsolve(diffeq2, x(t)).__pyobject__.rhs.diff(t)","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 1)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"即：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"x_2(t)=-(sqrtAC_3+C_1fracB^2t4)exp^-sqrtAt+(sqrtAC_4-C_2fracB^2t4)exp^sqrtAt+C_1fracB^2t4sqrtAexp^-sqrtAt-C_2fracB^2t4sqrtAexp^sqrtAt","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"这里一共有4个未知数:C_1C_2C_3C_4，通过4个边界调节确定：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"beginmatrix\nx_1(0)=fracpi4fracpi4fracpi4x_1(1)=000x_2(0)=000x_2(1)=000\nendmatrix","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"4个边界方程则可解出4个未知数C_1C_2C_3C_4。实际上C_1C_2C_3C_4是4个向量，每个向量分别对应机器人三部分的参数。在求解时，实际上是12个变量。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"note: Note\n也可以通过SymPy直接求解微分方程组。能获得同样的结果。using SymPy  \n@syms t A B λ1() x1() λ2() x2()\neqs = [\nEq(λ1(t).diff(t), -A * λ2(t)),\nEq(λ2(t).diff(t), -λ1(t)),\nEq(x1(t).diff(t), x2(t)),\nEq(x2(t).diff(t), A * x1(t) - B^2 / 2 * λ2(t))\n]\ndsolve(eqs)","category":"page"},{"location":"Control/OptimControl/#.2-参数矩阵求解","page":"最优控制理论与应用","title":"4.2 参数矩阵求解","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"下面介绍如何在Julia生态高效计算4个未知数。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"需要运用符号处理包——Symbolics.jl。该包在MTK的\"前世今生\"已经介绍过。本篇中也会用到。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"using Symbolics, EquationsSolver, LinearAlgebra\n# ==========================functions==================== #\nfunction initPara()\n    J1 = 1.0 / 12 * collect(I(3))\n    C1 = 0.5 * [1 2 2; 0 1 2; 0 0 2]\n    D1 = 0.5 * [1 0 0; 2 1 0; 4 2 1]\n    J = J1 + C1 * D1\n    K = 0.5 * [5 0 0; 0 3 0; 0 0 1]\n    B = [1 -1 0; 0 1 -1; 0 0 1]\n    A = inv(J) * K\n    B = inv(J) * B\n    return A, B\nend\n\nfunction x1(A, B, t, C1, C2, M1, M2)\n    A = sqrt(A)\n    B = inv(A) * B * B / 4\n    s = -(B * t) .* exp.(A * t) .* C1\n    s = s .+ exp.(A * t) .* M1\n    s = s .+ (B * t) .* exp.(-A * t) .* C2\n    s = s .+ exp.(-A * t) .* M2\n    return s\nend\n\nfunction x2(A, B, t, C1, C2, M1, M2)\n    A = sqrt(A)\n    B = B * B / 4\n    s = (-B * t .* C1 .+ A * M1 .- inv(A) * B * C1) .* exp.(A * t)\n    s = s .+ (-B * t .* C2 .- A * M2 .+ inv(A) * B * C2) .* exp.(-A * t)\n    return s\nend\n\nfunction SolvePro(eqs, init, vars)\n    pro = NLProblem(eqs, init)\n    res = solve(pro)\n    return [reshape([res[var[i]] for i in 1:3], (3, 1)) for var in vars]\nend\n\nfunction condition(θfields, A, B, tfields, C1, C2, M1, M2)\n    res = x1(A, B, tfields[1], C1, C2, M1, M2)\n    eqs = [res[i] ~ θfields[1][i] for i in 1:3]\n    res = x1(A, B, tfields[2], C1, C2, M1, M2)\n    append!(eqs, [res[i] ~ θfields[2][i] for i in 1:3])\n    res = x2(A, B, tfields[1], C1, C2, M1, M2)\n    append!(eqs, [res[i] ~ θfields[3][i] for i in 1:3])\n    res = x2(A, B, tfields[2], C1, C2, M1, M2)\n    append!(eqs, [res[i] ~ θfields[4][i] for i in 1:3])\n    return eqs\nend\n\nfunction Problem(A, B, θfields, tfields)\n    vars = @variables C1[1:3] C2[1:3] M1[1:3] M2[1:3]\n    C1, C2, M1, M2 = [reshape(collect(var), 3, 1) for var in vars]\n    eqs = condition(θfields, A, B, tfields, C1, C2, M1, M2)\n    init = Dict(var[i] => 0.0 for var in vars for i in 1:3)\n    return SolvePro(eqs, init, vars)\nend\n\n\n# ==========================main==================== #\nA, B = initPara()\n# 分别为x1(0) x1(t) x2(0) x2(t)的边界值\nθfields = [[π / 3, -π / 4, π / 2], [0, 0, 0], [0, 0, 0], [0, 0, 0]]\ntfields = (fill(0.0, 3, 1), fill(1.0, 3, 1))\nN = 100\nC1, C2, M1, M2 = Problem(A, B, θfields, tfields)\nt = (0, 1)\n\ndegrees = [x1(A, B, fill(i, 3, 1), C1, C2, M1, M2) for i in range(t[1], t[2], length=N)]\nvelocity = [x2(A, B, fill(i, 3, 1), C1, C2, M1, M2) for i in range(t[1], t[2], length=N)]","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"warning: Warning\nSolvePro()中，fracB^2t4sqrtA等含有除以矩阵A的式子，在编写时都要写为左乘A的逆矩阵。这是由数学含义决定的，否则结果错误。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"上述代码的核心思想为：将符号计算与数字计算在形式上统一。核心为函数x1()与x2()。其便捷性在于，若把符号矩阵作为传递给x1()，则x1()计算结果为符号矩阵，若传递数值，则计算结果为数值解。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"符号计算解参数：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"function SolvePro(eqs, init, vars)\n    pro = NLProblem(eqs, init)\n    res = solve(pro)\n    return [reshape([res[var[i]] for i in 1:3], (3, 1)) for var in vars]\nend\nfunction condition(θfields, A, B, tfields, C1, C2, M1, M2)\n    res = x1(A, B, tfields[1], C1, C2, M1, M2)\n    eqs = [res[i] ~ θfields[1][i] for i in 1:3]\n    res = x1(A, B, tfields[2], C1, C2, M1, M2)\n    append!(eqs, [res[i] ~ θfields[2][i] for i in 1:3])\n    res = x2(A, B, tfields[1], C1, C2, M1, M2)\n    append!(eqs, [res[i] ~ θfields[3][i] for i in 1:3])\n    res = x2(A, B, tfields[2], C1, C2, M1, M2)\n    append!(eqs, [res[i] ~ θfields[4][i] for i in 1:3])\n    return eqs\nend\nfunction Problem(A, B, θfields, tfields)\n    vars = @variables C1[1:3] C2[1:3] M1[1:3] M2[1:3]\n    C1, C2, M1, M2 = [reshape(collect(var), 3, 1) for var in vars]\n    eqs = condition(θfields, A, B, tfields, C1, C2, M1, M2)\n    init = Dict(var[i] => 0.0 for var in vars for i in 1:3)\n    return SolvePro(eqs, init, vars)\nend","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"在Problem()函数中，定义了12个未知数。\n将符号作为参数传递给condition()并通过其构建待求解方程。如果兴趣可以在函数中Print待求解方程结果。\n通过SolvePro()调用EquationsSolver方程求解器求解。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"最终可得到12个参数的结果","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"数字计算算结果：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"在计算出4个参数向量后，SolvePro()经过结果处理返回参数向量值，再调用x1()与x2()时，则能够得到各时间点的数值。具体的操作方式如下：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"t = (0, 1)\ndegrees = [x1(A, B, fill(i, 3, 1), C1, C2, M1, M2) for i in range(t[1], t[2], length=N)]\nvelocity = [x2(A, B, fill(i, 3, 1), C1, C2, M1, M2) for i in range(t[1], t[2], length=N)]","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"在调用x1()与x2()时，不过是传递了不同的参数，就能得到不同结果的类型。传递符号就计算符号，传递数值就计算数值。符号与数值本在数学形式上是一致的，在Julia中则完美地实现了这一点！","category":"page"},{"location":"Control/OptimControl/#.3-解析解可视化","page":"最优控制理论与应用","title":"4.3 解析解可视化","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"degrees = real.(degrees)\nvelocity = real.(velocity)\nusing Plots\nfilename = \"./a.gif\"\nlen = 1\nanim = @animate for i in 1:N\n    strings = \"t=$(i/N*(t[2]-t[1])+t[1])  \"\n    strings *= \"v₁=\" * string(round.(velocity[i][1], digits=2))\n    strings *= \" v₂=\" * string(round.(velocity[i][2], digits=2))\n    strings *= \" v₃=\" * string(round.(velocity[i][3], digits=2))\n    l = collect(0:0.01:len)\n    xs1 = l .* sin(degrees[i][1])\n    ys1 = l .* cos(degrees[i][1])\n    xs2 = l .* sin(degrees[i][2]) .+ xs1[end]\n    ys2 = l .* cos(degrees[i][2]) .+ ys1[end]\n    xs3 = l .* sin(degrees[i][3]) .+ xs2[end]\n    ys3 = l .* cos(degrees[i][3]) .+ ys2[end]\n    plot([xs1, xs2, xs3], [ys1, ys2, ys3],\n        ylims=(0, 4), xlims=(-3, 3), w=3,\n        grid=false, showaxis=false, legend=false,\n        title=strings)\nend\ngif(anim, filename, fps=24)","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"上面的实例计算的是机器人初态为theta=fracpi3-fracpi4fracpi2的情况。动图如下：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 2)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"机器人初态为theta=fracpi3fracpi4fracpi5的情况：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 3)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"机器人初态为theta=fracpi18fracpi6fracpi4的情况：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 4)  ","category":"page"},{"location":"Control/OptimControl/#数值解","page":"最优控制理论与应用","title":"5 数值解","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"该问题使用数值解则很好解决，优化问题使用JuMP则迎刃而解。","category":"page"},{"location":"Control/OptimControl/#.1-求解方法","page":"最优控制理论与应用","title":"5.1 求解方法","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"首先看一个示例：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"using JuMP, LinearAlgebra, Ipopt, Statistics\n\nθ = [π / 3, -π / 4, π / 2]\nθ = [π / 18, π / 6, π / 4]\nθ = [π / 3, π / 4, π / 5]\nN = 100\ntf = 4.0\n\n#---------------------------------------------#\nfunction initPara()\n    J1 = 1.0 / 12 * collect(I(3))\n    C1 = 0.5 * [1 2 2; 0 1 2; 0 0 2]\n    D1 = 0.5 * [1 0 0; 2 1 0; 4 2 1]\n    J = J1 + C1 * D1\n    K = 0.5 * [5 0 0; 0 3 0; 0 0 1]\n    B = [1 -1 0; 0 1 -1; 0 0 1]\n    A = inv(J) * K\n    B = inv(J) * B\n    return A, B\nend\nA, B = initPara()\nmodel = Model(Ipopt.Optimizer)\n@variables(model, begin\n    -π / 2 <= x1[1:N, 1:3] <= π / 2\n    x2[1:N, 1:3]\n    -10 <= u[1:N, 1:3] <= 10\nend)\ninitzeros = zeros(3)\nfor j in 1:3\n    @NLconstraint(model, x1[1, j] == θ[j])\n    @NLconstraint(model, x2[1, j] == initzeros[j])\n    @NLconstraint(model, x1[N, j] == initzeros[j])\n    @NLconstraint(model, x2[N, j] == initzeros[j])\nend\nfor i in 1:N-1\n    a1 = x1[i, :] + (x2[i+1, :] + x2[i, :]) * 0.5 * tf / N\n    a2 = x2[i, :] + (A * (x1[i+1, :] + x1[i, :]) + B * (u[i+1, :] + u[i, :])) * 0.5tf / N\n    for j in 1:3\n        @NLconstraint(model, x1[i+1, j] == a1[j])\n        @NLconstraint(model, x2[i+1, j] == a2[j])\n    end\nend\n@NLobjective(model, Min, sum(20 / π * x1[i, j]^2 + u[i, j]^2 for i in 1:N-1 for j in 1:3))\nJuMP.optimize!(model)\ndegrees = JuMP.value.(x1)\nvelocity = JuMP.value.(x2)\n\n\nusing Plots\nfilename = \"./u_x_a4.gif\"\nlen = 1\nanim = @animate for i in 1:N\n    strings = \"Numerical t=$(i/N*tf)  \"\n    strings *= \"v₁=\" * string(round(velocity[i, 1], digits=2))\n    strings *= \" v₂=\" * string(round(velocity[i, 2], digits=2))\n    strings *= \" v₃=\" * string(round(velocity[i, 3], digits=2))\n    l = collect(0:0.01:len)\n    xs1 = l .* sin(degrees[i, 1])\n    ys1 = l .* cos(degrees[i, 1])\n    xs2 = l .* sin(degrees[i, 2]) .+ xs1[end]\n    ys2 = l .* cos(degrees[i, 2]) .+ ys1[end]\n    xs3 = l .* sin(degrees[i, 3]) .+ xs2[end]\n    ys3 = l .* cos(degrees[i, 3]) .+ ys2[end]\n    plot([xs1, xs2, xs3], [ys1, ys2, ys3],\n        ylims=(0, 4), xlims=(-3, 3), w=3,\n        grid=false, showaxis=false, legend=false,\n        title=strings)\nend\ngif(anim, filename, fps=24)","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"该示例包含了求解与可视化，有如下特征:","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"时间采样数（离散数）为：N = 100；\n调节时间为：tf = 4；\n优化变量（扭矩、角度）有范围限制；\n终端对速度也有约束；\n状态方程作为优化问题的约束，约束不同时刻的状态量之间的关联（不同时间的角度值为不同优化变量。角度状态，角速度状态，扭矩状态各有3N个）。状态方程变为离散结构，因为一旦涉及到数值解，必定是离散化的。离散的方式是二阶的梯形法；\n优化目标为sum_j=1^3sum_i=1^Nfrac20pix_1(ij)^2+u_(ij)^2","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"tip: Tip\n离散的概念有两种理解，一种为问题性质上的理解，即问题本身具有离散性质。另外一种是方法上的理解，即求解问题的过程中对于连续问题采用了离散化的方式。问题性质的离散，是变量本身的一种状态或特性，如开关状态的0与1是独立的状态，本身具有不连续的特性。而离散化是对于连续问题的求解方式。问题本身是连续的，但是为了使用数值计算方法求得数值解，需要取“连续”中的一些相互间隔的“离散”点来代表“连续”。例如，微分方程的数值解法欧拉法的步长则是具有“连续”性质的离散。微分方程的数值解法，一定是离散化的方法——在时间域上选取一定步长间隔的点求解。这两者都可以认为是离散问题，而离散化的方法决定了数值计算的精度以及求解的计算量。从方法的层面说，数值计算本身就是离散问题，对于使用计算机进行数值求解来说，不存在连续求解方法。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"对于以上6点，先不做说明，可以先看一些结果。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况一","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"优化目标：sum_j=1^3sum_i=1^Nu_(ij)^2；\n参数：N = 100，tf = 1；\n末速度限制为0；变量无约束。\n初态为theta=fracpi3-fracpi4fracpi2","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 5)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况二 ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"优化目标：sum_j=1^3sum_i=1^Nu_(ij)^2；\n参数：N = 100，tf = 1；\n末速度无限制；变量无约束。\n初态为theta=fracpi3-fracpi4fracpi2","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 6)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况三 ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"优化目标：sum_j=1^3sum_i=1^Nx_1(ij)^2；\n参数：N = 100，tf = 1；\n末速度限制为0；变量无约束。\n初态为theta=fracpi3-fracpi4fracpi2","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 8)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况四","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"优化目标：sum_j=1^3sum_i=1^Nx_1(ij)^2；\n参数：N = 100，tf = 2；\n末速度限制为0；变量范围限制：-10=u=10。\n初态为theta=fracpi3-fracpi4fracpi2","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 9)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况五","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"优化目标：sum_j=1^3sum_i=1^Nx_1(ij)^2+u_(ij)^2；\n参数：N = 100，tf = 4；\n末速度限制为0；变量范围限制：-10=u=10。\n初态为theta=fracpi3-fracpi4fracpi2","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 10)  ","category":"page"},{"location":"Control/OptimControl/#.2-对比分析","page":"最优控制理论与应用","title":"5.2 对比分析","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况一（站直且速度为零）与情况二（站直速度任意）为不同边界约束的结果。情况一确实不如情况二“迅猛”，情况一的机器人有些拘束，情况二的动作则一气呵成，因为约束少了。同时，情况一的解析解与数值解结果，机器人动作非常神似。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况一（最省力）、情况三（距离最短）与情况五（省力也要距离短）为不同优化条件的结果。可以看出来情况五综合了情况一个和情况二的优点。同时，情况五x_1前面的系数目的是为了平衡优化的效果——将角度值与速度值置于同一量级，即加大省距离的权重。这类似于机器学习的正则化。其实他们在内涵上有相通之处，通过权重规定了对不同优化目标的“重视程度”！","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况三与情况四的不同之处在于控制量的范围约束与调节时间限制。在数学上来说，不管给定何种始终条件，若控制量u不限制，则一定能完成控制任务（优化问题有解）。所以在条件4的控制量约束下，若是设tf=1，则在求解时找不到最优解，唯有把时间放款才能在控制量约束下找到解。这非常符合实际，控制量不能无限大，控制过程也需要时间。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"事实上，也可以通过解析解来验证这些结论，但解析解的代码量太大，不如数值解来得方便 :) 。例如，同时考虑x与u的解析解结果为 :)：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 11)  ","category":"page"},{"location":"Control/OptimControl/#总结","page":"最优控制理论与应用","title":"总结","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"由机器人的最优控制问题，介绍最优问题的解析解与数值解。从两方面基本上已经诠释了最优控制的内涵。即，为了某种目标去找到一组最合适的控制量。事实上，这只是控制的第一步，计算结果都是静态的。接下来还需要根据实际的系统反馈进行时间域上的滚动优化，滚动起来后，就能够利用系统的反馈，实现了真正意义上的控制——对反馈的处理与计算。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"另外，从整个机器人问题求解的过程也可以看出Julia生态的强大之处。当问题清楚之后，灵活使用Julia生态的各种软件包，能方便快捷地计算出结果。事实上，最优控制问题的底层数学形式为两种——求解类问题（解析解）与优化类问题（数值解）。同时，符号计算使得编写代码方便快捷。这三者恰恰是Julia计算的长处。所以Julia处理最优控制问题，可以用两个词来形容——丝滑、顺畅。","category":"page"},{"location":"JuliaIntro/2-julia的REPL/#julia的REPL","page":"julia的REPL","title":"julia的REPL","text":"","category":"section"},{"location":"JuliaIntro/2-julia的REPL/#什么是REPL","page":"julia的REPL","title":"什么是REPL","text":"","category":"section"},{"location":"JuliaIntro/2-julia的REPL/","page":"julia的REPL","title":"julia的REPL","text":"REPL是\"Read-Eval-Print Loop\"（读取-求值-输出循环）的缩写，它是一种交互式的编程环境。REPL通常是通过命令行界面提供的，允许用户输入代码、进行求值和查看结果。","category":"page"},{"location":"JuliaIntro/2-julia的REPL/","page":"julia的REPL","title":"julia的REPL","text":"在Julia中，REPL是与Julia交互的主要方式。当您打开Julia的命令行界面或终端时，您就进入了Julia的REPL环境。REPL具有以下主要功能：","category":"page"},{"location":"JuliaIntro/2-julia的REPL/","page":"julia的REPL","title":"julia的REPL","text":"读取（Read）：REPL等待用户输入Julia代码。用户可以逐行输入代码，也可以将代码块作为一次性输入。\n求值（Eval）：一旦用户输入了代码，REPL会对代码进行求值。它会将代码发送给Julia的解释器或编译器，并计算结果。\n输出（Print）：求值完成后，REPL会将结果显示在终端中。这可以是计算结果、变量的值、函数的输出或错误信息。\n循环（Loop）：一旦输出被显示，REPL会再次等待用户的输入，形成一个循环。用户可以继续输入新的代码，并重复读取、求值和输出的过程。","category":"page"},{"location":"JuliaIntro/2-julia的REPL/","page":"julia的REPL","title":"julia的REPL","text":"REPL是一个交互式的环境，它使您能够迅速尝试和调试代码，查看计算结果，并与Julia进行实时交互。它是学习、测试和探索Julia语言的重要工具。","category":"page"},{"location":"JuliaIntro/2-julia的REPL/","page":"julia的REPL","title":"julia的REPL","text":"除了在命令行中使用的REPL，还有一些基于Web的交互式Julia环境，如Jupyter Notebook和Pluto.jl，它们提供了更丰富的功能和更好的可视化支持。","category":"page"},{"location":"JuliaIntro/2-julia的REPL/#julia的REPL-2","page":"julia的REPL","title":"julia的REPL","text":"","category":"section"},{"location":"JuliaIntro/2-julia的REPL/","page":"julia的REPL","title":"julia的REPL","text":"当使用Julia的REPL（Read-Eval-Print Loop）时，您可以直接在终端中输入和执行Julia代码，以便快速尝试和调试代码片段。以下是一些关于Julia REPL的重要信息和常用命令：","category":"page"},{"location":"JuliaIntro/2-julia的REPL/","page":"julia的REPL","title":"julia的REPL","text":"启动Julia REPL：在终端中输入\"julia\"命令，然后按下回车键，即可启动Julia的REPL。您将看到一个交互式的Julia环境。\n执行代码：在Julia REPL中，您可以直接输入Julia代码，并按下回车键执行。Julia将立即执行代码并显示结果。\n多行输入：如果您有多行代码需要输入，可以使用连续的三个小数点（...）来表示多行输入。在输入完最后一行代码后，按下回车键即可执行。\n历史记录：Julia REPL会记住您在当前会话中输入的代码，并将其记录在历史记录中。您可以使用上下箭头键来浏览和重新执行之前的代码。\n帮助文档：要获取关于Julia函数、模块或类型的帮助文档，您可以在REPL中输入问号（?）后跟着您感兴趣的函数或类型的名称，然后按下回车键。Julia将显示相关的帮助文档。\n退出REPL：要退出Julia REPL，您可以输入\"exit()\"或按下Ctrl+D（在大多数系统上）。","category":"page"},{"location":"JuliaIntro/2-julia的REPL/","page":"julia的REPL","title":"julia的REPL","text":"Julia的REPL是一个强大的工具，可用于快速测试代码、尝试新功能、查看帮助文档等。它提供了一个与Julia交互的方式，使您能够更加灵活地使用和学习Julia语言。","category":"page"},{"location":"JuliaIntro/2-julia的REPL/","page":"julia的REPL","title":"julia的REPL","text":"希望这些信息能够帮助您向学生介绍Julia的REPL！如有任何进一步的问题，请随时向我提问。","category":"page"},{"location":"JuliaIntro/2-julia的REPL/#julia的REPL的4个模式","page":"julia的REPL","title":"julia的REPL的4个模式","text":"","category":"section"},{"location":"JuliaIntro/2-julia的REPL/","page":"julia的REPL","title":"julia的REPL","text":"Julia REPL提供了四个不同的模式，每个模式都有不同的用途和功能。以下是关于Julia REPL的四个模式的简要介绍：","category":"page"},{"location":"JuliaIntro/2-julia的REPL/","page":"julia的REPL","title":"julia的REPL","text":"默认模式 (Default mode)： 默认模式是Julia REPL的标准模式，也是您在启动REPL时进入的模式。在默认模式下，您可以输入和执行Julia代码，并查看代码的结果。默认模式是最常用的模式，适用于大多数日常的交互式编程任务。\n帮助模式 (Help mode)： 帮助模式是一种特殊的模式，用于查看Julia函数和类型的帮助文档。要进入帮助模式，您可以在REPL中输入问号（?）后跟着您感兴趣的函数或类型的名称，然后按下回车键。在帮助模式下，您可以浏览和搜索函数的用法、参数以及相关的示例代码。要退出帮助模式，只需按下回车键即可返回默认模式。\n包管理模式 (Package mode)： 包管理模式允许您管理Julia的软件包（Packages）。Julia的软件包是用于扩展和增强Julia功能的工具。在包管理模式下，您可以安装、更新和删除软件包，查看已安装软件包的列表，以及管理项目的依赖关系。要进入包管理模式，您可以在REPL中输入\"]\"（右方括号），然后按下回车键。在包管理模式下，您可以使用各种命令来管理软件包。要退出包管理模式，只需输入\"exit\"并按下回车键即可返回默认模式。\nShell模式 (Shell mode)： Shell模式允许您在Julia REPL中执行系统命令。在Shell模式下，您可以使用Julia REPL作为一个简单的终端来执行操作系统命令，如列出目录内容、运行脚本文件等。要进入Shell模式，您可以在REPL中输入分号（;），然后按下回车键。在Shell模式下，您可以输入系统命令并查看其输出。要退出Shell模式，只需输入\"exit\"并按下回车键即可返回默认模式。","category":"page"},{"location":"JuliaIntro/2-julia的REPL/","page":"julia的REPL","title":"julia的REPL","text":"这些不同的模式使Julia REPL成为一个更加灵活和功能丰富的工具，适用于不同的工作流程和任务。您可以根据需要切换不同的模式，以最大程度地发挥Julia REPL的潜力。","category":"page"},{"location":"JuliaIntro/2-julia的REPL/","page":"julia的REPL","title":"julia的REPL","text":"希望这些介绍有助于您了解Julia REPL的四个模式！如有任何进一步的问题，请随时向我提问。","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/#MTK符号系统参数辨识","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"","category":"section"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"tip: Tip\nContents：MTK模型、优化、DiffEqParamEstimContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"note: Note\nDEPE = DiffEqParamEstim.jl(Differential Equation Parameters Estimate)DiffEqParamEstim.jl是计算微分方程参数估计的软件包。","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/#原理","page":"MTK符号系统参数辨识","title":"原理","text":"","category":"section"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"MTK与DE在问题层面具有一致性。MTK是符号处理的软件包，问题的求解仍然推给DE。而DEPE是从DE的problem层面构建的参数优化问题，所以使用MTK进行建模后，依然可以使用DEPE进行参数估计。对于DEPE来说，不管是MTK还是DE，它接受的问题都是DE的Problem。所以，不管是使用MTK还是DE构建模型，到DEPE这一层面都是贯通的。","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"下面以RC电路模型为例，进行电路中正弦电压源的电压值估计。","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/#RC组件建模","page":"MTK符号系统参数辨识","title":"RC组件建模","text":"","category":"section"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"基于ModelingToolkit，建立RC电路模型，模型如下图所示。这是一个震荡电路 (Image: 在这里插入图片描述)","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/#构建组件","page":"MTK符号系统参数辨识","title":"构建组件","text":"","category":"section"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"首先完成电路模型的组件编写，一共有5个组件，分别是电源、电阻、电容、电感、接地","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"using ModelingToolkit, Plots, DifferentialEquations\n\n@variables t\n@connector function Pin(; name)\n    sts = @variables v(t) = 1.0 i(t) = 1.0 [connect = Flow]\n    ODESystem(Equation[], t, sts, []; name=name)\nend\n\nfunction Ground(; name)\n    @named g = Pin()\n    eqs = [g.v ~ 0]\n    compose(ODESystem(eqs, t, [], []; name=name), g)\nend\n\nfunction OnePort(; name)\n    @named p = Pin()\n    @named n = Pin()\n    sts = @variables v(t) = 1.0 i(t) = 1.0\n    eqs = [\n        v ~ p.v - n.v\n        0 ~ p.i + n.i\n        i ~ p.i\n    ]\n    compose(ODESystem(eqs, t, sts, []; name=name), p, n)\nend\n\nfunction Resistor(; name, R=1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters R = R\n    eqs = [\n        v ~ i * R\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction Capacitor(; name, C=1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters C = C\n    D = Differential(t)\n    eqs = [\n        D(v) ~ i / C\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction ConstantVoltage(; name, V=1.0)\n    @named oneport = OnePort()\n    @unpack v = oneport\n    ps = @parameters V = V\n    eqs = [\n        V ~ v\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction Inductor(; name, L=1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters L = L\n    D = Differential(t)\n    eqs = [\n        D(i) ~ v / L\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction ChangeableVoltage(; name)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    eqs = [\n        v ~ 16 * sin(2π * t)\n    ]\n    extend(ODESystem(eqs, t, [], []; name=name), oneport)\nend","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"可以看到，系统一共定义有4个参数，分别是电阻值，电容值，电感值以及电压的最大值","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"然后，通过连接函数，组建系统","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"@named resistor = Resistor(R=3.0)\n@named capacitor = Capacitor(C=1.0/24)\n@named source = ChangeableVoltage(vol=10.0)\n@named inductor = Inductor(L=0.1)\n@named ground = Ground()\n\n\nrc_eqs = [\n          connect(source.p, capacitor.p)\n          connect(capacitor.n, inductor.p)\n          connect(inductor.n, resistor.p)\n          connect(source.n,resistor.n,ground.g)\n         ]\n\n@named _rc_model = ODESystem(rc_eqs, t)\n@named rc_model = compose(_rc_model,\n    [resistor, inductor, capacitor, source, ground])\n\nsys = structural_simplify(rc_model)\n\nusing Plots\nu0 = [\n    capacitor.v => 0.0\n    capacitor.p.i => 0.0\n    inductor.i => 0\n    inductor.v => 0\n     ]\nP=[3.0,1.0/24,0.1,10.0]  #系统的参数\nprob = ODAEProblem(sys, u0, (0, 10.0),P)\nsol = solve(prob, Tsit5())\n\np1 = plot(sol,vars=[capacitor.v capacitor.p.i],xlims = (0,10),ylim = (-10,15))\np2 = plot(sol,vars=[inductor.v inductor.i],xlims = (0,10),ylim = (-5,5))\nplot(p1,p2,layout=(2,1))\n","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"运行代码可以得到结果图： (Image: 在这里插入图片描述)","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"电容的电压电流、电感的电压电流都是震荡的。","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"初值向量P分别对应4个参数的参数值，电压值为最后一个，设定为10.0","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"在不知道参数的顺序时，可以使用parameters函数查看系统参数。","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"parameters(sys)","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/#建立问题","page":"MTK符号系统参数辨识","title":"建立问题","text":"","category":"section"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"为了能够模拟参数辨识，给其中一个变量加上扰动（这里依旧采用手动生成数据的思想，可能保证模型与数据匹配）。可以使用states函数查看系统变量（在组件设计过程中定义的）。","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"states(sys)","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"这里对两个变量都添加扰动。","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"using RecursiveArrayTools\nt = collect(range(0,stop=10,length=1000)) # 建立时间向量\nrandomized = VectorOfArray([(sol(t[i]) + .5randn(2)) for i in 1:length(t)])\ndata = convert(Array,randomized)  ","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"对sol的结果，选取了1000个点作为样本点加入扰动。","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"加入的扰动的方式是：通过生成绝对值小于0.5的随机数加入到从sol中选取出来的样本点中去，将其作为需要参数辨识的样本数据。","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"看一看扰动生成的结果：","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"p1=plot(t,data[1,:],ylim=(-8,8))\np1=plot!(t,data[2,:],ylim=(-8,8))\np2=plot(sol,vars=[inductor.i,capacitor.v],ylim=(-8,8))\nplot(p1,p2,layout=(2,1))","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"产生的结果图为： (Image: 在这里插入图片描述)","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/#辨识过程","page":"MTK符号系统参数辨识","title":"辨识过程","text":"","category":"section"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"参数辨识使用DiffEqParamEstim，","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"using DiffEqParamEstim\ncost_function = build_loss_objective(prob,Tsit5(),\nL2Loss(t,data),maxiters=10000,verbose=false)","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"通过buildlossobjective建立了辨识模型，即通过该函数可以求处理后的样本点与模型计算结果的方差和（L2Loss），当然方差和只是作为拟合的评价指标之一，可以选取不同的函数或者构建不同的指标。","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"接下来，看一看不同的电压值，带来的方差和的变化。","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"vals = 0:0.1:20.0\nplot(vals,[cost_function([3.0,1.0/24,0.1,i]) for i in vals],yscale=:log10,\n     xaxis = \"Parameter\", yaxis = \"Cost\", title = \"1-Parameter Cost Function\",\n     lw = 3)","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"val为从0开始，到20，步长为0.1。对这些电压值，去匹配模型，算出来的与样本值的方差和会不同。","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"结果为： (Image: 在这里插入图片描述)","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"可以看到，在10.0的地方，方差和最小（因为设定的值就是10.0，扰动是在此基础之上叠加的）。说明辨识结果有效。","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"以上是通过“肉眼”观察的出来的结果。科学的方法是求一组参数，使得方差和最小。这是一个最优化问题。使用Optim","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"using Optim\nresult = optimize(cost_function, [3.0,1.0/24,0.1,15])\nresult.minimizer","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"将电压的初始值设为15去寻优，得到的结果为：","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"4-element Vector{Float64}:\n 2.975801390547115\n 0.04266590691854741\n 0.09999565290932136\n 9.923607580088433","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"和真实值是非常接近的！寻优有效！","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"也可以将4个初始值都改变去寻优。","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"result = optimize(cost_function, [2.0,0.1,0.5,16])\nresult.minimizer","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"得到的结果也很好","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"4-element Vector{Float64}:\n 2.972037379476059\n 0.04300492580277582\n 0.09998659716890046\n 9.911215185371102","category":"page"},{"location":"Optimization/97-MTK符号系统参数辨识实例/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"note: Note\n该参数辨识仍然是优化问题的子集，选择不同的初值很可能得到不同的结果。","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/#MTK部分参数辨识实例","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"","category":"section"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"tip: Tip\nContents：MTK模型、优化、DiffEqParamEstimContributor: HYEmail:1171006975@qq.com如有错误，请批评指正。","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"note: Note\nDEPE = DiffEqParamEstim.jl(Differential Equation Parameters Estimate)DiffEqParamEstim.jl是计算微分方程参数估计的软件包。","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/#原理","page":"MTK部分参数辨识实例","title":"原理","text":"","category":"section"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"在进行参数辨识的时候，我们往往会遇到一个问题——实验只能测一到两个关键数据，例如温度、电压电流等。但在咱们的ODEsystem中，状态量states往往不止一两个（甚至有几十个），而在DiffEqParamEstim.jl包中，构建损失函数时要求我们导入所有states的实验数据，显然咱们是办不到的。这个时候，咱们有两种解决方案：1.自己重构损失函数，这个方法显然是最高级的，是真正的治标又治本的方法，但是重构损失函数对初学者可能不够友好（比如说我）。因此，在这里给大家介绍第2种解决方案：引入加权值weight，无法通过实验测得的数据，我们可以将其的weight设为0，其他能测得的states设为1。这样，我们相当于重构了损失函数，程序只会根据我们“指定”的那些数据进行参数辨识，效果跟方案1是一样的。","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"下面以三星18650锂电池为例，对锂电池的模型参数进行辨识。","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/#等效电路建模","page":"MTK部分参数辨识实例","title":"等效电路建模","text":"","category":"section"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"基于ModelingToolkit，建立Thevenin二阶RC等效电路模型，如下图所示。 该等效电路模型是由开路电压Uoc，欧姆内阻R0和两个RC网络结构组成，U1、U2分别为R1、R2的端电压，UT表示电池的端电压。 (Image: 图1)","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/#构建组件","page":"MTK部分参数辨识实例","title":"构建组件","text":"","category":"section"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"组件总共有两个，一个是锂电池组件，用来模拟锂电池的伏安特性，另一个是充放电控制器组件，用来模拟锂电池的恒流充放电。","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"using DiffEqParamEstim, DifferentialEquations, Random, ModelingToolkit, PlotlyJS\nusing OptimizationOptimJL\nusing IfElse: ifelse\nimport RecursiveArrayTools.VectorOfArray\n@variables t\n∂ = Differential(t)\n@connector function Pin(; name)\n    sts = @variables v(t) = 1.0 i(t) = 1.0 [connect = Flow]\n    ODESystem(Equation[], t, sts, []; name=name)\nend\nfunction OnePort(; name)\n    @named p = Pin()\n    @named n = Pin()\n    sts = @variables v(t) = 1.0 i(t) = 1.0\n    eqs = [\n        v ~ p.v - n.v\n        0 ~ p.i + n.i\n        i ~ p.i\n    ]\n    compose(ODESystem(eqs, t, sts, []; name=name), p, n)\nend\nfunction OnePort_key(; name, v_start = 1.0, i_start = 0.0)\n    @named p = Pin()\n    @named n = Pin()\n    sts = @variables v(t) = v_start [irreducible=true] i(t) = i_start [irreducible=true]\n    eqs = [\n        v ~ p.v - n.v\n        0 ~ p.i + n.i\n        i ~ p.i\n    ]\n    compose(ODESystem(eqs, t, sts, []; name=name), p, n)\nend\nfunction Ground(; name)\n    @named g = Pin()\n    eqs = [g.v ~ 0]\n    compose(ODESystem(eqs, t, [], []; name=name), g)\nend\nfunction Lithium_ion_batteries(; name, OCV=3.9998, R0=0.029031, R1=0.00994, R2=0.01408, C1=147.462, C2=902.911)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    sts = @variables v_c1(t) = 0.001 v_c2(t) = 0.001 v_b(t) = 1.0 i_b(t) = 0.0\n    ps = @parameters(\n        R0 = R0,\n        R1 = R1,\n        R2 = R2,\n        C1 = C1,\n        C2 = C2,\n        OCV = OCV,\n    )\n    eqs = [\n        OCV ~ i_b * R0 + v_c1 + v_c2 + v_b\n        i_b ~ C1 * ∂(v_c1) + v_c1 / R1\n        i_b ~ C2 * ∂(v_c2) + v_c2 / R2\n        v ~ v_b\n        i ~ -i_b\n    ]\n    return extend(ODESystem(eqs, t, sts, ps; name=name), oneport)\nend\nfunction charge_controller(; name)\n    @named oneport = OnePort_key()\n    @unpack v, i = oneport\n    equa = ifelse(t <= 10.0,16.0,ifelse(t <= 40.0,0.0,ifelse(t <= 50.0,-16.0,0.0)))\n    eqs = [i ~ equa]\n    return extend(ODESystem(eqs, t, [], []; name=name), oneport)\nend","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"不难发现，系统一共定义有6个参数，分别是欧姆内阻R0,两个RC支路所对应的R1,R2,C1,C2以及开路电压OCV。","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"然后，通过连接函数，组建系统","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"@named ground = Ground()\n@named cg = charge_controller()\n@named batter = Lithium_ion_batteries()\neqs = [\n    connect(batter.p, cg.p)\n    connect(batter.n, cg.n, ground.g)\n]\n\n@named OdeFun = ODESystem(eqs, t)\n@named model = compose(OdeFun, [batter, cg, ground])\nsys = structural_simplify(model)\nu0 = [\n    batter.v_c1 => 0.024058864\n    batter.v_c2 => 0.002594792\n    cg.v => 3.928902637\n    cg.i => 0\n    batter.R0 => 0.037517357\n    batter.R1 => 0.020913201\n    batter.R2 => 0.006915906\n    batter.C1 => 4636.08469\n    batter.C2 => 1292.103841\n    batter.OCV => 3.955556293\n]\nprob = ODEProblem(sys, u0, (40.0, 60.0))","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/#导入实验数据","page":"MTK部分参数辨识实例","title":"导入实验数据","text":"","category":"section"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"导入实验数据，并对数据的格式进行一定的处理。","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"time = [\n    40.98797751\n    42.00601125\n    42.99980609\n    43.99360093\n    45.01163467\n    46.00542951\n    46.99922436\n    47.9930192\n    50.99864262\n    53.0104712\n    55.99185573]\nreal_data = [\n    4.511920324\n    4.536819172\n    4.551011516\n    4.570183629\n    4.57665733\n    4.5881108\n    4.593588547\n    4.598817305\n    3.985060691\n    3.94746343\n    3.910364146]\n\nrandomized = VectorOfArray([[0, 0, real_data[i], 0] for i in 1:length(time)])\ndata = convert(Array, randomized)\n\nweight = VectorOfArray([[0.0, 0.0, 1.0, 0.0] for i in 1:length(time)])\ndata_weight = convert(Array, weight)","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"本实例的数据通过getdata软件从文献中扣取。","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"系统变量有四个，分别为batter.v_c1,batter.v_c2,cg.v,cg.i。其中cg.v的数据通过实验获得，其权重值weight设为1，其他的变量权重值设为0。","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"系统参数有六个，分别为batter.R0,batter.R1,batter.R2,batter.C1,batter.C2,batter.OCV。","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"最终生成了data和data_weight矩阵，分别代表实验数据和相应权重值。","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"(Image: 图2)","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"在不知道参数的顺序时，可以使用parameters和states函数查看系统参数。","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"parameters(sys)\nstates(sys)","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/#构建损失函数并求解","page":"MTK部分参数辨识实例","title":"构建损失函数并求解","text":"","category":"section"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"obj = build_loss_objective(prob, Rosenbrock23(), L2Loss(time, data, data_weight=data_weight), maxiters=100000)\n\nresult = OptimizationOptimJL.optimize(obj,[0.037517357, 0.020913201, 0.006915906, 4636.08469, 1292.103841, 3.955556293])\nresult.minimizer","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"参数辨识结果为：","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"(Image: 图3)","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"至此，锂电池充电阶段的参数辨识完毕。同理可辨识放电阶段的参数。","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"放电阶段实验数据：","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"time = [\n    1.502811712\t\n    3.005623424\n    4.508435137\t\n    6.011246849\t\n    7.489819663\t\n    11.9982548\t\n    13.50106651\t\n    15.00387822\t\n    16.50668994\t\n    18.00950165\t\n    19.48807446\t\n    20.99088617\t\n    22.49369789\t\n    23.9965096\t\n    25.49932131\t\n    27.00213302\t\n    28.50494474\n    30.00775645\t\n    31.51056816\t\n    32.98914097\n    34.49195269\n    35.9947644]\nreal_data = [\n    3.335698724\n    3.31503268\n    3.295860566\n    3.277933396\n    3.266977902\n    3.864799253\n    3.878244631\n    3.880734516\n    3.888702148\n    3.897167756\n    3.898910675\n    3.902645503\n    3.908372238\n    3.911858077\n    3.915094927\n    3.918082789\n    3.91957672\n    3.926797386\n    3.923311547\n    3.92107065\n    3.92107065\n    3.926299409]","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"放电阶段参数辨识结果为：","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"(Image: 图4)","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/#模型验证","page":"MTK部分参数辨识实例","title":"模型验证","text":"","category":"section"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"当放电阶段和充电阶段的模型参数全部辨识出来了以后，我们再将模型参数重新带回ODEsystem中，验证一下辨识结果是否有效。","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"continuous_events = [\n    [t ~ 40.0] => [batter.R0 ~ 0.037203619\n        batter.R1 ~ 0.062205413\n        batter.R2 ~ 0.007078411\n        batter.C1 ~ 6373.89753\n        batter.C2 ~ 407.3465496\n        batter.OCV ~ 3.902760964]\n]\n\n@named OdeFun = ODESystem(eqs,t,continuous_events=continuous_events)\n@named model = compose(OdeFun, [batter, cg, ground])\nsys = structural_simplify(model)\nu0 = [\n    batter.v_c1 => 0.0\n    batter.v_c2 => 0.0\n    cg.v => 0.0\n    cg.i => 0.0\n    batter.R0 => 0.037517357\n    batter.R1 => 0.020913201\n    batter.R2 => 0.006915906\n    batter.C1 => 4636.08469\n    batter.C2 => 1292.103841\n    batter.OCV => 3.955556293\n]\nprob = ODEProblem(sys, u0, (0.0, 60.0))\nsol = solve(prob)","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"对比锂电池的实验数据和仿真数据，可以得到锂电池模型的端电压响应拟合曲线与实际端电压响应曲线的误差，如下图所示。","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"(Image: 图5)","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"(Image: 图6)","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"可以看到，各点的拟合电压曲线误差范围均在约±0.006 V以内，即0.19%。电压最大误差为0.0059 V，平均误差为0.0021 V。电压误差大小远远较锂电池平台电压的变化范围小。因此从精度上看，模型误差尚在可接受的范围之内。","category":"page"},{"location":"Optimization/98-MTK部分参数辨识实例/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"note: Note\n该参数辨识仍然是优化问题的子集，选择不同的初值很可能得到不同的结果。 完整代码可以在/src目录下查看","category":"page"},{"location":"Modeling/ModelingTutorial/#组织方程的艺术——组件化（入门）","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"tip: Tip\nContents：建模思想Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Modeling/ModelingTutorial/#前言","page":"组织方程的艺术——组件化（入门）","title":"前言","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"Ai4Energy开发者总是张口闭口组件化建模，那么组件化建模的内涵到底是什么？为什么要组件化建模？这篇我们从头至尾介绍做一个组件化思想的入门介绍。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"建模用ModelingToolkit.jl；求解用DifferentialEquations.jl。","category":"page"},{"location":"Modeling/ModelingTutorial/#电路问题","page":"组织方程的艺术——组件化（入门）","title":"电路问题","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"以电路系统切入，深入探讨组件化建模的内涵是最合适不过的了。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"首先准备2个电路元件的方程。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"欧姆定律：电阻两端的电压与流过电阻电流成正比。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"U=IR","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电容器：电容两端电压的变化率与电流成正比。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"fracdVdt = fracIC","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"tip: Tip\nC是电容量，单位为法拉（F）。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"我们再准备一个电路系统，如下图:","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"(Image: 图 5)  ","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"需要求解的问题是：电容初始电压为0，当开关闭合后，电容电压电流的变化情况是？","category":"page"},{"location":"Modeling/ModelingTutorial/#手搓求解","page":"组织方程的艺术——组件化（入门）","title":"手搓求解","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"手搓的意思是电路中学的传统解法。开关闭合后，视为导线。采用节点电压法求解。标记三个节点1，2，3。节点电压分别为V_1V_2V_3，如下图。整个电路只有一条主路，所以电流为I。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"(Image: 图 6)  ","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"所以电路的方程为：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"V_1-V_3=1 (V) \nV_1-V_2=1 (Omega) * I\nfracd(V_2-V_3)dt = fracI1 (F) = I\nV_3 = 0 tag1","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"手动化简之后可以得到2种情况：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"保留I，化简掉V_1V_3V_2。开关刚闭合，有电容视为导线，则0时刻，I=1","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"frac1-Idt = -fracdIdt= I\nI_0 = 1(A) tag2","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"保留V_2，化简掉V_1V_3I","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"fracdV_2dt = 1-V_2\nV_20=0(V) tag3","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"以上微分方程式2或3，求解任何一个，把结果代回方程组1，整个电路系统的情况就可以得到了。这个问题就解决了。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"下面看一看组件化怎么做！","category":"page"},{"location":"Modeling/ModelingTutorial/#组件化求解","page":"组织方程的艺术——组件化（入门）","title":"组件化求解","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"在之前的基础之上，我们只做一件事情——引入额外的变量。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"为每个器件添加两个端口变量（地只加一个端口）。正极叫p，负极叫n。同时为器件取名，电源叫做source，电阻叫做resistor，电容叫做capacitor，地叫做ground。同时规定，器件索引其子要素的方式为“.”。例如，电阻正极电压的变量全名为resistorpV。如下图所示。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"(Image: 图 2)  ","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"那么我们新引入了14个变量：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电源的4个","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"sourcenV\nsourceni\nsourcepV\nsourcepi","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电阻的4个","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"resistornV\nresistorni\nresistorpV\nresistorpi","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电容的4个","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"capacitornV\ncapacitorni\ncapacitorpV\ncapacitorpi","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"地的两个","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"groundportV\ngroundporti","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"再研究一下变量关系，我们可以发现。所有端口电流（地端口除外）的数值都等于I，端口电压值都等于对应的电压节点的电压。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"这，貌似就是给V_1V_3V_2I这几个变量加了很多别名？一顿操作猛如虎，细想发现全白干，形式主义我最行？","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"下面才是主菜！","category":"page"},{"location":"Modeling/ModelingTutorial/#Step1:-把V_1,V_3,V_2,I**全踢掉**，如下图。","page":"组织方程的艺术——组件化（入门）","title":"Step1: 把V_1V_3V_2I全踢掉，如下图。","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"(Image: 图 3)   ","category":"page"},{"location":"Modeling/ModelingTutorial/#Step2.-分别写组件的方程，规定电流入流为正，流出为负：","page":"组织方程的艺术——组件化（入门）","title":"Step2. 分别写组件的方程，规定电流入流为正，流出为负：","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电源：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"sourcepV - sourcenV = 1 (V)\nsourcepI + sourcenI = 0","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电阻：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"resistorpV - resistornV = resistorpI * 1 (Omega)\nresistorpI + resistornI = 0","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电容：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"fracd(capacitorpV - capacitornV)dt = fraccapacitorpI1 (F) \ncapacitorpI + capacitornI = 0","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"地（规定电势为0的点，电流不做要求）：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"groundportV = 0\ngroundportI = 0","category":"page"},{"location":"Modeling/ModelingTutorial/#Step3:-构建连接关系","page":"组织方程的艺术——组件化（入门）","title":"Step3: 构建连接关系","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电源和电阻连（等价于节点1，节点电压相等、电流净流量为0）","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"sourcenV = resistorpV\nsourcenI + resistorpI = 0","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电阻和电容连（等价于节点2，节点电压相等、电流净流量为0）","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"resistornV = capacitorpV\nresistornI + capacitorpI = 0","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电容、电源和地连（等价于节点3，节点电压相等、电流净流量为0）","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"capacitornV = sourcpV = groundportV\ncapacitornI + sourcpI + groundportI= 0\n","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"稍微思考一下可以发现，上述10多个方程组成的方程大组，其数学本质与方程小组1完全等价！唯一的区别是前者多引入了很多变量，并且这些变量完全可以消去！","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"但是，前者完成了组件化的封装，由此连接关系与组件内部之间成了相互独立的关系。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"什么意思呢？以V_1为例。V_1既是电压源的出口电压又是电阻的正极电压。同时V_1作为节点电压，已经消去了电流的概念。这就意味每节点是不同的。而组件化的内涵就是把这一点拆解成了两部分：连接与组件内部。以电阻的正负极端口为例，对内建立组件内部的方程：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"resistorpV - resistornV = resistorpI * 1","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"其本质就是U=IR；对外建立与其他组件连接：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"sourcepV = resistorpV\nsourcenI + resistorpI = 0\nresistornV = capacitorpV\nresistornI + capacitorpI = 0","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"其本质就是节点电压1和2.","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"这么多方程很复杂但逻辑清晰。其实它很简单，因为化简计算机会去做。","category":"page"},{"location":"Modeling/ModelingTutorial/#求对比解","page":"组织方程的艺术——组件化（入门）","title":"求对比解","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/#手搓版","page":"组织方程的艺术——组件化（入门）","title":"手搓版","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"把节点电压法的分析过程，写成ModelingToolkit的代码。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"tip: Tip\n在VScode中，输入入V_3就能输入V₃(Image: 图 1)  在VScode中，按下Ctrl+Enter可以执行光标所在行的一行代码。以下的代码可以一行一行执行，看中间结果。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"using ModelingToolkit, DifferentialEquations\n\n# 定义变量\n@variables t\n@variables V₁(t) V₂(t) V₃(t) I(t)\n\n# 定义微分\nD = Differential(t)\n\n# 设置参数\nR = 1.0\nC = 1.0\nV = 1.0\n\n# 输入方程\nrc_eqs = [\n    V₁ - V₃ ~ V\n    V₁ - V₂ ~ I * R\n    D(V₂) ~ I / C\n    V₃ ~ 0\n]\n\n# 构建系统\n@named rc_model = ODESystem(rc_eqs, t)\n\n# 系统化简\nsys = structural_simplify(rc_model)\n\n# 设置初值\nu0 = [\n    V₂ => 0.0\n]\n# 求解时间范围\ntspan = (0.0, 10.0)\n\n# 构建问题并求解\nprob = ODAEProblem(sys, u0, tspan)\nsol = solve(prob, Tsit5())\n\n# 分别查看 V₁, V₂, V₃ 的变化\nsol[V₂]\nsol[V₁]\nsol[V₃]\n","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"再查看一下化简前的方程：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"equations(rc_model)","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"再查看一下化简后的方程：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"equations(sys)","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"方程中V_1=1，和推导的结果是一致的。","category":"page"},{"location":"Modeling/ModelingTutorial/#组件版","page":"组织方程的艺术——组件化（入门）","title":"组件版","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"把组件化的过程，写成代码。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"using ModelingToolkit, DifferentialEquations\n\n# 定义独立时间变量\n@variables t\n\n# 器件端口作为连接点\n@connector function Pin(; name)\n    sts = @variables v(t) = 1.0 i(t) = 1.0 [connect = Flow]\n    return ODESystem(Equation[], t, sts, []; name=name)\nend\n\n# 地，地的端口名字改为g，不是port\nfunction Ground(; name)\n    @named g = Pin()\n    eqs = [g.v ~ 0; g.i ~ 0]\n    return compose(ODESystem(eqs, t, [], []; name=name), g)\nend\n# 电阻元件\nfunction Resistor(; name, R=1.0)\n    @named p = Pin()\n    @named n = Pin()\n    ps = @parameters R = R\n    eqs = [\n        p.v - n.v ~ p.i * R\n        0 ~ p.i + n.i\n    ]\n    return compose(ODESystem(eqs, t, [], ps; name=name), p, n)\nend\n# 电容元件，因为不能对表达式进行微分，所以再引入一个电容的电压差变量v\nfunction Capacitor(; name, C=1.0)\n    @named p = Pin()\n    @named n = Pin()\n    ps = @parameters C = C\n    sts = @variables v(t) = 1.0\n    D = Differential(t)\n    eqs = [\n        v ~ p.v - n.v\n        D(v) ~ p.i / C\n        0 ~ p.i + n.i\n    ]\n    return compose(ODESystem(eqs, t, sts, ps; name=name), p, n)\nend\n# 电压源\nfunction ConstantVoltage(; name, V=1.0)\n    @named p = Pin()\n    @named n = Pin()\n    ps = @parameters V = V\n    eqs = [\n        V ~ p.v - n.v\n        0 ~ p.i + n.i\n    ]\n    return compose(ODESystem(eqs, t, [], ps; name=name), p, n)\nend\n\n# 定义组件\nR = 1.0\nC = 1.0\nV = 1.0\n@named resistor = Resistor(R=R) # @name可以视为给定义的组件起了个名字，Resistor(R=R)返回的组件名字就叫resistor\n@named capacitor = Capacitor(C=C)\n@named source = ConstantVoltage(V=V)\n@named ground = Ground()\n\n# 构建连接关系\nrc_eqs = [\n    connect(source.p, resistor.p)\n    connect(resistor.n, capacitor.p)\n    connect(capacitor.n, source.n, ground.g)\n]\n@named _rc_model = ODESystem(rc_eqs, t) #连接关系也需要放到ODESystem中。\n\n# 组件与组件连接关系一起构建系统\n@named rc_model = compose(_rc_model,[resistor, capacitor, source, ground])\nequations(rc_model) # 查看方程\n\n# 系统化简\nsys = structural_simplify(rc_model)\nequations(sys) # 查看方程\n\n# 定义初值\nu0 = [\n    capacitor.v => 0.0\n]\n\n# 求解\nprob = ODAEProblem(sys, u0, (0, 10.0))\nsol = solve(prob, Tsit5())\n\n# 查看\nsol[capacitor.v]\nsol[resistor.n.v]\nsol[capacitor.p.v]","category":"page"},{"location":"Modeling/ModelingTutorial/#小结","page":"组织方程的艺术——组件化（入门）","title":"小结","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"引入的组件端口变量作为内部方程与外部连接关系的桥梁，使得组件完整又独立，可以与任意外部组件相连接。连接就去干连接的活，组件内部就管组件内部的方程。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"从另一个角度说，节点电压法需要针对每一个系统做比较复杂的系统分析，因为其包含了某种化简的内涵；而组件化模式则是批量定义组件和批量处理连接关系，最后统一化简。后者更加易于理解与设计计算算法。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"组件化的意义就在于高效复用以提高系统构建效率。因为组件都是由开发者写好的，用户只需要构建连接关系，系统即可搭建好。这也是为什么说组件化是关于方程组织的艺术了，本质还是那个本质，只是换一种变量与方程的组织模式。电路系统的组件化是组件化思想的体现之一。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"组件化建模实例简要介绍了组件化建模思想。\nAi4EComponentLib.jl中系统的设计方法，都体现了组件化思想。\nAi4EComponentLib.jl设计理念介绍了更高层次的抽象组件内涵。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"最后，思考如何用节点电压法解下图的电路，以及如何用组件搭建。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"(Image: 图 2) ","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"其实思考之后就会发现组件化构建的优点：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"高复用性：节点电压法构建需要自己写组件的特性方程；组件化不需要，不管它内部是什么牛鬼蛇神，组件写好了就能拿来用。之后就一个事——连接。定义组件的过程就是对组件内部方程的重用。\n高易用性：一旦组件设计好了，构建连接关系不需要再动脑子了，照着系统图哪里有节点连哪里不就完事了？剩下精髓，是如何去设计一个系统，不再需要考虑组件底层。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"tip: Tip\n提问：我们上面手敲代码定义组件和构建连接的过程，与在Simulink中通过图形化界面拖一个组件连一个线的过程，有本质的区别吗？如果你觉得没有区别，恭喜，你已经大致掌握流程模拟仿真软件底层架构的逻辑了。","category":"page"},{"location":"Modeling/ModelingTutorial/#练习","page":"组织方程的艺术——组件化（入门）","title":"练习","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"尝试用上面写好的组件构建上图系统并求解。同样的，都假设电容电压初值为0。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/#从虚拟机到云计算","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"","category":"section"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"我这里先介绍虚拟机，然后讲解云服务器，接着讲容器和容器编排，最后介绍Kubernetes（简称K8s）。以下是每个主题的简要概述：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"虚拟机（Virtual Machine，VM）：虚拟机是一种软件仿真的计算机系统，它在物理硬件上模拟出一个完整的计算环境。通过虚拟机，可以在一台物理计算机上运行多个独立的操作系统和应用程序，实现资源的有效利用和隔离。\n云服务器：云服务器是基于云计算技术提供的一种计算资源。它可以在云服务提供商的数据中心上创建和管理，用户可以按需购买和使用，无需关心硬件设备的维护和管理。云服务器提供了灵活、可扩展的计算能力，使用户能够根据需要快速部署和管理应用程序。\n容器：容器是一种轻量级的虚拟化技术，它将应用程序及其所有依赖项打包到一个可移植的单元中。容器可以在不同的计算环境中运行，提供了更高的可移植性和可伸缩性。容器技术能够实现快速部署、高效利用资源和隔离应用程序之间的环境。\n容器编排：容器编排是指自动化管理和协调大规模容器集群的过程。它涉及到调度、扩缩容、服务发现等操作，以确保容器应用程序的高可用性和可靠性。容器编排工具可以简化容器集群的部署和管理，提供了高级的功能和抽象层，使开发人员和运维人员能够更方便地管理容器化应用。\nKubernetes（K8s）：Kubernetes是目前最流行的容器编排工具之一，它提供了丰富的功能和强大的编排能力。Kubernetes可以自动化地管理容器化应用程序的部署、伸缩、负载均衡和容错等方面。它还提供了灵活的架构和可扩展性，使得在大规模环境中部署和管理容器应用变得更加简单和可靠。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"通过这样的顺序，您可以循序渐进地介绍云计算的相关概念，从虚拟化开始，逐步引入云服务器、容器和容器编排，最后引入Kubernetes作为云原生应用程序部署和管理的解决方案","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/#虚拟机","page":"从虚拟机到云计算","title":"虚拟机","text":"","category":"section"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/#虚拟机简介","page":"从虚拟机到云计算","title":"虚拟机简介","text":"","category":"section"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"虚拟机（Virtual Machine，VM）是一种软件仿真的计算机系统，它在物理硬件上模拟出一个完整的计算环境。通过虚拟机，可以在一台物理计算机上运行多个独立的操作系统和应用程序，实现资源的有效利用和隔离。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"虚拟机可以将一台物理计算机分割为多个虚拟环境，每个环境都拥有自己的操作系统、应用程序和资源。每个虚拟机都被视为一个独立的计算机，可以进行操作系统的安装、应用程序的运行和网络的配置。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"虚拟机的好处包括：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"资源利用率高：通过虚拟机技术，一台物理计算机可以同时运行多个虚拟机，充分利用硬件资源，降低资源浪费。\n隔离性强：每个虚拟机是相互隔离的，它们运行在自己的虚拟环境中，互不干扰，提供了更高的安全性和稳定性。\n灵活性和可移植性：虚拟机可以在不同的物理计算机之间迁移，实现应用程序的高度灵活性和可移植性。\n管理和维护简便：通过虚拟机管理软件，可以对虚拟机进行集中管理、监控和维护，简化了系统管理的工作。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"虚拟机技术是云计算的基础之一，它为云服务器提供了可扩展和弹性的计算资源。通过虚拟机，用户可以根据需要快速创建和管理多个独立的虚拟服务器，实现按需分配计算资源的优势。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"有几个流行的虚拟机软件可以选择，以下是其中一些：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"VMware vSphere：VMware vSphere是一款功能强大的虚拟化平台，广泛应用于企业级环境。它提供了全面的虚拟化解决方案，包括虚拟机管理、资源调度、高可用性和故障转移等功能。\nMicrosoft Hyper-V：Hyper-V是微软的虚拟化平台，集成在Windows Server操作系统中。它提供了可靠的虚拟化技术，支持创建和管理多个虚拟机，具有良好的兼容性和集成性。\nOracle VM VirtualBox：VirtualBox是一款免费的开源虚拟机软件，适用于个人和小型企业。它支持多种操作系统，具有易用性和灵活性，适合在桌面环境中运行虚拟机。\nKVM（Kernel-based Virtual Machine）：KVM是一种基于Linux内核的虚拟化解决方案，它利用虚拟化扩展了Linux操作系统的功能。KVM提供了高性能和安全性，并且作为开源软件，广受欢迎。\nXen：Xen是一种开源的虚拟化平台，它具有高性能和安全性。Xen支持多种操作系统，并提供了强大的虚拟机管理功能和资源分配控制。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"这些是目前较为流行的虚拟机软件，每个软件都有自己的特点和适用场景。选择虚拟机软件时，您可以根据需求、预算和技术要求来进行评估和选择。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/#virtualbox安装ubuntu","page":"从虚拟机到云计算","title":"virtualbox安装ubuntu","text":"","category":"section"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"以VirtualBox为例，在Windows系统上安装Ubuntu，请按照以下步骤进行操作：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 1：下载软件","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在您的Windows主机上，打开浏览器，并访问VirtualBox的官方网站（https://www.virtualbox.org）。\n在下载页面上，选择适用于Windows主机的最新版本的VirtualBox软件，并下载安装程序。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 2：安装VirtualBox","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"打开下载的安装程序，并按照提示进行安装。这将在您的Windows主机上安装VirtualBox。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 3：下载Ubuntu镜像","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在浏览器中，访问Ubuntu官方网站（https://ubuntu.com）。\n在下载页面上，选择您想要安装的Ubuntu版本（例如Ubuntu 20.04 LTS）。\n下载适用于桌面版的Ubuntu镜像（通常是一个ISO文件）。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 4：创建虚拟机","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"打开VirtualBox应用程序。\n点击\"新建\"创建一个新的虚拟机。\n在弹出窗口中，输入虚拟机的名称（例如Ubuntu）和选择操作系统类型（Linux）。\n根据您下载的Ubuntu镜像选择相应的版本（例如Ubuntu 64位）。\n按照默认设置为虚拟机分配内存大小，或根据您的需要进行调整。\n在\"虚拟硬盘\"部分，选择\"创建虚拟硬盘\"并点击\"创建\"。\n在弹出窗口中，选择虚拟硬盘文件类型（通常选择VDI）。\n在存储位置和大小上，可以使用默认设置或按需进行调整。\n完成后，您将在VirtualBox主界面上看到新创建的虚拟机。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 5：安装Ubuntu","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"选中您创建的虚拟机，并点击\"启动\"。\n在弹出窗口中，选择您之前下载的Ubuntu镜像文件（ISO文件）。\n点击\"启动\"开始安装过程。\n在Ubuntu安装程序中，按照提示进行操作。您可以选择安装Ubuntu并跟随向导进行设置，或者选择\"试用\"以进入Ubuntu的Live模式。\n完成Ubuntu的安装后，重新启动虚拟机。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 6：享受Ubuntu","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在重新启动后，您将看到Ubuntu登录界面。\n输入您在安装过程中设置的用户名和密码，登录到Ubuntu桌面。\n现在，您可以开始使用安装在VirtualBox中的Ubuntu操作系统了。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"这是使用VirtualBox在Windows系统上安装Ubuntu的基本步骤。请注意，具体步骤可能会因VirtualBox或Ubuntu版本的不同而有所不同，但大致流程是类似的。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"如果您想要在VirtualBox中安装增强功能，以便实现更好的集成和功能支持（例如，自动调整屏幕分辨率、共享剪贴板、鼠标和键盘的无缝切换等），请按照以下步骤进行操作：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 1：启动虚拟机","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在VirtualBox主界面上，选中您安装的Ubuntu虚拟机。\n点击\"启动\"来启动虚拟机。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 2：安装VirtualBox增强功能","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在Ubuntu虚拟机启动后，在VirtualBox菜单栏中选择\"设备（Devices）\"。\n在设备菜单中，选择\"安装增强功能\"（通常在菜单的最下方）。\n这将加载一个名为\"VBoxGuestAdditions.iso\"的虚拟光驱到Ubuntu虚拟机中。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 3：安装增强功能","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在Ubuntu虚拟机中，打开终端应用程序。\n在终端中，输入以下命令来挂载并运行增强功能的安装程序：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"sudo mount /dev/cdrom /mnt\ncd /mnt\nsudo ./VBoxLinuxAdditions.run","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"这将安装增强功能到Ubuntu虚拟机中。根据提示，您可能需要输入管理员密码来继续安装过程。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 4：重新启动虚拟机","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在安装完成后，输入以下命令来重新启动Ubuntu虚拟机：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"sudo reboot","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"虚拟机将重新启动并加载增强功能。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 5：享受增强功能","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在重新启动后，您可以享受增强功能提供的各种特性，如自动调整屏幕分辨率、共享剪贴板、鼠标和键盘的无缝切换等。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"请注意，安装增强功能的步骤可能会因VirtualBox或Ubuntu版本的不同而有所不同。如果遇到任何问题，请参考VirtualBox的官方文档或Ubuntu的官方支持资源，以获取更具体的安装指南和解决方案。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/#wsl2的安装和使用（为了熟悉Linux操作）","page":"从虚拟机到云计算","title":"wsl2的安装和使用（为了熟悉Linux操作）","text":"","category":"section"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"很多同学对linux不熟悉，我们可以安装一个WSL2来学习。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"当安装WSL2（Windows Subsystem for Linux 2）以在Windows系统上使用Linux环境时，可以按照以下步骤进行：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 1：检查系统要求","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"确保同学们的计算机运行的是Windows 10操作系统的版本2004或更高版本，并且使用的是64位系统。\n还需要启用虚拟化功能（BIOS设置中的虚拟化选项）。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 2：启用WSL功能","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"打开Windows PowerShell（或命令提示符）作为管理员。右键单击开始菜单，选择\"Windows PowerShell（管理员）\"。\n运行以下命令来启用WSL功能：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 3：启用虚拟机平台功能","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"继续在管理员权限的Windows PowerShell中，运行以下命令来启用虚拟机平台功能：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 4：安装WSL2 Linux内核更新包","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"下载适用于WSL2的Linux内核更新包：\n访问https://aka.ms/wsl2kernel下载最新版本的Linux内核更新包。\n运行下载的更新包安装程序并按照提示进行安装。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 5：设置WSL2为默认版本","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"打开Windows PowerShell（管理员权限）。\n运行以下命令以将WSL2设置为默认版本：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"wsl --set-default-version 2","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 6：安装Linux发行版","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"打开Microsoft Store（Microsoft商店）应用程序。\n在搜索栏中搜索所需的Linux发行版（如Ubuntu、Debian等）。\n选择所需的发行版，并点击\"获取\"以开始安装过程。\n安装完成后，可以在开始菜单或应用程序列表中找到Linux发行版的图标。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 7：配置和使用WSL2","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"点击Linux发行版的图标启动它。第一次运行时，需要进行一些初始配置，例如创建用户名和密码。\n完成配置后，将进入Linux发行版的终端界面，可以在其中执行各种Linux命令和操作。\n同学们可以通过WSL2来运行和管理Linux应用程序，进行开发和学习。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"请注意，以上步骤提供了一个基本的指导，具体步骤可能会因Windows版本和更新的不同而有所变化。建议在指导同学们安装WSL2时，参考Microsoft的官方文档和指南，以获得最准确的信息和步骤。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在Windows Terminal中使用WSL2可以提供更好的终端体验和多个Linux发行版的集成。以下是在Windows Terminal中使用WSL2的步骤：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 1：安装Windows Terminal","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"打开Microsoft Store（Microsoft商店）应用程序。\n在搜索栏中搜索\"Windows Terminal\"。\n选择\"获取\"以开始安装Windows Terminal。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 2：启动Windows Terminal","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在开始菜单中搜索并打开\"Windows Terminal\"。\nWindows Terminal将打开并显示多个终端选项。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 3：配置Windows Terminal使用WSL2","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在Windows Terminal中，点击左上角的下拉箭头（或使用快捷键Ctrl+，）以打开设置。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 4：编辑配置文件","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在设置中，选择所需的配置文件（如Ubuntu、Debian等）。\n在配置文件的\"guid\"属性中，输入WSL2分配的唯一标识符。您可以使用命令wsl -l在Windows PowerShell或命令提示符中获取已安装的WSL2发行版的列表和标识符。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 5：保存配置文件","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在编辑完配置文件后，保存并关闭设置窗口。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 6：打开新终端","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在Windows Terminal中，点击左上角的\"+\"按钮，或按下快捷键Ctrl+Shift+T，以打开一个新的终端标签。\n在新的终端标签中，将自动使用配置文件中指定的WSL2发行版。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 7：切换和使用多个终端","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在Windows Terminal中，您可以使用下拉箭头或快捷键Ctrl+Tab来切换不同的终端标签。\n在每个终端标签中，您可以像在正常的Linux终端中一样运行和管理命令、应用程序等。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"通过以上步骤，您可以在Windows Terminal中配置和使用WSL2，并享受多个Linux发行版的集成和终端体验。请注意，具体的步骤可能因Windows Terminal的版本和配置文件的不同而有所变化。如果需要更多详细信息和配置选项，请参考Windows Terminal的官方文档和指南。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"如果您想在 MobaXterm 中使用 WSL2（Windows Subsystem for Linux 2），可以按照以下步骤进行设置：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 1：安装 MobaXterm","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在浏览器中访问 MobaXterm 的官方网站（https://mobaxterm.mobatek.net）。\n下载适用于您的 Windows 系统的 MobaXterm 安装程序。\n运行安装程序并按照提示进行安装。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 2：启动 MobaXterm","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在安装完成后，打开 MobaXterm 应用程序。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 3：配置 WSL2","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在 MobaXterm 的主界面上，点击 \"Session\"（会话）按钮打开会话窗口。\n在会话窗口中，点击 \"New session\"（新建会话）按钮。\n在左侧的会话类型列表中，选择 \"WSL\"。\n在右侧的 \"WSL settings\"（WSL 设置）部分，选择您想要使用的 WSL2 发行版。\n点击 \"OK\"。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 4：连接到 WSL2","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在会话窗口中，点击 \"Start local terminal\"（启动本地终端）按钮。\n这将打开一个新的终端窗口，连接到您选择的 WSL2 发行版。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 5：使用 WSL2","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在 MobaXterm 的终端窗口中，您可以像在任何其他终端中一样使用 WSL2。\n运行 Linux 命令、管理文件、安装和运行应用程序等。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"通过以上步骤，您可以在 MobaXterm 中配置并使用 WSL2。请注意，MobaXterm 中的具体步骤可能会因版本和配置的不同而有所变化。如果需要更多详细信息和设置选项，请参考 MobaXterm 的官方文档和指南。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"当使用WSL2时，以下是一些常用的命令示例：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"查看当前目录：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"pwd","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"列出当前目录的文件和文件夹：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"ls","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"切换目录：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"cd <目录路径>","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"创建新目录：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"mkdir <目录名称>","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"复制文件或目录：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"cp <源文件/目录> <目标路径>","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"安装软件包：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"sudo apt-get install <软件包名称>","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"这些命令可以让您在WSL2中进行常见的文件操作和软件安装。根据您的需求，可以使用这些命令作为起点，并在需要时进一步扩展和探索其他命令和操作。请记住，具体命令的使用方法和选项可能会因所使用的Linux发行版和软件版本而有所不同。如果需要更多详细信息和特定命令的使用说明，请参考所使用的Linux发行版的官方文档或在线资源。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/#云计算","page":"从虚拟机到云计算","title":"云计算","text":"","category":"section"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/#云计算简介","page":"从虚拟机到云计算","title":"云计算简介","text":"","category":"section"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"云计算是一种通过网络提供计算资源和服务的模式，它提供了便捷的、按需的、可伸缩的计算资源，从而使用户能够在不拥有实际物理基础设施的情况下使用和管理计算资源。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"云计算的核心概念包括以下几个方面：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"虚拟化：云计算通过虚拟化技术将物理计算资源（如服务器、存储设备）抽象为虚拟资源，使其能够在多个用户之间进行共享。虚拟化技术包括虚拟机和容器等。\n弹性伸缩：云计算允许根据实际需求动态调整计算资源的规模，即根据业务负载的增减自动调整资源的分配。这种弹性伸缩能力可以帮助用户在需要更多计算能力时扩展资源，并在需求减少时进行资源的释放，从而提高资源的利用率和成本效益。\n服务模型：云计算提供多种服务模型，包括基础设施即服务（IaaS）、平台即服务（PaaS）和软件即服务（SaaS）。这些服务模型层次不同，提供的服务范围也不同，用户可以根据自身需求选择合适的服务模型来构建和管理应用程序。\n公共云、私有云和混合云：公共云是由云服务提供商管理和提供的云计算资源和服务，多个用户共享这些资源。私有云是由企业或组织自己搭建和管理的云计算基础设施，仅对内部用户提供服务。混合云是公共云和私有云的结合，使企业可以在需要时灵活地将工作负载部署到公共云或私有云中。\n云安全性：云计算提供商通常采取一系列措施来保护用户的数据和应用程序安全。这些措施包括数据加密、身份认证和访问控制、备份和灾难恢复等，以确保用户数据的机密性、完整性和可用性。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"云计算的优势包括灵活性、可伸缩性、成本效益和高可用性。它为个人用户、企业和组织提供了强大的计算能力和资源，使其能够更高效地开展业务、创新和应对变化。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"需要注意的是，云计算领域有多个主要的云服务提供商，如阿里云、天翼云、华为云、亚马逊AWS、微软Azure和谷歌云平台等，它们提供各种云服务和工具，支持各种应用场景和需求。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"通俗的理解，就是云服务商把很多硬件整合在一起，切分成不同的豆腐块，每个豆腐块都进行虚拟化，然后给我们卖这样的豆腐块（虚拟机）。虽然不严谨，可以这样理解吧。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"是的，您可以这样理解云计算。云服务商通过整合大量的硬件资源（如服务器、存储设备）并进行虚拟化，将这些物理资源切分成多个虚拟化的单位，通常被称为\"云实例\"或\"豆腐块\"，这些虚拟化单位可以是虚拟机、容器或其他形式的计算资源。然后，云服务商通过提供这些虚拟化单位给用户，让用户能够按需购买和使用这些计算资源，而无需拥有和维护实际的物理基础设施。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"这种虚拟化的方式使用户可以根据自身需求灵活地使用计算资源，无需关心底层的硬件和基础设施细节。用户可以根据业务需求动态调整计算资源的规模，并通过云服务商提供的管理工具来部署、监控和管理这些虚拟化单位。云计算的优势在于其灵活性、可伸缩性和成本效益，使用户能够更高效地利用计算资源，集中精力开展业务和创新。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"虚拟化是云计算的基础技术之一，它通过将物理资源虚拟化为虚拟资源，实现了资源的共享和隔离。虚拟机是最常见的虚拟化形式之一，它将物理服务器切分为多个虚拟机实例，每个虚拟机实例都具有自己的操作系统和应用程序。通过虚拟化技术，云服务商能够提供可靠、安全且高度可扩展的计算资源给用户，让用户能够以更灵活和经济的方式使用计算能力。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"所以，您的理解是准确的，云服务商将硬件资源虚拟化为不同的虚拟化单位（如虚拟机），然后提供给用户使用。用户可以根据需求选择和购买这些虚拟化单位，并将其用于托管应用程序、存储数据等各种计算任务。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/#公有云与私有云","page":"从虚拟机到云计算","title":"公有云与私有云","text":"","category":"section"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"当谈到云计算时，常常涉及到公有云、私有云和混合云这三个概念。它们表示不同类型的云计算部署和服务模式：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"公有云（Public Cloud）：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"公有云是由云服务提供商管理和提供的云计算基础设施和服务。在公有云中，云服务提供商拥有并管理硬件设施、虚拟化资源和服务，并将其提供给多个用户进行共享。用户可以按需购买和使用这些云服务，通常采用按使用量计费的模式。公有云提供了高度可扩展的计算资源、广泛的服务选择和灵活的付费模式。用户无需关心底层的基础设施和维护工作，可以专注于应用程序的开发和业务需求。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"私有云（Private Cloud）：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"私有云是企业或组织自己搭建和管理的云计算基础设施。在私有云中，计算资源、存储和网络等基础设施资源都是专门为企业内部使用而部署的。私有云提供了更高的安全性和控制性，因为企业可以自主管理和控制整个云环境。私有云可以部署在企业的数据中心内或由第三方服务提供商托管。它可以满足特定的合规要求、安全需求或业务流程的定制化需求。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"混合云（Hybrid Cloud）：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"混合云是公有云和私有云的结合。在混合云模式下，企业可以同时利用公有云和私有云来满足不同的需求。例如，企业可以将敏感数据和关键应用部署在私有云中，以满足安全和合规性要求，同时将其他非敏感的工作负载部署在公有云中，以获得弹性和可扩展性。混合云提供了更灵活的部署模式，使企业可以根据实际需求在公有云和私有云之间进行动态迁移和资源调度。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"混合云可以充分利用公有云和私有云的优势，同时解决安全性、合规性和可扩展性等方面的需求。企业可以根据业务需求和实际情况，灵活选择合适的云计算部署模式，并进行资源的分配和管理。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/#找个云服务器实操一下","page":"从虚拟机到云计算","title":"找个云服务器实操一下","text":"","category":"section"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"当以阿里云的ECS为例，在阿里云上创建一台虚拟机并安装Ubuntu LTS的步骤如下：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"注册阿里云账号并登录到阿里云控制台（https://www.aliyun.com）。\n进入ECS控制台，在左侧导航栏中选择\"实例\"，然后点击\"创建实例\"按钮。\n在创建实例页面，按照以下步骤进行配置：\n地域和可用区：选择适合的地域和可用区。\n实例配置：选择合适的实例规格、计费方式和购买时长。\n网络和安全组：选择网络类型和安全组配置。\n系统配置：选择操作系统镜像，点击\"更多\"按钮选择Ubuntu LTS版本。\n存储和盘：选择系统盘和数据盘的配置。\n标签和备注：根据需要添加标签和备注信息。\n网络计费：根据需要选择带宽计费方式。\n安全与监控：选择是否开启云监控和安全加固等功能。\n完成配置后，点击\"立即购买\"按钮。\n确认订单信息后，点击\"去开通\"按钮。\n阿里云将开始创建并启动您的实例。请等待几分钟，直到实例状态显示为\"运行中\"。\n当实例状态为\"运行中\"时，您可以在实例列表中找到您的实例。点击实例名称，进入实例详情页。\n在实例详情页中，您可以查看实例的基本信息。找到公网IP地址或登录密码信息，并记下来。\n打开SSH客户端（如PuTTY或OpenSSH），使用您的公网IP地址和登录密码连接到您的实例。如果使用Windows系统，您可以使用SSH客户端工具（如PuTTY）来连接。\n在SSH终端中，输入您的登录用户名和密码，即可成功登录到您的Ubuntu虚拟机。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"通过以上步骤，您就可以在阿里云的ECS上成功创建并登录到一台安装了Ubuntu LTS的虚拟机。请注意，创建实例的过程中会涉及到一些配置和选项，具体根据您的需求进行相应的选择和设置。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/#登录云服务器","page":"从虚拟机到云计算","title":"登录云服务器","text":"","category":"section"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"下面分别介绍如何使用 MobaXterm 和 PuTTY 进行云服务的登录，并演示密码认证和密钥认证的步骤。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"使用 MobaXterm 登录云服务：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"下载和安装 MobaXterm（https://mobaxterm.mobatek.net/download-home-edition.html）。\n打开 MobaXterm，点击 \"Session\" 标签页。\n在 \"Session\" 标签页中，选择 \"SSH\" 作为远程会话类型。\n输入云服务的 IP 地址或主机名。\n在 \"Specify username\" 输入框中，输入登录用户名。\n在 \"Advanced SSH settings\" 中，可以选择使用密码认证或密钥认证。首先，我们使用密码认证，请确保 \"Use private key\" 复选框未选中。\n点击 \"OK\" 按钮，MobaXterm 将尝试与云服务建立 SSH 连接，并提示输入密码。\n输入您的密码，按下回车键即可登录到云服务。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"使用 PuTTY 登录云服务：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"下载和安装 PuTTY（https://www.putty.org）。\n打开 PuTTY。\n在 \"Host Name (or IP address)\" 输入框中，输入云服务的 IP 地址或主机名。\n在 \"Connection type\" 下选择 \"SSH\"。\n在 \"Specify username\" 输入框中，输入登录用户名。\n在 \"Category\" 列表中，展开 \"SSH\" 选项，然后选择 \"Auth\"。\n在 \"Auth\" 部分，可以选择使用密码认证或密钥认证。首先，我们使用密码认证，请确保 \"Attempt authentication using Pageant\" 复选框未选中。\n点击 \"Open\" 按钮，PuTTY 将尝试与云服务建立 SSH 连接，并提示输入密码。\n输入您的密码，按下回车键即可登录到云服务。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"现在我们来介绍如何设置密钥认证：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"使用 MobaXterm 设置密钥认证：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"打开 MobaXterm。\n点击 \"Settings\" 菜单，选择 \"Configuration\"。\n在 \"Configuration\" 对话框中，展开 \"SSH\"，然后选择 \"SSH keys\"。\n点击 \"Generate\" 按钮，生成新的密钥对。\n选择密钥的类型和长度，并点击 \"Generate\"。\n在 \"Key passphrase\" 输入框中，输入一个密码以保护您的密钥（可选）。\n点击 \"Save private key\" 按钮，将私钥保存到本地计算机。\n在云服务上，将公钥（保存在 MobaXterm 中的公钥）添加到您的用户账户的 ~/.ssh/authorized_keys 文件中。\n在 MobaXterm 中，返回到 \"Session\" 标签页，输入云服务的 IP 地址或主机名、登录用户名。\n在 \"Advanced SSH settings\" 中，选择 \"Use private key\"","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"复选框，并点击 \"Browse\" 选择您保存的私钥文件。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"点击 \"OK\"，然后尝试连接到云服务。MobaXterm 将使用密钥认证进行连接。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"使用 PuTTY 设置密钥认证：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"打开 PuTTY。\n在 \"Category\" 列表中，展开 \"SSH\"，然后选择 \"Auth\"。\n点击 \"Browse\" 按钮，选择您保存的私钥文件。\n返回到 \"Session\" 标签页，输入云服务的 IP 地址或主机名、登录用户名。\n点击 \"Open\" 按钮，PuTTY 将使用密钥认证进行连接。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"通过以上步骤，您可以使用 MobaXterm 和 PuTTY 进行云服务的登录，并通过密码认证或密钥认证进行身份验证。请根据您的需求选择合适的认证方式。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"下面是使用 ssh-keygen 生成密钥对并设置 authorized_keys 的步骤：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"打开终端或命令行窗口。\n输入以下命令来生成密钥对：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"ssh-keygen -t rsa -b 2048","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"这将生成一个 RSA 类型的密钥对，密钥长度为 2048 位。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"按照提示，输入密钥文件的保存路径和名称，或者直接按回车键使用默认路径和名称。\n在生成密钥对的过程中，您将被要求设置一个密码短语（passphrase）。可以选择设置密码短语以增加密钥的安全性，或者直接按回车键跳过密码短语设置。\n完成后，会在指定路径生成两个文件：id_rsa（私钥）和 id_rsa.pub（公钥）。\n将公钥内容复制到剪贴板中。您可以使用以下命令在终端中打印公钥：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"cat ~/.ssh/id_rsa.pub","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在云服务中，登录到您的用户账户。\n打开 ~/.ssh/authorized_keys 文件，如果文件不存在，则创建一个新的。\n将剪贴板中的公钥内容粘贴到 authorized_keys 文件中，并保存文件。\n设置 authorized_keys 文件的权限为 600，确保只有当前用户具有读写权限：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"chmod 600 ~/.ssh/authorized_keys","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"现在，您可以使用私钥连接到云服务，而无需输入密码。使用以下命令进行连接：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"ssh username@server_ip_address -i path/to/private_key","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"其中，username 是您的用户名，server_ip_address 是云服务的 IP 地址，path/to/private_key 是私钥文件的路径和名称。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"通过以上步骤，您已经成功生成了密钥对，并将公钥添加到云服务的 authorized_keys 文件中，从而实现了密钥认证的登录方式。现在，您可以使用私钥连接到云服务，而无需每次输入密码。请确保妥善保管私钥，以确保安全性。","category":"page"},{"location":"CSAdv/6-代码生成/#代码生成","page":"代码生成","title":"代码生成","text":"","category":"section"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"计算，就是用计算机处理模型。处理模型有时候是生成另一套代码，我们讲一讲代码生成。","category":"page"},{"location":"CSAdv/6-代码生成/#代码生成的常用方式","page":"代码生成","title":"代码生成的常用方式","text":"","category":"section"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"代码生成是软件开发过程中的一个重要环节。常用的代码生成方法包括字符替换、模板和抽象语法树。","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"字符替换：字符替换是最简单的代码生成方法之一。通过定义一些占位符，然后将这些占位符替换为实际的代码片段。这种方法通常适用于生成简单的代码片段或者进行一些简单的文本替换操作。\n模板：模板是一种更灵活的代码生成方法。通过定义一些代码模板，其中包含一些占位符或者表达式，然后根据具体的需求填充这些占位符，生成最终的代码。模板可以包含条件判断、循环等控制结构，使得生成的代码更加灵活和可扩展。\n抽象语法树（AST）：AST是一种更高级的代码生成方法，它通过解析源代码构建一个抽象的语法树表示，然后对这个语法树进行分析和转换，最终生成目标代码。AST可以提供更高级的代码操作能力，例如对代码进行重构、优化等。它通常用于编译器、静态分析工具等领域。","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"这些代码生成方法各有优劣，选择合适的方法取决于具体的应用场景和需求。在实际开发中，可以根据任务的复杂性、生成代码的灵活性要求等因素进行选择。","category":"page"},{"location":"CSAdv/6-代码生成/#看看例子吧","page":"代码生成","title":"看看例子吧","text":"","category":"section"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"以下是一些简单的例子来演示这些代码生成方法：","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"字符替换：","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"假设我们有一个简单的代码片段，其中包含一个占位符{name}，我们想要根据不同的名字生成对应的代码。可以使用字符替换方法实现：","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"# 输入\nname = \"John\"\ncode_template = \"print('Hello, {name}!')\"\n\n# 生成代码\ngenerated_code = code_template.replace(\"{name}\", name)\nprint(generated_code)\n\n# 输出\n# print('Hello, John!')","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"模板：","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"假设我们需要生成一个简单的函数，根据传入的参数生成相应的求和代码。可以使用模板方法实现：","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"# 输入\nparameters = [\"a\", \"b\"]\ntemplate = '''\ndef sum_func({params}):\n    result = {a} + {b}\n    return result\n'''\n\n# 填充模板\nparams = \", \".join(parameters)\ngenerated_code = template.format(params=params, a=parameters[0], b=parameters[1])\nprint(generated_code)\n\n# 输出\n# def sum_func(a, b):\n#     result = a + b\n#     return result","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"抽象语法树（AST）：","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"假设我们要生成一个简单的四则运算表达式，并将其转化为逆波兰表达式形式。可以使用AST方法实现：","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"import ast\nimport astunparse\n\n# 构建抽象语法树\nexpr = ast.parse(\"2 * (3 + 4)\")\n\n# 转化为逆波兰表达式形式\nexpr = astunparse.unparse(expr).strip()\nexpr = expr.replace(\"(\", \"\").replace(\")\", \"\").replace(\",\", \"\")\nrpn_expr = \" \".join(expr.split())\nprint(rpn_expr)\n\n# 输出\n# 2 3 4 + *","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"这些例子只是简单的示例，实际中的代码生成通常更为复杂。但这些例子可以帮助你理解字符替换、模板和抽象语法树在代码生成中的应用。","category":"page"},{"location":"CSAdv/6-代码生成/#机器学习中pytorch和tensorfkow也用到了代码生成","page":"代码生成","title":"机器学习中pytorch和tensorfkow也用到了代码生成","text":"","category":"section"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"在机器学习领域中，PyTorch和TensorFlow都使用了代码生成技术，但它们在代码生成的方式和目的上有所不同。","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"PyTorch：PyTorch是一个流行的深度学习框架，它使用了动态图模型。在PyTorch中，代码生成主要用于构建计算图。当定义神经网络模型时，PyTorch会根据用户提供的代码动态地构建计算图。这种动态图的方式使得用户可以使用常规的编程语言（如Python）的灵活性和控制能力。在运行时，PyTorch会根据输入数据的形状和大小自动生成相应的计算图，以便进行前向传播和反向传播。这种动态图的方式使得PyTorch适用于灵活的模型定义和调试，但也可能带来一些运行时开销。\nTensorFlow：TensorFlow是另一个广泛使用的深度学习框架，它使用了静态图模型。在TensorFlow中，代码生成主要用于构建计算图的静态表示。用户首先定义计算图的结构，然后通过执行该图来进行计算。TensorFlow会将用户定义的计算图转化为一个优化过的表示形式，以便在不同设备上高效执行。这种静态图的方式允许TensorFlow进行更多的优化，并提供了一些高级特性，如分布式训练和部署。但相对于PyTorch，TensorFlow的模型定义和调试可能需要更多的额外步骤和复杂性。","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"总之，PyTorch和TensorFlow在机器学习中都使用了代码生成技术，但它们在计算图的构建方式和灵活性上有所不同，以适应不同的开发需求和优化目标。","category":"page"},{"location":"CSAdv/6-代码生成/#从bib到html也是代码生成","page":"代码生成","title":"从bib到html也是代码生成","text":"","category":"section"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"bibtexparser，它可以解析bib文件，然后格式化输出成html网页，也可以认为是一种代码生成。","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"bibtexparser是一个Python库，用于解析BibTeX文件并将其转换为其他格式，包括HTML网页。在这种情况下，可以将格式化输出的过程视为一种代码生成。","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"通过使用bibtexparser库，你可以将BibTeX文件中的参考文献数据解析为Python对象，然后根据需要进行处理和转换。例如，你可以编写代码来将参考文献数据转换为HTML格式，以便在网页上显示。","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"以下是一个简单的示例，演示如何使用bibtexparser库解析BibTeX文件并生成HTML网页：","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"import bibtexparser\nfrom bibtexparser.bwriter import BibTexWriter\n\n# 读取BibTeX文件\nwith open('references.bib', 'r') as bibtex_file:\n    bib_database = bibtexparser.load(bibtex_file)\n\n# 将解析的参考文献数据转换为HTML格式\nhtml = BibTexWriter().to_html(bib_database)\n\n# 将HTML保存到文件\nwith open('references.html', 'w') as html_file:\n    html_file.write(html)","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"在上述示例中，我们首先使用bibtexparser库加载BibTeX文件并将其解析为一个BibDatabase对象。然后，使用BibTexWriter将BibDatabase对象转换为HTML格式的字符串。最后，将生成的HTML字符串写入到文件中。","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"通过这种方式，你可以将BibTeX文件中的参考文献数据转换为可在网页上展示的格式。这可以被认为是一种代码生成，因为你使用代码将输入（BibTeX文件）转换为输出（HTML网页），实现了特定格式的转换和生成过程。","category":"page"},{"location":"CSAdv/6-代码生成/#编译过程就是代码生成","page":"代码生成","title":"编译过程就是代码生成","text":"","category":"section"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"编译器，如果我们不考虑优化，就是从抽象语法树生成我们的目标代码。","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"编译器在不考虑优化的情况下，主要任务就是从抽象语法树（AST）生成目标语言的代码。这个过程被称为代码生成阶段。","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"在编译器的工作流程中，代码生成是其中一个重要的阶段，它负责将高级语言（源语言）的抽象语法树转化为目标语言的代码。这个目标语言可以是汇编语言、机器码或者其他编程语言。","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"代码生成的过程通常涉及以下几个步骤：","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"遍历抽象语法树：从根节点开始，遍历整个抽象语法树。这可以通过递归或迭代的方式进行。\n生成代码：根据每个节点的类型和属性，在目标语言中生成相应的代码。这包括变量声明、赋值语句、条件语句、循环语句等等。\n处理表达式：在处理表达式时，需要考虑运算符的优先级和结合性。根据目标语言的规则生成相应的表达式代码。\n管理变量和作用域：在代码生成过程中，需要跟踪变量的声明和作用域，并为其生成正确的目标语言代码。\n控制流转换：根据源语言中的条件语句和循环语句，生成目标语言中相应的控制流代码，如if-else语句、for循环、while循环等。\n生成目标文件：将生成的目标语言代码写入目标文件中，以便后续的处理或执行。","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"需要注意的是，代码生成阶段通常与前面的词法分析、语法分析和语义分析阶段紧密相关。这些阶段共同工作，将源代码转化为抽象语法树，并在代码生成阶段使用该树生成目标代码。","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"尽管在不考虑优化的情况下，生成的目标代码可能不是最高效的，但代码生成是编译器的核心任务之一，它将源语言的抽象表示转化为可执行的目标语言代码。","category":"page"},{"location":"CSAdv/6-代码生成/#来一个Julia代码生成的例子","page":"代码生成","title":"来一个Julia代码生成的例子","text":"","category":"section"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"当涉及到Julia语言的代码生成时，一个常见的应用是使用元编程技术生成动态代码。Julia具有强大的元编程功能，可以在运行时生成和操作代码。","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"下面是一个简单的示例，演示如何在Julia中使用元编程生成一个函数，该函数根据给定的参数生成对应数量的变量赋值语句：","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"function generate_variables(n::Int)\n    code = quote\n        # 生成变量赋值语句\n        $([Symbol(\"x$i = $i\") for i in 1:n]...)\n    end\n    eval(code)\nend\n\n# 生成3个变量赋值语句\ngenerate_variables(3)\n\n# 打印生成的变量\nprintln(x1)\nprintln(x2)\nprintln(x3)","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"在上述示例中，generate_variables函数接受一个整数参数n，然后使用元编程技术生成对应数量的变量赋值语句。通过使用quote块和eval函数，我们可以将生成的代码块作为表达式进行求值。","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"当调用generate_variables(3)时，它会生成三个变量赋值语句，即x1 = 1、x2 = 2和x3 = 3。然后，我们可以在后续代码中访问生成的变量，如打印它们的值。","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"需要注意的是，这只是一个简单的示例，用于演示Julia的代码生成能力。在实际应用中，可以根据具体需求使用更复杂的元编程技术和代码生成模式来生成动态代码。","category":"page"},{"location":"CSAdv/6-代码生成/#一个简单些的代码生成例子","page":"代码生成","title":"一个简单些的代码生成例子","text":"","category":"section"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"以下是一个更简单的Julia代码生成的例子，供您参考和讲解给学生：","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"function generate_hello(name)\n    code = \"println(\\\"Hello, $name!\\\")\"\n    eval(Meta.parse(code))\nend\n\n# 生成打印“Hello, Julia!”的代码\ngenerate_hello(\"Julia\")","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"在这个例子中，generate_hello函数接受一个字符串参数name，然后生成一段打印“Hello, [name]!”的代码。我们使用字符串插值的方式将参数name嵌入到代码字符串中。","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"通过调用generate_hello(\"Julia\")，它会生成一段打印“Hello, Julia!”的代码，并使用Meta.parse将代码字符串解析为可执行的表达式。然后，我们可以通过eval函数执行生成的代码。","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"这个例子比之前的复杂例子更简单，可以更容易地讲解给学生理解。您可以根据需要调整代码生成的具体内容，让学生更好地理解和实践代码生成的概念。","category":"page"},{"location":"CSAdv/6-代码生成/#我们用Meta.show_sexpr解释一下","page":"代码生成","title":"我们用Meta.show_sexpr解释一下","text":"","category":"section"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"Meta.show_sexpr是Julia中的一个函数，用于将表达式转换为S表达式（S-expression）的形式并打印出来。S表达式是一种用于表示程序代码的简单、可读性较高的表达式形式。","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"下面是一个示例，演示如何使用Meta.show_sexpr函数将表达式转换为S表达式并打印出来：","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"x = 1\nexpr = :(x + 2)\nsexpr = Meta.show_sexpr(expr)\nprintln(sexpr)","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"在上述示例中，我们首先定义了一个变量x，并创建了一个表达式x + 2。然后，我们使用Meta.show_sexpr函数将该表达式转换为S表达式的形式，并将结果存储在变量sexpr中。最后，我们使用println函数将S表达式打印出来。","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"输出的结果将类似于下面的形式：","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"(:call, :+, :x, 2)","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"上面的S表达式表示了一个函数调用，函数名是+，参数是变量x和整数2。","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"通过使用Meta.show_sexpr函数，我们可以将Julia中的表达式转换为一种更抽象、可读性较高的形式，方便进行代码分析和理解。这在元编程、代码生成和其他需要对表达式进行操作的场景中特别有用。","category":"page"},{"location":"CSAdv/6-代码生成/#Julia一定意义上可理解为高级版的scheme","page":"代码生成","title":"Julia一定意义上可理解为高级版的scheme","text":"","category":"section"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"在某种程度上，可以将Julia理解为高级版的Scheme，因为它们在某些设计理念和特性上有相似之处。下面是一些Julia和Scheme之间的相似之处：","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"函数作为一等公民：在Scheme和Julia中，函数被视为一等公民，可以像其他值一样传递、存储和操作。这使得函数式编程成为可能，允许编写高阶函数和匿名函数。\n动态类型系统：Scheme和Julia都具有动态类型系统，允许变量在运行时绑定到不同类型的值。这使得编写灵活的代码和进行动态类型推断成为可能。\n宏（Macros）支持：Scheme和Julia都具有宏的概念，允许编写宏来进行代码转换和元编程。通过宏，可以在编译时对代码进行转换，增加了语言的表达能力和灵活性。\nREPL（交互式环境）：Scheme和Julia都提供了REPL，允许用户在交互式环境中逐行执行代码和测试表达式。这使得快速迭代、调试和探索语言特性成为可能。","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"尽管Julia和Scheme有一些相似之处，但它们也有一些显著的区别。例如，Julia是一门为科学计算和数据分析设计的高性能语言，支持多重派发和并行计算。它还具有直接调用C和Fortran代码的能力，以及广泛的生态系统和丰富的库支持。相比之下，Scheme是一门小而精简的语言，注重简洁性和可扩展性。","category":"page"},{"location":"CSAdv/6-代码生成/","page":"代码生成","title":"代码生成","text":"因此，虽然Julia在某些方面可以被看作是高级版的Scheme，但它们在设计目标、应用领域和语言特性上有所不同。","category":"page"},{"location":"Optimization/2-优化问题的分类/#优化问题的分类","page":"优化问题的分类","title":"优化问题的分类","text":"","category":"section"},{"location":"Optimization/2-优化问题的分类/","page":"优化问题的分类","title":"优化问题的分类","text":"在优化问题中，可以根据不同的分类标准对问题进行分类。以下是一些常见的分类标准：","category":"page"},{"location":"Optimization/2-优化问题的分类/#按问题类型分","page":"优化问题的分类","title":"按问题类型分","text":"","category":"section"},{"location":"Optimization/2-优化问题的分类/","page":"优化问题的分类","title":"优化问题的分类","text":"线性规划（Linear Programming）：目标函数和约束条件都是线性的。\n非线性规划（Nonlinear Programming）：目标函数和/或约束条件中包含非线性项。\n整数规划（Integer Programming）：决策变量被限制为整数值。\n混合整数规划（Mixed Integer Programming）：决策变量中既有连续型变量又有整数变量。\n二次规划（Quadratic Programming）：目标函数包含二次项，约束条件可以是线性或非线性。\n动态规划（Dynamic Programming）：优化问题涉及到时间序列上的决策。\n排队论（Queueing Theory）：优化问题涉及到队列的调度和排队模型。","category":"page"},{"location":"Optimization/2-优化问题的分类/#按目标函数类型分","page":"优化问题的分类","title":"按目标函数类型分","text":"","category":"section"},{"location":"Optimization/2-优化问题的分类/","page":"优化问题的分类","title":"优化问题的分类","text":"单目标优化（Single-Objective Optimization）：优化问题只有一个目标函数需要最小化或最大化。\n多目标优化（Multi-Objective Optimization）：优化问题有多个冲突的目标函数需要最小化或最大化。","category":"page"},{"location":"Optimization/2-优化问题的分类/#按约束类型分","page":"优化问题的分类","title":"按约束类型分","text":"","category":"section"},{"location":"Optimization/2-优化问题的分类/","page":"优化问题的分类","title":"优化问题的分类","text":"等式约束（Equality Constraints）：约束条件为等式形式。\n不等式约束（Inequality Constraints）：约束条件为不等式形式。\n范围约束（Bound Constraints）：决策变量有上下限范围。\n条件约束（Conditional Constraints）：约束条件是基于某些条件的。","category":"page"},{"location":"Optimization/2-优化问题的分类/#按解空间是否连续分","page":"优化问题的分类","title":"按解空间是否连续分","text":"","category":"section"},{"location":"Optimization/2-优化问题的分类/","page":"优化问题的分类","title":"优化问题的分类","text":"连续优化（Continuous Optimization）：决策变量可以取任意实数值。\n离散优化（Discrete Optimization）：决策变量受到离散值的限制。","category":"page"},{"location":"Optimization/2-优化问题的分类/","page":"优化问题的分类","title":"优化问题的分类","text":"这些分类标准有助于理解不同类型的优化问题和选择适当的优化算法。在实际问题中，可能会同时涉及多个分类标准，因此需要综合考虑问题的特点，选择适合的建模和求解方法。","category":"page"},{"location":"Optimization/2-优化问题的分类/#混合整数非线性规划","page":"优化问题的分类","title":"混合整数非线性规划","text":"","category":"section"},{"location":"Optimization/2-优化问题的分类/","page":"优化问题的分类","title":"优化问题的分类","text":"还有一个特别要提一下的是混合整数非线性规划。","category":"page"},{"location":"Optimization/2-优化问题的分类/","page":"优化问题的分类","title":"优化问题的分类","text":"混合整数非线性规划（Mixed-Integer Nonlinear Programming，MINLP）是一种复杂的优化问题，它同时具有离散整数变量、连续变量和非线性函数。","category":"page"},{"location":"Optimization/2-优化问题的分类/","page":"优化问题的分类","title":"优化问题的分类","text":"在混合整数非线性规划中，目标函数和约束条件可以包含非线性项，同时还存在需要取整的决策变量。这种问题的求解困难度较高，需要使用特定的优化算法和技术来找到最优解。","category":"page"},{"location":"Optimization/2-优化问题的分类/","page":"优化问题的分类","title":"优化问题的分类","text":"MINLP问题在实际应用中广泛存在，例如在生产计划、设备配置、资源分配等领域。一些常见的应用包括：","category":"page"},{"location":"Optimization/2-优化问题的分类/","page":"优化问题的分类","title":"优化问题的分类","text":"生产调度问题：考虑生产线上的机器调度、工人分配等问题，同时考虑生产量和成本的最优化。\n设备优化配置问题：确定最佳的设备配置和使用方案，以最小化成本或最大化产出，并考虑设备容量和技术约束。\n能源系统优化：考虑能源资源的选择、供需平衡和设备调度等问题，以最小化成本或最大化能源利用效率。","category":"page"},{"location":"Optimization/2-优化问题的分类/","page":"优化问题的分类","title":"优化问题的分类","text":"求解MINLP问题的方法包括分支定界法、割平面法、混合整数线性规划与非线性规划的交替求解、松弛方法等。这些方法结合了离散整数优化和连续非线性优化的技术，旨在有效地处理复杂的混合整数非线性规划问题。","category":"page"},{"location":"Optimization/2-优化问题的分类/","page":"优化问题的分类","title":"优化问题的分类","text":"由于混合整数非线性规划的复杂性，对于大规模问题或高精度要求，求解时间可能很长，并且无法保证找到全局最优解。因此，在实际应用中，常常需要根据问题的特点和要求，进行问题简化、约束松弛或采用启发式方法等策略来求解近似最优解。","category":"page"},{"location":"Control/1-控制的本质/#控制的本质","page":"控制的本质","title":"控制的本质","text":"","category":"section"},{"location":"Control/1-控制的本质/#从bangbang到pid再到mpc","page":"控制的本质","title":"从bangbang到pid再到mpc","text":"","category":"section"},{"location":"Control/1-控制的本质/#模型预测控制详解","page":"控制的本质","title":"模型预测控制详解","text":"","category":"section"},{"location":"Control/1-控制的本质/#TCLab与工业4.0","page":"控制的本质","title":"TCLab与工业4.0","text":"","category":"section"},{"location":"Control/1-控制的本质/","page":"控制的本质","title":"控制的本质","text":"设备->PLC->工控机","category":"page"},{"location":"Control/1-控制的本质/#物联网","page":"控制的本质","title":"物联网","text":"","category":"section"},{"location":"Control/1-控制的本质/#再看微分方程的时间展开","page":"控制的本质","title":"再看微分方程的时间展开","text":"","category":"section"},{"location":"Control/1-控制的本质/#正问题、反问题","page":"控制的本质","title":"正问题、反问题","text":"","category":"section"},{"location":"Control/1-控制的本质/#数字孪生","page":"控制的本质","title":"数字孪生","text":"","category":"section"},{"location":"Optimization/95-微分方程参数辨识实例/#微分方程参数辨识实例","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"section"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"tip: Tip\nContents：微分方程参数辨识、优化、DiffEqParamEstimContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"note: Note\nDEPE = DiffEqParamEstim.jl(Differential Equation Parameters Estimate)DiffEqParamEstim.jl是计算微分方程参数估计的软件包。","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/#微分方程参数辨识问题","page":"微分方程参数辨识实例","title":"微分方程参数辨识问题","text":"","category":"section"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"在JuMP非线性参数辨识实例与MTK非线性参数辨识实例中介绍了参数辨识问题的形式与求解工具。求解的问题的数学形式为一般方程：","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"y = ax^2+sin(bx)a=15b=08","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"DEPE则是针对另外一种数学形式进行参数辨识求解的工具包——微分方程形式。例如，如下问题：","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"fracdydt = at^2+sin(bt)a=15b=08","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"对于这样一个微分问题。假设我们并不知道参数ab的值是多少。同样只能过实验和测量获得对应时间点上y的观测值。参数辨识需要解决的问题是：根据t，y观测值。反推出ab的值。与前面解决的问题不同的是，它是微分方程形式。相同的是，它们的核心逻辑是“优化”。","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"要求解这样一个含有微分方程的参数辨识问题，可以很自然地想到：将微分方程的原函数求出来，再进行常规方程的参数辨识，问题就解决了。但是这有一个前提——能够求出原函数。","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"DEPE的解决方式是，直接将微分方程离散，通过离散后的节点直接构造优化问题，进行求解。这样就避免了求解原函数问题。","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/#离散的概念","page":"微分方程参数辨识实例","title":"离散的概念","text":"","category":"section"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"离散是微分方程数值解法中的一个概念。例如，求解：fracdydt = ytin(01)","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"具体的方法是在tin(01)选特定步长的点，假如选定步长为0.1，那么有：","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"t_0=0t_1=01t_2=02t_10=10","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"同时，对于函数y，有","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"y_n-y_n-1 = y_n-1 * 01nin01210","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"所以，对于微分方程问题，就转为了求y_0至y_10的值，也就是求出具体时间点上的函数值。问题就由一个连续的方程变成了有限个点上的函数值，这个过程就成为离散。","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"数值求解算法的精度与离散的方法有紧密关系。上面的离散方式可以换成：","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"y_n-y_n-1 = y_n * 01nin01210","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"区别不过不过是等式右端取y_n-1还是y_n的区别。但却是两种不同的方法——向前与向后差分，求解的精度也不一样。","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"此外，求解的精度还与步长等因素相关。更多理论，可以查阅《数值分析》一书。","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/#微分参数辨识的优化表达","page":"微分方程参数辨识实例","title":"微分参数辨识的优化表达","text":"","category":"section"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"回到问题fracdydt = at^2+sin(bt)，已知系列观测值：y_real那么优化问题的数学表达为：","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"undersetabminsum_i=0^n(y_reali-y_i)^2sthspace5mmy_i+1-y_i=at_i^2+sin(bt_i)","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/#加热器实例","page":"微分方程参数辨识实例","title":"加热器实例","text":"","category":"section"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"现有一个加热系统，由加热器、温度传感器、散热器构成。那么其控制方程为：","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"mcfracdTdt=(-Sh(T-T_out)+Q)*u(t-t_0)","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"可以简单理解为：","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"温度变化=加热-散热*延迟函数","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"经过化简之后：","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"beginarrayc\nfracd Td t=left(-fracTa+fracbaright) * u(t-c) \nu(t-c)=f(x)=leftbeginarrayll\n0  x0 1  x geq 0endarrayrightendarray","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"参数辨识的目标是辨识出a，b，c。","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"数据（数据在文档最后，以CSV文件格式保存到julia程序文件夹即可）的第二列中为加热功率，在方程模型中我们做了简化。由于功率只有0和100，在方程中我们简化为开关延时函数。所以第二列的原始数据后面并没有使用。","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"首先，实际的曲线如下：","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"using CSV,DataFrames,Plots\ndata = CSV.read(\"./codetest/data.csv\",DataFrame)\n########根据第一列与第三列数据画出图像#########\nplot(data[:,1],data[:,3]) ","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"(Image: 图 1)  ","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"使用DE作为建模基础建立方程：","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"using DifferentialEquations\nfunction fun(a)\n    if a>=0\n        1\n    else\n        0\n    end\nend\nfunction ff(u,p,t)\n    -u * fun( t- p[3])/p[1] + p[2] * fun( t- p[3])/p[1]\nend","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"这里采用了简写方式，省略了du，只包含微分方程右边的部分，因为只有一个微分变量所以可以简写。\nFun表示函数u的作用，其本质是单位阶跃函数。","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"定义参数等要素：","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"u0=3.6\ntspan = (0.0,3000.0)\np = [1.0,1.0,1.0]\nprob = ODEProblem(ff,u0,tspan,p)","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"需要留意p的值，这里p为选定的初始值。p的最终值是需要通过优化才能得到。优化目标为找到一组p，使得Loss方程的数值最小。","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"如果按照初值p = [1.0,1.0,1.0]求解，则可以得到如下结果：","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"sol = solve(prob, Tsit5())\nplot(sol)","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"(Image: 图 2)  ","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"可以看到，相去甚远！说明这个初值与真实值相差很远。","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"通过DiffEqParamEstim构建优化模型：","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"using DiffEqParamEstim\nrealdata = data[:,3]\nt= data[:,1]\ncost_function = build_loss_objective(prob, Tsit5(), L2Loss(t, realdata),\n    maxiters=10000, verbose=false)","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"其中，","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"realdata是实际过程中的温度值向量\nt是实际采样过程中的温度点\nbuildlossobjective 直接构建了Loss方程，其方法是L2Loss，即差的平方和。","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"求解优化问题：","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"using Optim\nresult_bfgs = Optim.optimize(cost_function, [1.0, 1.0, 1.0])\nprint(result_bfgs.minimizer)\n","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"Optim.optimize就是求解器，能求cost_function的最小值。","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"得到结果：","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"(Image: 图 3)  ","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"画图测试优化结果：","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"u0=3.6\ntspan = (0.0,3000.0)\np = [779.0,49.0,-652.0]\nprob = ODEProblem(ff,u0,tspan,p)\nsol = solve(prob, Tsit5())\nplot(sol)","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"(Image: 图 4)  ","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"似乎结果差得有点远！","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"再次优化：这是因为初值对优化问题造成的影响。由于初值与目标相去甚远，所以结果有些出入。p[3]应该是正数。把优化初值的第三项改为正数。再次优化","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"result_bfgs = Optim.optimize(cost_function, [773.0,49.0,652.0])\nprint(result_bfgs.minimizer)","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"(Image: 图 5)  ","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"在这个结果下，画出来的图像如图：","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"(Image: 图 6)  ","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"这是一个让人满意的结果！","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"note: Note\n多次优化是优化中一种常见的策略。某些问题的优化结果可能是一个局部最优解，这并不代表结果是错误的。所以，当优化结果不满意时，可以选择不同的初值进行优化求解。当初值离最优值越近，结果越准确。","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"全部代码：","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"using CSV, DataFrames, Plots\ndata = CSV.read(\"./codetest/data.csv\", DataFrame)\ndata[!, 3]\nplot(data[:, 1], data[:, 3]) #画出图像\n\nusing DifferentialEquations\nfunction fun(a)\n    if a >= 0\n        1\n    else\n        0\n    end\nend\nfunction ff(u, p, t)\n    -u * fun(t - p[3]) / p[1] + p[2] * fun(t - p[3]) / p[1]\nend\n\nu0 = 3.6\ntspan = (0.0, 3000.0)\np = [1.0, 1.0, 1.0]\nprob = ODEProblem(ff, u0, tspan, p)\n\nsol = solve(prob, Tsit5())\nplot(sol)\n\nusing DiffEqParamEstim\nrealdata = data[:, 3]\nt = data[:, 1]\ncost_function = build_loss_objective(prob, Tsit5(), L2Loss(t, realdata),\n    maxiters=10000, verbose=false)\n\nusing Optim\nresult_bfgs = Optim.optimize(cost_function, [1.0, 1.0, 1.0])\nprint(result_bfgs.minimizer)\n\nresult_bfgs = Optim.optimize(cost_function, [773.0,49.0,652.0])\nprint(result_bfgs.minimizer)\n\n\nu0=3.6\ntspan = (0.0,3000.0)\np = [267.0,45.0,343.0]\nprob = ODEProblem(ff,u0,tspan,p)\nsol = solve(prob, Tsit5())\nplot(sol)","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"原始数据：","category":"page"},{"location":"Optimization/95-微分方程参数辨识实例/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"Time (min),Valve Position (% open),Temperature (degC)\n0,0,3.6\n5,0,3.7\n10,0,3.6\n15,0,3.7\n20,0,3.6\n25,0,3.7\n30,0,3.7\n35,0,3.6\n40,0,3.6\n45,0,3.6\n50,0,3.6\n55,0,3.7\n60,0,3.7\n65,0,3.7\n70,0,3.7\n75,0,3.5\n80,0,3.6\n85,0,3.7\n90,0,3.5\n95,0,3.6\n100,0,3.5\n105,0,3.7\n110,0,3.6\n115,0,3.7\n120,0,3.6\n125,0,3.7\n130,0,3.7\n135,0,3.7\n140,0,3.7\n145,0,3.7\n150,0,3.7\n155,0,3.5\n160,0,3.6\n165,0,3.6\n170,0,3.6\n175,0,3.7\n180,0,3.6\n185,0,3.6\n190,0,3.7\n195,0,3.6\n200,0,3.5\n205,0,3.6\n210,0,3.5\n215,0,3.7\n220,0,3.6\n225,0,3.5\n230,0,3.7\n235,0,3.7\n240,0,3.6\n245,0,3.7\n250,0,3.5\n255,0,3.7\n260,0,3.7\n265,0,3.6\n270,0,3.6\n275,0,3.7\n280,0,3.7\n285,0,3.7\n290,0,3.5\n295,0,3.7\n300,0,3.5\n305,0,3.5\n310,0,3.7\n315,0,3.6\n320,0,3.7\n325,0,3.6\n330,0,3.7\n335,0,3.5\n340,0,3.5\n345,0,3.5\n350,0,3.7\n355,0,3.7\n360,0,3.6\n365,0,3.6\n370,0,3.7\n375,0,3.5\n380,0,3.7\n385,0,3.5\n390,0,3.7\n395,0,3.6\n400,100,3.7\n405,100,14.9\n410,100,18.2\n415,100,19.2\n420,100,19.9\n425,100,20.1\n430,100,20.8\n435,100,21.0\n440,100,21.3\n445,100,21.4\n450,100,21.5\n455,100,22.0\n460,100,21.8\n465,100,21.8\n470,100,21.9\n475,100,21.5\n480,100,21.7\n485,100,21.2\n490,100,20.7\n495,100,20.3\n500,100,20.3\n505,100,20.1\n510,100,21.2\n515,100,22.8\n520,100,23.9\n525,100,24.2\n530,100,24.9\n535,100,25.7\n540,100,26.4\n545,100,26.5\n550,100,26.7\n555,100,27.3\n560,100,27.6\n565,100,27.5\n570,100,27.5\n575,100,27.7\n580,100,27.8\n585,100,27.8\n590,100,27.9\n595,100,27.9\n600,100,28.0\n605,100,28.2\n610,100,28.2\n615,100,28.5\n620,100,28.7\n625,100,28.9\n630,100,29.0\n635,100,29.2\n640,100,29.7\n645,100,29.8\n650,100,30.1\n655,100,30.4\n660,100,30.5\n665,100,30.9\n670,100,31.6\n675,100,31.8\n680,100,32.2\n685,100,32.7\n690,100,32.8\n695,100,33.0\n700,100,33.4\n705,100,33.8\n710,100,34.0\n715,100,34.6\n720,100,34.8\n725,100,35.2\n730,100,35.4\n735,100,35.7\n740,100,36.0\n745,100,36.6\n750,100,36.8\n755,100,36.9\n760,100,37.3\n765,100,37.5\n770,100,37.7\n775,100,37.9\n780,100,37.9\n785,100,38.3\n790,100,38.2\n795,100,38.4\n800,100,38.7\n805,100,38.8\n810,100,39.1\n815,100,39.2\n820,100,39.2\n825,100,39.4\n830,100,39.4\n835,100,39.3\n840,100,39.5\n845,100,39.5\n850,100,39.7\n855,100,39.7\n860,100,39.8\n865,100,40.1\n870,100,39.9\n875,100,40.1\n880,100,40.0\n885,100,40.2\n890,100,40.1\n895,100,40.3\n900,100,40.3\n905,100,40.2\n910,100,40.1\n915,100,40.1\n920,100,40.1\n925,100,40.2\n930,100,40.3\n935,100,40.4\n940,100,40.4\n945,100,40.8\n950,100,40.8\n955,100,40.8\n960,100,40.7\n965,100,40.9\n970,100,41.0\n975,100,41.2\n980,100,41.3\n985,100,41.3\n990,100,41.3\n995,100,41.3\n1000,100,41.4\n1005,100,41.7\n1010,100,41.7\n1015,100,41.6\n1020,100,41.8\n1025,100,41.6\n1030,100,41.7\n1035,100,41.8\n1040,100,41.9\n1045,100,42.0\n1050,100,42.1\n1055,100,42.0\n1060,100,42.2\n1065,100,42.1\n1070,100,42.4\n1075,100,42.4\n1080,100,42.6\n1085,100,42.7\n1090,100,42.7\n1095,100,42.9\n1100,100,43.0\n1105,100,43.0\n1110,100,43.1\n1115,100,43.2\n1120,100,43.4\n1125,100,43.4\n1130,100,43.5\n1135,100,43.4\n1140,100,43.5\n1145,100,43.8\n1150,100,43.8\n1155,100,43.8\n1160,100,44.0\n1165,100,44.0\n1170,100,44.0\n1175,100,44.1\n1180,100,44.1\n1185,100,44.2\n1190,100,44.3\n1195,100,44.2\n1200,100,44.4\n1205,100,44.4\n1210,100,44.3\n1215,100,44.4\n1220,100,44.2\n1225,100,44.2\n1230,100,44.0\n1235,100,44.1\n1240,100,43.9\n1245,100,43.9\n1250,100,43.8\n1255,100,44.0\n1260,100,44.0\n1265,100,43.8\n1270,100,43.9\n1275,100,43.9\n1280,100,44.0\n1285,100,44.0\n1290,100,44.1\n1295,100,44.1\n1300,100,44.2\n1305,100,43.9\n1310,100,43.9\n1315,100,44.0\n1320,100,43.8\n1325,100,43.9\n1330,100,43.8\n1335,100,43.9\n1340,100,43.8\n1345,100,43.6\n1350,100,43.7\n1355,100,43.7\n1360,100,43.8\n1365,100,43.7\n1370,100,43.6\n1375,100,43.8\n1380,100,43.6\n1385,100,43.7\n1390,100,43.4\n1395,100,43.4\n1400,100,43.5\n1405,100,43.4\n1410,100,43.4\n1415,100,43.6\n1420,100,43.7\n1425,100,43.6\n1430,100,43.6\n1435,100,43.5\n1440,100,43.5\n1445,100,43.6\n1450,100,43.6\n1455,100,43.5\n1460,100,43.4\n1465,100,43.6\n1470,100,43.6\n1475,100,43.6\n1480,100,43.6\n1485,100,43.7\n1490,100,43.7\n1495,100,43.7\n1500,100,43.7\n1505,100,43.6\n1510,100,43.6\n1515,100,43.7\n1520,100,43.7\n1525,100,43.5\n1530,100,43.5\n1535,100,43.7\n1540,100,43.8\n1545,100,43.7\n1550,100,43.8\n1555,100,43.8\n1560,100,43.8\n1565,100,43.8\n1570,100,43.9\n1575,100,44.0\n1580,100,43.8\n1585,100,43.9\n1590,100,44.0\n1595,100,44.1\n1600,100,44.1\n1605,100,44.1\n1610,100,44.2\n1615,100,44.0\n1620,100,44.1\n1625,100,44.0\n1630,100,44.0\n1635,100,44.1\n1640,100,44.1\n1645,100,44.2\n1650,100,44.2\n1655,100,44.2\n1660,100,44.2\n1665,100,44.1\n1670,100,44.3\n1675,100,44.3\n1680,100,44.3\n1685,100,44.5\n1690,100,44.5\n1695,100,44.5\n1700,100,44.5\n1705,100,44.5\n1710,100,44.6\n1715,100,44.7\n1720,100,44.5\n1725,100,44.7\n1730,100,44.7\n1735,100,44.9\n1740,100,44.8\n1745,100,45.0\n1750,100,44.8\n1755,100,44.9\n1760,100,44.9\n1765,100,45.0\n1770,100,45.1\n1775,100,45.1\n1780,100,45.1\n1785,100,45.2\n1790,100,45.1\n1795,100,45.2\n1800,100,45.2\n1805,100,45.3\n1810,100,45.3\n1815,100,45.2\n1820,100,45.3\n1825,100,45.2\n1830,100,45.2\n1835,100,45.3\n1840,100,45.3\n1845,100,45.2\n1850,100,45.3\n1855,100,45.2\n1860,100,45.4\n1865,100,45.4\n1870,100,45.2\n1875,100,45.4\n1880,100,45.3\n1885,100,45.4\n1890,100,45.4\n1895,100,45.2\n1900,100,45.1\n1905,100,45.2\n1910,100,45.1\n1915,100,45.3\n1920,100,45.1\n1925,100,45.2\n1930,100,45.2\n1935,100,45.0\n1940,100,45.0\n1945,100,45.1\n1950,100,45.2\n1955,100,45.0\n1960,100,45.2\n1965,100,45.3\n1970,100,45.2\n1975,100,45.3\n1980,100,45.1\n1985,100,45.2\n1990,100,45.3\n1995,100,45.3\n2000,100,45.3\n2005,100,45.3\n2010,100,45.2\n2015,100,45.3\n2020,100,45.1\n2025,100,45.3\n2030,100,45.2\n2035,100,45.2\n2040,100,45.4\n2045,100,45.2\n2050,100,45.3\n2055,100,45.4\n2060,100,45.5\n2065,100,45.4\n2070,100,45.4\n2075,100,45.3\n2080,100,45.4\n2085,100,45.3\n2090,100,45.5\n2095,100,45.4\n2100,100,45.5\n2105,100,45.3\n2110,100,45.5\n2115,100,45.5\n2120,100,45.5\n2125,100,45.3\n2130,100,45.4\n2135,100,45.4\n2140,100,45.4\n2145,100,45.5\n2150,100,45.3\n2155,100,45.5\n2160,100,45.4\n2165,100,45.5\n2170,100,45.3\n2175,100,45.5\n2180,100,45.5\n2185,100,45.5\n2190,100,45.5\n2195,100,45.4\n2200,100,45.5\n2205,100,45.3\n2210,100,45.4\n2215,100,45.4\n2220,100,45.5\n2225,100,45.3\n2230,100,45.3\n2235,100,45.4\n2240,100,45.5\n2245,100,45.5\n2250,100,45.5\n2255,100,45.5\n2260,100,45.5\n2265,100,45.5\n2270,100,45.5\n2275,100,45.6\n2280,100,45.5\n2285,100,45.6\n2290,100,45.5\n2295,100,45.5\n2300,100,45.5\n2305,100,45.5\n2310,100,45.6\n2315,100,45.6\n2320,100,45.7\n2325,100,45.5\n2330,100,45.6\n2335,100,45.6\n2340,100,45.7\n2345,100,45.8\n2350,100,45.7\n2355,100,45.7\n2360,100,45.6\n2365,100,45.8\n2370,100,45.7\n2375,100,45.9\n2380,100,45.8\n2385,100,45.8\n2390,100,45.7\n2395,100,45.6\n2400,100,45.9\n2405,100,45.7\n2410,100,45.7\n2415,100,45.7\n2420,100,45.7\n2425,100,45.8\n2430,100,45.9\n2435,100,45.8\n2440,100,45.7\n2445,100,45.9\n2450,100,45.8\n2455,100,45.7\n2460,100,45.9\n2465,100,45.9\n2470,100,45.9\n2475,100,45.9\n2480,100,45.7\n2485,100,45.8\n2490,100,45.7\n2495,100,45.7\n2500,100,45.9\n2505,100,45.8\n2510,100,45.9\n2515,100,45.8\n2520,100,45.7\n2525,100,45.7\n2530,100,45.9\n2535,100,45.8\n2540,100,45.9\n2545,100,45.9\n2550,100,45.9\n2555,100,45.7\n2560,100,46.0\n2565,100,45.8\n2570,100,45.8\n2575,100,45.9\n2580,100,46.0\n2585,100,45.8\n2590,100,46.0\n2595,100,45.8\n2600,100,45.8\n2605,100,45.9\n2610,100,46.0\n2615,100,46.0\n2620,100,45.9\n2625,100,46.0\n2630,100,46.1\n2635,100,45.9\n2640,100,46.0\n2645,100,46.0\n2650,100,45.9\n2655,100,46.0\n2660,100,46.0\n2665,100,46.0\n2670,100,46.0\n2675,100,46.1\n2680,100,46.0\n2685,100,46.1\n2690,100,46.1\n2695,100,46.0\n2700,100,45.9\n2705,100,46.1\n2710,100,45.9\n2715,100,46.1\n2720,100,46.0\n2725,100,46.0\n2730,100,46.1\n2735,100,46.0\n2740,100,46.0\n2745,100,46.0\n2750,100,46.0\n2755,100,46.0\n2760,100,46.0\n2765,100,45.8\n2770,100,46.0\n2775,100,46.0\n2780,100,45.8\n2785,100,45.9\n2790,100,45.9\n2795,100,45.9\n2800,100,45.9\n2805,100,46.0\n2810,100,46.0\n2815,100,46.0\n2820,100,46.0\n2825,100,46.0\n2830,100,45.9\n2835,100,45.9\n2840,100,45.9\n2845,100,45.9\n2850,100,45.9\n2855,100,46.0\n2860,100,46.0\n2865,100,45.9\n2870,100,45.8\n2875,100,45.8\n2880,100,46.1\n2885,100,46.0\n2890,100,46.1\n2895,100,45.9\n2900,100,46.1\n2905,100,45.9\n2910,100,46.1\n2915,100,45.9\n2920,100,46.0\n2925,100,45.9\n2930,100,46.1\n2935,100,46.0\n2940,100,46.0\n2945,100,46.1\n2950,100,46.0\n2955,100,46.0\n2960,100,46.1\n2965,100,46.1\n2970,100,46.0\n2975,100,45.9\n2980,100,46.0\n2985,100,46.1\n2990,100,46.0\n2995,100,46.1\n3000,100,46.0","category":"page"},{"location":"GolangIntro/02-golang的特点/#golang简介","page":"golang简介","title":"golang简介","text":"","category":"section"},{"location":"GolangIntro/02-golang的特点/#golang的特点","page":"golang简介","title":"golang的特点","text":"","category":"section"},{"location":"GolangIntro/02-golang的特点/","page":"golang简介","title":"golang简介","text":"Go（通常称为 Golang，以避免与其他编程语言混淆）是由 Google 设计并在 2009 年发布的编程语言。它从一开始就被设计为简单、高效和可靠的。以下是 Go 语言的主要特点：","category":"page"},{"location":"GolangIntro/02-golang的特点/","page":"golang简介","title":"golang简介","text":"简洁性和可读性：Go 设计得非常简单和直观，它避免了不必要的复杂性，使得代码容易阅读和维护。\n并发性：Go 的其中一个突出特点是其并发模型。通过 goroutines 和 channels，Go 使并发编程变得相对简单和高效。\n静态类型：尽管 Go 是静态类型的，但其类型系统旨在最大化代码的简洁性和可读性。\n垃圾收集：Go 是一种带有垃圾收集功能的语言，这有助于自动管理内存。\n标准库：Go 有一个全面且高效的标准库，涵盖了网络编程、数据处理、加密、图像处理等多个领域。\n跨平台：Go 支持多平台编译，这意味着你可以在一种平台上轻松地为另一种平台编译应用程序。\n性能：由于 Go 是编译型语言，它生成的二进制代码能够直接在操作系统上运行，这使得其性能接近 C 或 C++。\n依赖管理：从 Go 1.11 开始，Go 引入了模块（modules），这是其新的依赖管理系统，使得包的版本管理和项目的依赖关系处理变得更为简单。\n工具链：Go 有一个强大的工具链，如 go fmt（用于自动格式化代码）和 go doc（用于生成文档）。\n内置测试框架：Go 提供了内置的测试工具和框架，使得测试变得简单而自然。\nC 兼容性：可以通过 Cgo 轻松地在 Go 中调用 C 代码，这为 Go 提供了与现有的 C 库的互操作性。\n简单的错误处理：通过多返回值和明确的错误类型，Go 为错误处理提供了一种简单而明确的方法。\n明确的设计哲学：Go 有一套明确的设计哲学，其中的许多原则都围绕着简化编程任务。这一点在 Go 的官方口号 \"Less is exponentially more\" 中得到了体现。","category":"page"},{"location":"GolangIntro/02-golang的特点/","page":"golang简介","title":"golang简介","text":"Go 由于其简单性、高效性和并发性，在云计算、微服务、网络编程以及其他多种领域中已经变得非常受欢迎。","category":"page"},{"location":"GolangIntro/02-golang的特点/#谁在使用golang","page":"golang简介","title":"谁在使用golang","text":"","category":"section"},{"location":"GolangIntro/02-golang的特点/","page":"golang简介","title":"golang简介","text":"Go 语言自从发布以来已经被广大的开发者社区和许多知名公司所采用。以下是一些主要使用 Go 的公司和基于 Go 开发的有影响的软件：","category":"page"},{"location":"GolangIntro/02-golang的特点/","page":"golang简介","title":"golang简介","text":"Google：Go 由 Google 设计并开发，因此 Google 的许多项目，如 Kubernetes、Istio 和 gVisor 都是用 Go 写的。\nDocker：Docker 是一个开源的应用容器化平台，它的核心组件是用 Go 编写的。\nKubernetes：这是一个开源的容器编排系统，用于自动化应用部署、扩展和管理，它的主体是用 Go 编写的。\nTerraform：HashiCorp 的 Terraform 是一个开源的基础设施即代码软件工具，允许用户使用声明式配置来提供、更改和版本控制云基础设施。\nConsul：也是由 HashiCorp 开发的，它提供服务发现和配置。\nPrometheus：是一个开源的系统监控和警报工具包，它的主体是用 Go 编写的。\nEtcd：由 CoreOS 开发的一个分布式可靠的键值存储，用于配置管理和服务发现。\nCockroachDB：一个分布式 SQL 数据库，旨在构建、扩展和管理关键业务数据。\nGrafana：用于大规模数据的开源平台，它为分析和监控提供了一种可视化方式。\nGo-Ethereum (Geth)：Ethereum 的 Go 实现，用于运行 Ethereum 节点。\nUber：Uber 使用 Go 在其微服务体系结构中处理高性能和高吞吐量的工作负载。\nTwitch：这家流媒体公司使用 Go 来处理其后端服务。\nDropbox：Dropbox 的一部分基础设施是用 Go 编写的。","category":"page"},{"location":"GolangIntro/02-golang的特点/","page":"golang简介","title":"golang简介","text":"这只是一个简短的列表，很多其他的公司和开源项目也已经开始采用 Go 语言，因为它为构建高性能、高并发和可靠的系统提供了一个强大而简单的工具集。","category":"page"},{"location":"GolangIntro/02-golang的特点/#我们为什么要用golang","page":"golang简介","title":"我们为什么要用golang","text":"","category":"section"},{"location":"GolangIntro/02-golang的特点/","page":"golang简介","title":"golang简介","text":"Julia 和 Go 都是近年来崭露头角的现代编程语言，但它们分别专注于不同的应用领域。结合使用两者，可以充分利用各自的优势，为复杂的计算和服务架构带来卓越的性能和便捷性。","category":"page"},{"location":"GolangIntro/02-golang的特点/","page":"golang简介","title":"golang简介","text":"Julia：专注于高性能计算","category":"page"},{"location":"GolangIntro/02-golang的特点/","page":"golang简介","title":"golang简介","text":"Julia 设计初衷是为了满足高性能数值计算和数据科学的需求。它具有以下特点：","category":"page"},{"location":"GolangIntro/02-golang的特点/","page":"golang简介","title":"golang简介","text":"高性能：Julia 被设计为能够与 C 和 Fortran 竞争的性能，但使用更高级和易读的语法。\n灵活的数学和统计库：Julia 拥有丰富的库，可以轻松处理各种数学、统计和机器学习任务。\n互操作性：Julia 可以轻松地与其他语言（如 Python、C、Fortran）的库和函数互操作。","category":"page"},{"location":"GolangIntro/02-golang的特点/","page":"golang简介","title":"golang简介","text":"因此，对于计算密集型任务和模型运算，Julia 显然是一个出色的选择。","category":"page"},{"location":"GolangIntro/02-golang的特点/","page":"golang简介","title":"golang简介","text":"Go (Golang)：构建稳健的系统和服务","category":"page"},{"location":"GolangIntro/02-golang的特点/","page":"golang简介","title":"golang简介","text":"Go 的设计重点是简单、高效和可靠。它在以下领域中表现出色：","category":"page"},{"location":"GolangIntro/02-golang的特点/","page":"golang简介","title":"golang简介","text":"并发：通过 goroutines 和 channels，Go 为并发编程提供了出色的原生支持。\n网络和微服务：Go 的标准库包括构建 HTTP 服务器和客户端的一切所需功能，非常适合构建和部署微服务。\n简洁和可靠：Go 的简单语法和强类型系统有助于构建可靠、维护性强的代码。\n跨平台和云集成：Go 可以轻松地为多个平台编译，并且与多种云服务提供商完美集成。","category":"page"},{"location":"GolangIntro/02-golang的特点/","page":"golang简介","title":"golang简介","text":"因此，对于描述模型、存储、网络服务构建和云计算任务，Go 是理想的选择。","category":"page"},{"location":"GolangIntro/02-golang的特点/","page":"golang简介","title":"golang简介","text":"整合 Julia 和 Go","category":"page"},{"location":"GolangIntro/02-golang的特点/","page":"golang简介","title":"golang简介","text":"结合 Julia 的计算能力和 Go 的系统和服务构建能力，我们可以创建一个强大、高效且可扩展的系统：","category":"page"},{"location":"GolangIntro/02-golang的特点/","page":"golang简介","title":"golang简介","text":"使用 Julia 进行核心计算和模型运算。\n利用 Go 构建描述、存储和管理这些模型的框架和系统。\n使用 Go 构建的网络服务，使模型可以在云中轻松部署、扩展和访问。","category":"page"},{"location":"GolangIntro/02-golang的特点/","page":"golang简介","title":"golang简介","text":"这种组合确保了计算的高效性和系统的稳健性，同时也为未来的扩展和维护提供了便利。","category":"page"},{"location":"GolangIntro/02-golang的特点/","page":"golang简介","title":"golang简介","text":"综上所述，通过整合 Julia 和 Go，我们不仅能够充分利用每种语言的优势，还能为用户和开发者提供一个既强大又易于使用的综合平台。","category":"page"},{"location":"CSAdv/4-从符号到模型/#从符号到模型","page":"从符号到模型","title":"从符号到模型","text":"","category":"section"},{"location":"CSAdv/4-从符号到模型/#符号与模型简介","page":"从符号到模型","title":"符号与模型简介","text":"","category":"section"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"在编程领域，从符号到模型涉及的概念主要包括符号、解析器和模型。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"符号（Symbol）通常指代编程语言中的基本单位，例如变量、函数名、关键字等。在程序的源代码中，符号是以文本形式出现的，用于表示程序的结构和逻辑。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"解析器（Parser）是编程语言处理器的一部分，它负责将源代码解析为抽象语法树（Abstract Syntax Tree，AST）或其他类似的数据结构。解析器将符号组织起来，根据语法规则和语义规则对其进行分析和转换。解析器可以识别和捕获语法错误，并将代码转换为计算机可以理解和执行的形式。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"抽象语法树是一种树状结构，它用于表示程序的语法结构，每个节点代表一个符号或操作。抽象语法树是编译器和解释器常用的中间表示形式，它便于对程序进行分析、优化和执行。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"模型（Model）在编程领域可以指代多种概念。在机器学习中，模型是对数据的学习结果，它可以用于进行预测、分类或生成新的数据。在编程中，模型还可以指代对程序行为或系统行为的抽象描述或模拟。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"在编程中，从符号到模型的过程可以描述为将程序的符号表示转化为对程序行为的抽象描述或模拟。这可以通过解析源代码、构建抽象语法树，并进一步分析和处理该语法树来实现。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"需要注意的是，从符号到模型的过程可能在不同的上下文中有不同的意义和实现方式。上述的描述是一种常见的理解，但在具体的编程语言、编程范式或应用领域中可能会有一些差异。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"符号是指具体的字符或图像，例如数字或运算符号。符号，它们只是表面上的表示，不能直接进行计算。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"模型是指我们对这些符号所赋予的意义或解释。通过将符号与相应的模型联系起来，我们可以进行计算。例如，用一只手表示数字4，另一只手表示数字3，然后通过对手指进行操作（弯曲、伸开等），我们可以得到结果。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"分清符号和模型的是很重要的。理解符号和模型之间的区别有助于我们在数学和算术中建立正确的概念和操作，同时也提醒我们符号本身只是表面的表示，需要将其与适当的模型联系起来才能进行实际的计算。","category":"page"},{"location":"CSAdv/4-从符号到模型/#编程中的源码与解析器","page":"从符号到模型","title":"编程中的源码与解析器","text":"","category":"section"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"在计算机科学中，源代码是一种符号系统，它由编程语言中的字符和语法规则组成。源代码是开发人员用来描述计算机程序的文本形式。然而，计算机无法直接理解源代码，因为它们只能处理二进制指令。因此，源代码需要被解析和转换成计算机能够执行的模型，例如抽象语法树（Abstract Syntax Tree）或字节码。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"让我们以一个简单的例子来说明这个过程。假设我们有以下的源代码片段，使用Python编程语言：","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"x = 5\ny = 3\nz = x + y\nprint(z)","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"在这个例子中，源代码是符号，由各种字符和标识符组成。编译器或解释器会对源代码进行解析，按照编程语言的语法规则来理解它。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"首先，编译器或解释器将分析代码的语法，将其组织成一个抽象语法树（AST）。抽象语法树是一种以树形结构表示代码的模型。对于上述源代码片段，抽象语法树可能如下所示：","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"   =\n  / \\\nx    5\n\n   =\n  / \\\ny    3\n\n   +\n  / \\\nx    y\n\nprint\n  |\n  z","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"这个抽象语法树捕捉了源代码中的结构和语义信息。每个节点代表一个操作或值，它们之间的关系由树的结构表示。通过这个模型，编译器或解释器可以理解代码中的变量赋值、运算和输出操作。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"接下来，编译器或解释器会将抽象语法树转换成计算机能够执行的形式。在Python的情况下，它会将代码转换成字节码，然后由解释器执行字节码。字节码是一种中间形式，它对应于特定的执行引擎。实际执行字节码时，计算机会根据字节码中的指令来进行操作，从而实现代码的功能。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"总结来说，源代码是符号，它们通过解析和转换成特定的模型（例如抽象语法树或字节码）来实现计算机程序的功能。这个过程使得计算机能够理解和执行源代码中描述的操作。","category":"page"},{"location":"CSAdv/4-从符号到模型/#再来一个Julia的例子","page":"从符号到模型","title":"再来一个Julia的例子","text":"","category":"section"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"当使用Julia编程语言时，我们可以使用Meta.parse和Meta.show_sexpr函数来演示源代码的解析和生成抽象语法树的过程。下面是一个示例：","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"code = \"x = 5 + 3\"\nexpr = Meta.parse(code)\nMeta.show_sexpr(expr)","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"在这个例子中，我们有一个简单的源代码字符串\"x = 5 + 3\"，它表示将数值5和3相加并将结果赋给变量x。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"首先，我们使用Meta.parse函数将源代码字符串解析成Julia中的表达式对象。expr变量将保存解析后的表达式对象。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"接下来，我们使用Meta.show_sexpr函数来显示抽象语法树的表示。该函数以表达式对象作为参数，并以S表达式的形式打印出抽象语法树的结构。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"运行这段代码，你会看到如下输出：","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"(:block,\n  (:line, 1),\n  (:(=),\n    :x,\n    (:(+), 5, 3)))","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"输出表示了抽象语法树的结构。这是一个由S表达式表示的树状结构，每个节点都是一个元组，第一个元素是节点的类型，后续元素是子节点。在这个例子中，抽象语法树表示为一个(:block, ...)的元组，其中(:line, 1)表示行信息，然后是(:(=), :x, (:(+), 5, 3))表示赋值操作。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"通过解析源代码并生成抽象语法树，我们可以进一步分析和操作代码的结构。这对于编译器、解释器和其他代码分析工具来说是非常有用的。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"我们可以用字符画表示前面的语法树。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"下面是使用字符画表示前面Julia代码生成的抽象语法树的示例：","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"           (:block,\n            /     |     \\\n   (:line, 1)  (:=)    (:+)\n                |     /   \\\n               :x   5     3","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"这个字符画呈现了树状结构，每个节点用括号括起来，并且以箭头形式连接父节点和子节点。在这个示例中，根节点是(:block, ...)，它有三个子节点：(:line, 1)、(:=)和(:+)。子节点之间用空格分隔。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"(:line, 1)是一个表示行信息的节点。(:=)是表示赋值操作的节点，它有两个子节点：:x和(:+, 5, 3)。:x表示变量名，(:+, 5, 3)表示加法操作，它有两个子节点分别表示数值5和数值3。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"通过这种字符画表示，我们可以更清晰地看到抽象语法树的层次结构和节点之间的关系。","category":"page"},{"location":"CSAdv/4-从符号到模型/#来看看bibtex解析bib文件生成文献结构体","page":"从符号到模型","title":"来看看bibtex解析bib文件生成文献结构体","text":"","category":"section"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"当解析BibTeX文件并生成文献结构体时，可以使用Python中的pybtex库。以下是一个示例代码：","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"from pybtex.database import parse_file\n\ndef parse_bibtex(file_path):\n    bib_data = parse_file(file_path)\n    entries = []\n    \n    for key, entry in bib_data.entries.items():\n        # 获取文献类型和标识符\n        entry_type = entry.type\n        entry_key = key\n        \n        # 获取文献字段\n        fields = {}\n        for field, value in entry.fields.items():\n            fields[field] = value\n\n        # 创建文献结构体\n        bib_entry = {\n            'type': entry_type,\n            'key': entry_key,\n            'fields': fields\n        }\n        \n        entries.append(bib_entry)\n    \n    return entries\n\n# 解析BibTeX文件并生成文献结构体\nbib_file = 'example.bib'\nbib_entries = parse_bibtex(bib_file)\n\n# 打印每个文献结构体\nfor entry in bib_entries:\n    print(entry)\n    print('---')","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"在上面的示例中，我们首先导入了pybtex库中的parse_file函数来解析BibTeX文件。然后，定义了一个parse_bibtex函数，它接受BibTeX文件的路径作为参数。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"在parse_bibtex函数中，我们使用parse_file函数解析BibTeX文件，并获取每个文献条目的类型、标识符和字段信息。然后，我们创建一个字典来表示每个文献条目，并将其添加到entries列表中。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"最后，我们返回包含所有文献结构体的entries列表。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"在主程序中，我们指定要解析的BibTeX文件路径，并调用parse_bibtex函数进行解析。然后，我们逐个打印每个文献结构体的内容。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"你可以将上述代码保存到一个Python脚本文件中，并将example.bib替换为你要解析的BibTeX文件的路径。运行该脚本后，它将解析BibTeX文件并打印每个文献结构体的内容。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"bib文件本身是符号，解析之后就是结构体，也就是模型。 在这种情况下，BibTeX文件本身可以被视为符号，因为它是一种文本格式，由特定的字符和语法规则组成。当我们解析BibTeX文件时，我们将其转换为具有结构化数据的模型，即文献结构体。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"BibTeX文件中的每个条目都有特定的字段，如作者、标题、出版物等。解析BibTeX文件后，我们可以将每个条目表示为结构体或字典，其中字段名和字段值成对出现。这个结构体或字典可以被视为模型，因为它们提供了对BibTeX条目的结构化表示和访问方式。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"通过解析BibTeX文件并生成文献结构体，我们可以以更方便的方式访问和操作文献条目的信息。这种转换过程将符号（BibTeX文件）转化为模型（文献结构体），使得我们可以更好地处理和利用其中的数据。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"对于解析BibTeX文件，bibtexparser是一个更常用和方便的Python库，它提供了更灵活和易于使用的功能。以下是使用bibtexparser解析BibTeX文件并生成文献结构体的示例代码：","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"import bibtexparser\n\ndef parse_bibtex(file_path):\n    with open(file_path) as bibtex_file:\n        bib_database = bibtexparser.load(bibtex_file)\n        entries = bib_database.entries\n        return entries\n\n# 解析BibTeX文件并生成文献结构体\nbib_file = 'example.bib'\nbib_entries = parse_bibtex(bib_file)\n\n# 打印每个文献结构体\nfor entry in bib_entries:\n    print(entry)\n    print('---')","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"在上面的示例中，我们导入了bibtexparser库，并定义了一个parse_bibtex函数来解析BibTeX文件。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"在parse_bibtex函数中，我们首先使用open函数打开BibTeX文件，然后使用bibtexparser.load函数加载BibTeX文件并解析为一个BibDatabase对象。我们可以通过entries属性获取文献条目的列表。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"最后，我们将每个文献条目表示为一个字典，并将其存储在entries列表中。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"在主程序中，我们指定要解析的BibTeX文件路径，并调用parse_bibtex函数进行解析。然后，我们逐个打印每个文献结构体的内容。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"通过使用bibtexparser库，我们可以更轻松地解析BibTeX文件并生成文献结构体。这个库提供了许多有用的功能，例如处理不同的文献类型、字段访问等。","category":"page"},{"location":"CSAdv/4-从符号到模型/#反序列化是从符号到模型，序列化是从模型到符号","page":"从符号到模型","title":"反序列化是从符号到模型，序列化是从模型到符号","text":"","category":"section"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"序列化可以被看作是一种将数据从模型形式转换为符号形式的过程。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"在计算机科学中，序列化是指将数据结构或对象转换为可存储或传输的形式，以便在需要时能够恢复成原始的数据结构或对象。这种转换的过程涉及将数据从内存中的对象表示转换为字节流或其他可持久化的形式。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"当我们对数据进行序列化时，我们将符号表示的数据（例如内存中的对象或数据结构）转换为模型表示（例如字节流、JSON、XML等格式），以便在需要时可以进行存储、传输或恢复。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"举个例子，假设我们有一个包含学生信息的对象：","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"class Student:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"我们可以将该对象序列化为字节流形式，如下所示：","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"import pickle\n\nstudent = Student(\"Alice\", 20)\nserialized_data = pickle.dumps(student)","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"在这个例子中，pickle.dumps函数将student对象序列化为字节流形式。通过序列化，我们可以将student对象转换为一种可持久化的模型表示。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"当我们需要时，可以通过反序列化将字节流转换回原始的数据结构或对象。继续上面的示例，我们可以通过以下方式进行反序列化：","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"deserialized_student = pickle.loads(serialized_data)","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"pickle.loads函数将字节流反序列化为原始的Student对象，从而将数据从模型形式转换回符号形式。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"总之，序列化是一种将数据从模型形式转换为符号形式的过程，使得数据能够在不同的环境中进行存储、传输和恢复。它为数据处理和交换提供了一种方便和通用的方法。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"序列化是将数据从模型形式转换为符号形式，而反序列化则是将数据从符号形式转换回模型形式。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"在计算机科学中，序列化是将数据结构或对象转换为一种可以存储或传输的形式，如字节流、JSON、XML等。这种转换的过程将数据从模型形式转换为符号形式，使得数据可以在不同的环境中进行存储、传输和处理。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"而反序列化则是将符号形式的数据转换回原始的数据结构或对象的过程。通过反序列化，我们可以从序列化后的数据中恢复出原始的数据模型，使其可以被进一步处理、操作或使用。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"例如，在前面提到的序列化示例中，我们将student对象序列化为字节流形式。如果我们希望将其反序列化为原始的Student对象，可以使用如下代码：","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"deserialized_student = pickle.loads(serialized_data)","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"在这个例子中，pickle.loads函数将字节流反序列化为原始的Student对象，将数据从符号形式转换回模型形式。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"反序列化是从符号到模型的转换过程，而序列化是从模型到符号的转换过程。","category":"page"},{"location":"CSAdv/4-从符号到模型/#以Julia来一个例子","page":"从符号到模型","title":"以Julia来一个例子","text":"","category":"section"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"当涉及到序列化和反序列化时，Julia提供了多个内置的函数和库来处理数据的转换。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"以下是一个简单的例子，展示了在Julia中如何进行序列化和反序列化，以及符号和模型之间的关系：","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"using Serialization\n\n# 定义一个结构体\nstruct Person\n    name::String\n    age::Int\nend\n\n# 创建一个Person对象\nperson = Person(\"Alice\", 25)\n\n# 序列化对象为字节流\nserialized_data = serialize(person)\n\n# 反序列化字节流为对象\ndeserialized_person = deserialize(Person, serialized_data)\n\n# 打印原始对象和反序列化后的对象\nprintln(\"原始对象: \", person)\nprintln(\"反序列化后的对象: \", deserialized_person)","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"在这个例子中，我们首先定义了一个名为Person的简单结构体，它有两个字段：name和age。然后，我们创建了一个Person对象，命名为person，并将其序列化为字节流，使用serialize函数将person对象序列化。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"序列化后，我们可以将字节流存储到文件、传输到其他计算机或通过其他方式进行处理。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"接下来，我们使用deserialize函数将字节流反序列化为原始的Person对象，将其命名为deserialized_person。通过反序列化，我们从字节流中恢复了原始的数据模型。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"最后，我们打印原始对象和反序列化后的对象，以验证反序列化的正确性。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"这个例子展示了在Julia中序列化和反序列化的过程，将数据从模型形式转换为符号形式（字节流），然后再从符号形式转换回模型形式。这说明了符号和模型之间的关系，序列化是一种从模型到符号的转换，而反序列化是一种从符号到模型的转换。","category":"page"},{"location":"CSAdv/4-从符号到模型/#Parser","page":"从符号到模型","title":"Parser","text":"","category":"section"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"解析器（parser）的主要目的是将符号表示的文本转换为具有结构和含义的模型。在计算机科学中，解析器常用于将符号形式的输入转化为可以进行进一步处理和理解的数据结构。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"解析器在各种应用领域中起着重要作用。在编程语言中，解析器将源代码转换为抽象语法树（AST），以便编译器或解释器能够理解和执行代码。在数据交换和通信中，解析器将文本格式的数据（如XML、JSON、BibTeX等）转换为内部数据结构，以便进行处理和存储。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"解析器的工作通常涉及以下几个步骤：","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"词法分析（Lexical Analysis）：将输入文本划分为词素（tokens），并标记每个词素的类型。词法分析器（Lexer）根据预定义的词法规则识别和提取词素。\n语法分析（Syntax Analysis）：根据语法规则，将词素序列转换为具有层次结构的语法树。语法分析器（Parser）使用语法规则和上下文信息对词素进行组合和解析，构建出语法树。\n语义分析（Semantic Analysis）：在语法树上进行额外的分析和处理，以验证语义正确性，执行类型检查，生成中间表示等。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"通过解析器，我们可以将符号表示的文本转化为有结构和含义的模型，使得我们能够更好地理解和处理输入数据。解析器在编程、数据处理、语言处理等领域都具有广泛的应用。","category":"page"},{"location":"CSAdv/4-从符号到模型/#自己写Parser还是调用Parser","page":"从符号到模型","title":"自己写Parser还是调用Parser","text":"","category":"section"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"在很多情况下，我们并不需要从头开始自己编写解析器，而是可以利用现有的成熟库或工具来完成解析过程。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"编写一个高效且准确的解析器是一项复杂的任务，需要深入了解语法规则、上下文处理和错误处理等方面。因此，为了提高开发效率和代码质量，使用现有的解析器库是一个常见的做法。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"许多编程语言和领域都有专门的解析器库可供使用，例如在Python中有bibtexparser库用于解析BibTeX文件，libsbml库用于解析SBML格式的生物模型。这些库经过开发和测试，提供了成熟的解析器实现，能够准确地解析特定格式的文本。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"使用现有的解析器库有以下好处：","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"减少开发时间和工作量：借助现有的解析器库，你无需从零开始编写解析器，而是可以直接使用库中的解析器功能，节省了大量的时间和工作量。\n可靠性和准确性：成熟的解析器库经过多次测试和优化，通常具有高度准确性和稳定性，可以处理各种复杂的语法规则和边界情况。\n避免常见的错误和陷阱：解析器开发涉及许多细节和技术，容易出现各种错误和陷阱。使用现有的解析器库可以避免这些问题，因为库已经解决了许多常见的问题。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"当然，有些情况下，如果你有特定的需求或特殊的语法规则，可能需要自己编写定制的解析器。但是，在大多数情况下，使用现有的解析器库是更快速、更可靠的选择，可以极大地简化解析任务。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"当涉及到解析器时，通常有两个选择：","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"自己编写解析器：这意味着你将从头开始编写解析器代码，处理输入文本并将其转换为模型表示。自己编写解析器需要深入了解语法规则、上下文处理、错误处理等方面，并进行相应的开发和测试。\n使用现有的解析器库：有许多成熟的解析器库可用，例如libsbml（用于解析SBML格式的生物模型）、bibtexparser（用于解析BibTeX文件）等。这些库提供了已经开发和测试的解析器实现，可以准确地解析特定格式的文本。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"使用现有的解析器库具有以下优势：","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"节省时间和工作量：通过使用现有的解析器库，你无需从头编写解析器，可以直接利用库中的功能，从而节省大量的时间和工作量。\n可靠性和准确性：成熟的解析器库经过多次测试和优化，通常具有高度准确性和稳定性，可以处理复杂的语法规则和边界情况。\n避免常见错误和陷阱：解析器开发涉及许多细节和技术，容易出现各种错误和陷阱。使用现有的解析器库可以避免这些问题，因为库已经解决了许多常见的问题。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"当然，如果你有特定的需求或特殊的语法规则，可能需要自己编写定制的解析器。但在大多数情况下，使用现有的解析器库是更快速、更可靠的选择，可以极大地简化解析任务。","category":"page"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"总而言之，根据具体情况，你可以选择自己编写解析器或使用现有的解析器库来实现从符号到模型的解析过程。","category":"page"},{"location":"Optimization/92-一些可以看一看的优化相关工具/#一些值得看看的工具","page":"一些值得看看的工具","title":"一些值得看看的工具","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/#过程抽象","page":"过程抽象","title":"过程抽象","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/#核心概念简要解释","page":"过程抽象","title":"核心概念简要解释","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"下面是我对每个主题的简要解释：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"过程抽象：过程抽象是指将一系列操作封装为一个单元，以便能够重复使用和组合。这有助于简化复杂的问题，提高代码的可读性和可维护性。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"数据抽象：数据抽象是指通过定义数据类型的接口，将数据的表示和实现细节与用户分离。这使得程序员可以将注意力集中在数据的高级概念上，而无需关注具体的实现。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"递归：递归是指一个函数在其定义中调用自身的过程。递归在解决需要重复执行相似操作的问题时非常有用，它可以将复杂问题分解为更小的子问题。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"从符号到模型（解析器）：这涉及将程序的源代码转换为计算机能够理解和执行的内部表示。解析器负责解析源代码，并构建出对应的抽象语法树（AST）或其他数据结构，以便进一步分析和执行。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"代码生成：代码生成是指将抽象语法树或其他中间表示转换为实际可执行的计算机指令。这是将高级代码转换为低级机器代码或字节码的过程。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"库和领域特定语言（DSL）：库是指预先编写好的可重用代码模块，用于解决特定的问题。DSL是一种专门为特定领域或特定问题而设计的编程语言，它提供了高度的表达能力和领域特定的抽象。","category":"page"},{"location":"CSAdv/1-过程抽象/#过程抽象-2","page":"过程抽象","title":"过程抽象","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"过程抽象就是函数。此函数与数学上的函数又有区别。他不是数学上的定义，而是一连串的操作实现一个功能，就算是求取数学的函数值（比如平方根），也是一系列的操作实现。这就是函数。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"没错，过程抽象在编程中通常通过函数来实现。函数是一种封装了一系列操作的代码块，用于实现特定的功能或计算。与数学中的函数不同，编程中的函数可以执行多个操作，可以接受输入参数并返回结果。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"函数在程序中起到模块化和重用的作用。通过将一组操作打包到一个函数中，我们可以将复杂的问题分解为更小的子问题，并通过函数的调用来实现这些操作。这种模块化的方式可以提高代码的可读性、可维护性和重用性。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"函数的定义通常包括函数名、参数列表和函数体。函数名是用来唯一标识函数的名称，参数列表指定函数接受的输入，函数体包含了实现函数功能的代码。当函数被调用时，传入的参数将被用于执行函数体中的操作，并根据需要返回一个值作为结果。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"例如，下面是一个简单的函数示例，用于计算一个数的平方：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"def square(x):\n    result = x * x\n    return result","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个例子中，函数名是square，它接受一个参数x。函数体中的操作是将x乘以自身，并将结果存储在result变量中，最后通过return语句返回结果。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"通过函数的抽象，我们可以将这个功能独立出来，随时在程序的其他地方调用它，而无需重复编写相同的代码。这样，我们可以更加灵活地组织和扩展程序。","category":"page"},{"location":"CSAdv/1-过程抽象/#函数可以有名字也可以没有名字","page":"过程抽象","title":"函数可以有名字也可以没有名字","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在编程中，函数是通过名称来标识和调用的，因此每个函数都必须有一个名称。函数的名称是用于唯一标识函数的，它是函数的身份标识符，使我们能够引用和调用特定的函数。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"然而，你可能提到的没有名字的函数可能指的是匿名函数（Anonymous Function），也被称为 lambda 函数。匿名函数是一种没有显式名称的函数，通常用于简单的函数操作，无需在程序中定义具名函数。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"匿名函数通常以 lambda 关键字开始，后面跟着参数列表和函数体，如下所示的 Python 示例：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"square = lambda x: x * x","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个例子中，lambda x: x * x 就是一个匿名函数，它接受一个参数 x，并返回 x 的平方。我们将这个匿名函数赋值给了变量 square，这样我们就可以通过 square 来调用这个匿名函数。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"匿名函数在需要简单的函数操作时非常有用，尤其是在需要传递函数作为参数或在一些函数式编程的场景中。虽然匿名函数没有显式的名称，但它们仍然是具有特定功能的函数对象。","category":"page"},{"location":"CSAdv/1-过程抽象/#匿名函数不同的语言的例子","page":"过程抽象","title":"匿名函数不同的语言的例子","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"Python:","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"# 使用 lambda 表达式计算两个数的和\nadd = lambda x, y: x + y\nresult = add(2, 3)  # 结果为 5\n\n# 使用 lambda 表达式筛选列表中的偶数\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\neven_numbers = filter(lambda x: x % 2 == 0, numbers)  # [2, 4, 6, 8, 10]","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"JavaScript:","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"// 使用箭头函数计算两个数的乘积\nconst multiply = (x, y) => x * y;\nconst result = multiply(3, 4);  // 结果为 12\n\n// 使用箭头函数筛选数组中的正数\nconst numbers = [-1, 2, -3, 4, -5, 6];\nconst positiveNumbers = numbers.filter(x => x > 0);  // [2, 4, 6]","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"Java:","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"import java.util.function.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 使用匿名函数计算两个数的差值\n        BinaryOperator<Integer> subtract = (x, y) -> x - y;\n        int result = subtract.apply(7, 3);  // 结果为 4\n\n        // 使用匿名函数判断字符串长度是否大于 5\n        Predicate<String> isLengthGreaterThanFive = s -> s.length() > 5;\n        boolean isGreaterThanFive = isLengthGreaterThanFive.test(\"Hello\");  // 结果为 false\n    }\n}","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"Julia:","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"# 使用匿名函数计算两个数的平方和\nsum_of_squares = (x, y) -> x^2 + y^2\nresult = sum_of_squares(3, 4)  # 结果为 25\n\n# 使用匿名函数筛选数组中的奇数\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nodd_numbers = filter(x -> x % 2 != 0, numbers)  # [1, 3, 5, 7, 9]","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在上述示例中，我们使用匿名函数通过->符号来定义。匿名函数可以接受参数，并在箭头后面指定函数体的操作。在第一个示例中，我们定义了一个匿名函数sum_of_squares,它接受两个参数x和y，并返回它们的平方和。在第二个示例中，我们使用匿名函数过滤出数组中的奇数。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"当然，你可以在 Julia 中使用map函数结合匿名函数进行映射操作。map函数可以将一个函数应用于一个可迭代对象（例如数组或范围），并返回一个新的经过函数处理后的可迭代对象。 Julia 的匿名函数语法相对简洁，使用->可以很方便地创建匿名函数来实现特定的功能。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"下面是在 Julia 中使用map函数和匿名函数的示例：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"# 使用匿名函数将数组中的元素平方\nnumbers = [1, 2, 3, 4, 5]\nsquared_numbers = map(x -> x^2, numbers)  # [1, 4, 9, 16, 25]\n\n# 使用匿名函数将字符串列表转换为大写\nstrings = [\"apple\", \"banana\", \"cherry\"]\nuppercase_strings = map(s -> uppercase(s), strings)  # [\"APPLE\", \"BANANA\", \"CHERRY\"]","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在上述示例中，我们使用匿名函数来定义要应用于每个元素的操作。然后，我们使用map函数将匿名函数应用于输入可迭代对象numbers和strings，并生成新的经过处理的可迭代对象squared_numbers和 uppercase_strings。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"map函数与匿名函数的结合是一种非常强大的工具，它使得对可迭代对象进行转换、映射和处理变得更加便捷和灵活。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"这些示例展示了在 Python、JavaScript、Java、julia 中使用匿名函数的用法。请注意，匿名函数在不同的编程语言中可能有不同的语法和约定，但核心思想是相似的：创建一个没有显式名称的函数以进行特定的操作。","category":"page"},{"location":"CSAdv/1-过程抽象/#函数可以给个名字，就是为了抓住它，需要它时再召唤出来","page":"过程抽象","title":"函数可以给个名字，就是为了抓住它，需要它时再召唤出来","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"是的，给函数赋予一个具名的名称可以使我们能够更方便地引用和调用它。在编程中，我们可以将函数定义为具名函数，并将其存储在变量中，以便在需要时进行调用。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"以下是在 Julia 中定义具名函数并调用的示例：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"# 定义具名函数\nfunction add(x, y)\n    return x + y\nend\n\n# 调用具名函数\nresult = add(3, 4)  # 结果为 7","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个例子中，我们使用function关键字定义了一个具名函数add，它接受两个参数x和y，并返回它们的和。然后，我们可以通过使用函数名add和传递参数来调用这个函数，并将结果存储在变量result中。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"使用具名函数可以提高代码的可读性和可维护性，因为它们可以直观地表示函数的用途和功能。而且，给函数命名后，我们可以在代码的任何位置调用这个函数，从而实现了代码的重用和模块化。","category":"page"},{"location":"CSAdv/1-过程抽象/#函数的参数就是一种约定","page":"过程抽象","title":"函数的参数就是一种约定","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"函数的参数可以被视为函数和其调用者之间的约定。通过定义函数时指定参数，我们可以规定函数需要接受的输入，并且在调用函数时传递相应的参数值。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"参数约定可以包括以下几个方面：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"1.参数数量：函数定义时可以指定需要多少个参数，调用函数时必须提供相应数量的参数。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"2.参数类型：函数定义时可以指定参数的类型，这样可以确保函数在接收参数时符合类型的要求。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"3.参数顺序：函数定义时参数的顺序很重要，调用函数时需要按照相同的顺序传递参数。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"通过参数约定，函数定义者可以定义函数的接口，并确保函数在使用时能够正确处理传入的参数。同时，函数的调用者也可以依据参数约定来使用函数，确保传入的参数与函数的期望相符。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"值得注意的是，不同的编程语言对于参数约定的方式可能有所不同。有些语言要求明确声明参数类型，有些语言允许参数的数量可变，还有一些语言支持默认参数值等特性。根据具体的编程语言和需求，我们可以选择适合的参数约定方式。","category":"page"},{"location":"CSAdv/1-过程抽象/#函数可以有返回值，也可以没有","page":"过程抽象","title":"函数可以有返回值，也可以没有","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"函数可以有返回值，也可以没有返回值。返回值是函数执行完成后向调用者返回的结果。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"如果函数有返回值，它可以通过使用关键字（如return）来指定返回的值。函数在遇到return语句时会立即停止执行，并将指定的值返回给调用者。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"以下是示例代码，展示了函数如何有返回值和没有返回值的情况：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"# 函数有返回值\ndef add(x, y):\n    result = x + y\n    return result\n\nsum = add(3, 4)  # 调用 add() 函数并将返回值赋给变量 sum\n\n# 函数没有返回值\ndef greet(name):\n    print(\"Hello, \" + name)\n\ngreet(\"Alice\")  # 调用 greet() 函数，没有返回值","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在上述示例中，add()函数有返回值，它将两个参数相加并返回结果。调用add()函数后，将返回的结果赋给变量sum。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"而greet()函数没有返回值，它仅仅打印一条问候信息到控制台。调用greet()函数后，并没有将返回值赋给任何变量。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"根据函数的需求，我们可以选择使用返回值或者不使用返回值。返回值可以使函数的结果传递给调用者，进而进行后续的操作或者处理。而没有返回值的函数则主要用于执行一些操作而不需要返回结果的场景。","category":"page"},{"location":"CSAdv/1-过程抽象/#函数可能改变参数的内容，也可能不改变","page":"过程抽象","title":"函数可能改变参数的内容，也可能不改变","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"函数可以具有副作用，这意味着它们可能会改变传递给它们的参数的内容，也可能不会改变。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在某些情况下，函数被设计为只接受参数并返回结果，而不会对传递的参数进行修改。这种类型的函数称为无副作用函数（Pure Functions），因为它们不会对外部环境产生任何影响，只根据输入产生输出。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"以下是一个无副作用函数的示例（使用Python）：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"def multiply(x, y):\n    return x * y","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个例子中，multiply()函数接受两个参数x和y，并返回它们的乘积。这个函数不会修改传递给它的参数的值，而是通过计算得到一个新的结果并将其返回。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"另一方面，有些函数被设计为具有副作用，它们可能会修改传递给它们的参数的内容，或者对外部环境产生其他的影响。这样的函数可能会更改传入的参数的值，或者与其他系统进行交互，例如修改文件、发送网络请求等。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"以下是一个具有副作用的函数的示例（使用Python）：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"def append_element(lst, element):\n    lst.append(element)","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个例子中，append_element()函数接受一个列表lst和一个元素element，并将element添加到 lst中。这个函数会直接修改传递给它的参数lst的内容，而不是返回一个新的结果。 根据函数的设计和用途，我们可以选择使用具有副作用的函数或无副作用的函数。在编写代码时，我们应该清楚函数是否具有副作用，并在使用函数时对其进行适当的处理。","category":"page"},{"location":"CSAdv/1-过程抽象/#函数可以被调用，可以被嵌套的调用","page":"过程抽象","title":"函数可以被调用，可以被嵌套的调用","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"函数可以被调用，也可以被嵌套调用。函数调用是指在程序中显式地使用函数名和参数来执行函数中定义的操作。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"函数的嵌套调用是指在一个函数内部调用另一个函数。这种嵌套调用的方式允许我们将程序的功能划分为更小的可重用部分，并通过函数之间的调用来实现复杂的任务。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"以下是一个示例，展示了函数的嵌套调用：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"def multiply(x, y):\n    return x * y\n\ndef add_and_multiply(a, b, c):\n    sum = a + b\n    result = multiply(sum, c)\n    return result\n\nproduct = add_and_multiply(2, 3, 4)\nprint(product)  # 输出：20","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个例子中，我们定义了两个函数multiply()和add_and_multiply()。函数multiply()接受两个参数并返回它们的乘积。函数add_and_multiply()接受三个参数，并在内部调用了multiply()函数来执行乘法操作。最后，我们通过调用add_and_multiply()函数，并将返回的结果赋给变量product，然后打印出product的值。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"通过函数的嵌套调用，我们可以在程序中构建出层次化的结构，将复杂的任务分解为更小的子任务，从而提高代码的可读性、可维护性和重用性。","category":"page"},{"location":"CSAdv/1-过程抽象/#一定意义上，编程就是写函数","page":"过程抽象","title":"一定意义上，编程就是写函数","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"可以说编程的核心就是编写函数。函数是编程中的基本构建块，它们封装了特定的操作或功能，并通过函数调用来执行这些操作。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"编程是通过将问题分解为更小的子问题，并为每个子问题编写函数来解决的过程。函数的编写可以使代码更加模块化和可维护，同时也促进了代码的重用性。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"通过编写函数，我们可以将复杂的任务分解为更小、更易管理的部分。这样不仅可以提高代码的可读性和可维护性，还可以使程序的开发和调试过程更加高效。函数还可以提供接口，使不同的模块之间可以相互调用和协作。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"编写函数还有助于实现抽象和封装的概念。通过将相关操作封装在函数中，我们可以隐藏内部实现细节，使代码更具可理解性，并提供一个简单的接口供其他开发人员使用。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"因此，可以说编程是函数的组织和组合，通过编写函数来解决问题和构建应用程序。函数的设计和编写能力对于成为一个优秀的程序员是非常重要的。","category":"page"},{"location":"CSAdv/1-过程抽象/#加减乘除本身就是函数，运算符就是函数","page":"过程抽象","title":"加减乘除本身就是函数，运算符就是函数","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在某种程度上，你可以将加减乘除等运算符看作是函数的一种形式。在编程语言中，这些运算符通常被称为内置函数或操作符（built-in functions/operators），它们提供了执行常见数学运算的功能。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"尽管这些运算符在语法上看起来不同于常规的函数调用，但它们背后的概念与函数相似。运算符接受输入（操作数），执行特定的操作，并返回结果。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"以下是示例，展示了加减乘除运算符的使用：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"# 加法运算符\nsum = 3 + 4  # 结果为 7\n\n# 减法运算符\ndifference = 10 - 5  # 结果为 5\n\n# 乘法运算符\nproduct = 2 * 3  # 结果为 6\n\n# 除法运算符\nquotient = 10 / 2  # 结果为 5.0","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个例子中，我们使用了加法运算符+、减法运算符-、乘法运算符*和除法运算符/来执行相应的数学运算。这些运算符接受操作数并返回运算结果。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"虽然运算符的语法和函数调用的语法有所不同，但它们本质上执行了类似的功能：接受输入并返回输出。这种函数调用和运算符的结合为我们提供了一种方便和直观的方式来进行数学运算和表达。","category":"page"},{"location":"CSAdv/1-过程抽象/#Julia中可以f,-再f(2,-3)调用","page":"过程抽象","title":"Julia中可以f=+, 再f(2, 3)调用","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"Julia 是一种支持函数作为一等公民的语言，允许您将函数分配给变量并以变量的形式进行调用。这种功能称为高阶函数（Higher-Order Functions）。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在 Julia 中，您可以使用=符号将函数赋值给变量，然后通过该变量进行函数调用。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"以下是示例，展示了在 Julia 中将函数赋值给变量并进行调用的方式：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"# 定义一个函数\nfunction add(x, y)\n    return x + y\nend\n\n# 将函数赋值给变量\nf = add\n\n# 使用变量进行函数调用\nresult = f(2, 3)  # 结果为 5","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个例子中，我们定义了一个名add的函数，它接受两个参数并返回它们的和。然后，我们将函数add赋值给变量f，使得f成为一个可调用的函数。最后，我们通过变量f进行函数调用，并将返回的结果赋给变量 result。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在 Julia 中，您可以将任何函数分配给变量，并通过变量进行函数调用。这种灵活性使您能够更好地组织和管理代码，将函数作为参数传递给其他函数，或者将函数存储在数据结构中进行后续使用。","category":"page"},{"location":"CSAdv/1-过程抽象/#Python则是定义类的**add**就相当于定义运算","page":"过程抽象","title":"Python则是定义类的add就相当于定义+运算","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在 Python 中，通过定义类的特殊方法 add()，可以为该类实现加法运算符 + 的行为。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"特殊方法（或称为魔术方法）是在类中定义的具有特殊命名和行为的方法，用于模拟类的一些内置操作。其中 __add__()方法用于定义对象之间的加法操作。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"以下是一个示例，展示了在 Python 中如何通过定义类的__add__()方法来实现加法运算：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"class Number:\n    def __init__(self, value):\n        self.value = value\n    \n    def __add__(self, other):\n        if isinstance(other, Number):\n            return Number(self.value + other.value)\n        else:\n            raise TypeError(\"Unsupported operand type.\")\n    \n    def __repr__(self):\n        return f\"Number({self.value})\"\n\n# 创建 Number 对象\nnum1 = Number(3)\nnum2 = Number(4)\n\n# 加法运算\nresult = num1 + num2\nprint(result)  # 输出：Number(7)","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个例子中，我们定义了一个名为Number的类，并在类中实现了__add__()方法。该方法接受另一个对象作为参数，并在方法内部执行加法运算。如果传递的参数是Number类型的对象，则返回一个新的Number对象，其值为两个对象值的和。否则，会抛出一个类型错误异常。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"通过定义__add__()方法，我们可以使用加法运算符+对Number对象进行加法操作。在示例中，我们创建了两个Number对象num1和num2，然后执行加法运算num1 + num2，得到了一个新的Number对象 result，其值为7。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"这种方式允许我们自定义类的加法行为，并使其与内置的加法运算符一致。类似地，还可以通过定义其他特殊方法来模拟其他运算符的行为。这种能力使得 Python 的类可以表现得像内置类型一样，并具有更强的灵活性。","category":"page"},{"location":"CSAdv/1-过程抽象/#主函数不一定是必须的。但是程序需要有个入口","page":"过程抽象","title":"主函数不一定是必须的。但是程序需要有个入口","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"甚至，主函数不一定是必须的。但是程序需要有个入口。像Julia语言，顺着jl文件走就是入口。像c也不则main是入口，像go则是main模块的main函数是入口。不同的编程语言有不同的程序入口约定。 在许多编程语言中，例如 C、C++、Java，程序的入口点是由一个特定的函数（通常是 main 函数）来定义的。这个函数被称为主函数（main function），它是程序执行的起点，定义了程序开始执行的逻辑。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"然而，并非所有的编程语言都要求必须有显式的主函数。在一些语言中，入口点可以是文件的执行顺序或模块的默认行为。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在 Julia 中，执行 Julia 脚本通常是从顶级的.jl文件开始的。当您运行一个Julia脚本时，该文件中的代码会按照顺序执行，没有显式的主函数要求。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在 Go 语言中，程序的入口是main包中的main函数。当您构建和运行一个 Go 程序时，系统会自动调用 main 包中的 main 函数作为程序的入口点。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"总而言之，不同的编程语言对于程序入口点的定义可能有所不同。有些语言要求显式地定义主函数，而有些语言则根据约定或默认行为来确定入口点。理解特定编程语言的入口规则对于编写正确的程序是很重要的。","category":"page"},{"location":"CSAdv/1-过程抽象/#同一个函数名，接受不同的参数类型，是一种进步，越来越对人友好。实际上是多重分发或者多态等设计实现的。","page":"过程抽象","title":"同一个函数名，接受不同的参数类型，是一种进步，越来越对人友好。实际上是多重分发或者多态等设计实现的。","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"函数重载（Function Overloading）是一种编程语言特性，允许在同一个函数名下定义多个具有不同参数类型或参数个数的函数。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"函数重载提供了一种方便的方式来编写多态的代码，使得函数能够根据传入的参数类型或参数个数进行不同的操作或返回不同的结果。这提高了代码的可读性和可维护性，同时也增强了代码的灵活性。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"以下是一个示例，展示了函数重载的概念：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"def add(x, y):\n    return x + y\n\ndef add(a, b, c):\n    return a + b + c\n\nresult1 = add(2, 3)  # 调用第一个 add 函数，结果为 5\nresult2 = add(1, 2, 3)  # 调用第二个 add 函数，结果为 6","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个例子中，我们定义了两个名为add的函数，它们具有不同的参数个数。当我们调用add函数时，根据传入的参数个数，解释器会自动选择匹配的函数进行调用。这样，我们可以使用相同的函数名进行不同类型或个数的参数操作，从而使代码更加灵活和易于理解。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"需要注意的是，函数重载在某些编程语言中是支持的，例如 C++、Java，但并不是所有的编程语言都直接支持函数重载。例如，Python 不直接支持函数重载，因为它是一种动态类型语言，函数的参数类型在运行时才确定。然而，通过使用可变参数、默认参数和函数内部的类型检查等技术，可以在 Python 中模拟一些函数重载的行为。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"函数重载是面向对象编程中多态性的一种实现方式，它允许不同类型的对象对同一个函数名进行不同的操作。这种灵活性使得代码更具可扩展性和可维护性，并提供了更好的代码组织和抽象能力。","category":"page"},{"location":"CSAdv/1-过程抽象/#Julia例子","page":"过程抽象","title":"Julia例子","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在 Julia 中，函数重载是通过多分派（Multiple Dispatch）的机制实现的。多分派允许函数根据参数的类型和个数来选择不同的方法进行调用。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"以下是一个示例，展示了在 Julia 中如何实现函数重载：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"# 定义一个名为 add 的函数\nfunction add(x::Int, y::Int)\n    println(\"Adding two integers:\", x + y)\nend\n\n# 重载 add 函数，处理不同类型的参数\nfunction add(x::Float64, y::Float64)\n    println(\"Adding two floats:\", x + y)\nend\n\n# 调用 add 函数\nadd(2, 3)  # 调用第一个 add 函数，输出：Adding two integers: 5\nadd(1.5, 2.5)  # 调用第二个 add 函数，输出：Adding two floats: 4.0","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个例子中，我们定义了一个名为add的函数，并使用不同的参数类型进行了两次重载。第一个add函数接受两个整数参数，并输出它们的和。第二个add函数接受两个浮点数参数，并输出它们的和。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"当我们调用add函数时，Julia 的多分派机制会根据传入的参数类型来选择最匹配的函数进行调用。在示例中，我们分别传入整数和浮点数参数来调用add函数，系统会根据参数类型选择对应的函数进行执行，并输出相应的结果。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"通过多分派的机制，我们可以方便地实现函数重载，并根据不同的参数类型提供不同的行为。这种能力使得 Julia 语言在处理不同类型数据的操作时非常灵活和高效。","category":"page"},{"location":"CSAdv/1-过程抽象/#函数的集合构成库","page":"过程抽象","title":"函数的集合构成库","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"库有一些函数是对外服务的，有一些函数是内部支持的。对外提供服务的就需要有办法描述，c语言中就是头文件 函数的集合可以构成一个库（Library），库可以包含一组相关的函数和数据结构，提供特定的功能和服务。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在许多编程语言中，为了能够正确地使用库中的函数和数据结构，通常需要提供一些描述库接口的文档或声明。在 C 语言中，常用的方式是使用头文件（Header File）来描述库的接口。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"头文件是一个包含函数原型（Function Prototype）、宏定义（Macro Definition）、类型定义（Type Definition）等信息的文本文件。它通常用于声明库中公共函数的名称、参数类型和返回类型，以便其他程序在编译和链接时能够正确地调用和使用库中的函数。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"以下是一个简化的示例，展示了一个库的头文件和库的使用方式：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"example.h（头文件）：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"#ifndef EXAMPLE_H\n#define EXAMPLE_H\n\n// 函数原型声明\nint add(int a, int b);\nvoid greet(const char* name);\n\n#endif","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"example.c（库的实现）：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"#include \"example.h\"\n\nint add(int a, int b) {\n    return a + b;\n}\n\nvoid greet(const char* name) {\n    printf(\"Hello, %s!\\n\", name);\n}","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"main.c（使用库的程序）：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"#include <stdio.h>\n#include \"example.h\"\n\nint main() {\n    int result = add(2, 3);\n    printf(\"Result: %d\\n\", result);\n\n    greet(\"Alice\");\n    return 0;\n}","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个例子中，example.h是库的头文件，其中包含了函数add()和greet()的原型声明。在example.c中实现了这两个函数。然后，在main.c中通过包含头文件example.h，以及使用add()和greet()函数来使用库的功能。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"头文件提供了对外部程序的接口定义，使得其他程序能够了解库中可用的函数和数据结构，并正确地与库进行交互。通过合适的头文件，库的使用者可以了解库中公开的函数、参数类型、返回类型等信息，从而能够正确地调用库中的函数和使用其提供的功能。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"需要注意的是，不同编程语言和开发环境可能有不同的方式来描述库的接口和提供对外服务的函数。头文件只是一种常见的方式，在其他语言中可能采用其他形式的接口定义，例如接口文件、模块文档等。","category":"page"},{"location":"CSAdv/1-过程抽象/#库，有静态链接库，有动态链接库","page":"过程抽象","title":"库，有静态链接库，有动态链接库","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"库可以分为静态链接库（Static Library）和动态链接库（Dynamic Library），它们在编译和链接时的行为和使用方式有所不同。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"静态链接库（Static Library）是在编译时将库的代码和数据直接复制到可执行程序中的一种库形式。当程序被编译链接时，静态链接库的代码会被复制到可执行文件中，成为可执行文件的一部分。这意味着程序在运行时不再需要依赖外部的库文件，因为所有需要的代码已经被包含在可执行文件中。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"优点：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"·简单易用，不需要额外的配置和依赖。 ·执行速度相对较快，因为所有代码都已经被复制到可执行文件中。 缺点：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"·静态链接库增加了可执行文件的大小。 ·如果多个可执行文件使用同一个静态链接库，会造成代码的冗余。 动态链接库（Dynamic Library），也称为共享库（Shared Library），是在程序运行时由操作系统动态加载的库。动态链接库的代码和数据被单独编译和链接为一个独立的文件，程序在运行时通过动态链接器将需要的库加载到内存中，并与程序进行链接。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"优点：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"·减小了可执行文件的大小，多个程序可以共享同一个动态链接库。 ·更新库时，不需要重新编译可执行文件，只需替换动态链接库文件即可。 缺点：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"·需要在运行时依赖相应的动态链接库文件。 ·由于动态加载和链接的过程，相对于静态链接库，会有一定的运行时性能损耗。 使用静态链接库还是动态链接库取决于具体的需求和应用场景。一般来说，静态链接库适合小型应用或者需要独立部署的应用，而动态链接库适合大型应用或者需要共享库的情况。选择哪种类型的库需要综合考虑可执行文件大小、运行时依赖、部署和维护的方便性等因素。","category":"page"},{"location":"CSAdv/1-过程抽象/#还有些语言，库就是个包，或者一个模块","page":"过程抽象","title":"还有些语言，库就是个包，或者一个模块","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在一些编程语言中，库可以被称为包（Package）或模块（Module），具有类似的功能和概念。这些术语可以根据不同的语言和上下文有不同的含义，但它们通常指代一组相关的函数、类、数据结构和其他代码组织形式的集合。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"包（Package）： 在许多现代编程语言中，包是一种用于组织和管理代码的方式。一个包可以包含多个模块、库、工具和其他资源文件。包的目的是提供一种逻辑上的组织结构，将相关的代码组织在一起，以便于复用、分发和维护。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"例如，Python 中的包是由一个或多个模块组成的目录，包含一个特殊的·init.py·文件作为包的入口点。通过使用包，可以将相关的模块组织在一起，提供命名空间管理，以及方便地导入和使用其中的函数和类。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"模块（Module）： 模块是指将相关的代码组织在一起，形成一个独立的单元。一个模块可以包含函数、类、变量和其他代码，可以通过导入（import）的方式在其他地方进行使用。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"许多编程语言都提供了模块的概念，例如 Python、JavaScript、Ruby 等。模块提供了一种代码封装和组织的机制，可以将代码分割成可管理的单元，并提供命名空间隔离，避免命名冲突。通过使用模块，可以将代码逻辑划分为模块化的部分，提高代码的可读性、可维护性和可重用性。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"需要注意的是，不同编程语言对于包和模块的具体实现和使用方式可能有所不同。有些语言可能将包和模块作为语言的一部分提供，而有些语言可能依赖第三方库或工具来支持包和模块的管理和使用。无论是包、模块还是库，它们都是为了方便代码组织、复用和管理而存在的重要概念。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在 Julia 中，包（Package）和模块（Module）是重要的概念，用于组织和管理代码。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"包（Package）： 在 Julia 中，包是一组相关功能的集合，可以包含模块、函数、数据类型、宏等。包提供了一种逻辑上的组织结构，用于封装和管理相关代码，并提供命名空间隔离和模块化的特性。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"Julia 中的包管理器（Package Manager）可以用来创建、安装、更新和管理包。用户可以通过创建自己的包或使用已经存在的包来扩展 Julia 的功能，并共享给其他用户使用。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"模块（Module）： 在 Julia 中，模块是用于组织代码的单元，它提供了一种命名空间隔离和代码封装的机制。通过定义模块，可以将相关的函数、数据类型和其他代码组织在一起，并提供对外接口。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"一个模块可以包含多个子模块、函数、常量、类型定义等。模块可以被导入到其他模块或脚本中使用，通过使用模块名和点操作符可以访问模块中的内容。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"以下是一个示例，展示了在 Julia 中如何定义和使用模块：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"# 定义一个名为 MyModule 的模块\nmodule MyModule\n\n    # 定义模块中的函数\n    function greet(name)\n        println(\"Hello, $name!\")\n    end\n\n    # 定义模块中的常量\n    const PI = 3.14159\n\nend\n\n# 使用模块中的函数和常量\nMyModule.greet(\"Alice\")  # 输出：Hello, Alice!\nprintln(MyModule.PI)  # 输出：3.14159","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个例子中，我们定义了一个名为MyModule的模块，其中包含了一个函数greet和一个常量PI。在使用模块中的函数和常量时，需要使用模块名和点操作符来访问。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"通过使用包和模块，Julia 提供了一种有效的代码组织和管理方式，可以使代码更可读、可维护，并提供了命名空间隔离和模块化的特性，方便在大型项目中进行开发和协作。","category":"page"},{"location":"CSAdv/1-过程抽象/#命名空间实际上是为了避免名字冲突","page":"过程抽象","title":"命名空间实际上是为了避免名字冲突","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"命名空间实际上是为了避免名字冲突，就像物理学不同领域可能有相同的符号代表不同的含义。命名空间的一个重要作用是避免命名冲突。在软件开发中，当不同的代码块（如模块、库、函数等）具有相同的名称时，可能会导致命名冲突，使代码的语义变得模糊或产生错误。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"命名空间通过提供一种隔离机制，使得在不同的命名空间中可以使用相同的名称来表示不同的实体，而不会产生冲突。每个命名空间都有自己的上下文环境，其中定义的名称只在该命名空间内可见。这样，即使在不同的命名空间中使用相同的名称，它们也不会相互干扰，因为它们存在于不同的命名空间中。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"类比物理学中的符号重用情况，不同的物理学领域可能会使用相同的符号来表示不同的物理量或概念。为了避免混淆，物理学家会在特定的上下文中明确定义符号的含义，确保在不同的物理学领域中使用相同的符号时不会发生歧义。这种方式类似于命名空间，通过上下文环境隔离不同的符号含义，避免混淆和冲突。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"因此，命名空间在编程中起到了类似的作用，通过提供隔离的上下文环境，确保不同代码块中的名称不会相互干扰，从而避免命名冲突，提高代码的可读性、可维护性和可重用性。","category":"page"},{"location":"CSAdv/1-过程抽象/#有些语言是通过模块实现命名空间的概念，如Julia","page":"过程抽象","title":"有些语言是通过模块实现命名空间的概念，如Julia","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"许多编程语言使用模块（Module）来实现命名空间的概念，包括 Julia。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在 Julia 中，模块是一种用于组织代码的机制，它提供了命名空间的隔离，可以将函数、变量、常量、类型等封装在模块中，避免名称冲突，并提供代码的模块化和可重用性。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"模块在 Julia 中使用module和end关键字进行定义，可以包含函数、类型定义、常量、导入其他模块等。模块可以被其他模块导入，并通过模块名和点操作符来访问其中的内容。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"下面是一个示例，展示了在 Julia 中如何定义和使用模块来实现命名空间：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"module MyModule\n\n    export my_function\n\n    # 定义模块中的函数\n    function my_function()\n        println(\"This is my function.\")\n    end\n\n    # 定义模块中的常量\n    const MY_CONSTANT = 42\n\nend\n\n# 使用模块中的函数和常量\nMyModule.my_function()  # 输出：This is my function.\nprintln(MyModule.MY_CONSTANT)  # 输出：42","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个例子中，我们定义了一个名为MyModule的模块，其中包含了一个函数my_function和一个常量 MY_CONSTANT。通过使用模块名和点操作符，我们可以在外部访问和使用模块中定义的函数和常量。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"通过模块的使用，我们可以将代码逻辑划分为模块化的部分，避免了命名冲突，提高了代码的可读性和可维护性。同时，模块也提供了一种封装和隐藏内部实现的机制，使得我们可以将一些实现细节隐藏在模块内部，只暴露需要对外使用的接口，增加了代码的安全性和灵活性。","category":"page"},{"location":"CSAdv/1-过程抽象/#函数能被跨语言调用","page":"过程抽象","title":"函数能被跨语言调用","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"函数可以通过跨语言的方式进行调用。当你使用多种编程语言开发不同的组件或模块时，有时需要在这些不同的语言之间进行函数调用，以实现功能的交互和整合。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"实现跨语言函数调用的方式取决于具体的编程语言和技术栈。以下是几种常见的跨语言函数调用方式：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"1.外部函数接口（Foreign Function Interface, FFI）：许多编程语言提供了外部函数接口，允许从一种语言调用另一种语言的函数。这通常涉及到使用特定的语法和工具，将函数的参数和返回值进行适配和传递。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"2.跨语言函数调用库：有些编程语言提供了专门的库或工具，用于简化跨语言函数调用的过程。这些库提供了一套标准的接口和机制，允许在不同的语言之间进行函数调用。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"3.远程过程调用（Remote Procedure Call, RPC）：RPC 是一种通过网络进行远程函数调用的方式。它允许不同语言的程序在网络上相互调用函数，通过序列化和反序列化的方式传递参数和结果。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"4.使用中间层或桥接器：有时可以使用中间层或桥接器来连接不同的编程语言。这可以是使用共享库、进程间通信、消息队列或其他机制，通过在中间层处理函数调用的逻辑，实现跨语言调用。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"需要注意的是，跨语言函数调用可能会涉及到数据类型、内存管理、参数传递方式等方面的兼容性问题。因此，在进行跨语言函数调用时，需要仔细考虑和处理这些问题，确保正确传递参数和处理返回值，以及保证程序的稳定性和正确性。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"总而言之，通过适当的技术手段和工具支持，函数可以在不同的编程语言之间进行跨语言调用，实现功能的整合和交互。这为跨语言开发和组件复用提供了灵活性和便利性。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"除了我之前提到的外部函数接口（FFI），RPC（Remote Procedure Call，远程过程调用）、REST（Representational State Transfer，表述性状态转移）和 Socket（套接字）也是常用的跨语言函数调用的方式。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"1.RPC（Remote Procedure Call）：RPC 是一种通过网络进行远程函数调用的机制。它允许不同语言的程序在网络上相互调用函数，通过序列化和反序列化的方式传递参数和结果。RPC 可以使用不同的协议和技术实现，如 gRPC、Thrift、XML-RPC 等。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"2.REST（Representational State Transfer）：REST 是一种基于 HTTP 协议的网络通信架构风格，它定义了一组规范和约束，用于构建分布式系统中的 Web 服务。RESTful API 提供了一组基于 URL 和 HTTP 方法的接口，通过 HTTP 请求和响应传递数据。不同的编程语言可以通过 HTTP 请求调用 RESTful API 来实现函数调用。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"3.Socket（套接字）：Socket 是一种通信机制，允许不同计算机或进程之间通过网络进行通信。它提供了一种底层的网络编程接口，通过在不同的主机之间建立连接，可以实现跨语言的函数调用。Socket 可以使用 TCP 或 UDP 协议进行通信，具体实现方式因编程语言和网络库而异。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"这些跨语言函数调用的方式在不同的场景和需求下具有不同的优势和适用性。选择合适的方式需要考虑诸多因素，包括性能要求、开发复杂度、协议支持、安全性等。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"无论使用哪种方式，跨语言函数调用都需要确保函数的参数和返回值的序列化和反序列化，协议的匹配性，以及处理错误和异常情况等。这些都是在设计和实现跨语言函数调用时需要注意的关键点。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"还有直接的，dll函数调用 直接调用动态链接库（DLL）中的函数也是一种常见的跨语言函数调用方式。这种方式适用于具有动态链接库支持的编程语言，如 C、C++、C# 等。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"动态链接库是编译好的可重用代码库，它包含一组函数和符号，可以在运行时动态加载和链接到应用程序中。通过调用动态链接库中的函数，可以实现跨语言函数调用。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在使用动态链接库进行函数调用时，通常需要以下步骤：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"1.动态链接库的加载：首先需要加载动态链接库，即将动态链接库加载到内存中，使得其中的函数和符号可用。这通常涉及到使用特定的语言或操作系统提供的函数或机制来加载动态链接库，如 LoadLibrary（Windows）、dlopen（Linux）等。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"2.函数签名和参数传递：在调用动态链接库中的函数之前，需要了解函数的签名和参数传递方式。这包括函数名称、返回类型、参数类型、参数个数等信息。确保在函数调用时传递正确的参数，以及正确处理返回值。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"3.函数调用：通过调用动态链接库中的函数，可以实现跨语言的函数调用。这通常涉及到使用特定的语言提供的机制来调用外部函数，如函数指针、DllImport（C#）、ctypes（Python）等。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"4.资源释放：在完成对动态链接库中函数的调用后，需要确保正确释放相关资源，如关闭动态链接库句柄等。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"需要注意的是，直接调用动态链接库中的函数需要对底层语言的函数调用、内存管理等有一定的了解，并且跨语言的函数调用可能涉及到类型转换、数据传递等方面的兼容性问题。因此，在进行跨语言函数调用时，建议仔细阅读相关文档和资料，并确保正确处理函数调用过程中的各种细节和问题。","category":"page"},{"location":"CSAdv/1-过程抽象/#一定意义上，执行某个程序也相当于一个函数调用。比如ls命令。在操作系统中执行某个程序实际上可以看作是一个函数调用的过程。","page":"过程抽象","title":"一定意义上，执行某个程序也相当于一个函数调用。比如ls命令。在操作系统中执行某个程序实际上可以看作是一个函数调用的过程。","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"当你在终端或命令行中输入一个命令，比如ls，操作系统会在搜索路径中查找对应的可执行文件，然后加载并执行该可执行文件。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"这个过程可以被视为操作系统内部的函数调用。操作系统会为每个可执行文件分配一个入口点，通常是一个函数，例如在 C 语言中是main函数。操作系统会调用这个入口函数，将命令行参数传递给它，并开始执行程序的逻辑。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"因此，你可以将执行某个程序看作是调用了这个程序中的入口函数，将命令行参数传递给它。这个程序的逻辑会在入口函数中执行，然后根据需要进行一系列的操作，例如输出结果、访问文件系统、执行其他函数等。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"总而言之，执行某个程序可以被看作是一个函数调用的过程，操作系统调用该程序的入口函数，并传递命令行参数，从而开始执行程序的逻辑。这样的函数调用是操作系统和编程语言运行时环境提供的基本机制，使得我们可以通过命令行或终端与计算机进行交互，并执行特定的任务和操作。 在操作系统中执行某个程序实际上可以看作是一个函数调用的过程。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"当你在终端或命令行中输入一个命令，比如 ls，操作系统会在搜索路径中查找对应的可执行文件，然后加载并执行该可执行文件。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"这个过程可以被视为操作系统内部的函数调用。操作系统会为每个可执行文件分配一个入口点，通常是一个函数，例如在 C 语言中是 main 函数。操作系统会调用这个入口函数，将命令行参数传递给它，并开始执行程序的逻辑。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"因此，你可以将执行某个程序看作是调用了这个程序中的入口函数，将命令行参数传递给它。这个程序的逻辑会在入口函数中执行，然后根据需要进行一系列的操作，例如输出结果、访问文件系统、执行其他函数等。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"总而言之，执行某个程序可以被看作是一个函数调用的过程，操作系统调用该程序的入口函数，并传递命令行参数，从而开始执行程序的逻辑。这样的函数调用是操作系统和编程语言运行时环境提供的基本机制，使得我们可以通过命令行或终端与计算机进行交互，并执行特定的任务和操作。","category":"page"},{"location":"CSAdv/1-过程抽象/#此时，函数的参数是通过命令行参数给出。","page":"过程抽象","title":"此时，函数的参数是通过命令行参数给出。","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"当执行某个程序时，可以将命令行参数作为函数调用的参数传递给程序的入口函数。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"命令行参数是在执行程序时通过命令行或终端提供的附加信息，用于向程序传递参数值。这些参数可以用来指定程序的行为、控制程序的运行方式，或者提供必要的输入数据。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在函数调用的概念中，命令行参数就相当于函数的参数。当执行程序时，操作系统会将命令行参数传递给程序的入口函数，以供程序在运行时使用。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在许多编程语言中，可以通过特定的方式获取和处理命令行参数。例如，在C语言中，可以使用main函数的参数来获取命令行参数，即int main(int argc, char *argv[])，其中argc表示参数的数量，argv是一个指针数组，每个元素指向一个命令行参数的字符串。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"类似地，在其他编程语言中也有相应的机制或库可以用于获取命令行参数，如sys.argv（Python）、args（Go）、os.Args（Go）等。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"通过命令行参数，我们可以将外部的信息传递给程序，从而在执行过程中根据不同的参数值进行不同的处理。这使得程序具有更大的灵活性和可配置性，可以根据需要进行定制和适应不同的场景。","category":"page"},{"location":"CSAdv/1-过程抽象/#以ls为例，示范一下","page":"过程抽象","title":"以ls为例，示范一下","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"当我们在命令行中执行 ls 命令时，它会列出当前目录下的文件和子目录。在这种情况下，ls 命令不需要接受额外的命令行参数。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"下面是一个简单的示例，展示如何在 Python 中获取命令行参数并模拟实现类似 ls 命令的功能：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"import os\nimport sys\n\ndef list_files(directory):\n    files = os.listdir(directory)\n    for file in files:\n        print(file)\n\n# 获取命令行参数\nargs = sys.argv\n\n# 确保至少有一个命令行参数（第一个参数是脚本本身的名称）\nif len(args) >= 2:\n    # 第二个参数是目录路径\n    directory = args[1]\n    list_files(directory)\nelse:\n    # 没有提供目录路径时，默认列出当前目录下的文件\n    list_files(os.getcwd())","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在上述示例中，我们使用os.listdir()函数获取指定目录下的文件和子目录的列表，然后使用循环逐个打印出来。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"要运行这个示例，可以保存为ls.py文件，并在命令行中执行以下命令：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"python ls.py [目录路径]","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"其中 [目录路径]是可选的，表示要列出文件的目录路径。如果不提供目录路径，默认会列出当前目录下的文件。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"请注意，这只是一个简化的示例，用于演示如何获取命令行参数并执行相应的操作。在实际的ls命令中，会有更多的选项和参数用于控制输出的格式和内容。","category":"page"},{"location":"CSAdv/1-过程抽象/#只需要执行系统本身的ls命令，给出不同的命令行参数例子即可","page":"过程抽象","title":"只需要执行系统本身的ls命令，给出不同的命令行参数例子即可","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"如果你想直接执行系统本身的ls命令，并传递不同的命令行参数，可以使用适当的方法来调用系统命令。这里给出几个示例：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在 Python 中使用subprocess模块执行系统命令：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"import subprocess\n\n# 执行 ls 命令，并列出当前目录下的所有文件和子目录\nsubprocess.call(['ls'])\n\n# 执行 ls 命令，并列出指定目录下的所有文件和子目录\nsubprocess.call(['ls', '/path/to/directory'])\n\n# 执行 ls 命令，显示文件的详细信息（长格式）\nsubprocess.call(['ls', '-l'])","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在命令行或终端中直接执行系统命令：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"# 列出当前目录下的所有文件和子目录\nls\n\n# 列出指定目录下的所有文件和子目录\nls /path/to/directory\n\n# 显示文件的详细信息长格式）\nls -l","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"上述示例中，通过subprocess.call()函数调用系统命令，并传递不同的命令行参数。在命令行或终端中直接执行命令时，可以直接输入命令和参数。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"请注意，在执行系统命令时要谨慎，确保输入的命令和参数安全可靠。避免直接从用户输入中构造命令，以免受到命令注入等安全风险。如果涉及到处理用户输入，建议使用适当的安全措施和参数验证来确保系统的安全性。","category":"page"},{"location":"CSAdv/1-过程抽象/#程序执行时的环境变量有可能也会影响函数的行为。环境变量就是当前环境的键值对表","page":"过程抽象","title":"程序执行时的环境变量有可能也会影响函数的行为。环境变量就是当前环境的键值对表","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"环境变量是当前执行环境中的键值对表，可以影响程序的行为和配置。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在操作系统中，每个进程都有自己的环境变量。环境变量包含了一些配置信息、路径设置、系统参数等，可以被程序在运行时读取和使用。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"编程语言通常提供了访问和操作环境变量的接口或函数，以便程序可以获取和修改环境变量的值。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"下面是一个示例，展示如何在 Python 中访问环境变量：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"import os\n\n# 获取单个环境变量的值\nvalue = os.environ.get('ENV_VARIABLE_NAME')\n\n# 获取所有环境变量的键值对\nenv_vars = os.environ\n\n# 遍历所有环境变量\nfor key, value in env_vars.items():\n    print(f'{key}: {value}')","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在上述示例中，我们使用 os.environ 来访问当前进程的所有环境变量。可以使用os.environ.get()方法来获取指定环境变量的值，传入环境变量的名称作为参数。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"程序可以根据环境变量的值来改变其行为，例如根据不同的环境变量配置读取不同的配置文件、设置不同的路径、启用或禁用特定的功能等。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"通过使用环境变量，可以提供一种灵活的方式来配置和定制程序的行为，而无需修改程序的源代码。这使得程序可以在不同的环境中以不同的方式运行，增强了程序的可配置性和适应性。","category":"page"},{"location":"CSAdv/1-过程抽象/#执行一个函数，就好比打游戏进入一扇门，保留现场就好比压栈，带入的技能集就好比环境","page":"过程抽象","title":"执行一个函数，就好比打游戏进入一扇门，保留现场就好比压栈，带入的技能集就好比环境","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"这是一个有趣的比喻！将执行一个函数比作打游戏进入一扇门，保留现场比作压栈，而带入的技能集比作环境，可以帮助我们更好地理解函数的执行过程。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"当我们执行一个函数时，可以将其类比为进入游戏中的一扇门。函数提供了一种进入特定逻辑或执行特定任务的方式，就像一扇门将我们引入一个新的场景或体验。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"保留现场则类似于压栈的操作，它表示在函数执行期间，程序会将当前执行的上下文和状态信息保存起来，以便在函数执行完毕后能够回到之前的执行点。这样做的好处是，可以确保函数执行后程序能够继续执行，并恢复到之前的状态。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"带入的技能集就好比环境，它可以影响函数的行为和结果。就像在游戏中，不同的技能集可以影响我们的能力和表现，环境也会对函数的执行产生影响。这可以是一些全局变量、配置参数、环境变量或其他上下文信息，它们提供了一种定制函数行为的方式。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"综合起来，这个比喻形象地描述了函数的执行过程。函数就像一扇门，通过执行函数可以进入不同的逻辑和任务；保留现场就像压栈，确保函数执行完毕后能够回到之前的执行点；而带入的技能集则像是环境，可以影响函数的行为和结果。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"这样的比喻有助于我们以一种形象的方式理解函数的概念和执行过程，并将其与我们在日常生活中的经验和场景联系起来。","category":"page"},{"location":"CSAdv/1-过程抽象/#运行时的环境，和入口，就构成一个闭包。就好比一下子穿越了。函数返回就穿越回来了。","page":"过程抽象","title":"运行时的环境，和入口，就构成一个闭包。就好比一下子穿越了。函数返回就穿越回来了。","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"闭包的概念与运行时的环境和函数的返回相关联。闭包是指函数对象以及它在定义时所处的环境的组合。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"当一个函数在定义时捕获了其周围的变量，并在之后的执行过程中保持对这些变量的引用，那么该函数就形成了一个闭包。闭包允许函数访问其定义时所在的作用域中的变量，即使在定义时的作用域已经不存在了。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"通过闭包，函数可以保持对定义时的环境的引用，这意味着函数可以捕获并操作其周围的状态和数据。这对于实现某些设计模式和编程技术非常有用，例如函数工厂、柯里化、延迟求值等。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"入口函数可以被看作是一个闭包的入口点，它提供了执行代码的起始位置。当程序开始运行时，入口函数会创建一个运行时的环境，并在该环境中执行代码。这个环境包含了各种变量、函数和其他资源，为代码的执行提供了必要的上下文。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在函数返回时，函数所处的执行环境被销毁，但如果该函数是一个闭包，它仍然保持对定义时的环境的引用。这样，当函数再次被调用时，它可以继续访问和操作定义时环境中的变量和状态，就好像穿越过去，回到了函数定义时的环境。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"闭包提供了一种强大的编程机制，使得函数能够捕获和操作其周围的环境，以及在不同的上下文中执行。这种能力可以增加代码的灵活性和可复用性，并为实现一些高级的编程模式和技术提供支持。","category":"page"},{"location":"CSAdv/1-过程抽象/#由函数可以构成服务。","page":"过程抽象","title":"由函数可以构成服务。","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"过去不让写死循环，现在daemon程序就是死循环。窗口界面程序也是死循环，基于事件做出响应。当然过去不让写死循环也是有原因的。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"函数可以构成服务，而服务通常需要以某种形式持续运行。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在过去的编程规范中，通常不鼓励使用死循环（infinite loop），因为它可能导致程序陷入无限循环中，无法正常退出或终止。死循环可能会造成资源浪费、性能下降或程序崩溃等问题。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"然而，在一些特定的应用场景下，死循环是必要的。例如，守护进程（daemon）是一种持续运行的后台程序，它通常以死循环的形式执行，以提供一些特定的服务或功能。守护进程会持续监听事件、处理请求或执行任务，并在必要时做出响应。它们通常在系统启动时启动，并在系统关闭前一直运行。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"类似地，窗口界面程序通常也会包含一个死循环，以等待用户的输入或事件发生，并在接收到输入或事件时做出相应的响应。这种基于事件的循环称为事件循环（event loop），它负责接收和分发事件，并调用相应的函数或方法来处理事件。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"现代的编程语言和框架通常提供了对事件循环的支持，使得编写基于事件的程序更加方便和灵活。事件循环可以帮助我们编写响应式的程序，实现用户交互、异步处理和并发任务等功能。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"虽然死循环在某些场景下是必要的，但在编写这样的程序时，我们仍然需要注意控制循环的条件、避免无限循环和资源泄漏，以确保程序的正确性和可靠性。","category":"page"},{"location":"CSAdv/1-过程抽象/#可以认为make也是一个函数，它的输入参数是makefile","page":"过程抽象","title":"可以认为make也是一个函数，它的输入参数是makefile","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"可以将make视为一个函数，而Makefile是作为输入参数传递给这个函数的。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"make是一个常用的构建工具，用于自动化构建软件项目。它根据项目中定义的规则（通常在一个名为Makefile 的文件中）来决定哪些文件需要重新构建，从而提高了构建过程的效率。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"Makefile文件中包含了一系列规则（rules），每个规则定义了一个目标（target）和相关的依赖项（dependencies）。规则描述了如何根据依赖关系来生成目标文件的过程。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"当运行make命令时，make工具会读取Makefile文件，并根据规则执行相应的动作。它会检查每个目标文件和对应的依赖项的时间戳，如果目标文件不存在或其依赖项的时间戳较新，那么make会执行规则中定义的命令来生成目标文件。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个过程中，我们可以将make视为一个函数，它接受Makefile作为输入参数，并根据规则来执行相应的操作。这个函数的目标是根据依赖关系生成所需的目标文件。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"通过定义规则和依赖关系，make提供了一种灵活的方式来管理和构建复杂的软件项目。它可以自动化构建过程，并根据文件的更新情况来确定需要重新构建的部分，从而提高了开发效率和代码管理的便利性。","category":"page"},{"location":"CSAdv/1-过程抽象/#cmake也是函数，它的输入是cmakelist.txt","page":"过程抽象","title":"cmake也是函数，它的输入是cmakelist.txt","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"CMake也可以被看作是一个函数，而CMakeLists.txt文件则是作为输入参数传递给这个函数的。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"CMake是一个跨平台的构建工具，用于自动生成用于不同构建系统（如Makefile、Visual Studio等）的构建脚本。它使用一种被称为 CMakeLists.txt 的脚本语言来描述项目的构建过程和依赖关系。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"CMakeLists.txt文件中包含了一系列的命令和指令，用于指导CMake如何生成构建系统所需的构建文件。这些命令可以用来定义目标、设置编译选项、指定依赖项、配置安装规则等。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"当运行CMake命令时，它会读取CMakeLists.txt文件，并根据文件中的指令和命令来生成相应的构建文件。生成的构建文件可以用于在目标平台上构建项目。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个过程中，我们可以将CMake视为一个函数，它接受CMakeLists.txt文件作为输入参数，并根据其中的指令和命令来生成构建文件。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"通过使用CMake，我们可以将项目的构建过程与具体的构建系统解耦，从而实现跨平台的构建。它提供了一种统一的方式来描述项目的构建需求，并自动生成适应不同平台和构建系统的构建文件。这使得项目的构建和移植变得更加简单和可维护。","category":"page"},{"location":"CSAdv/1-过程抽象/#过程抽象补充","page":"过程抽象","title":"过程抽象补充","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在讲解过程抽象时，已经提到了函数、参数、返回值、函数调用和函数嵌套等重要概念。这些都是过程抽象的核心内容。还可以考虑涵盖以下几个方面来完善：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"作用域：讲解函数内部的变量作用域以及变量的可见性。解释全局作用域和局部作用域的概念，并说明在函数调用过程中如何管理变量的作用域。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"递归：介绍递归作为一种重要的过程抽象方式。解释递归的概念、递归函数的结构和执行过程，并举例说明递归在问题求解中的应用。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"高阶函数：探讨高阶函数作为一种过程抽象的进阶概念。解释高阶函数的定义和特点，以及如何使用高阶函数来操作和组合其他函数。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"匿名函数：介绍匿名函数作为一种特殊的函数定义方式。讲解匿名函数的语法和用法，并说明它们在简洁性和灵活性方面的优势。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"函数式编程：简要介绍函数式编程范式，其中函数被视为一等公民，强调纯函数、不可变性和无副作用的编程风格。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"错误处理：讲解在函数调用中如何处理异常和错误情况，包括返回特定值、抛出异常和使用错误码等方式。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"部分应用和柯里化：探讨将函数部分应用于参数，以及柯里化作为一种将多参数函数转化为一系列单参数函数的技术。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"过程抽象的优势：总结过程抽象的优势，包括代码重用性、模块化和抽象屏障等方面的好处。","category":"page"},{"location":"Optimization/3-能源系统工程中的优化问题/#能源系统工程中有哪些优化问题","page":"能源系统工程中有哪些优化问题","title":"能源系统工程中有哪些优化问题","text":"","category":"section"},{"location":"Optimization/3-能源系统工程中的优化问题/#能源系统工程中典型优化问题","page":"能源系统工程中有哪些优化问题","title":"能源系统工程中典型优化问题","text":"","category":"section"},{"location":"Optimization/3-能源系统工程中的优化问题/","page":"能源系统工程中有哪些优化问题","title":"能源系统工程中有哪些优化问题","text":"当涉及到能源系统工程时，有几个典型的例子如下：","category":"page"},{"location":"Optimization/3-能源系统工程中的优化问题/","page":"能源系统工程中有哪些优化问题","title":"能源系统工程中有哪些优化问题","text":"发电系统规划： 发电系统规划是指在特定地区或国家范围内，根据电力需求和资源可用性，确定最佳的发电技术和配置。这涉及到选择合适的发电设备（如燃煤、天然气、风能、太阳能等）、容量规模、电网互联等因素。发电系统规划旨在最大化能源利用效率、降低环境影响、确保电力供应可靠性和经济性。\n微电网设计： 微电网是指一个相对较小的能源系统，可以独立运行或与传统电网连接。微电网通常由多种能源资源（如太阳能、风能、电池储能等）和能源转换设备组成。微电网设计涉及到确定适当的能源资源组合、储能容量、运行策略和互联性，以实现可靠的供电和能源自给自足。\n能源系统优化： 能源系统优化旨在通过最优化调度和管理能源系统中的各个组件，以最大化能源利用效率、降低能源成本或减少碳排放等目标。这可能涉及到能源供应与需求的平衡、能源存储和转换设备的优化、能源网络调度等。能源系统优化可以应用于各种场景，如建筑能源管理、工业过程优化、电动车充电规划等。\n可再生能源集成： 可再生能源集成是将不同的可再生能源技术（如太阳能、风能、水能等）整合到一个系统中，以满足能源需求。这涉及到确定适当的技术组合、能源存储、电力输配等因素，以实现可再生能源的高效利用和平稳供应。","category":"page"},{"location":"Optimization/3-能源系统工程中的优化问题/","page":"能源系统工程中有哪些优化问题","title":"能源系统工程中有哪些优化问题","text":"这些是能源系统工程中的一些典型例子，每个例子都涉及到能源资源的选择、设备配置、优化目标的定义等方面。在实践中，针对具体的能源系统工程问题，需要结合具体的需求、资源可用性和技术限制，进行系统建模、优化和评估。","category":"page"},{"location":"Optimization/3-能源系统工程中的优化问题/#决策变量","page":"能源系统工程中有哪些优化问题","title":"决策变量","text":"","category":"section"},{"location":"Optimization/3-能源系统工程中的优化问题/","page":"能源系统工程中有哪些优化问题","title":"能源系统工程中有哪些优化问题","text":"在能源系统工程中，决策变量可以涉及多个方面，以下是一些常见的决策变量：","category":"page"},{"location":"Optimization/3-能源系统工程中的优化问题/","page":"能源系统工程中有哪些优化问题","title":"能源系统工程中有哪些优化问题","text":"能源资源选择和配置： 决策变量可以包括选择和配置不同类型的能源资源，如太阳能光伏电池板的安装容量、风力涡轮机的数量、燃煤发电机组的容量等。这些决策变量影响能源系统的供给结构和资源利用。\n设备容量和规模： 决策变量可以涉及各种设备的容量和规模，如发电机组的容量、储能设备的存储容量、输电线路的传输能力等。这些决策变量影响能源系统的产能和输配能力。\n运营策略和调度： 决策变量可以涉及能源系统的运营策略和调度决策，如发电机组的启停策略、储能设备的充放电策略、电力市场交易策略等。这些决策变量影响能源系统的运行方式和资源调度。\n储能和能量存储： 决策变量可以涉及能源系统中储能设备的容量、充放电速率、储能策略等。这些决策变量影响能源系统的能量存储和调度能力。\n能源供需平衡： 决策变量可以涉及能源供需平衡的调节决策，如能源进口和出口策略、能源需求管理策略等。这些决策变量影响能源系统的供需平衡和稳定性。","category":"page"},{"location":"Optimization/3-能源系统工程中的优化问题/","page":"能源系统工程中有哪些优化问题","title":"能源系统工程中有哪些优化问题","text":"这些决策变量涉及能源系统的不同方面，从能源资源选择到运营策略和供需平衡等，都对能源系统的性能和效益产生影响。通过合理地选择和优化这些决策变量，能够实现能源系统的高效、可靠和可持续运行。","category":"page"},{"location":"Optimization/3-能源系统工程中的优化问题/#约束","page":"能源系统工程中有哪些优化问题","title":"约束","text":"","category":"section"},{"location":"Optimization/3-能源系统工程中的优化问题/","page":"能源系统工程中有哪些优化问题","title":"能源系统工程中有哪些优化问题","text":"约束在能源系统工程中起着重要的作用，限制了系统的可行性和可操作性。以下是一些常见的约束类型：","category":"page"},{"location":"Optimization/3-能源系统工程中的优化问题/","page":"能源系统工程中有哪些优化问题","title":"能源系统工程中有哪些优化问题","text":"资源约束： 资源约束涉及到能源系统所需资源的可用性和限制。例如，可再生能源资源的可利用程度受到日照、风速等天气条件的限制；化石燃料资源受到供应量和价格的影响。资源约束需要在系统设计和运营中考虑，以确保能源供应的可持续性和稳定性。\n供能系统容量约束： 供能系统容量约束是指能源系统中各个组件的容量限制。例如，发电厂的最大发电容量、储能设备的储存容量、输电线路的传输能力等。这些约束需要考虑设备的技术特性、安全性和经济性等因素，以确保能源系统的可靠性和稳定性。\n运行约束： 运行约束涉及到能源系统在运行过程中的限制条件。例如，发电机的最小稳定负荷要求、储能设备的充放电速率限制、输电线路的功率平衡等。这些约束用于确保能源系统在运行中满足特定的要求，如稳定性、可靠性和安全性。\n环境约束： 环境约束涉及到能源系统对环境的影响。例如，温室气体排放的限制、污染物排放标准的遵守等。这些约束旨在保护环境和生态系统，并促进可持续发展。\n经济约束： 经济约束涉及到能源系统的成本和经济效益。例如，能源价格、设备投资成本、运维成本等。这些约束需要考虑能源系统的经济可行性和盈利能力。","category":"page"},{"location":"Optimization/3-能源系统工程中的优化问题/","page":"能源系统工程中有哪些优化问题","title":"能源系统工程中有哪些优化问题","text":"这些约束在能源系统规划、运营和管理中起着重要的作用。合理地处理约束条件可以确保能源系统的可行性、可靠性和经济性，以实现系统的可持续发展和最优性。","category":"page"},{"location":"Optimization/3-能源系统工程中的优化问题/#优化目标","page":"能源系统工程中有哪些优化问题","title":"优化目标","text":"","category":"section"},{"location":"Optimization/3-能源系统工程中的优化问题/","page":"能源系统工程中有哪些优化问题","title":"能源系统工程中有哪些优化问题","text":"在能源系统工程中，经济性目标、技术经济性目标和环境目标是三个最典型的优化目标。","category":"page"},{"location":"Optimization/3-能源系统工程中的优化问题/","page":"能源系统工程中有哪些优化问题","title":"能源系统工程中有哪些优化问题","text":"经济性目标： 经济性目标旨在最大化能源系统的经济效益。这包括降低能源成本、最大化利润或投资回报率等。在发电系统规划、能源供应链优化和能源市场设计等问题中，经济性目标是最常见和重要的优化目标之一。通过优化资源配置、能源供需平衡和市场机制等方式，以经济性为导向来实现经济效益的最大化。\n技术经济性目标： 技术经济性目标是在能源系统工程中结合技术可行性和经济性，以实现可行和经济的解决方案。这包括在选择能源技术、设备容量和工程规模时考虑成本效益、资源利用效率、系统可靠性等方面的优化。技术经济性目标的关注点是将技术可行性与经济效益相结合，找到在技术和经济约束下最优的解决方案。\n环境目标： 环境目标旨在减少能源系统对环境的负面影响，包括减少温室气体排放、降低空气污染、保护生态系统等。这涉及到优化能源系统的环境性能，例如通过增加可再生能源比例、推动能源效率改进、采用清洁能源技术等方式来减少碳足迹和环境污染。环境目标在应对气候变化和可持续发展方面具有重要意义。","category":"page"},{"location":"Optimization/3-能源系统工程中的优化问题/","page":"能源系统工程中有哪些优化问题","title":"能源系统工程中有哪些优化问题","text":"在实际能源系统工程中，这些目标通常是综合考虑的，因为它们相互关联并且存在着权衡。优化算法和决策支持工具可以帮助分析人员在不同的目标之间找到平衡点，以制定出符合实际需求的最佳解决方案。","category":"page"},{"location":"JuliaIntro/5-julia的环境/#julia的环境","page":"julia的环境","title":"julia的环境","text":"","category":"section"},{"location":"JuliaIntro/5-julia的环境/#julia的环境简介","page":"julia的环境","title":"julia的环境简介","text":"","category":"section"},{"location":"JuliaIntro/5-julia的环境/","page":"julia的环境","title":"julia的环境","text":"julia提供了一种类似于Python虚拟环境的机制，称为\"环境\"（Environment）。环境允许您在不同的项目或场景中创建独立的Julia环境，以便管理不同版本的包和依赖关系。以下是关于Julia环境的介绍：","category":"page"},{"location":"JuliaIntro/5-julia的环境/","page":"julia的环境","title":"julia的环境","text":"环境的创建： 您可以使用Pkg模块中的activate命令来创建一个新的环境。例如，要创建一个名为\"myenv\"的环境，可以执行以下命令：\nusing Pkg\nPkg.activate(\"myenv\")\n这将在当前工作目录下创建一个新的\"myenv\"环境，并将Julia的包管理器指向该环境。\n环境的使用： 一旦您激活了特定的环境，Julia将在该环境中安装和管理包。您可以使用Pkg模块中的各种命令来安装、更新和移除包，就像在全局环境中一样。Julia将在当前环境中记录和管理您的包依赖关系，确保在该环境中使用一致的包版本。\n环境的切换： 您可以随时切换活动环境以在不同的环境之间切换。使用activate命令，您可以激活已创建的环境。例如，要切换回全局环境，可以执行以下命令：\nusing Pkg\nPkg.activate()\n这将切换回全局环境，使您可以在全局范围内管理和安装包。\n环境的导出和导入： 您可以将环境的依赖关系导出到一个文件中，以便在其他地方导入和重现相同的环境。使用Pkg模块中的instantiate命令，可以根据导出的文件创建和还原环境。例如，要从名为\"environment.toml\"的文件创建环境，可以执行以下命令：\nusing Pkg\nPkg.instantiate(\"environment.toml\")\n这将根据导出的文件还原依赖关系，并创建相应的环境。","category":"page"},{"location":"JuliaIntro/5-julia的环境/","page":"julia的环境","title":"julia的环境","text":"Julia的环境机制使您能够轻松地创建、管理和共享独立的Julia环境，以满足不同项目或场景的需求。","category":"page"},{"location":"JuliaIntro/5-julia的环境/","page":"julia的环境","title":"julia的环境","text":"希望这次的回答对您有帮助。如果您还有其他问题，请随时提问！","category":"page"},{"location":"Frameworks/OptControl/#OptControl.jl设计理念","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"tip: Tip\nContents：OptControl：最优控制问题的解释器Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"note: Note\nOptControl地址。arXiv文章引用","category":"page"},{"location":"Frameworks/OptControl/#摘要","page":"OptControl.jl设计理念","title":"摘要","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"最优控制问题的本质是一个优化问题。OptControl.jl(OptControl)基于Julia语言，实现了最优控制的符号化建模过程，并生成相应的基于Julia生态的最优控制问题的数值优化求解代码。OptControl没有定义数据类型(struct)，而是通过处理字符生成解决方案脚本，并在内部解析并运行脚本。OptControl也提供保存脚本文件到本地的接口。同时，OptControl支持组件化建模，这让构建复杂系统的最优控制问题变得简单。OptControl的依赖包完全来自于Julia生态。","category":"page"},{"location":"Frameworks/OptControl/#Motivation","page":"OptControl.jl设计理念","title":"1 Motivation","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"最优控制问题的本质是一个优化问题，更准确的说是一个泛函求极值问题。从实现的角度，最优控制的解析解只有在特定的几种情况下才能求出，例如线性系统。而实际问题中往往需要面对非线性系统或者一些复杂的系统，这些问题的解析解一般而言难以求得。因此，能算出结果的数值解则是一个利器。虽然数值解在结果上会有一些偏差，但有偏差的结果也能带给人们一定理解问题的灵感。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"最优控制问题的数值解法一般而言可以转化为数值优化问题。数值优化问题可以使用JuMP.jl来求解。使用JuMP.jl求解一个最优控制问题，可以分为5步：","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"抽象实际问题\n获得状态方程模型\n构建数值优化模型\n生成JuMP模型\n求解","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"事实上，JuMP.jl完成了第4步，第5步的内容由具体的求解器完成。但JuMP.jl在完成第4步的基础上，提供了到第5步的接口。因此也可以认为，JuMP.jl包揽了第4步和第5步的工作。那么整个问题需要留给用户解决的，还有前3步。它们的关系由下图所示。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"(Image: 图 1)  ","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"事实上，第一步包含了从实际问题到数学表达的抽象过程，这一过程只有高级的人脑才能完成。那么，第2步和第3步能否实现自动化呢？这正是OptControl所希望完成的内容。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"OptControl的重点在于自动化，即如何自动构建最优问题，如何自动构建JuMP优化模型以及调用求解器自动求解。如何求解一个最优问题，如何构建符号化的系统等类型的问题，OptControl都不涉及。OptControl关心的是，整合已有的资源（Julia生态中的各种软件包），尽可能地自动化完成上述5个步骤。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"所以可以视OptControl是一个解释器，实现状态空间模型到最优控制问题的转化。它有三个特点：","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"接受Symbolics.jl或ModelingToolkit.jl构建的基于符号系统的状态空间模型\n自动生成以JuMP模型表达的最优化问题求解脚本，并自动运行\n提供保存脚本文件的接口，供用户自由修改","category":"page"},{"location":"Frameworks/OptControl/#OptControl框架","page":"OptControl.jl设计理念","title":"2 OptControl框架","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"OptControl的能力是逐步提高的。","category":"page"},{"location":"Frameworks/OptControl/#.1-构建优化模型","page":"OptControl.jl设计理念","title":"2.1 构建优化模型","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"首先完成的是第3步到第5步的解决方案。该解决方案的函数是","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"generateJuMPcodes——处理线性系统\ngenerateNLJuMPcodes——处理非线性系统","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"generateJuMPcodes与generateNLJuMPcodes接受以符号形式表达的状态方程。符号表达通过Symbolics.jl构建。Symbolics.jl是一个拥有高性能，并能够以用户语言进行拓展的符号代数系统。用符号表达的状态方程能够转变成Julia函数，通过该函数对问题进行离散化处理，将离散后的模型中的状态作为JuMP系统的优化变量，构建JuMP优化模型进行求解。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"(Image: 图 3)  ","category":"page"},{"location":"Frameworks/OptControl/#.2-获得状态方程模型","page":"OptControl.jl设计理念","title":"2.2 获得状态方程模型","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"更进一步，我们希望自动化实现第2步到第5步。第2步到第5步的解决方案需要使用ModelingToolkit.jl的非因果组件建模系统。该解决方案的函数是","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"generateMTKcodes——处理ODESystem系统","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"generateMTKcodes接受ODESystem系统。ODESystem中描述系统的微分方程事实上就是最优控制问题的状态方程。它们的区别是，ODESystem系统中的某些变量在最优控制问题中是状态量，而另一些是控制量。换而言之即，在最优控制中的状态方程与仿真系统中的微分方程本质上是相同的，不同的是最优控制问题赋予了某些变量特殊的含义。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"generateMTKcodes使用ModelingToolkit.jl中的generate_function函数生成Julia函数，并使用函数进行离散，将离散后的状态作为JuMP系统的优化变量，构建JuMP优化模型进行求解。2.1与2.2中解决方案的思路是相同的。它们都生成了Julia函数。2.1中的函数来自Symbolics.jl符号矩阵，2.2中的函数来自ModelingToolkit.jl中的ODESystem。OptControl利用生成的Julia函数进行状态空间的离散，并构建JuMP优化模型。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"(Image: 图 4)  ","category":"page"},{"location":"Frameworks/OptControl/#OptControl中的数学推演","page":"OptControl.jl设计理念","title":"3 OptControl中的数学推演","text":"","category":"section"},{"location":"Frameworks/OptControl/#.1-仿真或者控制？","page":"OptControl.jl设计理念","title":"3.1 仿真或者控制？","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"最优控制问题的中描述系统的方程为:","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"dotboldsymbolx(t)=boldsymbolAboldsymbolx(t)+boldsymbolBboldsymbolu(t)=fboldsymbolx(t)boldsymbolu(t)ttag1","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"其中，boldsymbolx(t)是系统的状态向量，boldsymbolu(t)是系统的控制量向量。它们都是关于自变量t的函数，也就是说它们随时间的变化而变化。事实上，在控制问题中，系数矩阵boldsymbolAboldsymbolB也是可以随时间而变化的，则变为boldsymbolA(t)boldsymbolB(t)。这根据实际需要而定。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"省去关于时间的函数表达，上述方程可以简写成：","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"dotboldsymbolx=boldsymbolAboldsymbolx+boldsymbolBboldsymbolu=f(boldsymbolxboldsymbolut)tag2","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"如果从数学的角度思考，不考虑boldsymbolxboldsymbolu的物理含义，这是一个关于时间的常微分方程问题。如果boldsymbolu的值不人为地决定，而是在系统中自我演化。那么这个就是一个微分方程求解问题。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"dotboldsymbolx=f(boldsymbolxboldsymbolpt)tag3","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"求解该微分方程的在真实世界中对应系统的动态仿真。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"所以，控制问题和动态仿真问题的本质是相同的。系统的描述方程都为关于时间的微分方程（组）。不同之处在于，问题的中的某些变量是否可以人为介入改变。也可以说，动态仿真问题是我们希望看到系统是如何演化的，而控制问题是，我们希望系统按照我们的期望去演化。正因为我们有期望，所以我们需要介入，对系统进行人为干预。而在方程中的体现是boldsymbolu，boldsymbolu是对系统干预的数学表达。所以，如果我们构造了boldsymbolu而不改变它，即它没有起到干预的作用，那这样的问题仍然是一个动态仿真问题。因为人的影响并没有通过boldsymbolu传递到系统。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"这正是为何OptControl能够用ModelingToolkit.jl构建系统的原因。ModelingToolkit.jl原本是用来构建动态仿真问题的工具，ODESystem描述的是动态系统的仿真模型，它并不存在可以人为干预系统的接口——控制变量boldsymbolu。我们可以构建ODESystem，观察系统是怎样变化的，而不能从头至尾地控制它的演化方向（事实上，偶尔的干预是可以通过Callback功能实现的，但它远没有达到“控制”的内涵）。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"但我们只要稍加改变，就能够将仿真问题转变为控制问题。只需要给ODESystem中的某些变量加上控制属性，工作就完成了。这正是OptControl使用的方法——把ODESystem中的参数boldsymbolp变为了控制量boldsymbolu。就得到到了控制问题中状态空间方程的最原始形式。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"dotboldsymbolx=f(boldsymbolxboldsymbolpt)Rightarrow dotboldsymbolx=f(boldsymbolxboldsymbolut)tag4","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"为了实现这一点，在构建ODESystem时需要做一点设计——需要把我们系统中某需要转变为控制量的变量设置成参数boldsymbolp。","category":"page"},{"location":"Frameworks/OptControl/#.2-最优控制怎样最优","page":"OptControl.jl设计理念","title":"3.2 最优控制怎样最优","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"上一节中我们探讨了boldsymbolu的内涵。那么还剩下一个问题是，如何用于数学语言描述最优。整个最优问题可以分为两个部分，控制过程中的最优以及控制终态的最优。方程5表示对最优的一个目标。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"min Phi(boldsymbolx(t_f)t_f)+int_t_0^t_f Lboldsymbolx(t)boldsymbolu(t)tdt  tag5","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"其中，Phi(boldsymbolx(t_f)t_f)表示对终端状态的一个期望，积分int_t_0^t_f Lboldsymbolx(t)boldsymbolu(t)tdt表示控制过程中的期望状态达到的最小指标。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"方程2和方程5合起来，就成为了最优控制问题控制方程的一般形式。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"beginmatrix\nminPhi(boldsymbolx(t_f)t_f)+int_t_0^t_f Lboldsymbolx(t)boldsymbolu(t)tdtst hspace10cm dotboldsymbolx =\nfboldsymbolx(t)boldsymbolu(t)t \nendmatrix tag6","category":"page"},{"location":"Frameworks/OptControl/#.3-数值优化模型","page":"OptControl.jl设计理念","title":"3.3 数值优化模型","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"方程6是连续形式，如果采用数值优化方法则需要将其离散化。离散方法采用欧拉法，则有:","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"beginmatrix\nminPhi(boldsymbolx(t_f)t_f)+sum_i=1^n L(boldsymbolx_iboldsymbolu_it_i) st hspace04cm boldsymbolx_i+1 =boldsymbolx_i+f(boldsymbolx_iboldsymbolu_it_i)*dt\nendmatrix tag6","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"如果采用后退欧拉法则有：","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"beginmatrix\nminPhi(boldsymbolx(t_f)t_f)+sum_i=1^n L(boldsymbolx_iboldsymbolu_it_i) st hspace04cm boldsymbolx_i+1 =boldsymbolx_i+f(boldsymbolx_i+1boldsymbolu_i+1t_i+1)*dt\nendmatrix tag7","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"此外，还有很多的离散方法，如梯形法，亚当斯方法等等。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"一旦获得了方程6和方程7的结果，下一步可以用JuMP.jl来构建相应的JuMP模型，以便调用相关的求解器求解。这由OptControl自动化地完成。","category":"page"},{"location":"Frameworks/OptControl/#求解实例","page":"OptControl.jl设计理念","title":"4 求解实例","text":"","category":"section"},{"location":"Frameworks/OptControl/#.1-Case1:-线性系统最优控制问题","page":"OptControl.jl设计理念","title":"4.1 Case1: 线性系统最优控制问题","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"求解以下线性最优控制问题：","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"min int_0^2 u^2dt newline st  dotboldsymbolx =beginbmatrix01 newline 00endbmatrixboldsymbolx+ beginbmatrix0 newline 1 endbmatrixu newline boldsymbolx(0) = beginbmatrix 1 newline 1 endbmatrix boldsymbolx(2)=beginbmatrix 0 newline 0 endbmatrix","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"使用OptControl求解该问题的步骤是：","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"使用ModelingToolkit.jl或者Symbolics.jl描述系统方程\n确定初态和终态等参数\n调用generateJuMPcodes求解","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"using OptControl, Statistics, ModelingToolkit\n@variables t u x[1:2]\nf = [0 1; 0 0] * x + [0, 1] * u\nL = 0.5 * u^2\nt0 = [1.0, 1.0]\ntf = [0.0, 0.0]\ntspan = (0.0, 2.0)\nN = 100\nsol = generateJuMPcodes(L, f, x, u, tspan, t0, tf; N=N)","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"该最优问题中，x_1的解析解是","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"x_1(t) = 05*t^3-175*t^2+t+1","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"比较解析解和优化数值解，可以得到它们的均方差是2.696E-6。在这个误差下的结果即使不能使用，它也是极具参考意义的，能给与人们启示。","category":"page"},{"location":"Frameworks/OptControl/#.2-Case2:-非线性系统最优控制问题","page":"OptControl.jl设计理念","title":"4.2 Case2: 非线性系统最优控制问题","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"求解以下非线性最优控制问题：","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"min int_0^2 u^2dt newline st  dotboldsymbolx =beginbmatrixexpcos newline sin1endbmatrixboldsymbolx+ beginbmatrix0 newline 1 endbmatrixu newline boldsymbolx(0) = beginbmatrix 1 newline 1 endbmatrix boldsymbolx(1)=beginbmatrix 0 newline 0 endbmatrix","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"使用ModelingToolkit.jl或者Symbolics.jl定义符号变量，给定初态和终态。调用generateNLJuMPcodes则可以得到结果。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"using OptControl, ModelingToolkit, Test\n@variables t u x[1:2]\nf = [exp(x[1]) + cos(x[2]), sin(x[1]) + x[2]] + [1, 0] * u\nL = u^2\nt0 = [1.0, 1.0]\ntf = [0.0, 0.0]\ntspan = (0.0, 2.0)\nN = 100\nsol = generateNLJuMPcodes(L, f, x, u, tspan, t0, tf; N=N)","category":"page"},{"location":"Frameworks/OptControl/#.3-Case3:-RC电路系统最优控制","page":"OptControl.jl设计理念","title":"4.3 Case3: RC电路系统最优控制","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"这是一个简单的电路系统。电源电压1V，电阻1欧姆，电容1法拉。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"(Image: 图 2)  ","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"我们构造的最优控制问题是，电压如何变化才能使得电容电压在1s内从1V变化到3V的同时，满足整个过程中电压尽可能低的目标。这在物理上是有意义的，但是可能没有应用价值。但它能充分说明问题所在。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"using OptControl, ModelingToolkit, Test\n\n# Components ......\n\n# Define and Simplify System\nR = 1.0\nC = 1.0\nV = 1.0\n@named resistor = Resistor(R=R)\n@named capacitor = Capacitor(C=C)\n@named source = ConstantVoltage(V=V)\n@named ground = Ground()\nrc_eqs = [\n    connect(source.p, resistor.p)\n    connect(resistor.n, capacitor.p)\n    connect(capacitor.n, source.n)\n    connect(capacitor.n, ground.g)\n]\n@named _rc_model = ODESystem(rc_eqs, t)\n@named rc_model = compose(_rc_model,\n    [resistor, capacitor, source, ground])\nsys = structural_simplify(rc_model)\n\n# Build Optimal Control Problem and Solve\nL = 0.5 * (source.V^2)\nt0 = [1.0]\ntf = [3.0]\ntspan = (0.0, 1.0)\nN = 100\nsol = OptControl.generateMTKcodes(L, sys, states(sys), [source.V], tspan, t0, tf;N=N)","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"上述代码的组件来自于ModelingToolkit.jl的文档。如果是一个仿真问题，当ODESystem被化简完成后应该需要调用DifferentialEquations.jl来求解。现在是一个最优控制问题，所以我们指定优化目标，以及定义相关参数，通过generateMTKcodes求解。","category":"page"},{"location":"Frameworks/OptControl/#结论","page":"OptControl.jl设计理念","title":"5 结论","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"OptControl实现了从状态方程到最优控制问题的自动化构建以及从ModelingToolkit的常微分方程系统到系统最优控制问题的自动化构建。问题的核心在于选择设计控制变量boldsymbolu。在状态空间方程离散过程中，OptControl提供了选择离散方法的接口。在未来的工作中，会发展更多离散方法。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"OptControl另外一个重要特点是，它不直接解决问题，而是生成解决方案脚本并解释运行。这意味OptControl像一个指挥者，它把问题分解，再调用Julia生态中的包解决问题。OptControl提供了获得脚本的接口，这意味当OptControl的功能不能满足你的需求时，你可以直接修改脚本。在它基础之上添加任何你需要的功能。如果你不熟悉JuMP的建模语言，那么你正好可以通过生成的脚本学习一些JuMP的高级用法。如果你还想选择一些不同的求解器，那就修改脚本吧。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"在未来，OptControl也许会提供更多的接口。但它不会改变指挥者的角色。也就是说，OptControl会一直致力于自动化生成最优控制问题的解决方法，而不是像ModelingToolkit.jl和JuMP.jl发展一种建模语言，也不会像JuMP.jl调用的求解器一样发展求解算法。OptControl的初衷是打通壁垒，整合工具，方便快捷的解决最优控制的问题。","category":"page"},{"location":"Simulation/1-微分代数方程/#微分代数方程DAE","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"","category":"section"},{"location":"Simulation/1-微分代数方程/#何为微分代数方程","page":"微分代数方程DAE","title":"何为微分代数方程","text":"","category":"section"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"微分代数方程（Differential Algebraic Equation，简称DAE）是一种包含了未知函数及其导数的方程系统。与常微分方程（Ordinary Differential Equation，简称ODE）不同，DAE方程不仅涉及未知函数的导数，还可能涉及未知函数本身。","category":"page"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"DAE方程的一般形式可以表示为：","category":"page"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"F(t, x, x', ..., x^(n)) = 0","category":"page"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"其中，t是自变量（通常是时间），x是未知函数，x'是x的一阶导数，x^(n)是x的第n阶导数，F是一个给定的函数。","category":"page"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"DAE方程可以用来描述一些实际问题，例如物理系统的运动方程、电路网络的动态行为等。在求解DAE方程时，需要确定未知函数及其导数的值，使得方程系统得到满足。","category":"page"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"DAE方程的求解比ODE方程更加复杂，因为它们可能存在约束条件或者约束方程。通常需要借助数值方法或符号计算技术来求解DAE方程。常用的求解方法包括雅可比矩阵方法、拆分方法、隐式显式方法等。","category":"page"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"总之，微分代数方程是一类包含了未知函数及其导数的方程系统，求解这类方程需要采用特定的数值方法或符号计算技术。","category":"page"},{"location":"Simulation/1-微分代数方程/#代数方程、常微分方程、偏微分方程相互关系","page":"微分代数方程DAE","title":"代数方程、常微分方程、偏微分方程相互关系","text":"","category":"section"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"代数方程（Algebraic Equation）是一类只包含未知数及其代数运算的方程。它们通常以形如 F(x) = 0 的形式出现，其中 F(x) 是一个给定的函数，x 是未知数。","category":"page"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"常微分方程（Ordinary Differential Equation，ODE）是描述未知函数及其导数之间关系的方程。它涉及一个或多个未知函数及其关于自变量（通常是时间）的导数。常微分方程的一般形式可以表示为 dy/dt = f(t, y)，其中 y 是未知函数，t 是自变量，f(t, y) 是给定的函数。","category":"page"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"与常微分方程相对应的是偏微分方程（Partial Differential Equation，PDE）。偏微分方程是描述未知函数及其偏导数之间关系的方程，与空间维度有关。它涉及一个或多个未知函数及其关于空间变量的偏导数。常见的偏微分方程包括热传导方程、波动方程、扩散方程等。","category":"page"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"微分代数方程（Differential Algebraic Equation，DAE）是一种结合了常微分方程和代数方程的方程系统。它涉及未知函数及其导数，同时可能还涉及未知函数本身。微分代数方程的一般形式可以表示为 F(t, x, x', ..., x^(n)) = 0，其中 t 是自变量，x 是未知函数，x' 是 x 的一阶导数，x^(n) 是 x 的第 n 阶导数，F 是一个给定的函数。","category":"page"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"根据你提供的描述，可以对这些方程进行关联和区分的解释如下：","category":"page"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"常微分方程对时间进行离散化：常微分方程描述了未知函数及其导数之间的关系，对时间进行离散化意味着将时间变量拆分为一系列离散的时间点，得到一组代数方程。这些代数方程将未知函数在不同时间点上的值联系起来。\n偏微分方程对空间进行离散化：偏微分方程描述了未知函数及其偏导数之间的关系，对空间进行离散化意味着将空间变量拆分为一系列离散的空间点，得到一组微分代数方程。这些微分代数方程将未知函数在不同空间点上的值及其偏导数联系起来。\n微分代数方程不对时间离散化：微分代数方程结合了常微分方程和代数方程的特点，它涉及未知函数及其导数，同时可能还涉及未知函数本身。对时间不进行离散化意味着保持时间为连续变量，得到一组含有未知函数及其导数的方程系统。\n进一步对时间离散得到代数方程：如果对微分代数方程中的时间进行离散化，将时间变量拆分为一系列离散的时间点，那么就得到了一组代数方程。这些代数方程将未知函数及其导数在不同时间点上的值联系起来，但没有了时间的连续性。","category":"page"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"综上所述，常微分方程对时间离散化得到代数方程，偏微分方程对空间离散化得到微分代数方程，而进一步对时间离散化得到代数方程。这些关系描述了方程形式的变化与离散化的过程。","category":"page"},{"location":"Simulation/1-微分代数方程/#微分代数方程的应用","page":"微分代数方程DAE","title":"微分代数方程的应用","text":"","category":"section"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"微分代数方程（Differential Algebraic Equations，DAEs）在科学、工程和应用数学的各个领域中都有广泛的应用。以下是一些常见的应用范围：","category":"page"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"物理学和工程学：DAEs被广泛用于描述和模拟物理系统、工程系统和控制系统的动态行为。例如，在机械工程中，DAEs可以用于描述弹性体的振动和变形。在电气工程中，DAEs可用于建模和分析电路网络的动态响应。在航空航天工程中，DAEs可以用于描述飞行器的运动和控制。\n化学和生物学：DAEs在化学反应动力学和生物过程建模中也扮演重要角色。例如，DAEs可以用于描述化学反应网络的动态行为、酶动力学的过程、细胞生物学中的信号传递和调控等。\n经济学和金融学：经济学和金融学中的许多问题涉及到系统的动态行为和约束条件，因此DAEs也被广泛用于这些领域的建模和分析。例如，宏观经济模型中的消费、投资和产出之间的关系可以用DAEs来表示和求解。\n控制系统和优化：在控制系统和优化问题中，DAEs可以用于描述动态系统的行为和约束。DAEs在控制器设计、最优控制和系统优化中扮演重要角色。\n数值模拟和仿真：DAEs在数值模拟和仿真中也非常常见。它们可以用于模拟和预测系统的行为，帮助工程师和科学家优化系统设计和决策。","category":"page"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"总的来说，微分代数方程广泛应用于各个学科领域，包括物理学、工程学、化学、生物学、经济学、金融学等。它们为建模、分析和解决复杂的动态系统问题提供了有力工具，并在科学研究、工程设计和决策制定中发挥重要作用。","category":"page"},{"location":"Simulation/1-微分代数方程/#流程模拟的序贯模块法与联立方程法","page":"微分代数方程DAE","title":"流程模拟的序贯模块法与联立方程法","text":"","category":"section"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"流程模拟是一种用于描述和分析工业过程或系统行为的方法。它涉及建立数学模型来模拟系统的动态变化，并通过求解模型方程来预测和优化系统的运行情况。在流程模拟中，有两种常用的方法：序贯模块法和联立方程法。","category":"page"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"序贯模块法（Sequential Modular Approach）：序贯模块法将整个系统划分为多个子模块，每个子模块描述系统中的一个组成部分或阶段。每个子模块被建模为一组微分代数方程（DAEs），描述了该部分的动态行为。然后，从系统的初始状态开始，逐个模拟和求解每个子模块的方程，通过子模块之间的耦合条件传递信息，逐步计算系统的整体行为。每个子模块的方程求解通常使用数值方法进行。","category":"page"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"序贯模块法的优点是可以将复杂系统分解为可管理的子模块，每个子模块的建模和求解可以相对独立地进行。这样可以降低模型的复杂性，提高求解的效率。然而，序贯模块法可能无法准确地捕捉子模块之间的耦合效应，导致一些信息的传递延迟或不准确性。","category":"page"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"联立方程法（Simultaneous Equation Approach）：联立方程法将整个系统的所有组成部分或阶段的方程联立起来，形成一个整体的微分代数方程系统（DAEs）。这个系统包含了所有部分之间的耦合关系和约束条件。然后，对整个方程系统进行求解，得到系统的整体行为。","category":"page"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"联立方程法的优点是可以更准确地考虑系统的整体行为和耦合效应。由于系统的方程被同时求解，信息可以更准确地在各个部分之间传递。然而，联立方程法通常需要求解更大规模的方程系统，求解过程可能更复杂和耗时。","category":"page"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"选择使用哪种方法取决于具体的问题和系统特性。对于复杂系统，序贯模块法可以提供更好的模块化和求解效率；而联立方程法可以提供更准确的整体行为描述。因此，根据具体情况，可以选择合适的方法进行流程模拟和系统分析。","category":"page"},{"location":"Simulation/1-微分代数方程/#流程仿真的软件及其构建方法","page":"微分代数方程DAE","title":"流程仿真的软件及其构建方法","text":"","category":"section"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"流程仿真是通过使用专门的软件工具来模拟和分析工业过程或系统的行为。下面介绍一些常用的流程仿真软件以及它们的构建方法：","category":"page"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"Aspen Plus：Aspen Plus是一种广泛使用的流程仿真软件，主要用于化工和能源领域。它提供了建模和求解复杂化学过程、热力学性质、反应器、分离器、传热器等的工具。Aspen Plus使用基于物质平衡和能量平衡的联立方程法进行建模和求解。\nHYSYS：HYSYS是另一个常用的化工流程仿真软件，由Aspen Technology开发。HYSYS可以用于建模和分析化学过程、石油和天然气处理、能源系统等。它提供了丰富的组件库和模型库，可以进行物质和能量平衡的联立方程建模和求解。\nMATLAB/Simulink：MATLAB和Simulink是强大的数值计算和仿真平台，广泛应用于多个领域。Simulink提供了可视化的建模环境，可以进行动态系统的建模和仿真，包括连续时间和离散时间系统。它支持多种建模方法，包括差分方程、微分方程和状态空间模型等。\nAnyLogic：AnyLogic是一种通用的多方法仿真软件，可以用于建模和仿真多个领域的系统，包括离散事件仿真、连续时间仿真和混合仿真。AnyLogic提供了可视化建模环境和多种建模方法，使用户能够根据具体需求选择合适的建模方法。","category":"page"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"在构建流程仿真模型时，通常需要以下步骤：","category":"page"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"定义系统边界和目标：明确需要建模和仿真的系统的范围和目标。确定输入和输出变量，以及需要监测和优化的系统性能指标。\n收集数据和参数：收集系统所需的输入数据、物理参数和操作参数。这些数据可能包括物质属性、反应速率、传热系数等。\n建立模型：使用选择的仿真软件，根据系统的特性和目标，构建系统的数学模型。选择合适的建模方法（如连续时间模型、离散事件模型）和方程形式（如微分方程、代数方程）。\n设定初始条件和边界条件：根据实际情况，设定模型的初始条件和边界条件。这些条件可以包括初始状态、边界值、约束条件等。\n求解模型：使用仿真软件提供的求解器，对模型进行求解和仿真。根据设定的输入条件和控制策略，运行仿真并获得系统的动态行为和输出结果。\n评估和优化：分析仿真结果，评估系统的性能，并根据需要进行优化。通过调整模型的参数、操作策略或系统结构，改进系统的性能和效率。","category":"page"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"以上是一般的流程仿真软件和构建方法的概述。具体的软件和方法选择取决于系统的特性、应用领域和用户的需求。","category":"page"},{"location":"Simulation/1-微分代数方程/#gproms、Ascend、Modelica和DAETools的建模方法","page":"微分代数方程DAE","title":"gproms、Ascend、Modelica和DAETools的建模方法","text":"","category":"section"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"gproms、Ascend、Modelica和DAETools的建模方法类似。它们采用了一种分级建模的方法，通过组件之间的关联和连接方程逐级构建模型。这种建模方法可以自底向上地将系统分解为多个组件，并逐步建立连接和约束关系，最终形成一个完整的微分代数方程系统。","category":"page"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"具体来说，这些软件的建模方法一般可以按照以下步骤进行：","category":"page"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"描述变量和参数：定义系统中涉及的变量和参数，包括物理量、操作条件、模型参数等。\n组件建模：将系统分解为多个组件或子模块，每个组件表示系统中的一个部分。对于每个组件，建立相应的方程模型，描述其动态行为和约束条件。\n组件之间的连接：通过连接方程，描述组件之间的关系和相互作用。这些连接方程可以包括物质流动、能量传递、动力学约束等。\n递归展开：使用递归的方法，逐级展开组件和连接方程，生成整个系统的微分代数方程系统。在此过程中，每个组件的方程会与其连接的其他组件的方程相耦合。\n方程求解：使用矩阵求解器或其他数值方法对生成的微分代数方程系统进行求解。求解过程中，需要考虑边界条件、初始条件和约束条件等。","category":"page"},{"location":"Simulation/1-微分代数方程/","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"通过这种建模方法，可以有效地处理复杂的系统，并实现系统的模拟和优化。这种自底向上的分级建模方法能够提高模型的可管理性和求解的效率，同时保持对系统整体行为的准确描述。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#静态链接库和动态链接库","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"编程中函数的本质是把具有一定功能性代码整合起来，可以重复的使用。至于函数内部的实现，你可以认为就是一个黑箱。但是我得告诉你我这个黑箱中有什么功能。就像快递收发点一样，怎么运输的你不用管，但是我得有个目录告诉你有些什么选择和对应的收费标准。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"c语言中，stdio等库就是这么个情况，把很多有用的函数封装在一起，成为一个库（静态和动态我们等会儿再说），库里有什么则通过stdio.h这个文件告诉你，同时stdio.h也告诉你了要以什么样的参数方式调用。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"人们可以把一些函数封装成库，提供给用户服务。c语言就有很多这样的库，你写程序的时候，就可以调用c语言自带的这些库函数。编译的时候，你的c语言源代码会编译成.o文件，但是要做成exe文件，还需要把库里所有要用到的那些函数代码嵌入进来，这种方式就是静态的链接到了你的exe文件中。提供的这些库，就称呼为静态链接库。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"而如果某些函数使用率非常的高，或者你自己脑回路清奇，或者乐意，你也可以把那些用到的函数不嵌入进来，只是告诉你的exe程序，需要用到某个库中的某个函数，在运行的时候才加载那个库，调用库里的函数。这样的方式就是动态链接库。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在windows下，静态链接库一般是lib为后缀名，动态链接库一般是dll为后缀名。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在linux下，静态链接库一般是a为后缀名，动态链接库一般是so为后缀名。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在mac os x 下，动态链接库一般是dylib为后缀名。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"我们在julia中可以很方便的调用动态链接库里的函数。详情请见julia调用dll中的函数。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#静态链接库和动态链接库是什么","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库是什么","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"动态链接库（Dynamic Link Library，DLL）是一种在多个程序之间共享代码和数据的可执行文件格式。DLL包含一组可重用的函数、类、变量和资源，可以被不同的应用程序或进程调用和使用。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"与静态链接库（Static Link Library）不同，DLL在运行时才加载到内存中，并且可以由多个应用程序同时使用。这种共享的特性带来了一些优势：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"节省内存空间：由于多个应用程序可以共享同一个DLL，所以不同的应用程序不需要在内存中加载相同的代码和数据，从而节省了内存空间。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"代码和数据的更新和维护：如果需要更新DLL中的代码或数据，只需更新DLL本身，而不需要重新编译和链接所有使用该DLL的应用程序。这样可以简化代码的维护和更新过程。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"提供标准化的功能和接口：通过使用DLL，可以将常用的功能和接口封装在一个共享的库中，使得多个应用程序可以共享这些标准化的功能，减少了代码冗余和重复开发。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在Windows操作系统中，DLL文件具有特定的文件扩展名 \".dll\"，并且可以通过动态链接方式进行加载和调用。应用程序可以使用特定的函数调用语法来调用DLL中的函数，从而实现对DLL中功能的使用。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"需要注意的是，由于DLL是共享的，因此在使用DLL时需要注意版本兼容性和依赖关系。如果一个应用程序依赖于某个DLL的特定版本，那么必须确保该DLL的版本可用，并且正确配置应用程序的运行环境，以避免出现兼容性问题。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"总之，动态链接库是一种方便共享代码和数据的可执行文件格式，它提供了灵活性、代码重用和资源共享的好处，被广泛用于软件开发中。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#使用c语言，CMake工具，来个例子","page":"静态链接库和动态链接库","title":"使用c语言，CMake工具，来个例子","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"当使用CMake构建动态链接库或静态链接库时，您需要编写CMakeLists.txt文件来描述构建过程。下面是一个示例，展示如何使用C语言生成一个动态链接库和一个静态链接库。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"首先，创建一个名为mylib的文件夹，并在其中创建以下文件：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"CMakeLists.txt - 用于构建库的CMake文件。\nmylib.h - 库的头文件。\nmylib.c - 库的源代码文件。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"确保将这些文件放在同一个文件夹中。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"下面是CMakeLists.txt的内容：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"cmake_minimum_required(VERSION 3.10)\nproject(mylib)\n\n# 添加库的源文件\nset(SOURCES mylib.c)\n\n# 生成动态链接库\nadd_library(mylib_shared SHARED ${SOURCES})\n\n# 生成静态链接库\nadd_library(mylib_static STATIC ${SOURCES})\n\n# 设置库的输出名称\nset_target_properties(mylib_shared PROPERTIES OUTPUT_NAME \"mylib\")\nset_target_properties(mylib_static PROPERTIES OUTPUT_NAME \"mylib\")\n\n# 设置库的安装路径\ninstall(TARGETS mylib_shared mylib_static\n        LIBRARY DESTINATION lib\n        ARCHIVE DESTINATION lib)\n\n# 设置头文件的安装路径\ninstall(FILES mylib.h DESTINATION include)","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在上述示例中，我们使用add_library命令来创建动态链接库和静态链接库。set_target_properties命令用于设置库的输出名称，这里设置为\"mylib\"。install命令用于指定库的安装路径和头文件的安装路径。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"要构建库，可以按照以下步骤进行操作：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"创建一个名为build的文件夹，并进入该文件夹。\n打开终端，导航到build文件夹。\n运行以下命令以生成构建文件：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"cmake ..","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"运行以下命令以构建库：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"cmake --build .","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"完成上述步骤后，将在build文件夹中生成动态链接库（libmylib.so）和静态链接库（libmylib.a）。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"如果您希望安装库到系统路径中，可以运行以下命令（需要管理员权限）：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"sudo make install","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"这将把库文件和头文件安装到默认的系统路径（例如，/usr/local/lib和/usr/local/include）。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#对应的c语言源文件","page":"静态链接库和动态链接库","title":"对应的c语言源文件","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"这里是一个示例的C源文件mylib.c，用于生成动态链接库和静态链接库：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"#include \"mylib.h\"\n\nint add(int a, int b) {\n    return a + b;\n}\n\nint subtract(int a, int b) {\n    return a - b;\n}","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在上述示例中，我们定义了两个简单的函数：add和subtract。这些函数的实现位于mylib.c文件中，并在mylib.h文件中进行了声明。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"您可以将这个mylib.c文件放在与CMakeLists.txt相同的目录中，然后按照上述说明使用CMake来构建动态链接库和静态链接库。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#头文件呢？","page":"静态链接库和动态链接库","title":"头文件呢？","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"当生成动态链接库或静态链接库时，您需要一个头文件来声明库中的函数和数据结构。在上一个示例中，我忘记包含头文件mylib.h的内容，非常抱歉。以下是正确的mylib.h头文件内容：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"#ifndef MYLIB_H\n#define MYLIB_H\n\nint add(int a, int b);\nint subtract(int a, int b);\n\n#endif  // MYLIB_H","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"请将上述代码保存到名为mylib.h的文件中，并确保与CMakeLists.txt和mylib.c文件位于同一个目录中。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"这个头文件声明了两个函数：add和subtract，这些函数的实现位于mylib.c文件中。通过包含这个头文件，其他源文件就可以使用库中的函数。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"希望这次提供的信息对您有所帮助！如果您还有其他问题，请随时提问。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#如何调用","page":"静态链接库和动态链接库","title":"如何调用","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"当调用生成的动态链接库或静态链接库时，您需要创建一个主函数文件，并使用CMake来构建项目。下面是一个示例，展示如何编写主函数文件和CMakeLists.txt文件来调用生成的库。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"首先，创建一个名为myapp的文件夹，并在其中创建以下文件：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"CMakeLists.txt - 用于构建应用程序的CMake文件。\nmain.c - 主函数文件，用于调用库中的函数。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"确保将这些文件放在同一个文件夹中。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"下面是CMakeLists.txt的内容：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"cmake_minimum_required(VERSION 3.10)\nproject(myapp)\n\n# 添加库的源文件\nset(SOURCES main.c)\n\n# 生成可执行文件\nadd_executable(myapp ${SOURCES})\n\n# 链接动态链接库\ntarget_link_libraries(myapp PRIVATE mylib)\n\n# 设置库的搜索路径\nlink_directories(/path/to/mylib)\n\n# 设置库的头文件路径\ninclude_directories(/path/to/mylib)\n\n# 设置可执行文件的安装路径\ninstall(TARGETS myapp DESTINATION bin)","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在上述示例中，我们使用add_executable命令创建可执行文件，并使用target_link_libraries命令将生成的库（这里假设为mylib）链接到可执行文件中。通过link_directories和include_directories命令，我们设置库的搜索路径和头文件路径。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"要构建应用程序，可以按照以下步骤进行操作：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"创建一个名为build的文件夹，并进入该文件夹。\n打开终端，导航到build文件夹。\n运行以下命令以生成构建文件：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"cmake ..","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"运行以下命令以构建应用程序：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"cmake --build .","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"完成上述步骤后，将在build文件夹中生成可执行文件（myapp）。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"如果您希望安装应用程序到系统路径中，可以运行以下命令（需要管理员权限）：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"sudo make install","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"这将把可执行文件安装到默认的系统路径（例如，/usr/local/bin）。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"请注意，您需要根据实际情况修改link_directories和include_directories中的路径，以确保正确链接和包含库的头文件。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#使用clion来一个step-by-step生成动态链接库的例子","page":"静态链接库和动态链接库","title":"使用clion来一个step by step生成动态链接库的例子","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"使用CLion来生成动态链接库的步骤如下：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"步骤 1: 创建一个新的CMake项目","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"打开CLion并选择 \"Create New Project\"。\n在对话框中选择 \"C Executable\" 并点击 \"Next\"。\n为项目选择一个适当的名称和位置，并点击 \"Create\".","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"步骤 2: 创建源文件","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在项目中创建一个新的C源文件，例如 mylib.c。\n编写您的库的实现代码。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"以下是一个简单的示例 mylib.c：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"#include \"mylib.h\"\n\nint add(int a, int b) {\n    return a + b;\n}\n\nint subtract(int a, int b) {\n    return a - b;\n}","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"步骤 3: 创建头文件","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在项目中创建一个新的头文件，例如 mylib.h。\n在头文件中声明您的库的函数和数据结构。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"以下是 mylib.h 的内容：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"#ifndef MYLIB_H\n#define MYLIB_H\n\nint add(int a, int b);\nint subtract(int a, int b);\n\n#endif  // MYLIB_H","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"步骤 4: 编辑CMakeLists.txt","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在项目根目录下找到 CMakeLists.txt 文件，并编辑它。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"以下是一个基本的 CMakeLists.txt 示例：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"cmake_minimum_required(VERSION 3.10)\nproject(mylib)\n\n# 添加库的源文件\nset(SOURCES mylib.c)\n\n# 生成动态链接库\nadd_library(mylib SHARED ${SOURCES})\n\n# 设置库的安装路径\ninstall(TARGETS mylib LIBRARY DESTINATION lib)\ninstall(FILES mylib.h DESTINATION include)","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"步骤 5: 配置和构建项目","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"打开CLion中的项目。\n在CLion界面的底部工具栏，点击 \"Reload CMake Project\" 以加载新的CMake配置。\n在CLion界面的顶部工具栏，点击 \"Build\" 按钮构建项目。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"完成上述步骤后，CLion将使用CMake构建您的项目，并在构建过程中生成动态链接库。生成的动态链接库将位于 build/lib 目录中。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"如果您希望安装库到系统路径中，可以在 CMakeLists.txt 中添加以下安装规则：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"install(TARGETS mylib LIBRARY DESTINATION /usr/local/lib)\ninstall(FILES mylib.h DESTINATION /usr/local/include)","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"运行 Reload CMake Project 和 Build 命令后，库将安装到 /usr/local/lib 和 /usr/local/include 路径中。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"这样，您就可以在CLion中使用CMake逐步生成动态链接库了。如果您有任何进一步的问题，请随时提问。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#调用如何进行？","page":"静态链接库和动态链接库","title":"调用如何进行？","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"以下是在CLion中调用动态链接库的步骤：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"步骤 1: 创建一个新的CMake项目","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"打开CLion并选择 \"Create New Project\"。\n在对话框中选择 \"C Executable\" 并点击 \"Next\"。\n为项目选择一个适当的名称和位置，并点击 \"Create\".","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"步骤 2: 创建源文件","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在项目中创建一个新的C源文件，例如 main.c。\n编写您的主函数代码。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"以下是一个简单的示例 main.c：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"#include <stdio.h>\n#include \"mylib.h\"\n\nint main() {\n    int result = add(5, 3);\n    printf(\"Addition result: %d\\n\", result);\n\n    result = subtract(5, 3);\n    printf(\"Subtraction result: %d\\n\", result);\n\n    return 0;\n}","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"步骤 3: 添加动态链接库的引用","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"打开项目的 CMakeLists.txt 文件。\n在 add_executable 行之前，添加 add_library 行来引用动态链接库。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"以下是修改后的 CMakeLists.txt 示例：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"cmake_minimum_required(VERSION 3.10)\nproject(myapp)\n\n# 引用动态链接库\nadd_library(mylib SHARED IMPORTED)\n\n# 设置动态链接库的路径\nset_target_properties(mylib PROPERTIES IMPORTED_LOCATION /path/to/mylib.so)\n\n# 添加可执行文件\nadd_executable(myapp main.c)\n\n# 链接动态链接库\ntarget_link_libraries(myapp PRIVATE mylib)","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在上述示例中，您需要将 /path/to/mylib.so 替换为实际的动态链接库文件路径。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"步骤 4: 配置和构建项目","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"打开CLion中的项目。\n在CLion界面的底部工具栏，点击 \"Reload CMake Project\" 以加载新的CMake配置。\n在CLion界面的顶部工具栏，点击 \"Build\" 按钮构建项目。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"完成上述步骤后，CLion将使用CMake构建您的项目，并在构建过程中将动态链接库引用到可执行文件中。然后，您可以在CLion中运行项目，查看调用动态链接库函数的结果。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"请注意，您需要将 /path/to/mylib.so 替换为实际的动态链接库文件路径，并确保动态链接库文件存在。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#能否简单补充一下CMake是什么？","page":"静态链接库和动态链接库","title":"能否简单补充一下CMake是什么？","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"当然可以！CMake是一个开源的跨平台构建系统，用于管理软件项目的构建过程。它使用名为CMakeLists.txt的文本文件来描述项目的构建配置，并根据此配置生成适合各种构建工具（如make、Ninja等）的构建文件。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"CMake的主要优势在于它提供了一种简化和抽象构建过程的方式，使得开发者可以更方便地管理复杂的项目结构和依赖关系。通过CMake，您可以编写平台无关的构建脚本，这意味着您可以在不同的操作系统和编译器上使用相同的CMake配置来构建项目。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"CMake使用类似于编程语言的语法，提供了丰富的命令和变量，用于定义项目的源文件、目标、库依赖关系、编译选项等。通过编写CMakeLists.txt文件，您可以描述项目的组织结构、源代码文件、库的构建方式等细节，从而使得构建过程更加灵活和可定制。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在使用CMake构建项目时，通常的步骤是：创建CMakeLists.txt文件，定义源文件和目标，指定库的依赖关系和链接选项，然后运行CMake来生成构建文件，最后使用构建工具进行实际的构建操作。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"CMake已被广泛使用，并且许多开源项目和跨平台项目都使用CMake来管理其构建过程，使得项目在不同的平台和编译器上更容易构建和交付。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#作业","page":"静态链接库和动态链接库","title":"作业","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"请自己完成静态链接库及其调用。使用CLion，CMake。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#视频链接","page":"静态链接库和动态链接库","title":"视频链接","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"动态链接库和静态链接库","category":"page"},{"location":"Simulation/DE_heattran/#DE求解PDE（对比MTK）","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"tip: Tip\nContents：DE、PDE、手动空间离散Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"note: Note\nDE = DifferentialEquations.jlPDE = Partial Differential EquationDifferentialEquations.jl为处理时间微分的求解建模工具包。","category":"page"},{"location":"Simulation/DE_heattran/#DE求解PDE","page":"DE求解PDE（对比MTK）","title":"DE求解PDE","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"在MTK手动空间离散求解PDE中介绍了手动空间离散的思想。本篇中将通过手动PDE求解传热问题对DE与MTK进行一个小对比。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"DE构建的问题过程中，需要把问题推演至求解之前。求解之前的部分都需要手动完成。MTK手动空间离散求解PDE中提到，求解PDE的数值方法有这么几步：建立数学描述方程、对变量进行离散、迭代求解。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"把问题进一步细化，则变为：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"Step1:建立数学描述方程\nStep2:网格生成（变量离散）\nStep3:生成求解格式\nStep4:迭代求解","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"MTK完成了Step3、Step4的内容，而DE只能帮我们完成Step4的内容。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"tip: Tip\n如果我们仔细琢磨，会发现：如果是基于时间微分的组件化建模。使用MTK时，我们完成Step1的内容，剩下MTK全包了！所以这也是为什么说，MTK提供了基于时间的一条龙求解。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"我们来看看，DE是如何完成Step4的内容的。同时，也会让大家对数值求解过程有一个更加深刻的理解。","category":"page"},{"location":"Simulation/DE_heattran/#数值传热学实例","page":"DE求解PDE（对比MTK）","title":"数值传热学实例","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"考虑MTK手动空间离散求解PDE中正方形铸件的散热过程。节点的离散结果如下（不再推导）：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"内节点：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"fracpartial T_Ppartial t=A(T_W^n+T_E^n+ T_N^n+T_S^n - 4T_P^n)","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"边边界节点：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"fracpartial T_Ppartial t=A(T_W^n+T_N^n+T_S^n)-(B+3A)T_P^n+BT_f","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"角边界节点：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"fracpartial T_Ppartial t=A(T_E^n + T_N^n )-(2B+2A)T_P^n+2BT_f","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"这里，我们进一步对问题进行拓展。正方形铸件初始温度1000℃，环境温度为一个变化的值：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"T_f = 400 * (1 + sin(t))","category":"page"},{"location":"Simulation/DE_heattran/#求解实例","page":"DE求解PDE（对比MTK）","title":"求解实例","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"求解的全部代码如下：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"using ModelingToolkit, DifferentialEquations\nusing Dates\n\nprintln(\"=====DE TEST=====\")\nstarttime = now()\na = 1.27E-5\nn = 10\nL = 0.2\nδ = L / n\nλ = 50\nh = 1.0E9\nTf = 0.0\nA = a / δ^2\nB = a / (δ^2 / 2 + δ * λ / h)\np = [A, B, n]\nfunction to_index(i, j, n)\n    return (i - 1) * n + j\nend\nfunction heat!(dT, T, p, t)\n    A, B, n = p\n    n = Int(n)\n    Tf = 400.0 * (1 + sin(t))\n    # 内部节点\n    for i in 2:n-1\n        for j in 2:n-1\n            dT[to_index(i, j, n)] = A * (T[to_index(i + 1, j, n)] + T[to_index(i - 1, j, n)] + T[to_index(i, j + 1, n)] + T[to_index(i, j - 1, n)] - 4 * T[to_index(i, j, n)])\n        end\n    end\n    # 边边界\n    for i in 2:n-1\n        dT[to_index(i, 1, n)] = A * (T[to_index(i + 1, 1, n)] + T[to_index(i - 1, 1, n)] + T[to_index(i, 2, n)]) - (3B + A) * T[to_index(i, 1, n)] + B * Tf\n    end\n    for i in 2:n-1\n        dT[to_index(i, n, n)] = A * (T[to_index(i + 1, n, n)] + T[to_index(i - 1, n, n)] + T[to_index(i, n - 1, n)]) - (3B + A) * T[to_index(i, n, n)] + B * Tf\n    end\n    for i in 2:n-1\n        dT[to_index(1, i, n)] = A * (T[to_index(1, i + 1, n)] + T[to_index(1, i - 1, n)] + T[to_index(2, i, n)]) - (3B + A) * T[to_index(1, i, n)] + B * Tf\n    end\n    for i in 2:n-1\n        dT[to_index(n, i, n)] = A * (T[to_index(n, i + 1, n)] + T[to_index(n, i - 1, n)] + T[to_index(n - 1, i, n)]) - (3B + A) * T[to_index(1, i, n)] + B * Tf\n    end\n    # 角边界\n    dT[to_index(1, 1, n)] = A * (T[to_index(2, 1, n)] + T[to_index(1, 2, n)]) - (2B + 2A) * T[to_index(1, 1, n)] + 2B * Tf\n    dT[to_index(n, n, n)] = A * (T[to_index(n - 1, n, n)] + T[to_index(n, n - 1, n)]) - (2B + 2A) * T[to_index(n, n, n)] + 2B * Tf\n    dT[to_index(n, 1, n)] = A * (T[to_index(n, 2, n)] + T[to_index(n - 1, 1, n)]) - (2B + 2A) * T[to_index(n, 1, n)] + 2B * Tf\n    dT[to_index(1, n, n)] = A * (T[to_index(2, n, n)] + T[to_index(1, n - 1, n)]) - (2B + 2A) * T[to_index(1, n, n)] + 2B * Tf\nend\nu0 = [1000.0 for i in 1:n for j in 1:n]\nprob = ODEProblem(heat!, u0, (0, 100), p, saveat=1)\nsol = solve(prob, Tsit5())\nendtime = now()\nprintln(\"time use:\"*string(endtime - starttime))","category":"page"},{"location":"Simulation/DE_heattran/#可视化","page":"DE求解PDE（对比MTK）","title":"可视化","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"动画走你！","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"an_len = length(sol.u)\nusing Plots, GR\nres = rand(n, n, an_len)\nfor t in 1:an_len\n    for i in 1:n\n        for j in 1:n\n            res[i, j, t] = sol.u[t][to_index(i, j, n)]\n        end\n    end\nend\nxs = LinRange(0.0, L, n)\nys = LinRange(0.0, L, n)\nPlots.contourf(xs, ys, res[:, :, 1])\nanim = @animate for i ∈ 2:an_len\n    contourf!(xs, ys, res[:, :, i])\nend\ngif(anim, \"DE_trans.gif\", fps=24)","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"以上代码对比之前，有所改变的是：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"saveat","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"我们把时间拉长，同时saveat的时间步长变成了1s。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"","category":"page"},{"location":"Simulation/DE_heattran/#求解速度对比","page":"DE求解PDE（对比MTK）","title":"求解速度对比","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"跑相同的问题：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"MTK用时：2.407s\nDE用时：0.810s","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"可见，Step3的符号化简与DE问题生成的确需要消耗不少的资源。","category":"page"},{"location":"Simulation/DE_heattran/#关于内涵的理解","page":"DE求解PDE（对比MTK）","title":"关于内涵的理解","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"MTK与DE两种方法都能够求解PDE问题。为什么这样做能行呢？下面分享一些关于问题内涵的思考。","category":"page"},{"location":"Simulation/DE_heattran/#空间离散的物理内涵","page":"DE求解PDE（对比MTK）","title":"空间离散的物理内涵","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"动画中可以清晰感受到外围颜色的震动，这是我们设定环境温度波动的结果。若要把环境温度变化以微分方程的形式定义，同样可行。只需要再添加一个变量关于时间相关的变量即可。而这个随时间的变化的环境温度，是真正驱动系统变化的变量，它的变化是由时间决定，而不受其它网格影响。相反，其它网格受到环境温度变量的影响。可以说，环境温度变量是独立于网格离散而存在的。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"由此，我们可以聊一聊关于空间离散的内涵。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"在以上的传热实例中，系统的根本“驱动力”在于温差。也就是说，因为温差的存在，才会让系统产生变化。而我们在空间离散时，其实并没有对这种变化进行处理。我们手动空间离散的内涵是：在不同网格间，架起了让网格相互联系的桥梁。其本质描述了网格和网格之间的联系。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"从高数中微元的角度思考，只要网格足够小，那么我们就可以得到非常精确的模拟结果；从物理内涵的角度思考，不管网格如何小，任何一个网格都可以视为一个小组件，这个小组件的特性有：温度、边长、导热系数等等，并且在小组件内部，这些属性的数值视为不变。而空间离散，就是建立了这些小组件之间的关联。这种思想在数值计算领域是一种专业的离散方式——有限容积法。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"所以，以上空间离散的思想内涵就和之间组件化建模的思想内涵统一起来了。区别在于，空间离散出来的结果是微元，组件化建模的模型结果是宏观组件。 但是，不同组件（微元）之间需要建立相互联系的桥梁这一点是不变的。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"如果深入思考传热的内涵——由温差引起的热量传递。我们也能发现，以小组件的形式看待微元网格，其物理逻辑也是非常自洽的。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"把空间离散赋予物理内涵（微元组件化）后，剩下的问题也很清晰了——组件在时间域上的变化。组件之间的连接建立好之后，当外界环境（温度）随时间动态变化，组件的属性（温度）也会发生相应的变化。这不就是时间域上动态系统的求解内涵吗？只是我们不会把描述时间微分的方程离散，而是把它丢给求解器去解。","category":"page"},{"location":"Simulation/DE_heattran/#迭代格式的数学内涵","page":"DE求解PDE（对比MTK）","title":"迭代格式的数学内涵","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"迭代格式数学内涵中最关键的一环是函数to_index()","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"function to_index(i, j, n)\n    return (i - 1) * n + j\nend","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"MTK中采用T[i, j]的网格描述方式，这是从物理位置中对网格进行了一种描述。这种描述中是附加由物理含义的——空间位置。而这种附加了物理含义的变量描述，底层求解器是无法求解的。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"DE能求解的方程是什么样的呢？如下所示：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"leftbeginarrayc\ny_1^prime(x)=fleft(x y_1(x) y_2(x) ldots y_n(x) right) y_2^prime(x)=fleft(x y_1(x) y_2(x) ldots y_n(x) right)  ldots y_n^prime(x)=fleft(x y_1(x) y_2(x) ldots y_n(x) right)  y_1left(x_0right)=y_10 y_2left(x_0right)=y_20 ldots y_nleft(x_0right)=y_n 0endarrayright","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"写成统一的格式即：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"mathbfyprime=mathbff(mathbfxmathbfy)","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"note: Note\n求解微分方程的数值解法主要有：欧拉法yleft(x_i+1right)=yleft(x_iright)+hfleft(x_iy(x_i)right)+Oleft(h^2right)后退欧拉法yleft(x_i+1right)=yleft(x_iright)+hfleft(x_i+1y(x_i+1)right)+Oleft(h^2right)梯形法yleft(x_i+1right)=yleft(x_iright)+frach2leftfleft(x_iy_i right)+fleft(x_i+1y_i+1right)right+Oleft(h^3right)辛普森方法yleft(x_i+1right)=yleft(x_i-1right)+ frach3leftfleft(x_i-1y_i-1right)+4fleft(x_iy_iright)+fleft(x_i+1y_i+1right)right+Oleft(h^5right)标准龙格库塔法leftbeginarrayc\ny_i+1=y_i+frac16left(K_1+2 K_2+2 K_3+K_4right) \nK_1=h fleft(x_i y_iright) \nK_2=h fleft(x_i+frac12 h y_i+frac12 K_1right) \nK_3=h fleft(x_i+frac12 h y_i+frac12 K_2right) \nK_4=h fleft(x_i+h y_i+K_3right)\nendarrayright其中，h为求解的步长。各方法阶数为（阶数越高精度越高）：方法 阶数\n欧拉法 1阶\n后退欧拉法 1阶\n梯形法 2阶\n辛普森方法 4阶\n标准龙格库塔法 4阶","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"对于这样的数学描述方式，y可以视为微分变量的数组，f(xy)视为变量之间的联系。那么y=f(xy)的含义是：微分与其它变量之间的关联。这种关联是不包含物理内涵的。而二维数组T[i, j]包含了位置关系。所以要去位置化，就需要把二维映射到一维上。所以我们采用(i - 1) * n + j将二维索引展平为一维。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"本质是通过to_index()消除了物理位置含义。生成了DE可计算的描述方式——最原始最根本的微分方程组数学描述方式。这一步就是前面所说的Step3。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"总的来看，DE求解我们手动完成了Step2、Step3、Step4。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"tip: Tip\nMTK求解时。Step3、Step4由程序完成。","category":"page"},{"location":"Optimization/1-优化的概念/#优化的概念","page":"优化的概念","title":"优化的概念","text":"","category":"section"},{"location":"Optimization/1-优化的概念/#优化简介","page":"优化的概念","title":"优化简介","text":"","category":"section"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"优化，也称为数学规划，是数学中的一个分支领域，旨在找到最佳解决方案或最优化的决策。它涉及到在给定的约束条件下，通过最小化或最大化一个或多个目标函数来寻找最优解。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"优化问题可以在各种领域中应用，包括工程、经济学、物理学、计算机科学等。在实际应用中，我们常常面临资源有限的情况下，需要找到一种最佳分配方式。优化问题的目标是通过利用现有资源最大限度地满足需求或实现特定目标。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"数学规划可以分为线性规划、非线性规划、整数规划、动态规划等不同类型。线性规划是优化问题中最常见的类型，其中目标函数和约束条件都是线性的。非线性规划则涉及到目标函数或约束条件中包含非线性项。整数规划要求决策变量取整数值。动态规划则涉及到一系列决策问题，其中每个决策都会影响到后续决策的结果。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"为了解决优化问题，需要使用数学工具和算法来分析和计算最佳解。这些工具和算法可以根据具体问题的特征选择，例如简单的问题可以使用暴力搜索方法，复杂的问题可能需要使用高级的数值优化算法，如线性规划算法、梯度下降算法、遗传算法等。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"总之，优化是数学中研究如何在给定约束条件下找到最佳解决方案或最优化决策的领域。它在实际应用中具有广泛的应用价值，并且需要使用数学方法和算法来解决。","category":"page"},{"location":"Optimization/1-优化的概念/#一个Julia例子","page":"优化的概念","title":"一个Julia例子","text":"","category":"section"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"下面是一个使用Julia语言解决线性规划问题的简单例子：","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"using JuMP\nusing GLPK\n\n# 创建一个线性规划模型\nmodel = Model(with_optimizer(GLPK.Optimizer))\n\n# 定义决策变量\n@variable(model, x >= 0)  # 非负变量 x\n\n# 定义目标函数\n@objective(model, Max, 2x + 3)\n\n# 添加约束条件\n@constraint(model, 1x <= 4)\n@constraint(model, 2x >= 1)\n\n# 求解优化问题\noptimize!(model)\n\n# 输出结果\nprintln(\"最优解: x = \", value(x))\nprintln(\"最优目标值: \", objective_value(model))","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"在这个例子中，我们使用了JuMP包来建立优化模型，并使用GLPK包作为优化器。我们定义了一个决策变量x，它必须是非负的。然后，我们定义了目标函数2x + 3，希望最大化这个目标函数。最后，我们添加了两个约束条件：x小于等于4，2x大于等于1。通过调用optimize!函数，我们可以求解出最优解，并使用value函数获取变量的取值，objective_value函数获取最优目标值。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"这只是一个简单的例子，实际的优化问题可能会涉及更多的变量和约束条件，以及复杂的目标函数。Julia语言提供了丰富的优化工具和包，可以灵活地处理各种类型的优化问题。","category":"page"},{"location":"Optimization/1-优化的概念/#一个GAMS的例子","page":"优化的概念","title":"一个GAMS的例子","text":"","category":"section"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"下面是一个使用GAMS（General Algebraic Modeling System）解决线性规划问题的示例：","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"SET i /1*3/;\nPARAMETER c(i) '系数';\nc(i) = 2, 3, 4;\n\nVARIABLES x(i) '决策变量';\n\nEQUATIONS obj '目标函数' \n          constraint1 '约束条件1' \n          constraint2 '约束条件2';\n\nobj.. sum(i, c(i)*x(i)) =E= 0;  // 目标函数\n\nconstraint1.. sum(i, x(i)) =L= 10;  // 约束条件1\n\nconstraint2.. x('2') + x('3') =G= 5;  // 约束条件2\n\nMODEL LinearProgrammingModel /all/;\n\nSOLVE LinearProgrammingModel USING LP MAXIMIZING x;\n\nDISPLAY x.l, obj.l;","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"在这个例子中，我们使用GAMS建立了一个线性规划模型。首先，我们定义了一个集合i，其中包含了三个元素。然后，我们定义了一个参数c(i)，它包含了系数值。接下来，我们声明了一个变量x(i)，它是我们的决策变量。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"然后，我们定义了三个方程：obj（目标函数）、constraint1（约束条件1）和constraint2（约束条件2）。目标函数是求解的目标，约束条件限制了变量的取值范围。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"在GAMS中，我们使用\"E=\"表示等式约束，\"L=\"表示小于等于约束，\"G=\"表示大于等于约束。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"接下来，我们定义了一个名为LinearProgrammingModel的模型，并使用LP（线性规划）求解器进行求解。通过使用MAXIMIZING关键字，我们指定了求解最大化目标函数。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"最后，我们使用DISPLAY命令来显示变量x和目标函数的取值（x.l和obj.l）。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"这只是一个简单的示例，GAMS提供了更多高级功能和约束类型来处理各种优化问题。通过使用GAMS语言和相应的求解器，您可以更灵活地定义和求解复杂的优化模型。","category":"page"},{"location":"Optimization/1-优化的概念/#一个Pyomo的例子","page":"优化的概念","title":"一个Pyomo的例子","text":"","category":"section"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"下面是一个使用Pyomo库解决线性规划问题的示例：","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"from pyomo.environ import *\n\n# 创建一个具体模型\nmodel = ConcreteModel()\n\n# 定义决策变量\nmodel.x = Var([1, 2, 3], domain=NonNegativeReals)\n\n# 定义目标函数\nmodel.obj = Objective(expr=2 * model.x[1] + 3 * model.x[2], sense=maximize)\n\n# 添加约束条件\nmodel.constraint1 = Constraint(expr=sum(model.x[i] for i in [1, 2, 3]) <= 10)\nmodel.constraint2 = Constraint(expr=model.x[2] + model.x[3] >= 5)\n\n# 求解优化问题\nsolver = SolverFactory('glpk')\nresult = solver.solve(model)\n\n# 输出结果\nprint(\"最优解：\")\nfor i in [1, 2, 3]:\n    print(f\"x[{i}] = {model.x[i].value}\")\n\nprint(\"最优目标值：\", model.obj())","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"在这个例子中，我们使用Pyomo库创建了一个具体模型。我们定义了决策变量model.x，它是一个字典变量，包含了三个非负实数变量。然后，我们定义了目标函数model.obj，使用maximize指定了最大化的目标。接下来，我们添加了两个约束条件model.constraint1和model.constraint2。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"然后，我们选择了一个求解器（在这个例子中是GLPK）来求解优化问题。通过调用solver.solve(model)，我们可以求解出最优解。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"最后，我们使用model.x[i].value获取变量x的取值，并使用model.obj()获取最优目标值。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"Pyomo提供了丰富的建模语言和优化求解功能，可以用于解决各种优化问题。通过定义变量、目标函数和约束条件，并选择适当的求解器，您可以使用Pyomo库解决复杂的优化问题。","category":"page"},{"location":"Optimization/1-优化的概念/#决策变量、约束与目标函数","page":"优化的概念","title":"决策变量、约束与目标函数","text":"","category":"section"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"在优化问题中，决策变量、约束和目标函数是三个核心概念。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"决策变量（Decision Variables）：","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"决策变量是在优化问题中我们希望确定的未知量或可调节量。它们表示问题的决策或选择，我们希望找到一组合适的取值来达到优化的目标。决策变量可以是实数、整数或离散值，具体取决于问题的特性和要求。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"在优化模型中，我们通常会明确定义决策变量的名称、类型（如连续型变量、整数变量等）以及可能的取值范围。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"约束（Constraints）：","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"约束是对决策变量的限制条件，它们反映了问题的约束性质和限制条件。约束条件用于限制决策变量的取值范围，确保最优解满足问题的要求。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"约束可以包括等式约束（如等于某个常数）、不等式约束（如大于等于某个常数或小于等于某个常数）、范围约束（如取值在某个范围内）等。这些约束条件反映了问题的实际限制和约束条件。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"目标函数（Objective Function）：","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"目标函数是在优化问题中需要最小化或最大化的函数。它表示我们所追求的目标或效用，是问题的评价标准。目标函数的设计取决于具体的问题和我们希望达到的优化目标。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"在优化模型中，我们通常需要明确定义目标函数的表达式和优化方向（最小化或最大化）。目标函数可以是线性函数、非线性函数或其他复杂的函数形式。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"优化问题中的目标函数通常是要最小化或最大化的量。最常见的情况是将问题转化为最小化问题，因为很多优化算法都是针对最小化问题设计的，并且在数学上也更加方便处理。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"在机器学习中，损失函数用于衡量模型预测结果与真实值之间的差异，而目标是通过调整模型参数来最小化损失函数。因此，机器学习中的优化问题可以看作是通过最小化损失函数来优化模型的参数。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"当然，并非所有的优化问题都要求最小化目标函数。有些问题可能要求最大化目标函数，例如某些最大化利润的问题或最大化模型的某个指标（如准确率）的问题。在这种情况下，可以通过取目标函数的负值来将其转化为最小化问题。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"总而言之，无论是优化问题还是机器学习中的损失函数，最常见的做法是将其转化为最小化问题，以便使用适用于最小化问题的优化算法进行求解。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"优化问题的目标是找到一组决策变量的取值，使得目标函数最优，并且满足所有的约束条件。优化算法通过在决策变量的可行区域内搜索，调整决策变量的取值，以逐步接近或达到最优解。决策变量的取值必须同时满足所有的约束条件，并使得目标函数达到最优值。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"因此，决策变量、约束和目标函数是构建和描述优化问题的重要组成部分，通过合理定义和约束它们，我们可以建立数学模型，并通过求解算法找到最佳解决方案。","category":"page"},{"location":"Optimization/1-优化的概念/#单目标优化与多目标优化","page":"优化的概念","title":"单目标优化与多目标优化","text":"","category":"section"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"单目标优化（Single-Objective Optimization）和多目标优化（Multi-Objective Optimization）是两种不同的优化问题类型，它们在目标函数的数量和优化目标的角度上存在差异。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"单目标优化： 单目标优化是指在优化问题中只有一个目标函数需要最小化或最大化。在单目标优化中，我们试图找到一个解决方案，使得目标函数达到最优值，同时满足约束条件。单目标优化可以用来解决各种问题，例如线性规划、非线性规划和整数规划等。\n在单目标优化中，问题的关注点集中在一个单一的目标上。优化算法通过在决策变量空间中搜索，找到使得目标函数最优的解决方案。常见的单目标优化算法包括梯度下降、遗传算法、粒子群优化等。\n多目标优化： 多目标优化是指在优化问题中存在多个冲突的目标函数需要最小化或最大化。在多目标优化中，我们试图找到一组解决方案，这些解决方案形成了一个“帕累托前沿”（Pareto Front），其中没有一个解决方案可以在所有目标上优于其他解决方案。\n多目标优化的目标是寻找一组解决方案，这些解决方案代表了不同的权衡和取舍。这些解决方案通常称为非支配解（Non-Dominated Solutions），它们在不同的目标之间形成了一种平衡。多目标优化的关键是通过搜索和评估决策变量空间中的多个解来构建帕累托前沿。\n多目标优化算法包括多目标遗传算法、多目标粒子群优化、多目标模拟退火等。这些算法旨在寻找一组尽可能好的非支配解，并提供一系列可行的解决方案供决策者选择。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"在实际问题中，我们需要根据具体情况来确定是使用单目标优化还是多目标优化。如果问题只涉及一个主要目标，那么单目标优化可能更适合。而如果问题涉及到多个相互关联的目标，并且需要权衡不同的目标之间的取舍，那么多目标优化更适合。","category":"page"},{"location":"Optimization/1-优化的概念/#一个真实的问题","page":"优化的概念","title":"一个真实的问题","text":"","category":"section"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"问题描述： 我们要制造一个圆柱形的水罐，要求它的体积固定为V（已知值），而制造成本最低。制造成本与所需钢材的面积成正比。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"解决方案： 为了解决这个问题，我们可以使用优化方法来确定水罐的尺寸，使得制造成本最低。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"决策变量：","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"R：水罐底部的半径（决策变量）\nH：水罐的高度（决策变量）","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"目标函数： 制造成本（目标函数）：由于制造成本与所需钢材的面积成正比，我们可以将制造成本定义为钢材的面积，即成本 = π * R^2 + 2 * π * R * H。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"约束条件：","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"水罐的体积（约束条件）：V = π * R^2 * H，这个约束条件确保水罐的体积固定为V。\n尺寸的非负性（约束条件）：R >= 0，H >= 0，这些约束条件确保水罐的尺寸非负。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"通过求解这个优化问题，我们可以找到最佳的水罐尺寸，使得制造成本最低。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"请注意，这个例子只是简化的示例，实际的问题可能还涉及其他约束条件和考虑更多的实际因素。例如，我们可能还需要考虑材料的可获得性、制造工艺的限制等等。","category":"page"},{"location":"Optimization/1-优化的概念/#再来一个例子","page":"优化的概念","title":"再来一个例子","text":"","category":"section"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"问题描述： 某商店有一个仓库，店主有一定的本钱，他可以购买棉花和钢材以售出以获得收益。希望通过合理购买和销售来最大化收益。然而，仓库有一定的容量限制，而棉花和钢材的购买受到店主本钱和仓库容量的限制。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"解决方案： 为了解决这个问题，我们可以使用优化方法来确定棉花和钢材的购买量，使得收益最大化。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"决策变量：","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"x1：购买的棉花质量（决策变量）\nx2：购买的钢材质量（决策变量）","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"目标函数： 收益（目标函数）：收益由售出的棉花和钢材所得，即收益 = p1o * x1 + p2o * x2，其中p1o和p2o分别为棉花和钢材的售价。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"约束条件：","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"仓库容量约束（约束条件）：v1 * x1 + v2 * x2 <= C，这个约束条件确保购买的棉花和钢材的总体积不超过仓库的容量C。其中v1和v2分别为单位质量棉花和钢材的体积。\n本钱约束（约束条件）：p1 * x1 + p2 * x2 <= B，这个约束条件确保购买棉花和钢材的成本不超过店主的本钱B。其中p1和p2分别为单位质量棉花和钢材的进价。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"通过求解这个优化问题，我们可以找到最佳的购买方案，使得收益最大化。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"请注意，这个例子只是简化的示例，实际的问题可能还涉及其他约束条件、售价变动、销售量的考虑等等。此外，还需要考虑市场需求、供应量等因素来更全面地建模和求解这个优化问题。","category":"page"},{"location":"JuliaIntro/1-julia的安装/#julia的安装","page":"julia的安装","title":"julia的安装","text":"","category":"section"},{"location":"JuliaIntro/1-julia的安装/#julia简介","page":"julia的安装","title":"julia简介","text":"","category":"section"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"Julia是一种高性能、动态的编程语言，旨在提供与传统科学计算语言（如Matlab）和通用编程语言（如Python）相媲美的性能。它是为解决科学计算和数据分析中的复杂问题而设计的。Julia的特点包括易于使用、动态类型、即时编译和可扩展性。","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"Julia的语法类似于其他科学计算语言，如Matlab和Python，但它引入了一些独特的特性。它支持向量化操作和广播，使得处理数组和矩阵等数据结构变得更加高效和简洁。Julia还具有强大的类型推导功能，可以根据代码上下文自动推断变量类型，从而提高执行速度。","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"Julia拥有丰富的科学计算和数据分析库，包括线性代数、统计学、优化、图形化等方面的工具。这些库使得使用Julia进行科学研究和数据分析变得非常方便。","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"要开始学习Julia，你可以安装Julia的最新版本并打开交互式终端。在Julia的REPL（Read-Eval-Print Loop）中，你可以直接输入和执行Julia代码。Julia的官方网站提供了大量的学习资源，包括官方文档、教程和示例代码，这些资源可以帮助你快速入门并掌握Julia的基础知识。","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"总之，Julia是一个强大而灵活的科学计算语言，它通过提供高性能和易用性的组合，为科学家、工程师和数据分析师提供了一种有效的工具来解决复杂的计算问题。","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"希望这段介绍能帮助到你！如有任何进一步的问题，我会尽力回答。","category":"page"},{"location":"JuliaIntro/1-julia的安装/#安装Julia","page":"julia的安装","title":"安装Julia","text":"","category":"section"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"Julia官方提供了免安装的绿色版本，也被称为Julia的二进制预编译版本。以下是安装Julia的步骤：","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"访问Julia官方网站：https://julialang.org/downloads/，在\"Current release\"下找到适合您操作系统的版本。点击下载按钮。\n在下载页面中，您可以选择不同的操作系统和体系结构，选择与您的系统匹配的版本。\n一旦下载完成，您将得到一个压缩文件（.tar.gz或.zip）。将其解压缩到您喜欢的位置，比如您的桌面或特定的文件夹。\n解压缩后，您将看到一个名为\"julia-x.y.z\"（x.y.z代表版本号）的文件夹。进入该文件夹，然后进入\"bin\"子目录。\n在\"bin\"目录中，您可以找到可执行文件\"julia\"（Windows上可能是\"julia.exe\"）。您可以直接运行该文件，它将启动Julia的REPL（交互式终端）。","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"现在您已经成功地安装了免安装的绿色版本的Julia，并可以开始在REPL中编写和执行Julia代码了。","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"请注意，虽然免安装的绿色版本不需要进行传统的安装过程，但它并没有集成到您的系统路径中。这意味着您需要手动指定Julia的路径，或者将其添加到系统路径中，以便在任何位置都能够访问Julia。","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"当使用免安装的绿色版本的Julia时，您可能需要手动将Julia的路径添加到系统的环境变量中，这样您就可以在任何位置使用\"julia\"命令来启动Julia。以下是添加环境变量的操作：","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"打开系统的环境变量设置。具体操作方式可能因不同的操作系统而异：\n在Windows上，右键点击\"计算机\"（或\"此电脑\"），选择\"属性\"，然后点击\"高级系统设置\"。在弹出窗口中，点击\"环境变量\"按钮。\n在Mac上，打开\"终端\"应用程序，然后输入命令\"nano ~/.bash_profile\"来编辑bash配置文件。\n在Linux上，打开终端，并编辑~/.bashrc或~/.bash_profile文件，具体命令取决于您使用的Linux发行版。\n在环境变量设置中，找到\"PATH\"变量，并进行编辑。\n在\"PATH\"变量的值中，添加Julia的路径。路径应指向Julia的\"bin\"目录，该目录中包含可执行文件\"julia\"（在Windows上可能是\"julia.exe\"）。\n例如，在Windows上，您可以将路径添加为：C:\\path\\to\\julia\\bin 在Mac和Linux上，您可以将路径添加为：/path/to/julia/bin\n请确保将上述路径替换为实际的Julia安装路径。\n保存更改并关闭编辑器或终端窗口。\n重新启动终端或命令提示符，以使环境变量的更改生效。","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"现在，您应该能够在任何位置使用\"julia\"命令来启动Julia了。","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"请注意，以上步骤可能因操作系统和个人设置而有所不同。如果您遇到任何问题，请参考您所使用的操作系统的文档或进行相关的在线搜索。","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"希望这可以帮助您成功地添加Julia到系统的环境变量中！如果您有任何其他问题，请随时向我提问。","category":"page"},{"location":"JuliaIntro/1-julia的安装/#安装vscode以及julia插件","page":"julia的安装","title":"安装vscode以及julia插件","text":"","category":"section"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"当然！以下是安装Visual Studio Code（简称VS Code）以及Julia插件的步骤：","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"访问VS Code官方网站：https://code.visualstudio.com/。\n点击网页上的\"Download\"按钮，选择适用于您的操作系统的版本，并下载安装程序。\n执行安装程序，并按照提示进行安装。在安装过程中，您可以选择是否将VS Code添加到系统的环境变量中，以便您可以从任何位置使用\"code\"命令来启动VS Code。\n安装完成后，打开VS Code。您将看到一个简洁的编辑器界面。\n在VS Code的扩展市场中，搜索并安装Julia插件。您可以通过按下Ctrl+Shift+X（Windows和Linux）或Command+Shift+X（Mac）来打开扩展视图，然后在搜索框中输入\"Julia\"进行搜索。选择\"Julia\"插件，并点击\"Install\"按钮进行安装。\n安装完成后，您将可以在VS Code中使用Julia插件。插件提供了语法高亮、代码补全、调试支持等功能，使您更方便地编写和调试Julia代码。\n要开始使用Julia插件，请打开一个Julia源代码文件（后缀为\".jl\"），然后使用VS Code的编辑器功能来编写代码。Julia插件将会根据Julia语法和上下文提供相应的功能和建议。","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"请注意，安装Julia插件之前，确保您已经成功安装了Julia，并将其路径添加到系统的环境变量中（之前提到的步骤）。这样Julia插件才能正常与Julia进行交互。","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"希望这可以帮助您安装VS Code以及Julia插件！如果您有任何进一步的问题，请随时向我提问。","category":"page"},{"location":"JuliaIntro/1-julia的安装/#vscode中Julia插件的使用","page":"julia的安装","title":"vscode中Julia插件的使用","text":"","category":"section"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"当您在Visual Studio Code（VS Code）中安装并启用了Julia插件后，以下是一些常用的操作和功能：","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"打开Julia文件：使用VS Code的文件菜单或快捷键（Ctrl+O）打开一个Julia源代码文件（后缀为\".jl\"）。\n代码编辑功能：在Julia文件中，您可以使用VS Code的丰富编辑功能，如语法高亮、自动缩进、括号匹配等。\n代码补全：在您键入代码时，Julia插件会根据上下文和库函数提供代码补全建议。您可以使用Tab键或Enter键来接受建议。\n函数签名和参数提示：当您输入函数名称时，Julia插件会显示函数的签名和参数信息。您可以按下Tab键或Enter键来接受函数的参数提示。\n文档查看：通过将光标停留在Julia函数或变量上，按下Ctrl键并单击鼠标，或使用快捷键（Ctrl+K Ctrl+I），可以查看函数或变量的文档字符串。\n调试支持：Julia插件提供了调试功能，使您能够在VS Code中调试Julia代码。您可以设置断点、逐行执行代码，并查看变量的值和堆栈信息。\nJulia REPL：Julia插件内置了一个交互式的Julia REPL终端。您可以使用快捷键（Ctrl+Shift+P）打开命令面板，然后输入\"Julia: Start REPL\"来启动Julia REPL。在REPL中，您可以输入和执行Julia代码，并查看输出结果。\n任务和构建：您可以使用VS Code的任务功能来执行Julia脚本或运行Julia项目。通过创建一个\"tasks.json\"文件并定义相应的任务，您可以方便地执行Julia代码。","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"这些是Julia插件中的一些常见操作和功能。请注意，插件的功能和操作方式可能会有所变化，因此建议查阅Julia插件的文档以获取更详细的信息。","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"希望这些介绍有助于您在VS Code中使用Julia插件！如有任何进一步的问题，请随时向我提问。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/#以SAM为例实操","page":"以SAM为例实操","title":"以SAM为例实操","text":"","category":"section"},{"location":"CSBase/7-以SAM为例整体实操一下/#SAM是什么","page":"以SAM为例实操","title":"SAM是什么","text":"","category":"section"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"NREL (National Renewable Energy Laboratory) 的 SAM (System Advisor Model) 是一个广泛应用于可再生能源系统分析和评估的计算工具。SAM 可以帮助研究人员、工程师和政策制定者评估各种可再生能源项目的技术和经济可行性。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM 提供了一系列模块，涵盖了太阳能、风能、生物质能、地热能等多个可再生能源技术。使用 SAM，用户可以建立虚拟的可再生能源项目，并对其进行系统级的模拟和分析。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM 的主要功能包括：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"建模工具：SAM 提供了丰富的建模工具，可以创建和配置各种可再生能源系统。用户可以定义系统的组件、能源资源、电网连接等。\n技术性能模型：SAM 包含了各种可再生能源技术的技术性能模型，例如太阳能光伏电池板的发电模型、风力涡轮机的功率曲线等。这些模型基于广泛的实验数据和经验，并提供了高精度的技术性能预测。\n资金成本模型：SAM 还提供了成本模型，可以帮助用户估算可再生能源项目的资金成本。这些成本模型包括设备成本、建设成本、运营维护成本等。\n经济性分析：SAM 可以对可再生能源项目进行经济性分析，包括计算项目的净现值、内部收益率、年均收益等经济指标。这有助于评估项目的可行性和经济效益。\n市场分析：SAM 还提供了市场分析模块，可以评估可再生能源项目在不同市场条件下的竞争力和盈利潜力。用户可以模拟不同的电力市场、能源政策和投资条件，以了解项目在不同情景下的表现。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM的GitHub地址是：https://github.com/nrel/SAM","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"关于NREL和SAM的官方网站，您可以访问以下链接获取更多信息：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"NREL官方网站：https://www.nrel.gov/","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM官方网站：https://sam.nrel.gov/","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"总而言之，NREL 的 SAM 是一个功能强大的可再生能源系统分析工具，可以帮助用户评估和优化可再生能源项目的技术性能、经济可行性和市场前景。它在可再生能源领域的研究、工程设计和政策制定中发挥了重要作用。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/#SAM的组件构成","page":"以SAM为例实操","title":"SAM的组件构成","text":"","category":"section"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM的组件构成主要包括以下几个部分：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SSC（SAM Simulation Core）：SSC是SAM的内核，是一个用C++编写的计算引擎。它提供了可再生能源系统模拟和分析的核心功能，包括模型计算、数据处理和结果生成等。SSC负责处理技术性能模型、成本模型、经济模型等方面的计算。\nGUI（Graphical User Interface）：SAM的GUI是一个可视化界面，提供了图形化的用户界面，使用户可以通过交互方式创建、配置和分析可再生能源项目。GUI简化了输入参数的设置和结果的可视化，使用户更方便地使用SAM进行建模和分析。\nSDK（Software Development Kit）：SDK是一个开发工具包，用于扩展SAM的功能和自定义模块。SDK提供了一组API和文档，使开发人员可以根据自己的需求开发新的模型、算法或工具，并与SAM进行集成。\nDatasets：SAM还包括一系列数据集，用于提供输入参数和参考数据。这些数据集包括天气数据、设备性能数据、成本数据等，可以帮助用户进行准确的模拟和分析。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"综上所述，SAM的核心是SSC，它提供了计算引擎和模型库，支持可再生能源系统的建模和分析。GUI提供了图形化界面，使用户可以通过可视化方式操作SAM。SDK则允许开发人员进行功能扩展和定制化开发。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/#SAM的windows下的编译过程","page":"以SAM为例实操","title":"SAM的windows下的编译过程","text":"","category":"section"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"当使用SAM进行编译时，以下是SAM的编译过程的基本步骤和解释：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"源代码收集：首先，需要获取SAM的源代码。您可以从SAM的GitHub存储库中获取源代码，并将其下载到本地计算机中。\n依赖项安装：在编译之前，需要安装SAM所需的依赖项和开发工具。这些依赖项可能包括编译器、构建工具、库文件等。您可以查阅SAM的文档或README文件，了解所需的依赖项和安装说明，并确保在编译之前正确安装它们。\n配置编译环境：为了成功编译SAM，您需要配置适当的编译环境。这可能包括设置编译器选项、环境变量、路径设置等。根据您的操作系统和编译工具，您可能需要执行一些特定的设置步骤。确保按照指南进行正确的环境配置。\n构建项目：一旦环境配置完成，您可以开始构建SAM项目。这通常涉及使用构建工具（如Makefile或CMake）执行构建命令。构建过程会编译源代码文件，并将它们转换为可执行文件或库文件。构建过程可能需要一些时间，具体取决于项目的规模和计算机的性能。\n编译错误解决：在编译过程中，可能会出现错误或警告。这些错误可能是由于缺少依赖项、语法错误、库文件问题等引起的。如果出现编译错误，您需要仔细阅读错误消息，并在代码中找到并修复问题。通常，错误消息会提供有关问题所在的线索，例如错误的行号或函数名称。\n构建成功：一旦编译过程成功完成，您将获得SAM的可执行文件或库文件。这些文件可以用于在您的计算机上运行SAM，并开始使用它的功能。确保验证编译的结果，并根据需要进行必要的配置和安装。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"通过以上步骤，您可以通过SAM的编译过程理解程序编译的 step by step 流程。请注意，编译过程可能因操作系统、编译工具和项目的特定要求而有所差异。因此，建议您参考SAM的文档和指南，以获取针对SAM的具体编译说明和最佳实践。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"这里是Windows下如何编译SAM的官方说明。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"以下是其中文翻译： Windows构建说明","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"这些说明适用于在您的计算机上设置构建SAM Windows版本所需的几个开源C++代码库。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"更新于2022年7月","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"概述 构建工具 要构建SAM，您需要构建CMake、wxWidgets和Google Test：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"CMake是一套用于构建软件的工具集：https://cmake.org/。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"wxWidgets是一个用于开发用户界面的平台：https://www.wxwidgets.org。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"Google Test是一个C++测试框架：https://github.com/google/googletest。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"版本控制和协作 SAM的代码存储库存储在GitHub.com上，因此您需要使用Git进行工作的工具。这些说明假设您已经安装了Git并熟悉它。（如果您需要使用Git进行SAM的帮助，请参阅此基本教程。）","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"Git是版本控制和协作软件：https://git-scm.com/ 源代码 构建SAM所需的C++和其他代码存储在GitHub.com上的LK、WEX、SSC和SAM存储库中：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"LK是SAM的内置LK脚本语言：https://github.com/nrel/lk。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"WEX包含了对wxWidgets的自定义用户界面增强功能：https://github.com/nrel/wex。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SSC是用于SAM性能和财务模型的代码：https://github.com/nrel/ssc。（SSC API和PySAM Python软件包提供了对SSC的访问权限，供其他软件应用程序使用。）","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM是用于SAM用户界面的代码：https://github.com/nrel/SAM。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM-private存储库包含了SAM官方NREL版本的代码。只有在与NREL的SAM软件开发团队合作构建官方NREL版本的SAM时，才需要这些代码。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM-private是用于用户注册、欢迎页面、Web API密钥和其他SAM官方NREL版本的功能的代码：https://github.com/nrel/SAM-private。 开发和修补分支 每个存储库的Develop分支包含最新的代码。如果您要贡献代码，应从该分支开始工作。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"每个存储库的Patch分支在发布新版本的SAM后的几个月内处于活动状态。在此期间，如果您要贡献代码以更新当前版本，应从Patch分支开始工作。（完成和批准工作后，应将Patch分支合并到Develop分支。）","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"GitHub.com上的默认分支为Develop，除了在更新期间，此时默认分支设置为Patch。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM版本的标签 要构建特定版本的SAM，可以检出该版本的标签。请参阅此标签列表，了解SAM、SSC、WEX和LK的不同版本。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"总体构建步骤 整个设置和构建过程应该需要1到2个小时，具体取决于您选择每个步骤的选项和互联网下载速度。计算机设置完成后","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"，首次构建SAM可能需要几分钟时间。后续构建速度较快，具体取决于构建选项以及在构建之前修改的代码量。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"下载并安装Visual Studio Community 2022（10分钟，需要Microsoft账户和计算机重新启动）。\n下载并构建wxWidgets 3.2.0（10分钟）。\n下载并安装CMake 3.24或更高版本（5分钟）。\n克隆并构建Google Test（需要CMake）（5分钟）。\n克隆SAM代码存储库（根据互联网速度，可能需要10-20分钟）。\n设置环境变量（5分钟）。\n为Visual Studio生成SAM项目文件（需要CMake）（5分钟）。\n构建SAM（对于SAMOS的干净构建需要10分钟，构建所有项目需要更长时间）。\n测试构建结果。\n1.下载并安装Visual Studio Community 2022\n如果您的计算机上尚未安装Visual Studio Community 2022 (VS 2022)，请从https://visualstudio.microsoft.com/下载并安装。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"使用VS 2022需要一个免费的Microsoft账户，当您首次启动程序时，系统会提示您创建或输入账户。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"运行Visual Studio安装程序，并选择以下三个工作负载：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"C++桌面开发\nPython开发（用于SAM与Python的集成）\nC++ Linux和嵌入式开发（用于CMake）","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果您的计算机上安装了其他版本的Visual Studio，您可以与其他版本并存安装和运行VS 2022。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"启动VS 2022并登录到您的Microsoft账户或创建一个新账户。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"下载并构建wxWidgets 3.2.0","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM的用户界面使用的是wxWidgets 3.2.0，这是截至2022年7月7日的最新稳定版本。其他版本的wxWidgets可能与SAM兼容也可能不兼容。您可以从https://www.wxwidgets.org/downloads/下载不同版本的wxWidgets。在页面底部的\"Other Downloads\"下的GitHub Release Archive中，提供了以前的版本。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"从https://github.com/wxWidgets/wxWidgets/releases/tag/v3.2.0下载Windows源代码，可以选择ZIP或7Z文件。将文件解压到计算机上的一个文件夹中，例如c:/wxWidgets-3.2.0。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"启动VS 2022并打开c:/wxWidgets-3.2.0/build/msw/wx_vc17.sln解决方案文件。该目录中有适用于其他版本的Visual Studio的项目文件，因此请确保打开vc17文件。vc17解决方案适用于VS 2022。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"构建64位的Debug和Release版本：在VS 2022的工具栏中，选择Release配置和x64平台，然后按F7键或从Build菜单中选择Build Solution。构建完成后，选择Debug x64并进行构建（24个项目都要构建）。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果构建成功，您应该会看到构建了24个项目成功的消息。在c:/wxWidgets-3.2.0/build/msw中，您还应该看到vcx64-mswu和vcx64-mswud文件夹，每个文件夹中都有几个文件夹和.pch文件。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"下载并安装CMake","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM需要CMake 3.24或更高版本来为Windows、Linux和Mac生成构建文件。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"从https://cmake.org/download/下载最新版本的Windows x64安装程序。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"运行安装程序，按照提示安装CMake，并勾选“将CMake添加到系统路径中”选项，可以选择单个用户或所有用户。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"安装程序应自动将C:/Program Files/CMake/bin添加到Windows系统路径中。要验证，请在Windows开始菜单中输入\"env\"，打开\"环境变量\"窗口，双击系统变量下的Path变量。如果路径列表中没有该路径，您可以手动添加。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"4.克隆并构建Google Test SAM的代码存储库依赖于Google Test C++单元测试框架。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"从https://github.com/google/googletest.git克隆Google Test。在命令窗口中执行以下命令：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"cd path/to/my/repos\ngit clone https://github.com/google/googletest.git","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"在问题https://github.com/NREL/ssc/issues/806解决之前，切换到提交b85864c64758dec007208e56af933fc3f52044ee：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"cd path/to/googletest\ngit checkout b85864c64758dec007208e56af933fc3f52044ee","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"这样就会显示HEAD is now at b85864c6 Eliminate the legacy GTESTCOMPILEASSERT_ macro.（这个问题如果已经解决，则不需要进行上述步骤，文件会直接被完整克隆下来）","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"进入包含ci、docs、googlemock和googletest的顶级googletest文件夹，并创建一个build文件夹（也可以通过鼠标在对应位置创建文件夹）：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"mkdir path/to/googletest/build","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"进入刚创建的build文件夹（建议创建文件夹的位置与示例相同，如果不同，进行命令行操作时，注意要输入与之相对应的正确路径）：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"cd path/to/googletest/build 运行CMake生成Visual Studio项目文件：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"请注意，在CMake命令的末尾使用两个句点..，以确保命令能够找到父文件夹中的CMakeLists.txt文件。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"cmake -G \"Visual Studio 17 2022\" -DCMAKE_CONFIGURATION_TYPES=\"Release;Debug\" -Dgtest_force_shared_crt=ON ..","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果CMake成功，您应该会看到path/to/googletest/build/googletest/gtest.sln文件。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"在VS 2022中打开gtest.sln文件，并构建x64的Debug和Release配置（步骤同第二步wxWidgets的配置）。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果构建成功，您应该会在path/to/googletest/build/lib中看到包含gtest.lib等文件的Release和Debug文件夹。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"克隆SAM代码存储库","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"创建一个父文件夹来存储这些存储库，例如path/to/sam_dev：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"mkdir path/to/sam_dev","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"将每个存储库克隆到父文件夹中。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"cd path/to/sam_dev","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"git clone https://github.com/nrel/lk","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"git clone https://github.com/nrel/wex","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"git clone https://github.com/nrel/ssc","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"git clone https://github.com/nrel/sam","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果您可以访问SAM-private存储库以构建官方的NREL版本的SAM，请选择使用Web浏览器身份验证方式验证您的GitHub.com账户是否有权访问该存储库：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"git clone https://github.com/nrel/sam-private","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"设置环境变量","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM的构建工具使用Windows环境变量来确定它所需文件在计算机上的存储位置。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"关闭任何打开的命令窗口以及正在运行的VS 2022。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"打开Windows系统属性窗口，在\"高级\"选项卡上，点击\"环境变量\"，或在Windows搜索栏中输入\"env\"并点击\"编辑系统环境变量\"。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"在用户变量列表中，点击\"新建\"，并为下表中的每一项输入变量名和值。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"例如，如果您将LK存储库放在c:/samdev/lk中，您将把环境变量的名称设置为\"LKDIR\"，其值设置为\"c:/samdev/lk\"（不需要输入引号）。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"LKDIR path/to/sam_dev/lk\nWEXDIR path/to/sam_dev/wex\nSSCDIR path/to/sam_dev/ssc\nSAMNTDIR path/to/sam_dev/sam\nRAPIDJSONDIR path/to/sam_dev/ssc","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"*RAPIDJSONDIR是一个单独的环境变量，用于支持不依赖于SSC的WEX构建。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果您可以访问SAM-private存储库以构建官方的NREL版本的SAM：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"| SAMNRELDIR | path/to/sam_dev/SAM-private | | ––––– | –––––––––––––- |","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"创建以下用户变量，指向Google Test、wxWidgets和CMake的文件夹：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"GTDIR path/to/googletest\nWXMSW3 path/to/wxWidgets-3.2.0\nCMAKEBUILDDIR path/to/sam_dev/build","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"关闭系统属性窗口。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"生成 SAM Visual Studio 2022 项目文件","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"这一步是在首次构建 SAM 以及从 LK、WEX、SSC 或 SAM 存储库中添加或移除 .cpp 源文件后所需的。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"使用文本编辑器在 SAM 的父文件夹中创建一个名为 CMakeLists.txt 的 \"总体 CMake 文件\"（在我们的例子中为 path/to/sam_dev/CMakeLists.txt），其内容如下：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"cmake_minimum_required(VERSION 3.24)\n\nset(CMAKE_OSX_DEPLOYMENT_TARGET \"10.15\" CACHE STRING \"Minimum OS X deployment version\")\nif (UNIX AND NOT CMAKE_C_COMPILER)\n    set(CMAKE_C_COMPILER gcc)\n    set(CMAKE_CXX_COMPILER g++)\nendif()\n\nif(MSVC)\n    set(CMAKE_CONFIGURATION_TYPES \"Debug;Release\" CACHE STRING \"Debug and Release Builds Configured\" FORCE)\nendif()\n\nproject(system_advisor_model)\n\noption(SAMPRIVATE \"Release build of SAM\" OFF)\n\nadd_subdirectory(lk)\nadd_subdirectory(wex)\nadd_subdirectory(ssc)\nadd_subdirectory(sam)\nif (SAMPRIVATE)\n    add_subdirectory(SAM-private)\n    add_subdirectory(SAM-private/webupd)\nendif()","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"打开一个终端窗口，并在 SAM 的父文件夹中创建一个名为 build 的文件夹（path/to/sam_dev/build）。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"cd path/to/sam_dev\nmkdir build","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果这不是你第一次构建 SAM，而且你想删除旧的构建（除非你在构建过程中遇到问题或重新运行 cmake 后添加了 .cpp 文件到其中一个存储库，否则不需要删除旧的构建）：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"cd path/to/sam_dev\nrmdir /Q/S build\nmkdir build","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"现在，你应该有一个 SAM 的目录结构，它看起来像这样（对于我们的示例，这将是 path/to/sam_dev 的内容）：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"build\nlk\nsam\nssc\nwex\nCMakeLists.txt","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"进入你上面创建的 build 文件夹。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"cd path/to/sam_dev/build","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"运行 CMake 以生成 Visual Studio 解决方案和项目文件。该命令为 SAM 的开源版本构建了 Debug 和 Release 文件，这对于大多数开发任务足够了。如果要构建官方的 NREL 版本的 SAM，并/或者生成用于 PySAM 的 API 文件，请选择下面描述的适当的 CMake 选项。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"请注意，CMake 命令的末尾有两个句点 ..，以确保运行你在父文件夹中创建的 CmakeLists.txt 文件。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"cmake -G \"Visual Studio 17 2022\" -DCMAKE_CONFIGURATION_TYPES=\"Debug;Release\" -DSAM_SKIP_AUTOGEN=1 -DSAMAPI_EXPORT=0 -DSAMPRIVATE=0 -DCMAKE_SYSTEM_VERSION=10.0 ..","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"当 CMake 完成后，你应该在 path/to/samdev/build/ 文件夹中看到 systemadvisor_model.sln Visual Studio 解决方案文件以及支持文件、Debug 和 Release 文件夹，以及分别包含 SAM、","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SSC、WEX 和 LK 的文件夹等其他文件和文件夹。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果出现有关缺少文件的构建错误，请检查环境变量以确保它们被正确命名并指向正确的文件夹。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"CMake 选项:","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"请注意，每个选项在 cmake 命令中的前面都有字母 \"D\"。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"CMAKECONFIGURATIONTYPES","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"​       构建调试、发布版本或两个版本的选项。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"\"Debug\" = 为调试版本构建文件。如果你打算使用 VS 2022 的调试工具，请选择此选项。 \n\"Release\" = 为发布版本构建文件。选择此选项可在不使用 VS 2022 的调试工具的情况下运行 SAM。\n\"Debug;Release\" = 为调试和发布版本构建文件。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAMSKIPAUTOGEN","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"​       跳过从 export_config 自动生成 SAMAPI 文件。SAMAPI 文件用于 PySAM    Python 包。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"1 = 跳过 SAMAPI 文件的生成。当不需要生成 SAMAPI 文件时，使用此选项可以加快构建时间。\n0 = 重新生成文件。如果你正在向 SSC 的 Develop 或 Patch 分支提交添加、删除或修改输入或输出变量，或添加或删除计算模块的代码，请使用此选项。 ","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAMAPI_EXPORT","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"​       将 SSC 二进制文件导出到 SAMapi 文件夹。这些文件用于 PySAM Python 包。（Unix 还会编译 SAMAPI 的库文件）。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"1 = 导出二进制文件。如果你正在向 SSC 的 Develop 或 Patch 分支提交添加、删除或修改输入或输出变量，或添加或删除计算模块的代码，请使用此选项。\n0 = 不导出。当不需要构建 PySAM 文件时，使用此选项可以加快构建时间。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAMPRIVATE","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"​        为官方的 NREL 发行版本的 SAM 构建解决方案文件。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"1 = 在解决方案中包括私有 (SAM) 和开源 (SAMOS) 项目。如果你正在构建官方的 NREL 发行版本并且可以访问私有的 SAM-private 存储库，请使用此选项。\n0 = 在解决方案中只包括开源 (SAMOS) 项目。如果你正在构建 SAM 的开源版本，请使用此选项。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"CMAKESYSTEMVERSION CMake 版本号。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"（可选，但推荐）：在 path/to/sam_dev 文件夹中添加一个 .editorconfig 文件，以确保你的代码与项目标准一致的格式化。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"构建 SAM","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"启动 VS 2022，打开上一步中的 systemadvisormodel.sln 解决方案文件。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"在大多数情况下，你只需要构建 SAMOS 项目：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"在解决方案资源管理器中选择 SAMOS 项目（如果看不到解决方案资源管理器，请按 Ctrl+; 显示它）。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"从窗口顶部的工具栏中选择 Release 或 Debug。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"从“生成”菜单中选择“构建 SAMOS”（或按 Ctrl+B）。这将从 SAM、SSC、WEX 和 LK 以及其他依赖项目构建出 SAM 的可执行版本。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"构建解决方案中的所有项目比仅构建 SAMOS 需要更长时间，会创建 SDKtoool 和 TCSconsole 的可执行文件，并生成大量用于 PySAM 的 API 文件，你可能不需要。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果你有权限构建官方 NREL 版本的 SAM，并在上面的 cmake 命令中使用了 SAMPRIVATE = 1 选项，将会有两个 SAM 项目：SAMOS 是 SAM 的开源版本，而 SAM 是官方 NREL 版本的 SAM。构建 SAMOS 来测试官方版本特定的功能。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"官方版本（SAM）需要注册密钥才能运行，并包括从 SAM 用户界面下载 NSRDB 天气文件、URDB 电费数据和 Cambium 市场价格数据等功能。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"开源版本（SAMOS）可以在没有注册密钥的情况下运行。如果你想在 SAMOS 中使用下载功能，请修改 path/to/samdev/sam/src/private.h 添加有效的 API 密钥。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"默认情况下，VS 2022 的启动项目设置为 ALL_BUILD。如果你想在 VS 2022 中从“调试”菜单运行 SAM，或者按 Ctrl+F5 或 F5 键而不构建不必要的其他项目，可以将启动项目更改为 SAMOS（或 SAM，如果是官方 NREL 版本的 SAM）。要更改启动项目，请在解决方案资源管理器中右键单击项目名称（SAMOS 或 SAM），然后单击“设置为启动项目”。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果你的代码贡献涉及添加或更改输入的默认值，你应该在构建中包含 exportconfig 和 SAMapi，以更新用于 PySAM 的文件中的默认值。这需要在上面的 cmake 命令中使用 -DSAMSKIPAUTOGEN=0 和 -DSAMAPIEXPORT=1，以便这些项目在你的 Visual Studio 解决方案中可用。为了避免同时运行两个作业时的冲突，你只需要构建一个 Release 版本即可。（对于此目的来说，构建调试和发布版本是多余的，例如，没有 exportconfigd.exe。）","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"你还可以使用批量构建来选择要构建的项目：在“生成”菜单中，点击“批量生成”。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"测试构建","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"在构建解决方案后，通过启动 SAM 并运行模拟来","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"测试构建。可执行文件取决于你构建的版本：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"对于 SAM 的开源版本，请转到 path/to/sam_dev/SAM/deploy/x64 并运行 SAMOS.exe。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"对于 SAM 的官方 NREL 版本，请转到 path/to/samdev/SAM-private/buildwindows/deploy/x64 并运行 SAM.exe。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"调试版本位于相同的文件夹中，但文件名中包含 \"d\"：SAMOSd.exe 和 SAMd.exe。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"进行基本功能测试：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM 启动后，在 SAM 的欢迎页面上，点击“开始新项目”。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"选择“光伏”、“详细光伏模型”和“分布式”、“住宅业主”。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"在 SAM 窗口左下方点击“模拟”。SAM 应该运行模拟并显示结果。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"在“模拟”按钮下方点击“宏”，选择其中一个宏名称，然后点击“运行宏”或“查看代码”。你应该看到宏代码，表示 LK 构建正确。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"在“位置和资源”页面上，点击“查看数据”。一个 DView 窗口应该打开，表示 WEX 项目的 DView 构建正确。（SAM 还使用 DView 在“结果”页面上显示数据。）","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果你正在测试官方 NREL 版本，请在“位置和资源”和“电费”页面上测试下载功能。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/#小结","page":"以SAM为例实操","title":"小结","text":"","category":"section"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果不明白，请查看前面6条内容。ssc实际编译完就是ssc.dll这个动态链接库。sam额外加了gui壳，以方便用户使用。lk只是sam提供的一个脚本语言，忽略它。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/#写在最后","page":"以SAM为例实操","title":"写在最后","text":"","category":"section"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果对git不懂，请参考我们系列文档的git介绍。对cmake不懂请参考我们的make和makefile介绍。仍然不明白，请自行借助网络搜索引擎。编译完之后，把前面讲过的内容再想一想，体会一下。每一步大概都是在干啥，为什么。","category":"page"},{"location":"IotBigdataCloud/3-大数据简介/#大数据简介","page":"大数据简介","title":"大数据简介","text":"","category":"section"},{"location":"IotBigdataCloud/3-大数据简介/#大数据的框架体系","page":"大数据简介","title":"大数据的框架体系","text":"","category":"section"},{"location":"IotBigdataCloud/3-大数据简介/","page":"大数据简介","title":"大数据简介","text":"当介绍大数据时，可以覆盖以下内容：","category":"page"},{"location":"IotBigdataCloud/3-大数据简介/","page":"大数据简介","title":"大数据简介","text":"定义：解释什么是大数据。大数据是指规模庞大、复杂多样、高速生成的数据集合，无法通过传统的数据处理工具进行捕捉、管理和处理。\n特征：介绍大数据的特点。大数据通常具有四个主要特征：3V特征，即数据的体量（Volume）、速度（Velocity）、多样性（Variety），以及变化的真实性（Veracity）。\n应用领域：讨论大数据在不同领域的应用。大数据应用广泛，可以在商业、科学研究、医疗保健、金融、能源等领域发挥作用，例如市场营销分析、智能交通管理、风险评估和疾病预测等。\n数据收集与存储：介绍大数据的收集和存储方法。大数据的收集可以通过传感器、社交媒体、日志文件等多种途径进行，而存储则需要使用大数据存储技术，如分布式文件系统和数据库。\n数据处理与分析：探讨大数据的处理和分析方法。大数据处理需要使用分布式计算框架，如Apache Hadoop和Apache Spark，以及机器学习和数据挖掘算法，来从大数据中提取有价值的信息和见解。\n挑战与机遇：讨论大数据所面临的挑战和带来的机遇。挑战包括数据质量问题、隐私和安全性问题、技术复杂性等，而机遇则包括基于数据的创新、决策的优化和商业竞争力的提升等方面。\n伦理和法律问题：提及大数据伦理和法律方面的问题。大数据的使用可能涉及隐私、数据所有权、数据安全和歧视等问题，因此需要遵守相关法律法规，并确保数据使用的公平性和透明性。\n未来发展趋势：展望大数据的未来发展趋势。大数据在不断演进，包括更高级的数据分析技术、人工智能和机器学习的融合、边缘计算和云计算的结合等，将为我们带来更多的机会和挑战。","category":"page"},{"location":"IotBigdataCloud/3-大数据简介/","page":"大数据简介","title":"大数据简介","text":"通过涵盖这些内容，您可以提供一个全面的大数据介绍，并使读者对大数据的概念、应用和影响有一个初步的了解。","category":"page"},{"location":"IotBigdataCloud/3-大数据简介/","page":"大数据简介","title":"大数据简介","text":"大数据是指规模庞大、复杂多样、高速生成的数据集合，无法通过传统的数据处理工具进行捕捉、管理和处理。大数据具有以下主要特征：体量大（Volume）、速度快（Velocity）、多样性高（Variety）和变化的真实性（Veracity）。大数据的应用广泛，可以在商业、科学研究、医疗保健、金融、能源等领域发挥作用。收集大数据可以通过传感器、社交媒体、日志文件等多种途径进行，而存储则需要使用大数据存储技术，如分布式文件系统和数据库。处理大数据需要使用分布式计算框架和机器学习算法，以从大数据中提取有价值的信息和见解。大数据的使用面临一些挑战，如数据质量、隐私和安全性问题，但也带来了创新和商业机会。在未来，大数据将继续演进，包括更高级的数据分析技术、人工智能和机器学习的融合，以及边缘计算和云计算的结合，为我们带来更多机会和挑战。","category":"page"},{"location":"IotBigdataCloud/3-大数据简介/#大数据的核心技术","page":"大数据简介","title":"大数据的核心技术","text":"","category":"section"},{"location":"IotBigdataCloud/3-大数据简介/","page":"大数据简介","title":"大数据简介","text":"MapReduce是大数据处理中的核心技术之一，它是一种用于处理和分析大规模数据集的编程模型。除了MapReduce，还有其他一些核心技术在大数据领域中发挥着重要作用。以下是几个关键的大数据核心技术：","category":"page"},{"location":"IotBigdataCloud/3-大数据简介/","page":"大数据简介","title":"大数据简介","text":"分布式存储系统：大数据需要有效的存储解决方案来处理大规模数据的存储需求。分布式存储系统如Apache Hadoop的Hadoop分布式文件系统（HDFS）和云存储平台如Amazon S3等，能够可靠地存储大数据并实现数据的高可用性和容错性。\n分布式计算框架：大数据处理需要强大的计算能力来处理庞大的数据集。分布式计算框架如Apache Hadoop的MapReduce、Apache Spark和Apache Flink等，能够将任务并行分发到集群中的多个计算节点上进行并行处理，以实现高效的大数据计算。\n数据挖掘和机器学习：数据挖掘和机器学习技术用于从大数据中发现模式、提取知识和进行预测。这些技术包括聚类、分类、回归、关联规则挖掘等。流行的机器学习工具和库如Scikit-learn、TensorFlow和PyTorch等，提供了丰富的算法和工具来处理大规模数据集。\n实时流处理：大数据处理不仅限于批处理，还需要能够处理实时数据流的技术。实时流处理框架如Apache Kafka和Apache Flink的流处理功能，能够实时接收、处理和分析数据流，对于需要实时决策和响应的应用非常有用。\n数据库技术：传统的关系型数据库在处理大数据时存在限制，因此出现了一些专门用于大数据的数据库技术。例如，NoSQL数据库（如MongoDB、Cassandra）提供了高可扩展性和灵活性，适用于大规模分布式数据存储和查询。\n数据可视化和探索：大数据分析结果的可视化和交互探索对于理解和传达数据的洞察力非常重要。可视化工具和库如Tableau、Power BI和D3.js等，能够将大数据以图表、图形和仪表板的形式呈现，帮助用户发现数据中的模式和趋势。","category":"page"},{"location":"IotBigdataCloud/3-大数据简介/","page":"大数据简介","title":"大数据简介","text":"这些核心技术的综合应用可以实现大规模数据的高效存储、处理和分析，从而为企业和研究机构提供更深入的洞察力和价值。","category":"page"},{"location":"IotBigdataCloud/3-大数据简介/#更多参考信息","page":"大数据简介","title":"更多参考信息","text":"","category":"section"},{"location":"IotBigdataCloud/3-大数据简介/","page":"大数据简介","title":"大数据简介","text":"厦门大学数据库实验室的大数据课程公共服务平台。很全面啦。要想学习，自己去看吧。","category":"page"},{"location":"CSAdv/7-领域特定语言/#领域特定语言DSL","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"","category":"section"},{"location":"CSAdv/7-领域特定语言/#领域特定语言DSL简介","page":"领域特定语言DSL","title":"领域特定语言DSL简介","text":"","category":"section"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"DSL（领域特定语言）通常指的是一种专门设计用于解决特定领域问题的编程语言。与通用编程语言（如Python、Java或C++）相比，DSL更加关注特定领域的需求，使得在该领域中的编程更加简洁、直观和高效。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"DSL的设计目标是使得领域专家能够更轻松地表达其领域知识和需求，而无需过多关注底层编程细节。DSL可以用于各种领域，例如数据分析、机器学习、网络配置、领域建模等。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"DSL通常有两种主要类型：外部DSL（EDSL）和内部DSL（IDSL）。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"外部DSL（EDSL）是一种独立的语言，具有自己的语法和语义。EDSL被设计成在特定领域中执行特定任务，且通常具有更高的表达能力。EDSL的例子包括R语言用于数据分析和处理的数据框架（例如tidyverse），以及SQL用于关系数据库查询。\n内部DSL（IDSL）是嵌入在通用编程语言中的DSL。通过使用通用编程语言的语法和语义，IDSL可以在特定领域中创建一种更加直观和简洁的编程体验。IDSL通常使用特定的库、框架或编程模式来实现。例如，TensorFlow库提供了一种用于定义和执行机器学习模型的IDSL。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"使用DSL的好处包括：","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"更高的领域专业性：DSL允许领域专家使用熟悉的术语和概念来描述问题和解决方案，从而提高开发效率和代码可读性。\n更高的生产力：DSL可以提供更简洁、高级别的语法和语义，减少冗余代码，简化开发流程，并加速开发周期。\n更好的错误检测：DSL可以在编译或解释阶段捕获特定领域中的常见错误，从而提供更好的错误检测和调试支持。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"然而，DSL也有一些挑战和限制。DSL的设计和实现可能需要专业的知识和技能。DSL的学习曲线可能相对陡峭，并且可能会受限于特定的技术栈和工具支持。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"综上所述，DSL是一种为特定领域定制的编程语言，它旨在提高开发效率、简化代码，并使领域专家能够更直接地表达其领域需求。通过使用DSL，可以提高开发效率、代码质量和可维护性，从而在特定领域中实现更好的解决方案。","category":"page"},{"location":"CSAdv/7-领域特定语言/#modelica可以认为是一个dsl","page":"领域特定语言DSL","title":"modelica可以认为是一个dsl","text":"","category":"section"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"Modelica可以被认为是一种DSL（领域特定语言）。Modelica是一种用于建模和仿真物理系统的开放式建模语言。它提供了一种描述复杂多物理领域系统行为的方式，例如机械、电气、热力、控制等。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"Modelica的语法和语义是专门设计用于描述物理系统的行为和结构。它使用方程式描述系统的动态行为，并通过连接不同的组件来描述系统的结构。Modelica的建模能力非常强大，可以描述各种复杂的物理现象和系统。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"Modelica还提供了丰富的标准库，涵盖了各种领域的组件，例如电气、机械、热力、控制等。这些标准库使得建模和仿真各种物理系统变得更加容易和高效。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"Modelica的优点包括：","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"物理系统建模：Modelica提供了丰富的物理模型描述能力，使得建模各种物理系统变得直观和方便。\n跨领域建模：Modelica允许在同一个模型中集成不同领域的组件，使得多领域系统的建模变得简单和一致。\n仿真和分析：Modelica支持系统级仿真和分析，可以用于评估系统性能、优化设计和进行虚拟验证。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"需要注意的是，Modelica虽然是一种领域特定语言，但它也是一种通用的编程语言，具有完整的语法和语义。它可以通过编译器或解释器进行处理，并且可以与其他编程语言和工具进行集成。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"因此，Modelica可以被看作是一种具有专注于物理系统建模和仿真的DSL，它提供了特定领域中更高级别、更直观的语法和语义，使得物理系统建模变得更加方便和高效。","category":"page"},{"location":"CSAdv/7-领域特定语言/#来一个极简modelica例子","page":"领域特定语言DSL","title":"来一个极简modelica例子","text":"","category":"section"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"以下是一个极简的Modelica例子，展示了如何使用Modelica描述一个简单的弹簧-质量系统：","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"model SpringMassSystem\n  parameter Real k = 1.0 \"弹簧刚度\";\n  parameter Real m = 1.0 \"质量\";\n  \n  Real x(start = 0.0) \"位移\";\n  Real v \"速度\";\n  Real F \"力\";\n  \nequation\n  F = -k * x;  // 根据胡克定律计算力\n  \n  m * der(v) = F;  // 牛顿第二定律\n  \n  der(x) = v;  // 位移的导数等于速度\n  \nend SpringMassSystem;","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"在这个例子中，定义了一个名为SpringMassSystem的模型，它描述了一个弹簧-质量系统。模型中包含两个参数：弹簧刚度k和质量m，以及三个状态变量：位移x、速度v和力F。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"通过方程式来描述系统的行为。根据胡克定律，力F与位移x成反比，因此通过F = -k * x计算力。根据牛顿第二定律，力与加速度的乘积等于质量乘以加速度的导数，因此通过m * der(v) = F表示牛顿第二定律。最后，通过der(x) = v表示位移的导数等于速度。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"这个简单的Modelica模型描述了弹簧-质量系统的基本行为，可以用于仿真和分析该系统的动态特性。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"请注意，这只是一个非常简单的例子，Modelica还提供了更丰富的语法和功能，用于描述更复杂的物理系统。此例仅用于演示基本概念和语法。实际应用中，可能需要更多的组件和连接来描述更复杂的物理系统。","category":"page"},{"location":"CSAdv/7-领域特定语言/#再来由两个组件连接成系统的Modelica例子","page":"领域特定语言DSL","title":"再来由两个组件连接成系统的Modelica例子","text":"","category":"section"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"以下是两个组件连接的示例，展示了如何在Modelica中连接两个组件以构建更复杂的系统：","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"model SpringMassSystem\n  parameter Real k = 1.0 \"弹簧刚度\";\n  parameter Real m = 1.0 \"质量\";\n  \n  Modelica.Mechanics.Translational.Components.Mass mass(\n    m = m, \n    useHeatPort = false) \n    annotation (Placement(transformation(extent = {{-10, 10}, {-10, 10}})));\n  \n  Modelica.Mechanics.Translational.Components.Spring spring(\n    c = k,\n    useHeatPort = false) \n    annotation (Placement(transformation(extent = {{-30, -10}, {30, 10}})));\n  \nequation\n  connect(spring.frame_a, mass.frame) annotation(Line(\n    points = {{-30, 0}, {-10, 0}},\n    color = {0, 0, 255}));\n  \n  connect(spring.frame_b, world.frame) annotation(Line(\n    points = {{10, 0}, {30, 0}},\n    color = {0, 0, 255}));\n  \nend SpringMassSystem;","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"在这个例子中，我们在之前的弹簧-质量系统的基础上，引入了两个新的组件：Mass和Spring。Mass表示质量，Spring表示弹簧。我们通过连接这两个组件来构建更复杂的系统。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"Mass组件和Spring组件都来自于Modelica标准库中的Modelica.Mechanics.Translational.Components包。我们通过实例化这两个组件，并为它们提供必要的参数。例如，我们将质量参数m传递给Mass组件，将刚度参数k传递给Spring组件。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"在方程部分，我们使用connect语句来连接组件之间的端口。通过connect(spring.frame_a, mass.frame)，我们将Spring组件的frame_a端口连接到Mass组件的frame端口，形成了弹簧与质量的连接。类似地，通过connect(spring.frame_b, world.frame)，我们将Spring组件的frame_b端口连接到world环境组件的frame端口，形成了弹簧与外部环境的连接。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"通过这样的连接，我们构建了一个由弹簧和质量组成的系统，并将其连接到外部环境。该系统可以进行仿真和分析，以研究弹簧和质量之间的相互作用。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"请注意，上述示例中引用的组件和库来自Modelica标准库，如果要运行该示例，需要确保在Modelica环境中包含了相应的库和组件。实际应用中，您可以根据具体需求选择不同的组件和库来构建更复杂的系统。","category":"page"},{"location":"CSAdv/7-领域特定语言/#gproms实际上也是写了一个dsl","page":"领域特定语言DSL","title":"gproms实际上也是写了一个dsl","text":"","category":"section"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"GPROMS可以被认为是一个DSL（领域特定语言）。GPROMS（Generalized Process Modeling System）是一个面向过程建模和优化的软件平台，用于描述和解决化工、制药和其他过程工业中的问题。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"GPROMS提供了一种专门设计用于过程工业领域的建模语言。该语言具有专门的语法和语义，旨在描述化工和过程系统的行为和特性。它可以用于描述各种化工过程、反应器、分离器、换热器等单元操作，以及它们之间的连接和相互作用。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"使用GPROMS的DSL，用户可以构建复杂的过程模型，并进行仿真、优化、敏感性分析和设计评估等任务。DSL提供了丰富的建模元素和方程式，允许用户描述流体流动、物料平衡、能量平衡、动力学行为、热力学性质等方面的问题。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"GPROMS的DSL还提供了丰富的模型库和模型开发工具，使用户能够更轻松地构建和验证模型。它还提供了高级的优化算法和工具，用于求解模型并进行过程优化。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"需要注意的是，GPROMS不仅仅是一个DSL，它是一个完整的软件平台，包括DSL、建模工具、求解器、优化算法等组件。GPROMS提供了一体化的环境，使得在过程工业领域进行建模、仿真和优化变得更加方便和高效。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"综上所述，GPROMS可以被视为一个面向过程工业领域的DSL，它提供了专门用于描述化工和过程系统的语法和语义。通过使用GPROMS，用户可以建立复杂的过程模型，并进行仿真和优化，以解决过程工业中的问题。","category":"page"},{"location":"CSAdv/7-领域特定语言/#来个例子呗","page":"领域特定语言DSL","title":"来个例子呗","text":"","category":"section"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"以下是一个简化的GPROMS DSL示例，用于描述一个简单的化学反应过程：","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"// 定义组分\ncomponent A\n  properties\n    molarMass = 32.04;  // 摩尔质量\n    density = 789.0;   // 密度\n  end properties\nend component\n\ncomponent B\n  properties\n    molarMass = 18.02;\n    density = 997.0;\n  end properties\nend component\n\n// 定义反应\nreaction R1\n  reactants\n    A;\n    B;\n  end reactants\n  \n  products\n    C;\n  end products\n  \n  kinetics\n    rateConstant = 0.1;\n    activationEnergy = 50.0;\n  end kinetics\nend reaction\n\n// 定义反应器\nunit Reactor\n  inlet\n    flowrateA;\n    flowrateB;\n  end inlet\n  \n  outlet\n    flowrateC;\n  end outlet\n  \n  equations\n    // 守恒方程\n    flowrateA + flowrateB = flowrateC;\n    \n    // 反应速率方程\n    rate = rateConstant * flowrateA * flowrateB * exp(-activationEnergy / (8.314 * temperature));\n  end equations\nend unit\n\n// 定义系统\nsystem ChemicalSystem\n  components\n    A;\n    B;\n    C;\n  end components\n  \n  units\n    Reactor;\n  end units\n  \n  connections\n    Reactor.inlet.flowrateA = 10.0;\n    Reactor.inlet.flowrateB = 5.0;\n    Reactor.outlet.flowrateC = 15.0;\n  end connections\nend system","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"在这个例子中，我们定义了三个组分：A、B和C。每个组分都有一些属性，例如摩尔质量和密度。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"然后，我们定义了一个反应R1，它具有两个反应物（A和B）和一个生成物（C）。我们还为反应定义了一些动力学参数，如速率常数和活化能。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"接下来，我们定义了一个反应器Reactor作为单元。反应器有一个进料口（inlet）和一个出料口（outlet）。我们在反应器的方程中编写了质量守恒方程和反应速率方程。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"最后，我们定义了一个系统ChemicalSystem，该系统包含了组分和单元，并通过连接将它们关联起来。在连接中，我们指定了进料和出料的流量。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"这个示例演示了如何使用GPROMS DSL来描述一个简单的化学反应过程，包括组分、反应、反应器和系统之间的关系。通过使用GPROMS的DSL，可以更加直观和简洁地描述化学反应过程，并进行模拟和优化分析。请注意，上述示例是简化的，实际的GPROMS模型可能包含更多组分、反应和单元，并且涉及更复杂的方程和参数设置。","category":"page"},{"location":"CSAdv/7-领域特定语言/#现在gproms采用xml存储模型，把刚才的例子输出一下","page":"领域特定语言DSL","title":"现在gproms采用xml存储模型，把刚才的例子输出一下","text":"","category":"section"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"以下是将刚才的GPROMS DSL示例转换为GPROMS XML模型的输出示例：","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<gproms version=\"1.0\">\n  <component name=\"A\">\n    <properties>\n      <property name=\"molarMass\" value=\"32.04\"/>\n      <property name=\"density\" value=\"789.0\"/>\n    </properties>\n  </component>\n  <component name=\"B\">\n    <properties>\n      <property name=\"molarMass\" value=\"18.02\"/>\n      <property name=\"density\" value=\"997.0\"/>\n    </properties>\n  </component>\n  <reaction name=\"R1\">\n    <reactants>\n      <component name=\"A\"/>\n      <component name=\"B\"/>\n    </reactants>\n    <products>\n      <component name=\"C\"/>\n    </products>\n    <kinetics>\n      <property name=\"rateConstant\" value=\"0.1\"/>\n      <property name=\"activationEnergy\" value=\"50.0\"/>\n    </kinetics>\n  </reaction>\n  <unit name=\"Reactor\">\n    <inlet>\n      <variable name=\"flowrateA\"/>\n      <variable name=\"flowrateB\"/>\n    </inlet>\n    <outlet>\n      <variable name=\"flowrateC\"/>\n    </outlet>\n    <equations>\n      <equation>flowrateA + flowrateB = flowrateC</equation>\n      <equation>rate = rateConstant * flowrateA * flowrateB * exp(-activationEnergy / (8.314 * temperature))</equation>\n    </equations>\n  </unit>\n  <system name=\"ChemicalSystem\">\n    <components>\n      <component name=\"A\"/>\n      <component name=\"B\"/>\n      <component name=\"C\"/>\n    </components>\n    <units>\n      <unit name=\"Reactor\"/>\n    </units>\n    <connections>\n      <connection>Reactor.inlet.flowrateA = 10.0</connection>\n      <connection>Reactor.inlet.flowrateB = 5.0</connection>\n      <connection>Reactor.outlet.flowrateC = 15.0</connection>\n    </connections>\n  </system>\n</gproms>","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"上述输出是将GPROMS DSL示例转换为XML格式的GPROMS模型表示。XML模型文件包含了组分（component）、反应（reaction）、单元（unit）和系统（system）的定义。每个组件、反应、单元和系统都有相应的属性和参数。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"通过将GPROMS模型转换为XML格式，可以方便地存储和传输模型定义，并且可以与其他软件系统进行交互和集成。GPROMS软件可以读取和解析XML模型文件，并进行模拟、优化和分析等操作。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"请注意，上述输出仅展示了将GPROMS DSL示例转换为XML模型的示例，并非完整的GPROMS模型文件。实际的GPROMS模型文件可能包含更多的定义和配置信息，以描述更复杂的过程系统和模型设置。","category":"page"},{"location":"CSAdv/7-领域特定语言/#Cellml也是一个dsl","page":"领域特定语言DSL","title":"Cellml也是一个dsl","text":"","category":"section"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"CellML可以被认为是一种DSL（领域特定语言）。CellML（Cellular Markup Language）是一种用于建模和描述生物系统的开放式标记语言。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"CellML的设计目标是提供一种用于描述细胞生物学过程的语言，以便研究人员能够更好地理解和模拟生物系统的行为。CellML使用基于XML的语法结构，以一种结构化的方式描述细胞模型的组件、变量和方程。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"CellML的主要特点和功能包括：","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"组件描述：CellML允许用户定义和描述生物系统中的组件，例如细胞、离子通道、反应器等。组件可以嵌套和连接，以构建更复杂的细胞模型。\n变量定义：CellML允许用户定义变量，用于表示细胞模型中的物理量、参数和状态。变量可以具有特定的单位和初始值，并可以在方程中引用和操作。\n方程建模：CellML使用数学方程来描述生物系统的行为。用户可以编写方程来表示变量之间的关系和动态变化。方程可以包含代数方程、微分方程和常微分方程等。\n可扩展性：CellML支持模型的扩展和组合。用户可以定义自定义的组件和方程，并将其组合到更大的模型中。这使得CellML具有灵活性和可重用性。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"通过使用CellML，研究人员可以描述和共享生物系统的模型，并使用CellML工具进行模拟、分析和模型验证。CellML还提供了与其他工具和平台的集成能力，以促进生物系统建模和研究的合作。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"综上所述，CellML是一种专门用于描述和模拟生物系统的DSL。它提供了描述组件、变量和方程的语法和结构，以支持细胞生物学建模和仿真。通过使用CellML，研究人员可以更好地理解和研究生物系统的行为和特性。","category":"page"},{"location":"CSAdv/7-领域特定语言/#例子例子","page":"领域特定语言DSL","title":"例子例子","text":"","category":"section"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"以下是一个简单的CellML示例，展示了如何使用CellML描述一个简单的生物反应模型：","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<model xmlns=\"http://www.cellml.org/cellml/2.0#\" name=\"BioReactionModel\">\n  <component name=\"A\">\n    <variable name=\"concentration_A\" units=\"mol/L\"/>\n    <variable name=\"rate_A\" units=\"mol/(L·s)\"/>\n    <equation>\n      <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n        <apply>\n          <eq/>\n          <ci>rate_A</ci>\n          <apply>\n            <times/>\n            <ci>k</ci>\n            <ci>concentration_A</ci>\n          </apply>\n        </apply>\n      </math>\n    </equation>\n  </component>\n  \n  <component name=\"B\">\n    <variable name=\"concentration_B\" units=\"mol/L\"/>\n    <variable name=\"rate_B\" units=\"mol/(L·s)\"/>\n    <equation>\n      <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n        <apply>\n          <eq/>\n          <ci>rate_B</ci>\n          <apply>\n            <times/>\n            <ci>k</ci>\n            <ci>concentration_B</ci>\n          </apply>\n        </apply>\n      </math>\n    </equation>\n  </component>\n  \n  <component name=\"Reaction\">\n    <variable name=\"k\" units=\"1/s\"/>\n    <equation>\n      <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n        <apply>\n          <eq/>\n          <ci>k</ci>\n          <apply>\n            <times/>\n            <cn>0.1</cn>\n          </apply>\n        </apply>\n      </math>\n    </equation>\n  </component>\n  \n  <connection>\n    <mapComponents component1=\"Reaction\" component2=\"A\">\n      <mapVariables variable1=\"k\" variable2=\"k\"/>\n    </mapComponents>\n    <mapComponents component1=\"Reaction\" component2=\"B\">\n      <mapVariables variable1=\"k\" variable2=\"k\"/>\n    </mapComponents>\n  </connection>\n  \n  <connection>\n    <mapComponents component1=\"A\" component2=\"Reaction\">\n      <mapVariables variable1=\"rate_A\" variable2=\"rate_A\"/>\n    </mapComponents>\n  </connection>\n  \n  <connection>\n    <mapComponents component1=\"B\" component2=\"Reaction\">\n      <mapVariables variable1=\"rate_B\" variable2=\"rate_B\"/>\n    </mapComponents>\n  </connection>\n</model>","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"在这个例子中，我们定义了三个组件：A、B和Reaction。每个组件包含变量和方程来描述其行为。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"组件A和B表示两种物质的浓度（concentration）和反应速率（rate）。方程使用简单的乘法运算来计算反应速率，其中速率常数k与浓度变量相乘。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"组件Reaction表示反应的速率常数k。该组件只有一个变量k，并通过方程设定为0.1。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"通过连接（connection），我们建立了组件之间的关联。在连接中，我们使用mapComponents指定了组件之间的连接关系，使用mapVariables指定了变量之间的映射关系。例如，我们将组件Reaction的变量k连接到组件A和B的变量k，以实现反应速率常数的共享。类似地，我们将组件A和B的反应速率变量连接到组件Reaction的反应速率变量，以实现反应速率的计算。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"这个简单的CellML示例展示了如何使用CellML语言描述一个生物反应模型，包括组件、变量、方程和连接的定义。通过使用CellML，可以更加直观和结构化地描述生物系统的行为和动态特性。请注意，上述示例是简化的，实际的CellML模型可能包含更多组件、变量、方程和连接，以描述更复杂的生物过程和模型结构。","category":"page"},{"location":"CSAdv/7-领域特定语言/#Sbml也是dsl","page":"领域特定语言DSL","title":"Sbml也是dsl","text":"","category":"section"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"SBML（Systems Biology Markup Language）可以被认为是一种DSL（领域特定语言）。SBML是一种用于建模和描述生物系统的开放式标记语言，它专门设计用于系统生物学领域。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"SBML的设计目标是提供一种通用的语言，用于描述生物化学反应、代谢网络和细胞信号传导等生物系统的模型。SBML使用基于XML的语法结构，以一种结构化的方式描述生物系统的组件、反应和参数。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"SBML的主要特点和功能包括：","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"组件描述：SBML允许用户定义和描述生物系统中的分子物种、反应和参数。用户可以定义物种的浓度、反应的速率以及反应的催化剂和产物。\n反应建模：SBML使用化学反应方程式来描述生物系统中的反应。用户可以定义反应的物质转化和反应速率方程，以描述生物系统的动态行为。\n参数设置：SBML允许用户定义和调整模型中的参数。用户可以为反应速率常数、浓度初始值和其他参数设置数值，并进行参数敏感性分析和参数优化。\n模型扩展性：SBML支持模型的扩展和组合。用户可以使用SBML的扩展机制定义自定义的组件、反应类型和模型注释，以适应不同的生物系统建模需求。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"通过使用SBML，研究人员可以描述和共享生物系统的模型，并使用SBML工具进行模拟、分析和模型验证。SBML还提供了与其他系统生物学工具和数据库的集成能力，以促进生物系统建模和研究的合作。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"综上所述，SBML是一种专门用于描述和模拟生物系统的DSL。它提供了描述组件、反应和参数的语法和结构，以支持系统生物学建模和仿真。通过使用SBML，研究人员可以更好地理解和研究生物系统的行为和特性。","category":"page"},{"location":"CSAdv/7-领域特定语言/#例子例子-2","page":"领域特定语言DSL","title":"例子例子","text":"","category":"section"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"以下是一个简单的SBML示例，展示了如何使用SBML描述一个简单的生物反应模型：","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<sbml xmlns=\"http://www.sbml.org/sbml/level3/version1/core\" level=\"3\" version=\"1\">\n  <model id=\"BioReactionModel\" name=\"Biochemical Reaction Model\">\n    <listOfCompartments>\n      <compartment id=\"compartment\" name=\"Cell\" size=\"1\"/>\n    </listOfCompartments>\n    <listOfSpecies>\n      <species id=\"A\" name=\"Species A\" compartment=\"compartment\" initialConcentration=\"0.1\"/>\n      <species id=\"B\" name=\"Species B\" compartment=\"compartment\" initialConcentration=\"0.2\"/>\n      <species id=\"C\" name=\"Species C\" compartment=\"compartment\" initialConcentration=\"0\"/>\n    </listOfSpecies>\n    <listOfParameters>\n      <parameter id=\"k\" name=\"Rate Constant\" value=\"0.05\"/>\n    </listOfParameters>\n    <listOfReactions>\n      <reaction id=\"R1\" reversible=\"false\" fast=\"false\">\n        <listOfReactants>\n          <speciesReference species=\"A\" stoichiometry=\"1\"/>\n          <speciesReference species=\"B\" stoichiometry=\"1\"/>\n        </listOfReactants>\n        <listOfProducts>\n          <speciesReference species=\"C\" stoichiometry=\"1\"/>\n        </listOfProducts>\n        <kineticLaw>\n          <math xmlns=\"http://www.w3.org/1998/Math/MathML\">\n            <apply>\n              <times/>\n              <ci>k</ci>\n              <ci>A</ci>\n              <ci>B</ci>\n            </apply>\n          </math>\n        </kineticLaw>\n      </reaction>\n    </listOfReactions>\n  </model>\n</sbml>","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"在这个例子中，我们使用SBML描述了一个简单的生物反应模型。模型包含一个反应，涉及三个物种A、B和C。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"我们首先定义了一个细胞（compartment）用于容纳这些物种。然后，我们定义了三个物种A、B和C，它们分别在细胞中具有初始浓度。物种A和B参与反应，生成物种C。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"接下来，我们定义了一个参数k，表示反应速率常数。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"最后，我们定义了一个反应R1，它具有反应物A和B以及产物C。反应的动力学方程通过乘法运算来计算反应速率，其中速率常数k与物种A和B的浓度相乘。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"这个简单的SBML示例展示了如何使用SBML语言描述一个生物反应模型，包括细胞、物种、参数、反应和动力学方程的定义。通过使用SBML，可以更加结构化和标准化地描述生物系统的模型，方便与其他SBML兼容工具和数据库进行交互和共享。请注意，上述示例是简化的，实际的SBML模型可能包含更多的物种、反应、参数和注释，以描述更复杂的生物过程和模型结构。","category":"page"},{"location":"CSAdv/7-领域特定语言/#再回顾一下从符号到模型（解析）和从模型到符号（导出）","page":"领域特定语言DSL","title":"再回顾一下从符号到模型（解析）和从模型到符号（导出）","text":"","category":"section"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"当从符号到模型进行解析时，您将从符号或表达式的表示形式转换为实际的模型。这涉及将符号转化为模型的组件、参数、方程等元素，并建立它们之间的关联。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"在建立模型时，您需要根据所使用的建模语言或工具的规范，将符号转换为相应的模型元素。这可能包括创建组件、定义参数和变量、编写方程或规则，以及设置模型的初始状态和约束。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"从符号到模型的解析过程通常需要遵循一些规则和语法，以确保生成的模型是正确和一致的。这可能涉及对符号表达式进行解析、语法分析和语义验证。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"当从模型到符号进行导出时，您将从实际的模型中提取相关的符号信息或数值结果，并以符号或表达式的形式导出。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"导出的方式可以根据具体的需求和目标而有所不同。例如，您可以导出模型的参数和变量名称、模型的方程式、模型的解析结果或模型的数值结果。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"导出的符号信息可以用于进一步的分析、可视化或集成到其他系统中。导出的数值结果可以用于生成图表、进行统计分析或与其他模型进行对比。","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"总而言之，从符号到模型的解析涉及将符号转换为实际的模型元素，而从模型到符号的导出涉及从模型中提取相关的符号信息或数值结果。这两个过程都需要遵循特定的规则和语法，并根据具体的需求进行处理和转换。","category":"page"},{"location":"CSAdv/7-领域特定语言/#关于如何造一个语言参考","page":"领域特定语言DSL","title":"关于如何造一个语言参考","text":"","category":"section"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"mongkeylang","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"Lox-clox","category":"page"},{"location":"CSAdv/7-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"Lox-jlox","category":"page"},{"location":"tengfeibei/#腾飞杯","page":"腾飞杯","title":"腾飞杯","text":"","category":"section"},{"location":"tengfeibei/#**腾飞杯招募**","page":"腾飞杯","title":"腾飞杯招募","text":"","category":"section"},{"location":"tengfeibei/#腾飞杯项目简介信息","page":"腾飞杯","title":"腾飞杯项目简介信息","text":"","category":"section"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"自我介绍：能动研二杨景懿，感兴趣的研究方向是：系统的建模、仿真、优化与控制。个人主页。QQ：522432938","category":"page"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"目前已有核心开发人员3名，指导老师1名。","category":"page"},{"location":"tengfeibei/#主题","page":"腾飞杯","title":"主题","text":"","category":"section"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"云仿真平台（具体名字待定），简单理解为：网页版Simulink（或者网页版AspenPlus，网页版gproms，网页版modelica，本质都一样）","category":"page"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"暂定赛道：科技发明制作A类","category":"page"},{"location":"tengfeibei/#技术框架","page":"腾飞杯","title":"技术框架","text":"","category":"section"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"前后端分离。前端VUE3，后端Julia，通过json交互。","category":"page"},{"location":"tengfeibei/#已有进展","page":"腾飞杯","title":"已有进展","text":"","category":"section"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"所有代码、文档可在Github上自行查看。","category":"page"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"我们的Ai4Energy开源组织：https://github.com/ai4energy\n模型库Ai4EComponentLib.jl，现在已有的有可压缩组件库（空压系统），不可以压缩组件库（管道系统），电化学库（光伏、电解槽、电池等），热力循环库（各类循环等）\njson解析器：Ai4EMetaPSE.jl\nAi4ELab，Julia的web框架。但是灵活性不够高，希望用VUE3开发。\n求解器采用开源求解器。\n前端页面参考：https://github.com/yaolunmao/vue-webtopo-svgeditor","category":"page"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"总结：高可拓展性的后端框架已经完成，完整作品的上线测试运行只差前端。","category":"page"},{"location":"tengfeibei/#招募队员","page":"腾飞杯","title":"招募队员","text":"","category":"section"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"招募2-3名队员。","category":"page"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"负责内容：基于该VUE实现做开发，打造自己的作品。 要求：专业不限，年级不限。动手能力强，具有钻研精神。热爱程序设计。能投入。","category":"page"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"有兴趣的同学联系+QQ：522432938","category":"page"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"tip: Tip\n基于上述介绍，我们是踏实严肃的且有货的开发团队，不鸽不水。\n本网页是我们开放的文档库，可自行学习浏览。\n我们的目的是打造作品，只要东西能做出来，队长、队员重要程度什么的都好商量。最后，腾飞杯只是一个展示平台。比赛过后，我们的组织依旧会传承与发展，我们的目标是星辰大海~ 抛开比赛，欢迎有热情、有激情的同学加入，共同学习、成长与开发。","category":"page"},{"location":"Simulation/componementModel/#组件化建模实例","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"section"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"tip: Tip\nContents：MTK、组件化建模Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"note: Note\nMTK = ModelingToolkit.jlModelingToolkit.jl Acausal Component-Based Modeling the RC Circuit介绍了组件化建模的例子","category":"page"},{"location":"Simulation/componementModel/#MTK符号建模","page":"组件化建模实例","title":"MTK符号建模","text":"","category":"section"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"在DifferentialEquations建模方法与ModelingToolkit建模方法中介绍DE与MTK的两种建模方式。分析了使用它们建模的具体步骤与实现方法，并介绍了相应的内涵。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"这一篇中主要介绍符号建模的另一个强大功能——组件化建模。","category":"page"},{"location":"Simulation/componementModel/#RC电路建模实例","page":"组件化建模实例","title":"RC电路建模实例","text":"","category":"section"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"仿真如下图的电路系统：","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"(Image: 图 2)  ","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"@MTK版本：8.5.5","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"using ModelingToolkit, Plots, DifferentialEquations\n\n@variables t\n@connector function Pin(; name)\n    sts = @variables v(t) = 1.0 i(t) = 1.0 [connect = Flow]\n    ODESystem(Equation[], t, sts, []; name=name)\nend\n\nfunction Ground(; name)\n    @named g = Pin()\n    eqs = [g.v ~ 0]\n    compose(ODESystem(eqs, t, [], []; name=name), g)\nend\n\nfunction OnePort(; name)\n    @named p = Pin()\n    @named n = Pin()\n    sts = @variables v(t) = 1.0 i(t) = 1.0\n    eqs = [\n        v ~ p.v - n.v\n        0 ~ p.i + n.i\n        i ~ p.i\n    ]\n    compose(ODESystem(eqs, t, sts, []; name=name), p, n)\nend\n\nfunction Resistor(; name, R=1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters R = R\n    eqs = [\n        v ~ i * R\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction Capacitor(; name, C=1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters C = C\n    D = Differential(t)\n    eqs = [\n        D(v) ~ i / C\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction ConstantVoltage(; name, V=1.0)\n    @named oneport = OnePort()\n    @unpack v = oneport\n    ps = @parameters V = V\n    eqs = [\n        V ~ v\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction Inductor(; name, L=1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters L = L\n    D = Differential(t)\n    eqs = [\n        D(i) ~ v / L\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction ChangeableVoltage(; name)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    eqs = [\n        v ~ 16 * sin(2π * t)\n    ]\n    extend(ODESystem(eqs, t, [], []; name=name), oneport)\nend\n\n\n\n@named resistor = Resistor(R=3.0)\n@named capacitor = Capacitor(C=1.0 / 24)\n@named source = ChangeableVoltage()\n@named inductor = Inductor(L=0.1)\n@named ground = Ground()\n\n\nrc_eqs = [\n    connect(source.p, capacitor.p)\n    connect(capacitor.n, inductor.p)\n    connect(inductor.n, resistor.p)\n    connect(source.n, resistor.n, ground.g)\n]\n\n\n@named _rc_model = ODESystem(rc_eqs, t)\n@named rc_model = compose(_rc_model,\n    [resistor, inductor, capacitor, source, ground])\n\nsys = structural_simplify(rc_model)\n\nusing Plots\nu0 = [\n    capacitor.v => 0.0\n    capacitor.p.i => 0.0\n    inductor.i => 0\n    inductor.v => 0\n]\nprob = ODAEProblem(sys, u0, (0, 10.0))\nsol = solve(prob, Tsit5())\nsol[resistor.p.i]\np1 = plot(sol, vars=[capacitor.v capacitor.p.i], xlims=(0, 10), ylim=(-20, 20))\np2 = plot(sol, vars=[inductor.v inductor.i], xlims=(0, 10), ylim=(-5, 5))\nplot(p1, p2, layout=(2, 1))","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"结果如图所示：","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"(Image: 图 1)  ","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"主要的过程有以下几步：","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"构建组件\n定义组件实例\n连接系统\n化简\n设置初值\n构建问题并求解\n结果处理","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"构建组件过程中主要有两方面考虑，系统内部结构与系统对外接口。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"内部结构则是各个组件内部的数学特性。对于电阻有： V=R*I","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"对于电容有： fracdVdt=fracIC","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"对于电感有： fracdIdt=fracVL","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"这些关系可以在模型构建时体现。这是系统的内部变量之间的决定关系。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"外部结构是模块化的另一个关键部分。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"RC的接口体现在函数Pin()上，每一个组件都由两个Pin——输入引脚与输出引脚。这完全是抽象出来的，引脚存在的意义就是为了连接。每个引脚有自己的电压值（更准确的说是电势大小）以及电流。这些变量的引入只是为了跟好地模块化。例如，器件A的出口引脚与器件B的进口引脚相连，它们在电路模型中完全可以视为一个等价的点。为了使模块变得更加完整，分化出来各自的引脚。事实上，这些引脚变量在最后计算时，被化简消除了。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"所以，在模块化的过程中为了使个组件变得完整，会派生出很多变量，这些变量都是“锦上添花”的存在，不具备决定性意义。但它们又是使各模块间能够衔接的必要存在。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"\n@named resistor = Resistor(R=3.0)\n@named capacitor = Capacitor(C=1.0 / 24)\n@named source = ChangeableVoltage()\n@named inductor = Inductor(L=0.1)\n@named ground = Ground()\n","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"组件实例化中的@named的作用是给相应组件命名，每个组件的本质都是一个ODESystem，不同的组件不过是ODESystem中存储的方程不同。ODESystem中有一个成员为name，@named把实例的名称赋值给这个成员变量。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"例如,下面两种定义方式是等价的。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"\n@named resistor = Resistor(R=3.0)\n\nresistor = Resistor(R=3.0;name =:resistor)","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"rc_eqs = [\n    connect(source.p, capacitor.p)\n    connect(capacitor.n, inductor.p)\n    connect(inductor.n, resistor.p)\n    connect(source.n, resistor.n, ground.g)\n]","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"依据系统的拓扑结构进行连接。connect函数可以接受任意参数个（并联中多点连接的问题就解决了）。连接的本质是建立模块间的联系，连接模块内部的机理，一旦连接绑定，这些变量的使命就完成了。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"化简的过程中，会把多余的中间变量都消去。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"sys = structural_simplify(rc_model)","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"查看各组件各变量的求解结果：","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"sol[resistor.p.i]","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"值得一提的是，在求解的过程中会化简，但是依旧可以查看这些变量的求解结果。方法如示例所示。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"page"},{"location":"JuliaIntro/7-julia的类型系统/#julia的类型系统","page":"julia的类型系统","title":"julia的类型系统","text":"","category":"section"},{"location":"JuliaIntro/7-julia的类型系统/#julia的类型系统-2","page":"julia的类型系统","title":"julia的类型系统","text":"","category":"section"},{"location":"JuliaIntro/7-julia的类型系统/","page":"julia的类型系统","title":"julia的类型系统","text":"当进一步学习Julia时，了解其类型系统是很重要的。Julia拥有强大的类型系统，允许您指定和操作变量的类型，从而提高性能并增强代码的可读性。下面是关于Julia类型系统的一些基本概念：","category":"page"},{"location":"JuliaIntro/7-julia的类型系统/","page":"julia的类型系统","title":"julia的类型系统","text":"动态类型系统： Julia是一种动态类型语言，这意味着变量的类型是在运行时确定的。您可以在声明变量时指定类型，也可以在后续的操作中改变变量的类型。\n类型注解： 您可以使用类型注解来显式指定变量的类型。类型注解使用::符号，后跟要指定的类型。这有助于编译器进行类型推断，并可以提高性能。\nx::Int = 10  # 声明x为整数类型\n抽象类型： 在Julia中，抽象类型是其他类型的父类型。它们不会被直接实例化，而是作为类型层次结构的基础。例如，Number是整数和浮点数等具体类型的抽象父类型。\nabstract type Number end\n具体类型： 具体类型是实际实例化的类型。它们是类型层次结构中的叶子节点。例如，Int和Float64是具体类型。\nstruct Int <: Number end\nstruct Float64 <: Number end\n类型参数化： Julia允许您创建参数化类型，这些类型具有一个或多个类型参数。类型参数化可以使代码更灵活，可以为同一种类型的不同实例提供不同的行为。\nstruct Point{T}\n    x::T\n    y::T\nend\n类型转换和类型断言： 在Julia中，您可以使用convert函数将一个类型转换为另一个类型。如果您确定某个变量的类型，可以使用typeof函数进行类型断言。\nx = 3.14\ny = convert(Int, x)  # 将x转换为整数类型\nz = typeof(x)        # 获取x的类型\n多分派： Julia是一种多分派语言，这意味着函数可以根据参数的类型和数量选择不同的方法进行调用。这使得您可以根据不同的参数类型定义多个相同名称的函数。\nfunction add(x::Int, y::Int)\n    println(\"Adding two integers\")\n    return x + y\nend\n\nfunction add(x::Float64, y::Float64)\n    println(\"Adding two floating-point numbers\")\n    return x + y\nend","category":"page"},{"location":"JuliaIntro/7-julia的类型系统/","page":"julia的类型系统","title":"julia的类型系统","text":"Julia的类型系统是其强大和灵活性的基础，使您能","category":"page"},{"location":"JuliaIntro/7-julia的类型系统/","page":"julia的类型系统","title":"julia的类型系统","text":"够编写高性能和可维护的代码。深入了解和利用Julia的类型系统将使您能够更好地利用语言的优势。","category":"page"},{"location":"JuliaIntro/7-julia的类型系统/#多重分发","page":"julia的类型系统","title":"多重分发","text":"","category":"section"},{"location":"JuliaIntro/7-julia的类型系统/","page":"julia的类型系统","title":"julia的类型系统","text":"多重派发（Multiple Dispatch）是Julia语言的一项强大特性，它允许您根据函数参数的类型和数量来选择不同的方法进行调用。这意味着可以根据函数参数的不同组合来定义多个具有相同名称的函数，并根据实际传入的参数类型来决定使用哪个方法。","category":"page"},{"location":"JuliaIntro/7-julia的类型系统/","page":"julia的类型系统","title":"julia的类型系统","text":"多重派发有助于实现更具表达力和灵活性的代码，以及更高效的函数调用。下面是多重派发的几个关键要点：","category":"page"},{"location":"JuliaIntro/7-julia的类型系统/","page":"julia的类型系统","title":"julia的类型系统","text":"定义多个相同名称的函数： 在Julia中，您可以定义多个具有相同名称的函数，但它们的参数类型和数量不同。这些函数可以被称为方法（methods）。例如，可以定义不同类型的参数的加法方法：\nfunction add(x::Int, y::Int)\n    println(\"Adding two integers\")\n    return x + y\nend\n\nfunction add(x::Float64, y::Float64)\n    println(\"Adding two floating-point numbers\")\n    return x + y\nend\n根据参数类型和数量选择方法： 当您调用一个具有多个方法的函数时，Julia会根据实际传入的参数类型和数量来选择最匹配的方法。这种选择过程称为派发（Dispatch）。根据参数类型的匹配程度，Julia会选择执行最合适的方法。\nadd(2, 3)      # 调用第一个方法：Adding two integers\nadd(2.0, 3.0)  # 调用第二个方法：Adding two floating-point numbers\n支持多个参数的多重派发： 多重派发不仅可以基于单个参数的类型进行派发，还可以基于多个参数的类型组合进行派发。这使得可以定义更加复杂和灵活的函数行为。\nfunction foo(x::Int, y::Float64)\n    println(\"Int and Float64\")\nend\n\nfunction foo(x::Float64, y::Int)\n    println(\"Float64 and Int\")\nend\n\nfoo(2, 3.0)   # 调用第一个方法：Int and Float64\nfoo(2.0, 3)   # 调用第二个方法：Float64 and Int","category":"page"},{"location":"JuliaIntro/7-julia的类型系统/","page":"julia的类型系统","title":"julia的类型系统","text":"多重派发是Julia语言的一项强大功能，它使得函数调用可以根据参数类型和数量动态选择最适合的方法。这样可以更好地表达和处理不同类型和组合的数据，并提供更高效的函数调用。","category":"page"},{"location":"JuliaIntro/7-julia的类型系统/#julia的类型和python、java的oop对比","page":"julia的类型系统","title":"julia的类型和python、java的oop对比","text":"","category":"section"},{"location":"JuliaIntro/7-julia的类型系统/","page":"julia的类型系统","title":"julia的类型系统","text":"当涉及到类型和面向对象编程（OOP）的比较时，Julia、Python和Java有一些不同的特点。以下是它们之间的简要对比：","category":"page"},{"location":"JuliaIntro/7-julia的类型系统/","page":"julia的类型系统","title":"julia的类型系统","text":"类型系统：\nJulia：Julia具有强大的类型系统，支持动态类型和静态类型的结合。它允许您显式地定义类型和类型层次结构，并利用多重派发来实现多态。\nPython：Python是一种动态类型语言，它具有灵活的类型系统。它使用类和对象来组织代码，并支持面向对象编程的概念，如继承、多态和封装。\nJava：Java是一种静态类型语言，具有强类型检查和显式的类型声明。它使用类、接口和对象来实现面向对象编程的概念，并且支持继承、多态和封装。\n类和对象：\nJulia：Julia在语言层面上没有类和对象的概念。相反，它使用结构体（structs）和抽象类型（abstract types）来组织和管理数据。\nPython：Python是一种面向对象的语言，支持类和对象的概念。您可以定义类来创建对象，并使用继承和多态等OOP特性来组织代码。\nJava：Java是一种纯粹的面向对象编程语言，具有类和对象的概念。您可以定义类来创建对象，并使用继承、多态和封装等OOP特性来组织和管理代码。\n继承和多态：\nJulia：Julia使用多重派发来实现多态。多重派发允许根据函数参数的类型和数量选择不同的方法进行调用，从而实现灵活的函数重载。\nPython：Python支持单继承和多继承。通过继承，子类可以继承父类的属性和方法。Python还通过鸭子类型（Duck Typing）来实现多态，即根据对象的行为而不是类型进行函数调用。\nJava：Java支持单继承和接口实现。通过继承，子类可以继承父类的属性和方法。Java使用方法重写和接口实现来实现多态。\n封装：\nJulia：Julia使用模块（Modules）来实现封装，允许将相关的函数和数据组织在一起，并通过限制访问来保护模块中的私有内容。\nPython：Python使用类的访问修饰符（如公有（public）、私有（private）和受保护（protected））来实现封装。公有成员可以被任何代码访问，私有成员只能在类内部访","category":"page"},{"location":"JuliaIntro/7-julia的类型系统/","page":"julia的类型系统","title":"julia的类型系统","text":"问，受保护成员可以在类及其子类中访问。","category":"page"},{"location":"JuliaIntro/7-julia的类型系统/","page":"julia的类型系统","title":"julia的类型系统","text":"Java：Java使用类的访问修饰符（如公有（public）、私有（private）和受保护（protected））来实现封装。公有成员可以被任何代码访问，私有成员只能在类内部访问，受保护成员可以在类及其子类中访问。","category":"page"},{"location":"JuliaIntro/7-julia的类型系统/","page":"julia的类型系统","title":"julia的类型系统","text":"总的来说，Julia、Python和Java在类型和OOP方面有一些区别。Julia的类型系统非常灵活且强大，可以与面向对象编程的概念结合使用。Python是一种面向对象的语言，具有类和对象的概念，并且支持多态和封装。Java是一种纯粹的面向对象编程语言，具有严格的静态类型和类的概念，并支持继承、多态和封装。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#Ai4EComponentLib.jl设计理念","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"tip: Tip\nContents：Ai4EComponentLib：Julia组件模型库Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"note: Note\nAi4EComponentLib地址。arXiv文章","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#摘要","page":"Ai4EComponentLib.jl设计理念","title":"摘要","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"Ai4EComponentLib是基于Julia语言构建的组件化模型库。它依赖于微分方程求解器DifferentialEquations.jl与符号建模工具Modelingtoolkit.jl。面向不同的物理领域的问题，Ai4EComponentLib尝试使用组件化建模的方法去构建它们。在新一代符号建模工具的支持下，使用Ai4EComponentLib构建的模型比传统的用Modelica构建的模型更加灵活，并具有更高的可拓展性。本文将介绍Ai4EComponentLib模型库的实例与通用建模思想。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#Motivation","page":"Ai4EComponentLib.jl设计理念","title":"1 Motivation","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"在建模仿真领域，已经存在着许许多多的建模工具，例如Modelica、gProms、Simulink等等。它们在不同领域中都发挥着重要的作用，这些工具也已经成为科研工作者的必备工具。但这并不意味着，它们是完美无暇的。以开源的Modelica为例，Modelica拥有自己的编译器，能将建模语言编译成C语言。对于仿真问题来说，它形成了一个完备的解决方案链条。但它的缺陷是，不易扩展。它不能向外扩展形成优化问题的解决方案（参数辨识、最优控制问题）等等。而Julia生态中的ModelingToolkit就解决了扩展性不足的问题。在符号建模体系下，它具有高可拓展性。基于ModelingToolkit的工作，Ai4EComponentLib构建了一些模型库，期望在将来能够利用其高可拓展行的优势。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#Ai4EComponentLib设计理念","page":"Ai4EComponentLib.jl设计理念","title":"2 Ai4EComponentLib设计理念","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"Ai4EComponentLib设计系统的方法与传统的组件化建模思想是相通的。但由于ModelingToolkit的高可拓展性，我们将用更高一层的抽象来看待这个问题。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"组件建模的核心在于过程，以及过程中的物质能量流动。建模过程中的两个关键点为：内部过程与外部连接。设计一个系统，也就是设计它们的内部过程与外部连接。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"现有一个系统，系统中有3个组件A, B and C，如图所示，每个组件有各自的输入输出节点（如a1、a2等），其输入输出特性如箭头所示。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"(Image: 图 1) ","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#.1-内部过程","page":"Ai4EComponentLib.jl设计理念","title":"2.1 内部过程","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"各模块内部有自身的特性。即输入输出量之间在节点内部产生的反应与物质信息交换的过程。在组件与组件之间是各不相同的。这些机制反映了模型对现实实体的映射，是不同的数学物理现象的抽象。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"例如上图组件A的a1、a2、a3。在组件内部，它们有特定的数学关系。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"f(a1a2a3) = 0","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"在这里f(a1a2a3)是一种通用的函数形式，它可以是微分方程，也可以是代数方程。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"例如，对于电阻组件，同样的电压差加在一个不同电阻的两端，流过的电流大小不同。若电阻是随时间变化的，那么系统的电流也是随时间变化的。“不同的电阻”与“随时间变化的电阻”都是组件的特性，在设计组件时，通过不同的方程f来描述。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"这些方程就决定了“物质能量流动”流经组件时的变化。一旦系统中的组件确定了，整个系统的特性就能够通过这些组件确定下来。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#.2-外部连接","page":"Ai4EComponentLib.jl设计理念","title":"2.2 外部连接","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"在构建系统连接时，我们关注点在于连接点的物质和能量。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"例如电路系统。电路系统的a2作为组件的出口，电流与电势值是必要的属性。同时，每个组件的进出口都存在电流与电势。所以，在电路系统中，电流与电势是连接系统的“物质流”。\n例如水流管道系统（不考虑势能）。管道系统的a2作为组件的出口，水流的压力与流速是必要的属性。每个组件的进出口都存在水压与流速属性。所以，在管道系统中，水压与流速连接系统的“物质流”。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"具体的物质流动关系，我们需要根据特性系统的数学模型来构建。例如，电路系统中的基尔霍夫定律，管道流动的伯努利方程。控制方程是描述系统的基础。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"在外部的连接特性中，一般都必须遵循守恒定律——能量守恒与质量守恒：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"leftbeginarrayl\na 2=b 1  b 3=c 2 a 3=c 1\nendarrayrighttag1","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"对于状态量，如电压、水压、气体压力。一般有：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"leftbeginarrayl\na 2=b 1  b 3=c 2 a 3=c 1\nendarrayrighttag2","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"对于过程量，如电流、水流量、气体流量。一般有（规定流入为正，流出为负）：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"leftbeginarrayl\na 2+b 1=0  b 3+c 2 =0a 3+c 1=0\nendarrayrighttag3","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#系统实例","page":"Ai4EComponentLib.jl设计理念","title":"3 系统实例","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/#.1-不可压缩管道系统","page":"Ai4EComponentLib.jl设计理念","title":"3.1 不可压缩管道系统","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"当管道中液体为不可压缩流体时，系统的控制方程为伯努利方程。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"fracprho g +fracv^22g  + h=text  constant  tag4","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其中，p是压力，v是速度，h是高度。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"写成流量形式则有，","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"fracprho g +frac8q^2pi^2D^4g + h=mathrmconstant tag5","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其中，p是压力，q是流量，D是管道直径，h是高度。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"伯努利方程描述的是管道内部液体流动的能量守恒定律。组件的内部过程是能量的增加或减少。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#.1.1-管道组件","page":"Ai4EComponentLib.jl设计理念","title":"3.1.1 管道组件","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"对于一个直管道，组件内部一般有沿程阻力损失与局部阻力损失。当液体从管道一端流向另一端时，液体的总能量减小。沿程阻力损失与局部阻力损失是管道组件的内部过程。其数学方程为：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"fracp_inrho g +frac8q_in^22pi^2D^4g + z_in=\nfracp_outrho g +frac8q_out^22pi^2D^4g + z_out+h_f+h_mtag6","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其中，下标_in代表管道进口，_out代表管道出口，h_f表示沿程阻力损失，h_m表示局部阻力损失。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"沿程阻力损失方程为：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"h_f = ffracLD frac8q^2pi^2D^4gtag7","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其中，f为摩擦因数，L为管道长度，D为管道直径。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"局部阻力损失方程为：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"h_m = K frac8q^2pi^2D^4gtag8","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其中，K为局部阻力系数。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"管道的外部连接主要为压力与流量(高度也是，暂不考虑)。压力是状态量，流量是过程量。在两个组件a,b之间，有：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"p_a=p_bq_a+q_b=0","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#.1.2-离心泵组件","page":"Ai4EComponentLib.jl设计理念","title":"3.1.2 离心泵组件","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"与管道组件类型，离心泵组件的内部过程是为流体增加能量。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"fracp_inrho g +frac8q_in^22pi^2D^4g + z_in=\nfracp_outrho g +frac8q_out^22pi^2D^4g + z_out+H_ttag9","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其中，H_t表示流经离心泵增加的能量。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"H_t=frac(romega)^2g-fracomega cotbeta 2pi bgQ=c_0omega^2-c_1omega Q=a_0-a_1Qtag10","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其中，a_0a_1代表水泵特性参数，方程10实际上是水泵的理论扬程流量曲线。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#.1.3-组件与系统","page":"Ai4EComponentLib.jl设计理念","title":"3.1.3 组件与系统","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"构建系统的水泵、管道等主要组件之前，建立ModelingToolkit中的Connector（Connector中的变量在管道系统中为压力与流量）。代码仓库中有详尽的代码可以查看。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"# Component: SimplePipe(pipe with fixed friction factor `f`)\nfunction SimplePipe(; name, L=10.0, D=25E-3, f=0.01, ρ=1.0E3, zin=0.0, zout=0.0, K_inside=0.0)\n    @named in = PipeNode(z=zin)\n    @named out = PipeNode(z=zout)\n    ps = @parameters D = D L = L f = f K_inside = K_inside\n    eqs = [\n        _NodeEnergy(in, D, ρ) ~ _NodeEnergy(out, D, ρ) + _h_f(in, f, L, D) + _h_m(in, K_inside, D)\n        0 ~ in.q + out.q\n    ]\n    compose(ODESystem(eqs, t, [], ps, name=name), in, out)\nend\n\n# Component: CentrifugalPump\nfunction CentrifugalPump(; name, D=25E-3, ω=2500, c_0=4.4e-4, c_1=5.622, ρ=1.0E3)\n    @named in = PipeNode()\n    @named out = PipeNode()\n    a_0 = c_0 * abs2(ω * 2π / 60)\n    a_1 = c_1 * ω * 2π / 60\n    ps = @parameters D = D\n    eqs = [\n        _NodeEnergy(in, D, ρ) + a_0 - a_1 * abs(in.q) ~ _NodeEnergy(out, D, ρ)\n        0 ~ in.q + out.q\n    ]\n    compose(ODESystem(eqs, t, [], ps, name=name), in, out)\nend\n\n# Component: Sink_P\nfunction Sink_P(; name, p=101325)\n    @named port = PipeNode(z=0.0)\n    eqs = [\n        port.p ~ p\n    ]\n    compose(ODESystem(eqs, t, [], [], name=name), port)\nend\n","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"由以上组件构建如下系统则变得简单快捷。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"(Image: )","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"@named Pump = CentrifugalPump(ω=5000)\n@named A = Sink_P()\n@named B = Sink_P()\n\nsystem = [A, B, Pump]\n\n@named Pipe1 = SimplePipe(L=2.0);\npush!(system, Pipe1);\n@named Pipe2 = SimplePipe(L=3.0);\npush!(system, Pipe2);\n@named Pipe3 = SimplePipe(L=7.0);\npush!(system, Pipe3);\n@named Pipe4 = SimplePipe(L=9.0);\npush!(system, Pipe4);\n@named Pipe5 = SimplePipe(L=5.0);\npush!(system, Pipe5);\n@named Pipe6 = SimplePipe(L=4.0);\npush!(system, Pipe6);\n@named Pipe7 = SimplePipe(L=5.0);\npush!(system, Pipe7);\n@named Pipe8 = SimplePipe(L=1.0);\npush!(system, Pipe8);\n@named Pipe9 = SimplePipe(L=10.0);\npush!(system, Pipe9);\n@named Pipe10 = SimplePipe(L=2.0);\npush!(system, Pipe10);\n@named Pipe11 = SimplePipe(L=2.0);\npush!(system, Pipe11);\n@named Pipe12 = SimplePipe(L=3.0);\npush!(system, Pipe12);\n@named Pipe13 = SimplePipe(L=12.0);\npush!(system, Pipe13);\n@named Pipe14 = SimplePipe(L=1.0);\npush!(system, Pipe14);\n@named Pipe15 = SimplePipe(L=2.0);\npush!(system, Pipe15);\n@named Pipe16 = SimplePipe(L=3.0);\npush!(system, Pipe16);\n@named Pipe17 = SimplePipe(L=6.0);\npush!(system, Pipe17);\n@named Pipe18 = SimplePipe(L=6.0);\npush!(system, Pipe18);\n@named Pipe19 = SimplePipe(L=6.0);\npush!(system, Pipe19);\n@named Pipe20 = SimplePipe(L=1.0);\npush!(system, Pipe20);\n@named Pipe21 = SimplePipe(L=1.0);\npush!(system, Pipe21);\n@named Pipe22 = SimplePipe(L=7.0);\npush!(system, Pipe22);\n@named Pipe23 = SimplePipe(L=3.0);\npush!(system, Pipe23);\n@named Pipe24 = SimplePipe(L=3.0);\npush!(system, Pipe24);\n@named Pipe25 = SimplePipe(L=2.0);\npush!(system, Pipe25);\n\neqs = [\n  connect(A.port, Pump.in)\n  connect(Pump.out, Pipe1.in)\n  connect(Pipe1.out, Pipe2.in, Pipe5.in)\n  connect(Pipe2.out, Pipe3.in, Pipe6.in)\n  connect(Pipe3.out, Pipe4.in, Pipe7.in)\n  connect(Pipe4.out, Pipe10.out, Pipe14.in)\n  connect(Pipe5.out, Pipe11.in, Pipe12.in)\n  connect(Pipe6.out, Pipe8.in, Pipe9.in)\n  connect(Pipe7.out, Pipe9.out, Pipe10.in)\n  connect(Pipe12.out, Pipe8.out, Pipe13.in)\n  connect(Pipe13.out, Pipe14.out, Pipe15.in)\n  connect(Pipe11.out, Pipe19.in, Pipe16.in)\n  connect(Pipe16.out, Pipe17.in, Pipe20.in)\n  connect(Pipe17.out, Pipe18.in, Pipe21.in)\n  connect(Pipe18.out, Pipe15.out, Pipe22.in)\n  connect(Pipe19.out, Pipe20.out, Pipe23.in)\n  connect(Pipe21.out, Pipe22.out, Pipe24.in)\n  connect(Pipe23.out, Pipe24.out, Pipe25.in)\n  connect(B.port, Pipe25.out)\n]\n","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#.2-热力循环系统","page":"Ai4EComponentLib.jl设计理念","title":"3.2 热力循环系统","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/#.1.1-数学内涵","page":"Ai4EComponentLib.jl设计理念","title":"3.1.1 数学内涵","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"热力循环系统中，有几个典型的内部过程。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"等温过程：fracTP = constant\n等压过程：fracTv = constant\n等熵过程：pv^k = constant\n等容过程：pv = constant","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"这些过程中能量变化的体现，最终体现在流体的压力、密度、焓值、熵值、温度上。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"在热力循环中，外部连接正包含这5个状态量。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"在构建热力系统时，尽管可以使用不同内部过程的控制方程，但理论方程和实际始终会有些出入。所以在构建热力系统时，可以利用ModelingToolkit的可拓展性特点——调用外部的物性库。调用物性库可以减小某些理论计算的误差。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"以等温过程为例，过程起点的状态已知。其内部过程的控制方程为：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"T_1=T_2tag11","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"再确定过程终点的另一个状态量，则终点的其他状态可由2个已知状态得到。那么有以下4种组合：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"beginmatrix\n T_2p_2 Rightarrow  s_2D_2h_2\n T_2s_2 Rightarrow  p_2D_2h_2\n T_2D_2 Rightarrow  s_2p_2h_2\n T_2h_2 Rightarrow  s_2p_2D_2\nendmatrixtag12","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"使用CoolProp物性库，输入等式左边的两个参数，就能得到等式右边的任意一个参数。由此，可以外部CoolProp库替换内部方程，完成组件构建。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#.1.2-组件与系统","page":"Ai4EComponentLib.jl设计理念","title":"3.1.2 组件与系统","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"以等焓过程为例，等焓过程中，内部方程为：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"h_1=h_2","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"假如给定一个参数p，则函数chose_equations会自动生成通过ph调用CoolProp得到其他参数数值的代码","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"\nfunction IsoenthalpyProcess(; name, inter_state=\"Q_0\", fluid=\"Water\")\n    @assert inter_state != \"H\" \"IsoenthalpyProcess can't accept H. Please chose another state.\"\n    @named oneport = StreamPort()\n    @unpack Δh, out = oneport\n    eqs = [\n        Δh ~ 0\n    ]\n    push!(eqs, chose_equations(out, inter_state, \"H\", fluid)...)\n    return extend(ODESystem(eqs, t, [], []; name=name), oneport)\nend","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"考虑图3-2描述的再热循环：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"(Image: 图 1)  ","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其代码如下。更加详细的代码请查看代码仓库以及文档。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"@named pump = IsentropicProcess(inter_state=\"P\")\n@named pump_P = DThermalStates(state=\"P\", value=-1.0E5, u0=18.0E6)\n\n@named boiler = IsobaricProcess(inter_state=\"T\")\n@named boiler_T = ThermalStates(state=\"T\", value=550+ 273.15)\n\n@named turbine = IsentropicProcess(inter_state=\"P\")\n@named turbine_P = ThermalStates(state=\"P\", value=3.0e6)\n\n@named reboiler = IsobaricProcess(inter_state=\"T\")\n@named reboiler_T = ThermalStates(state=\"T\", value=450 + 273.15)\n\n@named returbine = IsentropicProcess(inter_state=\"P\")\n@named returbine_P = ThermalStates(state=\"P\", value=4.0e3)\n\n@named condenser = IsothermalProcess(inter_state=\"Q_0\")\n\neqs = [\n  connect(pump.out, boiler.in, pump_P.node)\n  connect(boiler.out, turbine.in, boiler_T.node)\n  connect(turbine.out, reboiler.in, turbine_P.node)\n  connect(reboiler.out, returbine.in, reboiler_T.node)\n  connect(returbine.out, condenser.in, returbine_P.node)\n  connect(condenser.out, pump.in)\n]\n","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#组件化模型的优势","page":"Ai4EComponentLib.jl设计理念","title":"4 组件化模型的优势","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"现在可以做一个小结，组件本质上就是描述变量与变量之间关系的方程。组件内部的控制方程才是最重要的部分，对系统的变化具有决定性意义。外部连接通过补充一个连接方程，描述了组件与组件之间的关系。连接方程对于真正的系统反应不具备决定性，只是辅助系统构建。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"模块化的组件在设计时会把大系统拆解成一个个小组件。这样做的好处是方便用户构建系统，坏处是这些连接变量在系统构建后的系统化简时还要消耗计算资源将它们化简。但事实上，组件化模型带来的收益远超过消耗一点计算资源付出的代价。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"例如，由模块ABC组成的系统视为一个整体X，则ABC成为了X的内部结构，其数学形式也为微分代数方程，与模块ABC的数学形式并没有本质上的区别。唯一的区别在于方程数量的多少。系统X同样拥有对外的三个接口：输入接口x1、x2与输出接口x3。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"(Image: 图 2)  ","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"此时系统与子系统有了完备的闭包概念。假若此时ABC并不是一个最小系统，在ABC的基础之上可进一步细分出更小的模块。那么，可以称ABC为系统X的子系统，系统ABC同样拥有自己的子系统。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"假如ABC一共只有几个方程，那么不需要ABC作为X的子系统来构建。我们直接把X内部的方程手动展平，只包含x1、x2、x3即可。但假如ABC一共有成千上万个方程，假若系统ABC同样拥有自己的子系统。这个时候手动展平还是一种好方法吗？","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"所以，分为内外结构的组件，在组成一个巨型系统时具有重要意义。一旦内部最关键的特性决定了，在今后复杂系统的任何层次节点上，人们的精力都能够集中在系统最关键的问题上——系统（子系统）之间的构建连接关系。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"剩下的化简，就交给计算机吧！若是让人不断的去展平方程，从零构建系统，不也是人力资源的浪费吗？人思维的价值应该体现系统的设计上，而不是展平方程上，虽然浪费一些计算资源，但不也是生产力的提升吗？","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#结论","page":"Ai4EComponentLib.jl设计理念","title":"结论","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"组件化模型在构建时具有它本身的优势。依托于ModelingToolkit符号体系构建的组件化模型则有更加广阔的应用前景。ModelingToolkit自动的回调时间相应、DifferentialEquations的求解器分析可以更加灵活地处理仿真问题，基于ModelingToolkit的OptControl.jl可以将组件模型系统转变利用JuMP求解的最优控制问题。此外还有SciML的参数辨识工具包等等。在Julia社区的强力支撑下，组件化模型不仅仅是用于仿真的方程，它也可以是控制问题中的状态方程模型，优化问题中的约束。组件的本质——方程可以用最基本Julia要素描述——函数。","category":"page"},{"location":"Optimization/GenSBO/#GenSBO—a-General-**S**imulation-**B**ased-**O**ptimizer","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"","category":"section"},{"location":"Optimization/GenSBO/#GenSBO简介","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO简介","text":"","category":"section"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"GenSBO（General Simulation Based Optimizer）是由Ai4Energy开发的一个面向仿真的优化器。它利用智能优化算法，在优化过程中通过调用仿真器获取当前方案的评价值，从而帮助算法获得可靠的优化结果。","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"GenSBO 支持单目标优化和多目标优化，并分别实现了基于改进简化小波粒子群算法的单目标优化引擎和基于改进小波全面学习粒子群算法的多目标优化引擎。该优化器还能够处理混合整数非线性优化问题，并且允许用户方便地自定义目标函数。","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"通过使用 GenSBO，用户可以灵活地进行面向仿真的优化，将智能优化算法与仿真模型相结合，实现高效、可靠的优化方案，从而优化设计和决策过程。","category":"page"},{"location":"Optimization/GenSBO/#模块组成","page":"GenSBO—a General Simulation Based Optimizer","title":"模块组成","text":"","category":"section"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"问题定义模块 (Problem): 该模块用于定义优化问题，包括目标函数、约束函数以及变量的类型和范围等信息。\n优化评估模块 (UserFunction): 用于评估优化问题的目标函数和约束函数值。它与实际的优化问题相关联，通过调用仿真模拟器来获取当前方案的评价值。\n优化算法模块 (PSO): 优化算法模块实现了多种优化算法，如粒子群算法（PSO）。用户可以根据需要选择合适的优化算法来解决特定的优化问题。\nGenSBO主程序 (GenSBO): GenSBO主程序是整个优化系统的核心部分。它将问题定义模块、仿真模拟器和优化算法模块进行整合，并负责执行优化过程。\n结果保存和可视化模块: GenSBO支持将优化结果保存为多种格式，如 np.array 和 xls。此外，它还提供了可视化功能，可以绘制寻优历史图和帕累托前沿图。","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"通过这些组成部分，GenSBO实现了面向仿真的优化功能，将智能优化算法与仿真模拟器相结合，以获得高效、可靠的优化方案结果。用户可以根据自己的需求，选择合适的目标函数、约束函数、变量类型以及优化算法来解决各类优化问题。","category":"page"},{"location":"Optimization/GenSBO/#算法组成","page":"GenSBO—a General Simulation Based Optimizer","title":"算法组成","text":"","category":"section"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"GenSBO结合了SPSO算法（粒子群优化算法）和PSOWM算法（粒子群优化算法）","category":"page"},{"location":"Optimization/GenSBO/#对于单目标优化","page":"GenSBO—a General Simulation Based Optimizer","title":"对于单目标优化","text":"","category":"section"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"在传统的PSO算法中，粒子通过维护位置和速度两个信息来进行搜索。在每次迭代中，粒子根据自身和邻域最优解的信息，更新自己的速度和位置。这样的设计可以使得粒子向着较优解的方向移动，逐渐收敛到全局最优解或局部最优解。","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"速度和位置更新公式：","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"(Image: GenSBO1)","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"SPSO算法的改进了PSO算法，它只保留粒子的位置更新公式，省略速度的更新，减少了计算成本；同时引入反向搜索机制，增强了算法的全局寻优能力，可以更好地找到全局最优解。","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"反向搜索公式：","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"(Image: GenSBO2)","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"(Image: GenSBO3)","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"PSOWM算法引入小波变异操作。在每一次迭代过程中，以一定的概率对部分粒子的位置进行小波变异。这个小波变异操作会在当前位置附近产生一个随机的扰动，从而增加了粒子的多样性和随机性。","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"小波变异公式：","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"(Image: GenSBO4)","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"(Image: GenSBO5)","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"(Image: GenSBO6)","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"通过这种方式，SPSO算法和PSOWM算法的结合使GenSBO既保留了传统PSO的粒子群协作和学习的特性，又提供了运算速度，增强了全局寻优能力，增加了算法的探索性和多样性。这样一种改进可以提高算法在复杂优化问题中的表现，并有可能找到更优的解。","category":"page"},{"location":"Optimization/GenSBO/#对于多目标优化","page":"GenSBO—a General Simulation Based Optimizer","title":"对于多目标优化","text":"","category":"section"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"对于多目标优化，GenSBO采取了基于MOPSO算法（多目标粒子群优化算法）的CLPSOWM算法（小波粒子群优化算法）","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"MOPSO算法相比于PSO算法，它是在多个目标函数下寻找一组非劣解（Pareto前沿）用于解决多目标优化问题，研究者可以根据自己的需求选择最合适的解。其适应度函数是一个多目标函数，它衡量解向量在多个目标下的优劣程度。","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"总的来说，MOPSO算法是PSO的扩展，用于解决多目标优化问题。MOPSO考虑了多个目标函数下的优化，并寻找一组非劣解来提供决策者多样的选择。","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"而CLPSOWM算法是对MOPSO算法的改进，它对位置信息增加小波变异操作，增加粒子的多样性和随机性。","category":"page"},{"location":"Optimization/GenSBO/#约束处理","page":"GenSBO—a General Simulation Based Optimizer","title":"约束处理","text":"","category":"section"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"GenSBO有普通罚函数方法和Oracle罚函数法可供选择。","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"普通罚函数是一种在优化问题中常用的约束处理方法，用于将含约束的优化问题转化为无约束的优化问题。在普通罚函数中，通过在目标函数中添加罚项来惩罚违反约束条件的解，从而将约束条件考虑进优化过程中。","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"Oracle罚函数是一种使用Oracle模型（也称为信赖域模型）的罚函数方法。在这种方法中，使用罚函数来惩罚违反约束的解，并在优化过程中使用Oracle模型来选择罚因子。Oracle模型是用于近似代替原始目标函数的模型，它在当前解附近进行局部逼近。通过使用Oracle模型来确定罚因子，可以更好地平衡罚函数的影响，从而提高优化的效率和稳定性。","category":"page"},{"location":"Optimization/GenSBO/#算法流程","page":"GenSBO—a General Simulation Based Optimizer","title":"算法流程","text":"","category":"section"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"设置算法参数；\n初始化粒子位置；\n评价粒子的适应值；\n更新粒子个体历史最优和全局最优信息；\n执行小波变异操作；\n按SPSO公式更新粒子的位置；\n重复（3）、（4）、（5）、（6），直到满足收敛条件。","category":"page"},{"location":"Optimization/GenSBO/#GenSBO的使用","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO的使用","text":"","category":"section"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"GenSBO只需要在python下载安装gensbo包即可，gensbo包的使用包含","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"导入所需模块\n编写变量类型\n确定目标函数和约束函数\n设置PSO优化算法参数\n运行寻优模块","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"这几个部分。相关示例可以参考官方文档，以下是对这几部分的详细说明。","category":"page"},{"location":"Optimization/GenSBO/#安装","page":"GenSBO—a General Simulation Based Optimizer","title":"安装","text":"","category":"section"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"# pip 安装\npip install gensbo\n# 下载代码\npython setup.py install","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"可以用pip 安装命令来安装它，通过输入上述代码，下载安装gensbo包。","category":"page"},{"location":"Optimization/GenSBO/#导入所需模块","page":"GenSBO—a General Simulation Based Optimizer","title":"导入所需模块","text":"","category":"section"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"#从sys模块中导入path\nfrom sys import path\npath.append('..\\\\..\\\\')\n\n#导入gensbo模块\nfrom gensbo.gensbo import GenSBO\nfrom gensbo.core import Problem\nfrom gensbo.simulators.userfunction import UserFunction\nfrom gensbo.optimizers.pso import PSO\n\n#导入 NumPy 库\nimport numpy as np","category":"page"},{"location":"Optimization/GenSBO/#编写变量类型","page":"GenSBO—a General Simulation Based Optimizer","title":"编写变量类型","text":"","category":"section"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"使用 Problem 模块定义您的优化问题。您需要指定变量的类型（连续、离散等）、变量的范围、约束函数以及目标函数。同时，您可以选择性地为变量提供初始值。","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"# 创建问题实例\nproblem = Problem(\"function_name\")\n\nproblem._TotalNumVar = 5         # 总变量数\nproblem._TotalNumConstraint = 3  # 总约束数\nproblem._NumObjFunc = 1\t         # 总目标函数数(1：单目标优化;  >=2：多目标优化)\n\n# 添加变量\nproblem.add_var(\"x1\", \"continuous\", lowbound=-15.0, upbound=15.0, value=None)      # 连续变量\"continuous\"\nproblem.add_var(\"x2\", \"discrete\", lowbound=-5.0, upbound=9.0, value=4)             # 离散连续整型变量\"discrete\"\nproblem.add_var(\"x3\", \"discrete_disconti\", \tset=[-5, -3, 0, 6, 9, 23], \tvalue=None)# 离散非连续变量\"discrete_disconti\"(从传入取值集合set中取值)\nproblem.add_var(\"x4\", \"binary\", lowbound=0, upbound=1, value=0)                    # 二元整型变量\"binary\"\n\n#传入变量初始值\nif_batch_add_var_ini = True        #是否批量传入变量初始值\nif if_batch_add_var_ini == True:\n     # 加载上次寻优导出的可行解\n    var_ini = np.load('%s_so.npy'%name,allow_pickle=True)[0][-1]  \n    problem.batch_add_var_ini(var_ini)","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"注：","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"lowbound,upbound为变量最大值与最小值\n初值value的选取应尽可能有助于提供最优解的信息，否则应将其设为‘None’（建议均设为‘None’）请谨慎使用\n在多目标优化中，通过设置某已知非支配解作为初值，同时减小寻优代数（‘stepmax’）或增大外部档案容量（‘paretosize’），可以在较短时间内获得该解周围的详细非支配解信息。\n导入值支持 list 和 np.array 格式\nvar_ini = np.load('%s_so.npy'%name, allow_pickle=True)[0][-1]: \nnp.load()函数用于从.npy文件中加载数据，根据文件名'%s_so.npy' % name加载上次寻优导出的可行解，参数allow_pickle=True表示允许加载包含Python对象的.npy文件。\n每个解向量初值中变量顺序应与添加变量顺序一致（与寻优结果导出的解向量中变量顺序相同）","category":"page"},{"location":"Optimization/GenSBO/#定义优化问题（目标函数和约束函数）","page":"GenSBO—a General Simulation Based Optimizer","title":"定义优化问题（目标函数和约束函数）","text":"","category":"section"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"在 problem_function 函数中添加目标函数和约束函数。","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"# 添加目标函数和约束函数\ndef problem_function(varset,if_cal_cons_only=False):\n    \"\"\"\n    添加目标函数和约束函数\n    :param varset: 变量集,字典（'var_name':value）\n    :param if_cal_cons_only：布尔值，是否只计算约束函数值而不计算评价函数值，用于产生可行解\n    :return: 目标函数值list、约束值list，参考值flag\n    \"\"\"\n    objfunc = [0 for _ in range(problem._NumObjFunc)]\n    constraint = [[] for _ in range(problem._TotalNumConstraint)]\n\n    # 给变量名赋值（x1 = value)\n    globals().update(varset)\n\n    if if_cal_cons_only == False:\n        # 添加目标函数\n        objfunc[0] = -(- x1 * np.cos(np.pi * x1) + x1 * x2 + 4 * x3 - 5 * x4) - x5\n\n    # 添加约束函数\n    constraint[0] = ['i', (x1 + x2) - 50]\n    constraint[1] = ['i', (x1 + x1 * x3) - 34]\n    constraint[2] = ['i', (x4 + x3) - 33.3]\n     ######################################################\n    # 第i个约束条件：constraint[i] = [cons_type,cons_value]\n    # 约束类型：cons_type=['i','e']\n    # 约束函数计算值：cons_value=[g(x),h[x]]\n    # 'i'：不等式约束，形式为g(x)<=0\n    # 'e'：等式约束，形式为|h(x)|-ϵ <= 0, ϵ默认值为1e-5。\n    ######################################################\n\n    # 参考信息\n    flag = 0\n    return objfunc, constraint, flag","category":"page"},{"location":"Optimization/GenSBO/#PSO优化算法参数设置","page":"GenSBO—a General Simulation Based Optimizer","title":"PSO优化算法参数设置","text":"","category":"section"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"参数设置方式：\n\t# 创建优化器实例\n\toptimizer = PSO(problem)\n\n\t# 设置参数\n\toptimizer.set_options('para_name', value)","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"公用参数：\n'if_ini_cons': False,\n    # 是否要求初始化的粒子必须含有可行解（不违反约束）,False：不要求；True:要求。\n\n'swarm_size': 30,  \n\t# 粒子数量\n'step_max': 500,\n\t# 最大寻优代数\n'w_type':'linear',\n\t# 惯性权重方式，'linear'-线性，'fixed'-定值，'chaos'-混沌惯性权重\n\t\n# {{{惩罚函数相关参数\n'penalty_type': 'common',\n# 选择罚函数方法，字符串（default：'common'）\n# 'common' - 普通（动态）罚函数，'oracle' - oracle罚函数\n# 粒子群多目标优化算法不支持oracle罚函数方法\n'penalty_times': 100,\n# penalty_type = 'common'时生效，惩罚倍数，浮点数（default：100）\n# 使违反约束的解受到惩罚后的函数值一定大于全局最优适应函数值\n'oracle': 1e9,\n# penalty_type = 'oracle'时生效，Ω初始值，浮点数（default：1e9）\n# 该值必须大于全局最优适应函数值\n# }}}惩罚函数","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"单目标粒子群算法sopso：","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"'pso_mode': \"ispsowm\",\n\t# 选择用于运算的单目标pso方法，字符串（default：'ispsowm'）\n\t# 目前提供：\n\t# \"standard_pso'-标准粒子群算法\n\t# 'ispsowm'-改进小波简化粒子群算法（复杂问题推荐）\n\t# 选择ispsowm时，\n\t# c（反向搜索阈值）, pm（变异阈值）, xi_wm（形状因子）,g（函数a的上限值） 参数生效。\n\t# 若搜索过程表明粒子群明显陷入早熟，则适当增大c，pm的值。具体参数设置请参考说明文档。\n\n'w': 0.8,\n# 惯性权重（default：0.8）\n'w_range_so': [0.4, 1.2],\n# 惯性权重变化范围，数组（浮点数）（default：[0.4, 1.2]）\n'c1': 2.0,\n# 加速因子中的认知因子（default：2）\n'c2': 2.0,\n# 加速因子中的社会因子（default：2）\n\n'precision': 0.001,\n# 收敛精度，浮点数（default：1e-3）\n# 寻优程序设定当种群粒子的个体历史最好目标函数值（集合）的标准差小于收敛精度时收敛。\n# 问题规模较小时，可将precision调大\n\n'neighborhood': 'star',\n# 粒子群邻域结构，'star'（全互连型），'ring'（环型）（搜索速度较慢，但更不容易陷入早熟）\t\n\n# {{{小波相关参数\n'c': 0.2,\n# 反向搜索概率，浮点数（default：0.2）\n'pm': 0.7,\n# 执行小波变异的概率阈值，浮点数（default：0.7），取值范围[0,1]\n'xi_wm': 0.5,\n# 形状参数，浮点数（default：0.5）\n'g': 1000,\n# 小波函数中a的上限值，浮点数（default：1000），常取1000或10000\n# }}}小波","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"多目标粒子群算法mopso：","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"\t'x_pareto_size': 100,\n\t# 外部档案大小（存放非支配解），整数（default：100）\n    \n    'if_use_former_x':True,\n    # 是否利用前次寻优得到的pareto前沿（稀疏部分）引导本次寻优\n\n\t'w_mo': 0.4,\n\t# 惯性权重（default：0.4）\n\t'w_range_mo': [0.2, 0.6],\n\t# 惯性权重变化范围，数组（浮点数）（default：[0.2, 0.6]）\n\t'c_mo': 2.0,\n\t# 加速因子，浮点数（default：2）\n\n\t'run_number': 5,\n\t# 独立寻优次数，整数（default：5），合并各次寻优结果pareto前沿\n\n\t'pm_mo': 0.7,\n\t# 执行小波变异的概率阈值，浮点数（default：0.7），取值范围[0,1]\n\t'xi_wm_mo': 0.5,\n\t# 形状参数，浮点数（default：0.5）\n\t'g_mo': 1000,\n\t# 小波函数中a的上限值，浮点数（default：1000），常取1000或10000\n\t'pe_mo': 0.4,\n\t# 精英概率，浮点数（default：0.4），取值范围[0,1]\n\t'pl_mo': 0.1,\n\t# 学习概率，浮点数（default：0.1），取值范围[0,1]","category":"page"},{"location":"Optimization/GenSBO/#运行寻优模块","page":"GenSBO—a General Simulation Based Optimizer","title":"运行寻优模块","text":"","category":"section"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"    # 执行主程序\n    gensbo = GenSBO(problem, simulator, optimizer)\n\n    # 记录当前寻优结果，防止意外报错使得进程结束--代码有误\n    result_temp = gensbo.result_temp\n\n    # 记录当前寻优可行解结果，防止意外报错使得进程结束\n    feasible_f_temp = gensbo.feasible_f_temp\n    feasible_x_temp = gensbo.feasible_x_temp\n\n    gensbo.run()\n\n    # 获取寻优结果\n    result = gensbo.result\n    '''\n    单目标优化结果\n    result = [f, x, constraint_info， f_history, feasible_f, feasible_x]\n               [寻优结果函数值（浮点数），寻优结果解向量（一维数组），\n                [解向量违反的约束序号数组，解向量所有约束函数的值],\n                寻优历史全局最优函数值（一维数组），\n                可行解的函数值集合（一维数组），可行解集合（二维数组）]\n    \n    \n    多目标优化结果\n    result = [f_pareto, x_pareto, feasible_f, feasible_x]\n               [寻优结果非支配解集（pareto前沿）的目标函数值集合（数组（浮点数））,\n                寻优结果非支配解向量（数组（浮点数））,\n                可行解的函数值集合（二维数组），可行解集合（二维数组）]\n    '''\n\n    # 保存数据\n    gensbo.save_data(filename=problem.name, filepath='.\\\\')\n\n    # 结果可视化，若需保存图片则需输入文件名及保存文件路径\n    gensbo.visualize(filename=problem.name, filepath='.\\\\')","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"如果需要更多相关信息，请参考官方文档。","category":"page"},{"location":"Optimization/GenSBO/#小结","page":"GenSBO—a General Simulation Based Optimizer","title":"小结","text":"","category":"section"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"GenSBO是一个功能丰富的仿真类问题的优化器。它提供了智能的优化算法，以及灵活的问题定义方式，使其适用于解决各种实际优化问题。在使用 GenSBO 进行优化时，可以实现更快的运算速度和可靠的优化结果。","category":"page"},{"location":"Optimization/GenSBO/","page":"GenSBO—a General Simulation Based Optimizer","title":"GenSBO—a General Simulation Based Optimizer","text":"使用 GenSBO 和其他通用型优化器类似，首先需要定义问题类型，然后补充变量、约束条件、目标函数等优化问题的基本要素。接着，可以根据问题的特点和复杂程度选择合适的优化算法，并对其进行调参。通过合理设置算法参数，可以提高优化效率和寻找更优解的能力。","category":"page"},{"location":"Modeling/neural_network/#数学视角下的神经网络","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"tip: Tip\nContents：Flux，神经网络Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"note: Note\nFlux.jl Julia机器学习包\n著作\nPattern Recognition and Machine Learning - Christopher M. Bishop\n机器学习 - 周志华\nDive into Deep Learning - 阿斯顿·张，李沐\n博文\nApacheCN 人工智能知识树\n机器学习原理\n视频\n吴恩达 deeplearning.ai\n李宏毅 Course-Machine Learning\n前言\npapers with code","category":"page"},{"location":"Modeling/neural_network/#神经网络的数学内涵","page":"数学视角下的神经网络","title":"1 神经网络的数学内涵","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 2)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"对于这样一个简单的神经网络，其中间神经元的激活函数为tanh，输入x与输出y之间的数学表达式为：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"y=w_21tanhleft(w_11x+b_11right)+w_22tanhleft(w_12x+b_12right)+b_2","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"训练的目标为：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"minsum_i=0^n left(y_reali-y_trainiright)^2 tag1-1","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"其中y_reali为实际数据，y_traini为通过模型计算出来的数据。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"如果y也是一个激活函数tanh，经过激活函数后输出，那么数学模型则变为：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"y=tanh(w_21tanhleft(w_11x+b_11right)+w_22tanhleft(w_12x+b_12right)+b_2)+b","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"神经网络的参数训练，则是为了要找到使训练目标最小的一组参数：w_ijb_ij。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"由此可以归纳：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"神经网络的本质是一个关于激活函数的复合函数\n训练的内涵是寻优的过程，内涵是优化问题（回归问题）\n神经网络处理问题的内涵是用复合函数去拟合数据集","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"所以从数学内涵上来说，作为人工智能代表之一的神经网络并没有那么神秘。事实上，它也并没有那么强大！根据其内涵，可以总结出其优缺点。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"优点：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"普适性的优化框架，如BP算法\n模型任意搭建，成熟的工具（Tensorflow等）","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"缺点：包含了拟合的缺点。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"其模型的内涵（机理）不明确，只是从数学的角度逼近真实数据\n容易过拟合","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"下面通过一些实验来说明。","category":"page"},{"location":"Modeling/neural_network/#神经网络的学习特性探究","page":"数学视角下的神经网络","title":"2 神经网络的学习特性探究","text":"","category":"section"},{"location":"Modeling/neural_network/#.1-一维曲线学习","page":"数学视角下的神经网络","title":"2.1 一维曲线学习","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"考虑简单的函数学习问题，用神经网络（1隐藏层2节点，如上图所示，中间层激活函数采用双曲正弦函数）来学习一个一元函数，即单输入单输出网络，一共有7（2*2+2+1）个参数。在数据集中生成中，严格按照二次曲线规律生成，不添加任何扰动。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"采用下面的程序计算，训练10000次，训练结果的均方差为5.52E-5。为了验证学习的效果。在区间010内取一些原函数（y= x^2）上的点，作为测试集。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"using Flux\nusing Flux: train!\nusing Plots\n\nW1 = rand(2,1)\nb1 = rand(2)\nlayer1(x) = W1 * x .+ b1\n\nW2 = rand(1,2)\nb2 = rand(1)\nlayer2(x) = W2 * x .+ b2\n\ng(x) = x^2\n\nmodel(x) = layer2(g.(layer1(x)))[1]\n\nx_train = collect(0:.1:1)\ny_train = x_train.^2\nscatter(x_train,y_train,legend=false)\n\nmodel.(x_train)\nloss(x,y) = Flux.Losses.mse(model.(x),y)\nparameters = [W1,b1,W2,b2]\ndata = [(x_train,y_train)]\nopt = Descent(0.1)\nfor i in 1:5000\n    train!(loss, parameters, data, opt)\nend\nprintln(loss(x_train,y_train))\nbegin\n    scatter(x_train,y_train,legend=false,title=\"x^2\",color=\"red\")\n    plot!(x_train,model.(x_train),color=\"blue\")\nend\n\nbegin\n    x_learned = collect(0.07:0.07:1)\n    scatter!(x_learned,x_learned.^2,legend=false,color=\"green\")\nend","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 3)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"学习的结果如上图，红色点为训练集，以绿色点为测试集。可以认为，学习机很好地找到了在区间010原有数据的“机理”，因为学习结果几乎和原函数一致。这是一个非常漂亮的学习过程！","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"上述学习训练过程的核心特点为：训练集的学习域覆盖了测试集的测试域，它们都在之内010。自然而然地想到，没有学习过的区域呢？比如1020left-1000right这些区间表现会表现得怎么样？","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"begin\n    x_pred = collect(1:.1:2)\n    scatter!(x_pred, x_pred.^2,legend=false,color=\"green\")\n    plot!(x_pred,model.(x_pred),color=\"blue\")\nend\n\nbegin\n    x_pred = collect(-1.0:.1:0)\n    scatter!(x_pred, x_pred.^2,legend=false,color=\"green\")\n    plot!(x_pred,model.(x_pred),color=\"blue\")\nend","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 5)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"在1020left-1000right区间上，结果如图所示。表现为没有“学会”。因为实际值和测试值偏离了。","category":"page"},{"location":"Modeling/neural_network/#.2-内涵探讨","page":"数学视角下的神经网络","title":"2.2 内涵探讨","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"事实上，这个结果应该是意料之中的。上面说过，神经网络学习的本质上是用复合函数逼近。用一个构造的数学函数y去代替数据点二次曲线的实际内涵。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"Tanh的泰勒展开为：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"tanh=x-fracx^35+frac2x^515+o(x^7)","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"在式（1-1）中，学习机除去偏移量b_2还有6个参数，简单认为逼近的精度为tanh泰勒展开的前6项，误差为项为o(x^13)。在数据训练集区间内，o(x^13)可以保证在训练域误差可以很小，但一旦扩展到全实数域，这部分误差是无法避免的。因为其本质的“机理”并不相同。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"上面的问题中，神经网络通过参数优化，逼近了0 10区间内关于x^2的数据特性，可以使得学习机在0 10 完美替代x^2$。在这个区间外，它还是它自己，即tanh。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"所以，神经网络的数学内涵是逼近，其预测世界规律的方法是激活函数。采用统一的方法去逼近任意区间内的数据。所以，从数学的角度，激活函数与神经元个数都体现神经网络结构的逼近能力。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"下图分表表示了激活函数为exp与x^2训练与预测情况。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 6)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 7)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"在0 10内，可以认为神经网络可以代表x^2。而在0 10外，函数走势都是它们“本来的样子”。","category":"page"},{"location":"Modeling/neural_network/#.3-二维曲线学习","page":"数学视角下的神经网络","title":"2.3 二维曲线学习","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"拓展到二维平面拥有相同的规律。采用10节点2隐藏层全连接网络逼近二元函数函数:","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"gleft(xyright)=sinleft(xright)ast c o sleft(yright)   xyinleft(01right)","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"神经网络图与训练结果如下图：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 8)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 9)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"散点代表真实值。平面代表预测平面。可以看到散点图几乎都在平面上，训练效果较好。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 10)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"学习机在xyinleft(02right)的表现如上图所示。红点为训练数据集，黄点为训练集域内的测试集，绿点为训练集外的测试集。可以看到随着预测范围往外扩展，绿点作为测试集与预测平面已经“分道扬镳”。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"这与前面的分析一致，不同之处在于学习机逼近二元函数，逼近的对象是面而不是曲线。再拓展到更高维度的超平面上，神经网络逼近的特性仍然成立。这是由它的数学内涵决定的。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"代码如下。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"using Flux\nusing Flux: train!\nusing Plots\n\nW1 = rand(10,2)\nb1 = rand(10)\nlayer1(x) = W1 * x .+ b1\n\nW2 = rand(10,10)\nb2 = rand(10)\nlayer2(x) = W2 * x .+ b2\n\nW3 = rand(1,10)\nb3 = rand(1)\nlayer3(x) = W3 * x .+ b3\n\nmodel(x) = layer3(tanh.(layer2(tanh.(layer1(x)))))[1]\n\nxs = collect(0:0.1:1.0)\nx_grid = [x for x = xs for y = xs]\na_grid = [y for x = xs for y = xs]\nz_train = cos.(x_grid) .* sin.(a_grid)\nxy = [[x,y] for x in xs for y in xs]\nmodel.(z_train)\n\nloss(x,y) = Flux.Losses.mse(model.(x),y)\nparameters = [W1,b1,W2,b2,W3,b3]\ndata = [(xy,z_train)]\nopt = Descent(0.1)\n\nfor i in 1:1000\n    train!(loss, parameters, data, opt)\nend\nprintln(loss(xy,z_train))\n\n\n\nxs = collect(0:0.1:2.0)\nx_grid = [x for x = xs for y = xs]\na_grid = [y for x = xs for y = xs]\nxy = [[x,y] for x in xs for y in xs]\nz_predic = model.(xy)\nplot(x_grid,a_grid,z_predic, st = :surface)\nscatter!(x_grid,a_grid,cos.(x_grid) .* sin.(a_grid))\n\n\nxs = collect(0:0.1:2.0)\nx_grid = [x for x = xs for y = xs]\na_grid = [y for x = xs for y = xs]\nxy = [[x,y] for x in xs for y in xs]\nz_predic = model.(xy)\nplot(x_grid,a_grid,z_predic, st = :surface)\nxs = collect(0.05:0.1:1.0)\nx_grid = [x for x = xs for y = xs]\na_grid = [y for x = xs for y = xs]\nscatter!(x_grid,a_grid,cos.(x_grid) .* sin.(a_grid),color=\"yellow\",legend=false)\nxs = collect(0:0.1:1.0)\nx_grid = [x for x = xs for y = xs]\na_grid = [y for x = xs for y = xs]\nscatter!(x_grid,a_grid,cos.(x_grid) .* sin.(a_grid),color=\"red\")\nxs = collect(0:0.1:2.0)\nx_grid = [x for x = xs for y = xs if x>=1.0||y>=1.0]\na_grid = [y for x = xs for y = xs if x>=1.0||y>=1.0]\nscatter!(x_grid,a_grid,cos.(x_grid) .* sin.(a_grid),color=\"green\")","category":"page"},{"location":"Modeling/neural_network/#.4-正则化对逼近的影响","page":"数学视角下的神经网络","title":"2.4 正则化对逼近的影响","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"那么正则化的引入有没有改变这一内涵呢？答案是否定的。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"在前面的讨论中，数据集都严格符合函数规律，没有任何误差。在实际的数据集中，不可能由如此理想的情况。而正则项就是对这测量值误差的一种折中处理，神经网络的设计者可以通过正则项来指引网络的优化方向，从人的智能角度规避纯数据带来的“误导”。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"首先，基于y=x^2在0010范围内生成一些点，并且加上随机扰动作为训练集。如下图所示。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 11)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"从散点图依稀可以看出二次函数的影子。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"下面尝试不同的正则化。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"情况1，无正则化：Loss=sum_i=1^Nleft(y_i-fleft(x_iright)right)^2","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 13)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"情况2，正则化大权值逼近y=05：Loss=sum_i=1^Nleft(y_i-fleft(x_iright)right)^2+100ast(fleft(x_iright)-05)^2","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 14)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"情况2，正则化大权值逼近y=x^2：Loss=sum_i=1^Nleft(y_i-fleft(x_iright)right)^2+100ast(fleft(x_iright)-x_i^2)^2","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 16)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"学习机是否克服了“逼近”带来的缺点呢？答案依旧是否定的。在未知域，学习机并没有带来惊喜。如图下图所示，在1020的预测范围内，预测能力也没有得到显著的提升。Loss方程的改变，只是规避了数据观测误差带来的影响，防止神经网络因某些异常点陷入过拟合状态。其并没有改变神经网络架构逼近的数学内涵，所以其仍然不具备学习域外的预测能力，因为其“探索世界的根本方法论”依旧是——tanh。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"但正则项所带来的泛化能力是毋庸置疑的，在遇到特定问题时也许不容易知道数据的“机理”，但是从方法论的进程上来说，正则化已经向“探索未知”迈出了重要的一步。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 17)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"using Flux\nusing Flux: train!\nusing Plots\nusing Statistics\n\nN = 10\nW1 = rand(N,1)\nb1 = rand(N)\nlayer1(x) = W1 * x .+ b1\n\nW2 = rand(1,N)\nb2 = rand(1)\nlayer2(x) = W2 * x .+ b2\n\nmodel(x) = layer2(tanh.(layer1(x)))[1]\n\nx_train = collect(0:.1:1)\ny_train = x_train.^2 .+ rand(length(x_train))*0.2\n\nmodel.(x_train)\nloss(x,y) = 0.1*Flux.Losses.mse(model.(x),y) + mean((model.(x).-x.^2).^2)\nparameters = [W1,b1,W2,b2]\ndata = [(x_train,y_train)]\nopt = Descent(0.1)\nbegin\n    for i in 1:2000\n        train!(loss, parameters, data, opt)\n    end\n    println(loss(x_train,y_train))\nend\n\nbegin\n    scatter(x_train,y_train,legend=false)\n    plot!(x_train,model.(x_train))\nend\n\nbegin\n    x_pred = collect(1:0.1:2)\n    y_pred = model.(x_pred)\n    scatter!(x_pred,x_pred.^2,color=\"green\")\n    plot!(x_pred,y_pred,color=\"green\")\nend\n","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"神经网络的数学内涵是用函数去逼近某个区间内的数据集，其本质的特征是激活函数。这一点决定了在未学习过的未知域，神经网络的预测作用有限。 在纷杂又充满噪声的数据中，正则化是探索数据内涵重要的利器！正则项代表人的智能对学习机学习的一种指导，在已知域内正则化可以剔除噪声发现已知域的本质。这是从完全的数据挖掘以至于陷入过拟合发展状态的重大突破。虽然如此，但正则项没有改变根本的拟合逼近问题。","category":"page"},{"location":"Modeling/neural_network/#启发与讨论","page":"数学视角下的神经网络","title":"3 启发与讨论","text":"","category":"section"},{"location":"Modeling/neural_network/#神经网络应用的启示","page":"数学视角下的神经网络","title":"神经网络应用的启示","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"从上面的分析中，我们可以划分定义两个概念：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"训练域：训练集涉及到的变量区间\n未知域：训练集未涉及到的变量区间","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"可以把测试集分成两类。一类是在训练域中的，一类是在未知域中的。由上面的实验可以推知，在训练域中训练集的临域通过学习机“逼近”了，那么在临域内的测试集就能有很高预测精度。而在未知域中的测试集，那么就只能听天由命。因为训练域之外，学习机就呈现了激活函数本来的面貌。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"对其应用而言，又要引入两个概念：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"结构化问题：传统的机理明确（能用完备的数学方程描述，如欧姆定律：U=I*R）的问题\n非结构化问题：机理不明确的问题（只知变量之间有关联但无明确的机理量化关系，如喝牛奶频率和身高的关系）","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"从以上分析，可以知道。在结构化问题中，神经网络无优势。其优势在于非结构化问题的预测，因为非结构化问题本就机理不明，不明就“暴力拟合”试试呗 :)！虽然上述过程中讨论的都是结构化问题，但是对于非结构化问题也有一定的参考。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"例如，人脸识别。这可以从某种程度上解释人脸学习时为何需要一组端端正正的人脸。图像可以视作高维函数（自变量为RGB值）。一组端正的人脸保证了不管是训练集还是测试集，他们作为“数”的特性的坐标都比较相近，即保证了用来测试的人脸一定是在训练时“见过的”，或者“和见过的非常相近”。类比至上述实验的解释是，采用端正的0 10区间的“人脸”作为训练集，当测试集的人脸也很端正，也在0 10区间内，或者在其“附近”，那么学习机就能准确识别，因为已经学过了。但是，出现了一张“奇怪”的人脸，假设它是在25 30区间内。这没有学过，那就不会！","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"那么，机器学习的应用中可以获得一些启示。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"对于分类问题判别问题，应该用训练集包含更加广泛的训练域，如果训练域涵盖了测试集，那么精度会非常高。类似与高维的图像识别在数据量少的如何做到这一点呢？就需要在特征提取与降维方面下功夫。简单来说是，训练时让学习机见识过了所有的情况，那么测试时再见到，它一定可以处理得很好。如果见识太少，那就只能靠猜。人的经验不就是这样的道理吗？但问题是，在一维0 10区间，我们很容易界定训练域与未知域。在实际问题中，这是很难定义的。例如，怎么量化定义人脸的训练域？仅通过RGB颜色值？似乎不好说。所以，这还有待长远的探索。\n关于预测，若是对于训练域之外的测试集要想准确预测，要么改变tanh能够让激活函数体现出数据发展趋势的“道”；要么提取被学习对象的精髓让激活函数能够成为它的“道”。但预测本来就有巨大的不确定性。在实际问题的非结构性问题中，神经网络拟合的这个“机理”究竟是否是“真实的机理”呢？没人说得清，依旧要靠其它测试集来实践检验！或者，面对一些复杂的问题，通过一系列“猛如虎的操作”（例如池化卷积等等），本质上没有提升神经网络的预测能力，而是通过调参把训练集与测试集的尽可能缩到了处理后的变量训练域内。这样，逼近就有效果了，但这内涵难道不更像是插值处理？所以预测在某些些问题上，本就是一个伪命题。要真正实现预测，一定是机理得以明确，找到了事物最本质的规律之后的“对未知的预测”，而不是基于统计原理的“带插值含义的预测”。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"所以，对于神经网络，我们不需要过于神话。其本质可以看作一个强有力的拟合工具，尤其是在计算机技术飞速发展的今天，神经网络有它巨大的使用价值。但作为工具来说，科学的发展并不依赖于工具。工具只是手段，有些时候我们也应该“不忘初心”，回到对问题本质的结构化性质探索的方向上去。从另一个角度来说，神经网络可以成为结构化性质探索道路上的得力帮手，但是其大概率不能成为决定性因素。若是我们心中对它已经有了一种依赖，或者陷入了某种网络调参的狂热。那么我们是不是应该反思，我们是否陷入了对机器学习的路径依赖，是否忘了探索的真谛——研究问题本身？","category":"page"},{"location":"Modeling/neural_network/#.2-学习的本质","page":"数学视角下的神经网络","title":"3.2 学习的本质","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"人类探索真理的过程，本质上是一个演绎推理、实验验证的过程。对应机器学习，一次训练对应演绎推理，测试集测试对应实验验证。对于人类的科学发展而言，这一探索是螺旋式上升的。从实践到理论，再用理论指导实践，实践结果修正理论，这是马克思科学原理的哲学观。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"在探索与发展的过程中，没有什么是绝对成立的，没有绝对的真理。就像牛顿定律不适用于量子领域，正是在“大误差”中，科学得以修正发展，本质上是一个理论与实践的Loss方程数值不断缩小的过程。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"类比科学发展的本质，在有限的数据集下，机器学习的学习方法或者学习范式还不够具有发展性。机器学习的学习方式更加接近于“一锤子买卖”。学习训练然后测试，没有测试结果指导理论的过程，或者说这一过程是由人来完成的。人根据测试结果的准确性来判断模型是否需要修改提升。目前阶段学习机没有自我驱动的迭代能力，即根据学习的效果来修正学习模型。人类智能的巨大潜力，正是体现在驱动实践理论再实践这一个过程当中。从这哲学的角度，这样一种实践理论再实践的学习范式是面对“未知的虚无”最强有力的手段，也是最强大的学习方法。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"学习的本质，在机器学习中更加接近元学习的思想。即在学习模型中提供根据结果修正模型参数的接口，让学习机能够在Loss方程的指引下，自我迭代。目前可能是调整超参数，未来可能就能发展成为自我修正网络结构、激活函数等学习模型的框架结构。从计算的本质来说，这一过程对应Code Generation。目前普遍的学习方法是修改模型参数，元学习的学习方法是学习机能够修改模型代码。对应的实现方式为元编程——用代码写代码。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"目前来说元编程的技术实现完全没有问题，Julia语言中就有成熟高效的元编程方式。元学习的技术实现不是问题。但从它的学习过程可以轻易推断，元学习的难点在于Loss方程的量化指标。由损失到参数，是在数的领域。而由损失到网络结构，这不是一个可以直接跨越的鸿沟。在它们中间，需要架起一座由数到结构的桥梁，也就是变成一个可计算的问题。要实现这一点，还需要长时间的探索。","category":"page"},{"location":"Optimization/6-传统决定性算法简介/#传统决定性算法","page":"传统决定性算法","title":"传统决定性算法","text":"","category":"section"},{"location":"Optimization/6-传统决定性算法简介/#传统决定性算法简介","page":"传统决定性算法","title":"传统决定性算法简介","text":"","category":"section"},{"location":"Optimization/6-传统决定性算法简介/","page":"传统决定性算法","title":"传统决定性算法","text":"传统决定性算法是指那些通过确定性的计算方法来求解优化问题的算法，通常是基于数学规划理论和算法设计的。下面介绍几个常见的传统决定性算法：","category":"page"},{"location":"Optimization/6-传统决定性算法简介/","page":"传统决定性算法","title":"传统决定性算法","text":"线性规划算法： 线性规划是一类优化问题，其中目标函数和约束条件都是线性的。线性规划问题可以使用诸如单纯形法、内点法和二次规划法等传统算法进行求解。这些算法通过迭代计算来寻找目标函数的最优值和对应的决策变量值。\n整数规划算法： 整数规划是线性规划的扩展，要求决策变量取整数值。整数规划问题通常更加复杂和困难，常用的传统算法包括分枝定界法、割平面法、动态规划和整数规划求解器等。这些算法通过系统地搜索决策变量的整数解空间来找到最优解。\n非线性规划算法： 非线性规划涉及目标函数或约束条件中包含非线性项的优化问题。传统的非线性规划算法包括梯度下降法、牛顿法、拟牛顿法、全局优化算法等。这些算法通过迭代计算和搜索策略来逐步优化目标函数并找到最优解。\n动态规划算法： 动态规划是一种通过将原问题分解为子问题并存储子问题的解来求解的优化方法。它适用于具有最优子结构性质的问题，例如背包问题、最短路径问题等。动态规划算法通过填表和递推关系来逐步计算并获得最优解。","category":"page"},{"location":"Optimization/6-传统决定性算法简介/","page":"传统决定性算法","title":"传统决定性算法","text":"这些传统决定性算法在优化领域得到了广泛应用，并在不同类型的优化问题中展现了强大的求解能力。根据具体问题的特性和约束条件，选择适当的传统算法可以提高求解效率和解的质量。然而，对于复杂和大规模问题，这些传统算法可能面临计算复杂性和局部最优解等挑战。因此，还需要结合问题特点，考虑其他高级优化技术和近似算法来求解实际问题。","category":"page"},{"location":"Optimization/6-传统决定性算法简介/#MINLP的算法","page":"传统决定性算法","title":"MINLP的算法","text":"","category":"section"},{"location":"Optimization/6-传统决定性算法简介/","page":"传统决定性算法","title":"传统决定性算法","text":"MINLP（Mixed-Integer Nonlinear Programming）是指混合整数非线性规划问题，即包含非线性函数和整数决策变量的优化问题。MINLP问题在实际应用中非常常见，但由于其复杂性，求解MINLP问题是一项具有挑战性的任务。下面介绍几种常见的算法用于求解MINLP问题：","category":"page"},{"location":"Optimization/6-传统决定性算法简介/","page":"传统决定性算法","title":"传统决定性算法","text":"分枝定界法（Branch and Bound）： 分枝定界法是一种广泛应用于求解MINLP问题的算法。它通过将问题分解为子问题，并在搜索过程中限制搜索空间，找到问题的最优解。算法通过不断分枝和界定来逐步收敛到全局最优解。\n分枝定界与约束推导法（Branch and Bound with Constraint Propagation）： 分枝定界与约束推导法是对传统分枝定界法的扩展，它在分枝的同时利用问题约束进行推导，以进一步削减搜索空间。通过利用问题结构和约束信息，它能够更快地收敛到最优解。\n分枝定界与线性规划松弛法（Branch and Bound with Linear Programming Relaxation）： 这种方法在分枝定界过程中，利用线性规划松弛问题来近似非线性函数。通过将非线性函数线性化为线性约束条件，将MINLP问题转化为一个线性规划问题，并在每个分支节点上求解线性规划问题来界定最优解。\n混合整数线性规划与松弛法（Mixed Integer Linear Programming and Relaxation）： 对于一些特殊的MINLP问题，可以通过将非线性函数近似为线性函数，并将整数决策变量线性化为连续变量，将MINLP问题转化为一个混合整数线性规划（MILP）问题。然后可以利用MILP求解器来求解该问题，获得近似最优解。\n代理优化法（Surrogate Optimization）： 代理优化法是一种基于代理模型的优化方法，用于近似求解MINLP问题。它通过构建代理模型来逼近原始问题的目标函数和约束条件，并利用代理模型进行优化。这种方法可以加快求解速度，但可能牺牲一定的解的质量。","category":"page"},{"location":"Optimization/6-传统决定性算法简介/","page":"传统决定性算法","title":"传统决定性算法","text":"这些算法是用于求解MINLP问题的常见方法，每种方法都有其适用的场景和局限性。对于具体的MINLP问题，选择合适的算法需要综合考虑问题的特征、规模和求解要求。此外，近年来还涌现了许多新的算法和技术，如近似算法、启发式算法和混合整数仿真优化等，用于求解MINLP问题。选择最佳算法需要根据具体问题的性质和实际需求进行评估和权衡。","category":"page"},{"location":"Optimization/91-优化应用之代理模型/#优化应用之代理模型","page":"优化应用之代理模型","title":"优化应用之代理模型","text":"","category":"section"},{"location":"Optimization/91-优化应用之代理模型/#代理模型简介","page":"优化应用之代理模型","title":"代理模型简介","text":"","category":"section"},{"location":"Optimization/91-优化应用之代理模型/","page":"优化应用之代理模型","title":"优化应用之代理模型","text":"代理模型（Surrogate Model），也称为元模型（Metamodel）或近似模型（Approximation Model），是指一种用于近似复杂系统或昂贵计算模型的简化模型。","category":"page"},{"location":"Optimization/91-优化应用之代理模型/","page":"优化应用之代理模型","title":"优化应用之代理模型","text":"在实际应用中，有些系统或模型的计算成本较高，或者存在复杂性和不确定性，导致难以直接进行优化或分析。此时，可以使用代理模型来代替原始系统或模型进行分析、优化或预测。","category":"page"},{"location":"Optimization/91-优化应用之代理模型/","page":"优化应用之代理模型","title":"优化应用之代理模型","text":"代理模型通常基于采样点或训练数据，通过数学或统计方法构建。它通过在输入参数空间中对系统或模型进行采样，并收集相应的输出结果来建立一个近似函数。这个近似函数可以是简单的数学公式、多项式拟合、插值方法、回归模型、神经网络等。","category":"page"},{"location":"Optimization/91-优化应用之代理模型/","page":"优化应用之代理模型","title":"优化应用之代理模型","text":"代理模型的优点在于它可以有效地降低计算成本，并提供对原始系统或模型的近似预测能力。通过代理模型，可以在较短的时间内进行优化搜索、参数估计或灵敏度分析，而无需反复执行原始复杂模型。","category":"page"},{"location":"Optimization/91-优化应用之代理模型/","page":"优化应用之代理模型","title":"优化应用之代理模型","text":"此外，代理模型还可以用于设计空间探索、参数优化、模型校准、参数估计和不确定性分析等任务。它们在工程、科学、经济等领域中广泛应用，特别是在计算机实验设计、工程优化和模型辅助决策等方面。","category":"page"},{"location":"Optimization/91-优化应用之代理模型/","page":"优化应用之代理模型","title":"优化应用之代理模型","text":"需要注意的是，代理模型是对原始系统或模型的近似，因此其精确性和可靠性取决于所采样的数据质量、代理模型的选择和建立方法，以及代理模型的验证和校准过程。在使用代理模型时，应进行适当的验证和验证，以确保其在目标任务中的有效性和适用性。","category":"page"},{"location":"Optimization/91-优化应用之代理模型/#最优化在代理模型构建中的应用","page":"优化应用之代理模型","title":"最优化在代理模型构建中的应用","text":"","category":"section"},{"location":"Optimization/91-优化应用之代理模型/","page":"优化应用之代理模型","title":"优化应用之代理模型","text":"最优化在代理模型构建中的应用是非常重要的。在代理模型的建立过程中，最优化方法可以用于优化模型的参数、调整模型的结构或选择最佳采样点，以获得更准确、可靠的代理模型。","category":"page"},{"location":"Optimization/91-优化应用之代理模型/","page":"优化应用之代理模型","title":"优化应用之代理模型","text":"以下是最优化在代理模型构建中的几个主要应用方面：","category":"page"},{"location":"Optimization/91-优化应用之代理模型/","page":"优化应用之代理模型","title":"优化应用之代理模型","text":"参数优化：代理模型通常具有一些参数，例如多项式拟合中的多项式阶数、神经网络中的隐藏层节点数等。最优化可以应用于代理模型的参数优化，以寻找最佳的参数配置，从而提高代理模型的拟合能力和预测精度。\n结构优化：在某些情况下，代理模型的结构选择也可以看作是一个优化问题。例如，在神经网络中，最优化可以用于确定网络的层数和节点的连接方式，以获得更好的拟合效果。通过最优化，可以探索不同的结构组合，并选择最佳的结构配置。\n采样点选择：代理模型的建立通常需要采集一定数量的训练数据。最优化可以应用于选择最佳的采样点，以最大程度地提高代理模型的预测能力。通过优化采样点的分布和密度，可以在保持模型准确性的同时，降低采样成本和计算负担。\n模型校准：代理模型的校准是确保代理模型与原始模型或系统之间一致性的重要步骤。最优化方法可以应用于优化代理模型与真实数据之间的误差，调整代理模型的参数或结构，使其更好地符合真实系统的特征。","category":"page"},{"location":"Optimization/91-优化应用之代理模型/","page":"优化应用之代理模型","title":"优化应用之代理模型","text":"通过将最优化方法与代理模型的构建相结合，可以优化代理模型的性能、精度和鲁棒性，提高代理模型在实际应用中的效果。这些应用使得代理模型成为一种强大的工具，在复杂系统分析、参数优化和决策支持中发挥重要作用。","category":"page"},{"location":"Optimization/91-优化应用之代理模型/#举个例子","page":"优化应用之代理模型","title":"举个例子","text":"","category":"section"},{"location":"Optimization/91-优化应用之代理模型/","page":"优化应用之代理模型","title":"优化应用之代理模型","text":"我们可以以基本函数的组合来构建我们的代理模型，选取基元函数系，那就是要确定系数了。我们可以在实测数据中取样，获得模型的预测值，与真实值对比，把最大误差点再加入到取样点中去，迭代这个过程，直到获得满意的结果。","category":"page"},{"location":"Optimization/91-优化应用之代理模型/","page":"优化应用之代理模型","title":"优化应用之代理模型","text":"这种方法是一种常见的代理模型构建方法之一，即基于基本函数的组合来构建代理模型。这种方法通常被称为基于基函数的代理模型（Radial Basis Function-based Surrogate Model）。","category":"page"},{"location":"Optimization/91-优化应用之代理模型/","page":"优化应用之代理模型","title":"优化应用之代理模型","text":"下面以一个简单的例子来说明这个方法的应用过程：","category":"page"},{"location":"Optimization/91-优化应用之代理模型/","page":"优化应用之代理模型","title":"优化应用之代理模型","text":"假设我们有一个复杂的系统或模型，我们希望构建一个代理模型来近似它。我们选择一组基本函数作为基元函数系，比如高斯函数或多项式函数。","category":"page"},{"location":"Optimization/91-优化应用之代理模型/","page":"优化应用之代理模型","title":"优化应用之代理模型","text":"首先，我们从实测数据中选择一些采样点，并计算这些采样点的真实值。然后，使用选定的基元函数系，在这些采样点处计算代理模型的预测值。","category":"page"},{"location":"Optimization/91-优化应用之代理模型/","page":"优化应用之代理模型","title":"优化应用之代理模型","text":"接下来，我们比较代理模型的预测值与真实值之间的差异，并找到最大误差点。将这个最大误差点加入到采样点集中。","category":"page"},{"location":"Optimization/91-优化应用之代理模型/","page":"优化应用之代理模型","title":"优化应用之代理模型","text":"然后，使用更新后的采样点集，重新计算代理模型的预测值，并再次与真实值对比。如果满意度不够，我们可以继续迭代这个过程，不断加入新的最大误差点，直到达到预期的拟合精度或满意的结果为止。","category":"page"},{"location":"Optimization/91-优化应用之代理模型/","page":"优化应用之代理模型","title":"优化应用之代理模型","text":"通过这种迭代过程，我们逐步优化代理模型的参数，使其能够更好地拟合原始系统或模型，并提供准确的预测能力。","category":"page"},{"location":"Optimization/91-优化应用之代理模型/","page":"优化应用之代理模型","title":"优化应用之代理模型","text":"需要注意的是，在实际应用中，我们需要综合考虑代理模型的预测精度和计算成本之间的权衡。过多的采样点可能会增加计算负担，而过少的采样点可能会导致代理模型的不准确性。因此，在选择采样点和迭代过程中，需要根据具体情况进行权衡和调整。","category":"page"},{"location":"Optimization/91-优化应用之代理模型/","page":"优化应用之代理模型","title":"优化应用之代理模型","text":"基于基函数的代理模型方法在许多领域中都得到了广泛应用，如工程优化、模拟建模、参数估计等。它提供了一种快速构建代理模型的方法，使得复杂系统的分析和优化变得更加高效和可行。","category":"page"},{"location":"Optimization/91-优化应用之代理模型/","page":"优化应用之代理模型","title":"优化应用之代理模型","text":"ALAMO（Automated Learning of Algebraic Models）就是这么一个方法。","category":"page"},{"location":"Optimization/91-优化应用之代理模型/","page":"优化应用之代理模型","title":"优化应用之代理模型","text":"ALAMO就是一种基于基函数的代理模型构建方法。ALAMO是一种自动化的机器学习工具，用于从数据中学习和构建代理模型。","category":"page"},{"location":"Optimization/91-优化应用之代理模型/","page":"优化应用之代理模型","title":"优化应用之代理模型","text":"ALAMO的基本思想是通过组合基函数来逼近目标函数，并使用最小二乘法进行参数估计。它使用了一种称为SOS（Sum of Squares）方法的技术，可以自动地确定基函数的系数和组合方式，以使得拟合误差最小化。","category":"page"},{"location":"Optimization/91-优化应用之代理模型/","page":"优化应用之代理模型","title":"优化应用之代理模型","text":"ALAMO的工作流程如下：","category":"page"},{"location":"Optimization/91-优化应用之代理模型/","page":"优化应用之代理模型","title":"优化应用之代理模型","text":"数据采集：首先，收集关于目标函数的采样数据，包括自变量和因变量的取值。\n基函数选择：根据需要，选择一组合适的基函数作为基元函数系，例如多项式函数、三角函数、高斯函数等。\n模型构建：使用采样数据和选定的基元函数系，通过最小二乘法或其他优化方法，估计基函数的系数，并构建代理模型。\n模型评估：评估代理模型的拟合精度和预测能力，通过与实际数据的对比来确定模型的准确性和可靠性。\n模型优化：如果代理模型的性能不满意，可以通过迭代的方式，调整基函数的选择和系数的估计，以获得更好的拟合效果。","category":"page"},{"location":"Optimization/91-优化应用之代理模型/","page":"优化应用之代理模型","title":"优化应用之代理模型","text":"ALAMO的优势在于它的自动化和高效性。它能够自动推断代理模型的结构和参数，并根据数据的特点进行调整和优化。此外，ALAMO还提供了一些诊断工具，用于评估模型的可靠性和应用范围。","category":"page"},{"location":"Optimization/91-优化应用之代理模型/","page":"优化应用之代理模型","title":"优化应用之代理模型","text":"ALAMO被广泛应用于各种领域，如化学工程、能源系统、流体力学、机械设计等。它为工程师和研究人员提供了一种快速构建代理模型的方法，从而简化了复杂系统的建模和分析过程。","category":"page"},{"location":"JuliaIntro/4-julia的包管理/#julia的包管理","page":"julia的包管理","title":"julia的包管理","text":"","category":"section"},{"location":"JuliaIntro/4-julia的包管理/#julia包管理概述","page":"julia的包管理","title":"julia包管理概述","text":"","category":"section"},{"location":"JuliaIntro/4-julia的包管理/","page":"julia的包管理","title":"julia的包管理","text":"当您使用Julia进行开发时，包管理是一个重要的方面。Julia提供了内置的包管理器，用于管理和安装各种扩展包。以下是关于Julia的包管理的一些重要信息和常用命令：","category":"page"},{"location":"JuliaIntro/4-julia的包管理/","page":"julia的包管理","title":"julia的包管理","text":"包的安装：要安装一个Julia包，您可以在Julia REPL中进入包管理模式（输入\"]\"并按下回车键），然后使用add命令后跟要安装的包的名称。例如，要安装名为\"Example\"的包，您可以执行以下命令：\n(@v1.6) pkg> add Example\n这将从官方的Julia软件包注册表中下载并安装指定的包。\n包的升级：要升级已安装的包到最新版本，您可以在包管理模式下使用update命令。例如，要升级名为\"Example\"的包，您可以执行以下命令：\n(@v1.6) pkg> update Example\n这将检查已安装包的最新版本并进行升级。\n包的移除：如果您想要移除已安装的包，可以在包管理模式下使用rm命令。例如，要移除名为\"Example\"的包，您可以执行以下命令：\n(@v1.6) pkg> rm Example\n这将从系统中移除指定的包。\n包的激活和使用：一旦您安装了一个包，您可以在Julia的代码中使用它。要在代码中使用已安装的包，只需在您的代码中使用using语句并指定包的名称。例如，要使用名为\"Example\"的包，您可以在代码中添加以下行：\nusing Example\n这将使您可以访问并使用该包中定义的函数、类型和其他功能。\n自定义包环境：Julia的包管理器还支持创建和管理自定义的包环境，以便在不同的项目中使用不同的包版本。您可以在包管理模式下使用activate命令来激活或创建一个新的包环境。例如，要激活名为\"myenv\"的包环境，您可以执行以下命令：\n(@v1.6) pkg> activate myenv\n这将切换到名为\"myenv\"的包环境，使您可以在该环境中管理和安装包。","category":"page"},{"location":"JuliaIntro/4-julia的包管理/","page":"julia的包管理","title":"julia的包管理","text":"这些是Julia的包管理器的一些常用命令和操作。包管理器使您能够轻松地安装、升级和移除Julia包，并为您的项目创建独立的包环境。","category":"page"},{"location":"JuliaIntro/4-julia的包管理/","page":"julia的包管理","title":"julia的包管理","text":"希望这些介绍有助于您了解Julia的包管理！如果您有任何进一步的问题，请随时向我提问。","category":"page"},{"location":"Control/KalmanFiltering/#卡尔曼滤波理论与应用","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"","category":"section"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"tip: Tip\nContents：卡尔曼滤波(Kalman Filtering)Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"note: Note\n一篇卡尔曼滤波的英文博客，兼具理论与感性认识。上述博客的中文翻译版本","category":"page"},{"location":"Control/KalmanFiltering/#卡尔曼滤波介绍","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波介绍","text":"","category":"section"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"一句简单的话概括卡尔曼滤波：综合考虑模型计算值与实际测量值，估计动态系统中状态的真实值。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"对这句概括的话，提出2个问题：","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"为什么要综合考虑模型计算值和实际测量值？\n如何综合考虑？","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"对于问题1，有2个事实：","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"模型不是准确的。例如，欧姆定律中，电阻值真的是一个常数吗？基础模型尚且如此，更不用说复杂系统的模型了。所以，描述系统的模型，一定是有偏差的。\n测量值不代表真实值。通过各种仪表读数时，读出来的数不能代表真实值，读数时会有各种随机误差。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"所以，Kalman觉得可以结合模型计算值与观测值，对状态的真实值进行估计。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"对于问题2：","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"综合考虑的方式为：先通过状态空间方程的计算出结果，再对结合误差对结果进行修正。由此可见，卡尔曼滤波是控制学与统计学的交叉学科方法。","category":"page"},{"location":"Control/KalmanFiltering/#卡尔曼滤波的数学表达","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波的数学表达","text":"","category":"section"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"只给结论，不推导。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"leftbeginarrayl\nx_k=F_k-1 x_k-1+Gamma_k-1 w_k-1 \nz_k=H_k x_k+v_k\nendarrayright","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"其中：","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"下表k代表k时刻\n系统状态向量——x_k（行向量）\n系统状态转移矩阵——F_k，如果在时间域上不变则为——F\n模型噪声——w_k\n模型噪声矩阵（描述噪声对变量的影响）——Gamma_k（行向量）\n系统量的测向量——z_k\n量测矩阵——H_k（行向量）\n模型噪声——v_k","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"同时，噪声满足正态分布：","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"w_k sim N(0Q_k)  v_k sim N(0R_k)","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"下面为卡尔曼滤波的滤波过程:","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"Step1 模型计算:","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"x_k=F_k-1 x_k-1\nP_k=F_k-1 P_k-1 F_k-1^T+Gamma_k-1 Q_k-1 Gamma_k-1^T","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"Step2 滤波:","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"G_k=P_k  H_k^TleftH_k P_k H_k^T+R_kright^-1\nhatx_k=x_k+G_k(tildez_k - H_kx_k)\nhatP_k = (I-G_kH_k)P_k","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"其中：","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"系统的量测的协方差矩阵——P\n滤波后的系统状态向量——hatx_k\n滤波后的系统状态向量——hatx_k\n模型噪声的方差——Q_k，如果在时间域上不变则为——Q\n测量噪声的方差——R_k，如果在时间域上不变则为——R\n滤波后的系统的量测的协方差矩阵——hatP_k\n测量值向量——tildez_k\n模型噪声——v_k","category":"page"},{"location":"Control/KalmanFiltering/#卡尔曼滤波实例","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波实例","text":"","category":"section"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"考虑加热器：fracdTdt = -(T-20) + 10 即散热系数为1，加热功率为10，环境温度为20。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"使用DifferentialEquations.jl获得仿真数据并加上扰动。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"using DifferentialEquations\nusing Statistics, Plots\n\nf(u, t, p) = -(u - 20) + 10\n\nprob = ODEProblem(f, 20.0, (0, 5))\n\nsol = solve(prob, saveat=0.1)\nnoise = rand(-0.5:0.0001:0.5, length(sol.u))\ncov(noise)\n\nmeasureT = noise + sol.u\nt = collect(0:0.1:5)\nplot(t, measureT, label=\"measure\", legend_position=:topleft)\nplot!(t, sol.u, label=\"real\", legend_position=:topleft)","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"获得的measureT将作为未来每个时间点上的温度测量数据（实际为精确解加随机误差生成的数据）。真实值与测量值如下图。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"(Image: 图 1)  ","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"若取dt=01，使用欧拉法离散，则上述微分则转变为状态空间方程：T_k+1 = 09T_k+3","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"若采用上述状态空间方程，则可以称之为“完美模型”。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"为了验证卡尔曼滤波的有效性，我们设计一个十分错误的模型：T_k+1 = T_k","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"即，我们认为这是一个温度不变的系统（错得不能再错的模型）。同时，给一个比较大的Q_w，说明模型扰动的方差比较大。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"begin\n    F = 1\n    Γ = 0.1\n    H = 1\n    Qv = 0.8\n    Qw = 10\n\n    P = 10\n    x = 20.0\n\n    x_res = zeros(1, length(measureT))\n    p_res = zeros(1, length(measureT))\n\n    p_res[:, 1] = [P]\n    x_res[:, 1] = [x]\n\n    for i in 1:length(measureT)-1\n        _P = F * p_res[1, i] * F' .+ Γ' * Qw * Γ\n        _G = _P * H * inv(H * _P * H + Qv)\n        _x = F * x_res[1, i]\n        global x_res[1, i+1] = _x + _G * (measureT[i+1] - H' * _x)\n        global p_res[1, i+1] = (1 - _G' * H) * _P\n    end\n\n    plot!(t, x_res[1, :], label=\"Wrong Model\", legend_position=:topleft)\nend","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"(Image: 图 2) ","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"结果显示，居然和真实值差不多。如果令Q_w=1，给得比较小。则变成了：","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"(Image: 图 3)  ","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"没那么好，但也不差（比直线好太多了）。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"如果把模型设置成原本的模型则:","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"begin\n    F = 0.9\n    Γ = 0.1\n    H = 1\n    Qv = 0.8\n    Qw = 10\n\n    P = 10\n    x = 20.0\n\n    x_res = zeros(1, length(measureT))\n    p_res = zeros(1, length(measureT))\n\n    p_res[:, 1] = [P]\n    x_res[:, 1] = [x]\n\n    for i in 1:length(measureT)-1\n        _P = F * p_res[1, i] * F' .+ Γ' * Qw * Γ\n        _G = _P * H * inv(H * _P * H + Qv)\n        _x = F * x_res[1, i] + 3\n        global x_res[1, i+1] = _x + _G * (measureT[i+1] - H' * _x)\n        global p_res[1, i+1] = (1 - _G' * H) * _P\n    end\n\n    plot!(t, x_res[1, :], label=\"Right Model\", legend_position=:topleft)\nend","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"(Image: 图 4)  ","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"基本就一致了。","category":"page"},{"location":"Control/KalmanFiltering/#小结","page":"卡尔曼滤波理论与应用","title":"小结","text":"","category":"section"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"卡尔曼滤波的重要意义是利用了测量值带来的信息。模型不准确的时候，利用滤波带来的效果，可以对模型进行一个矫正。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"但它的缺点在于，对预测没有帮助。对未来的多点预测只能是通过模型。既然是预测，说明事情还没有发生，那测量值无法获得，也就无法通过测量值进行矫正。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"其特点是，对已经发生的事情做一个优化，而不能提升预测未来的能力。","category":"page"},{"location":"WorkFlow/julia的安装/#Julia安装","page":"Julia安装","title":"Julia安装","text":"","category":"section"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"tip: Tip\nContents：julia安装Contributor: 孙蓓蓓、张启Email:如有错误，请批评指正。","category":"page"},{"location":"WorkFlow/julia的安装/#下载网址","page":"Julia安装","title":"下载网址","text":"","category":"section"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"搜索清华大学开源软件镜像站。   (Image: )","category":"page"},{"location":"WorkFlow/julia的安装/#下载julia-xxx-win64.zip安装包","page":"Julia安装","title":"下载julia-xxx-win64.zip安装包","text":"","category":"section"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"note: Note\nv1.7.2(Feb 6,2022)为julia当前稳定版本。新安装时，下载最新版。","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"首先，在搜索框中搜索julia，点击julia-releases： (Image: ) 其次，点击bin/： (Image: ) 找到winnt/： (Image: ) 选择x64/： (Image: ) 然后，找到最新版本系列： (Image: ) 最后，下拉找到julia-xxx-win64.zip安装包，点击下载。 (Image: )","category":"page"},{"location":"WorkFlow/julia的安装/#解压安装","page":"Julia安装","title":"解压安装","text":"","category":"section"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"找到下载好的安装包，右键解压。解压后，生成一个julia-1.7.2文件夹。可执行文件julia.exe就在julia-1.7.2文件夹的bin文件夹下。 (Image: )","category":"page"},{"location":"WorkFlow/julia的安装/#将路径加到环境变量中","page":"Julia安装","title":"将路径加到环境变量中","text":"","category":"section"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"在任务栏搜索框中找到“编辑系统环境变量”： (Image: ) 打开环境变量；在用户变量中选择变量Path，点击编辑；新建，将julia.exe文件所在路径复制进去，然后点击确定。 (Image: )","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"tip: Tip\n也可使直接“(Image: ) + r”打开运行▱，输入 rundll32 sysdm.cpl,EditEnvironmentVariables 直接打开环境变量设置界面，注意，此时无法编辑系统环境变量（实际上也并不建议直接编辑系统环境变量），编辑用户环境变量即可。","category":"page"},{"location":"WorkFlow/julia的安装/#执行julia","page":"Julia安装","title":"执行julia","text":"","category":"section"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"在任务栏搜索框输入cmd，打开命令提示符，输入julia，进入Julie REPL，此时julia就可以执行了。 (Image: ) 直接输入exit()，即可退出。","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"另外，Windows下推荐使用Windows Terminal作为交互终端（直接的Cmd或Powershell终端中，均不支持类似","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"20px\" height=\"20px\" viewBox=\"220 280 180 120\" xml:space=\"preserve\">\n    <g>\n        <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" fill=\"currentColor\" d=\"M259.618,401.811l1.231,0.268l-4.314,13.678h-39.031v-1.371h1.903\n  c2.132,0,3.654-0.699,4.568-2.082c0.521-0.799,0.774-2.639,0.774-5.506v-32.534c0-3.147-0.343-5.114-1.041-5.9\n  c-0.964-1.091-2.398-1.637-4.301-1.637h-1.903v-1.383h22.827v1.383c-2.677-0.025-4.556,0.216-5.634,0.736\n  c-1.078,0.52-1.814,1.18-2.208,1.979c-0.394,0.787-0.596,2.69-0.596,5.685v31.671c0,2.057,0.203,3.465,0.596,4.238\n  c0.292,0.52,0.749,0.9,1.37,1.154c0.622,0.242,2.551,0.367,5.799,0.367h3.68c3.87,0,6.586-0.279,8.146-0.85\n  c1.561-0.57,2.982-1.586,4.276-3.031C257.042,407.229,258.336,404.932,259.618,401.811L259.618,401.811L259.618,401.811z\" />\n        <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" fill=\"currentColor\" d=\"M265.631,392.346h-15.192l-2.657,6.193c-0.662,1.521-0.988,2.658-0.988,3.418\n  c0,0.594,0.287,1.117,0.85,1.57c0.573,0.455,1.797,0.752,3.694,0.889v1.068H238.98v-1.068c1.64-0.295,2.697-0.672,3.181-1.135\n  c0.988-0.92,2.074-2.805,3.27-5.641l13.809-32.292h1.008l13.661,32.637c1.097,2.627,2.094,4.326,2.993,5.107\n  c0.899,0.779,2.153,1.225,3.753,1.322v1.068h-15.489v-1.068c1.561-0.078,2.618-0.346,3.171-0.789\n  c0.553-0.436,0.83-0.979,0.83-1.621c0-0.848-0.396-2.182-1.166-4.02L265.631,392.346L265.631,392.346L265.631,392.346z\n   M264.821,390.202l-6.658-15.854l-6.826,15.854H264.821L264.821,390.202L264.821,390.202z\" />\n        <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" fill=\"currentColor\" d=\"M313.479,365.008l0.563,11.921h-1.432c-0.27-2.098-0.64-3.594-1.126-4.502\n  c-0.768-1.445-1.804-2.507-3.083-3.197c-1.292-0.691-2.98-1.036-5.077-1.036h-7.163v38.833c0,3.121,0.345,5.064,1.011,5.844\n  c0.946,1.051,2.417,1.574,4.387,1.574h1.766v1.381h-21.552v-1.381h1.803c2.149,0,3.671-0.652,4.566-1.957\n  c0.55-0.793,0.832-2.621,0.832-5.461v-38.833h-6.114c-2.367,0-4.055,0.179-5.053,0.524c-1.305,0.473-2.417,1.394-3.338,2.737\n  c-0.92,1.356-1.471,3.172-1.65,5.475h-1.42l0.602-11.921H313.479L313.479,365.008L313.479,365.008z\" />\n        <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" fill=\"currentColor\" d=\"M319.647,381.675v19.259h10.708c2.785,0,4.637-0.418,5.569-1.252\n  c1.251-1.104,1.938-3.042,2.085-5.826h1.325v16.965h-1.325c-0.331-2.367-0.674-3.889-1.006-4.564\n  c-0.429-0.834-1.141-1.496-2.122-1.975c-0.981-0.477-2.49-0.723-4.526-0.723h-10.708v16.068c0,2.158,0.098,3.471,0.281,3.938\n  c0.197,0.467,0.528,0.834,1.006,1.117c0.479,0.27,1.398,0.404,2.736,0.404h8.267c2.748,0,4.76-0.184,5.999-0.576\n  c1.251-0.381,2.44-1.129,3.594-2.258c1.484-1.484,3.006-3.729,4.563-6.723h1.435l-4.194,12.219h-37.56v-1.326h1.73\n  c1.141,0,2.232-0.281,3.263-0.834c0.772-0.379,1.288-0.957,1.569-1.717c0.271-0.773,0.405-2.344,0.405-4.709v-31.661\n  c0-3.091-0.307-4.992-0.933-5.716c-0.858-0.957-2.294-1.435-4.305-1.435h-1.73v-1.337h37.56l0.539,10.672h-1.41\n  c-0.503-2.563-1.055-4.318-1.668-5.274c-0.613-0.957-1.509-1.693-2.711-2.196c-0.957-0.355-2.65-0.54-5.066-0.54H319.647\n  L319.647,381.675L319.647,381.675z\" />\n        <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" fill=\"currentColor\" d=\"M370.217,387.709l10.832,16.14c2.997,4.469,5.219,7.289,6.679,8.469\n  c1.448,1.182,3.29,1.83,5.524,1.957v1.371h-21.651v-1.371c1.435-0.025,2.502-0.18,3.2-0.457c0.521-0.217,0.939-0.561,1.282-1.016\n  c0.331-0.459,0.496-0.928,0.496-1.398c0-0.57-0.114-1.143-0.331-1.713c-0.178-0.42-0.862-1.512-2.044-3.277l-8.559-12.94\n  l-10.565,13.538c-1.117,1.447-1.791,2.4-2.006,2.883c-0.229,0.482-0.344,0.99-0.344,1.51c0,0.801,0.344,1.447,1.004,1.969\n  c0.672,0.521,1.955,0.826,3.835,0.902v1.371h-17.893v-1.371c1.27-0.127,2.349-0.395,3.276-0.789\n  c1.536-0.646,2.996-1.51,4.381-2.602c1.396-1.092,2.984-2.77,4.762-5.029l11.911-15.022l-9.93-14.552\n  c-2.705-3.937-5.004-6.527-6.883-7.747c-1.893-1.232-4.063-1.879-6.515-1.956v-1.384h23.327v1.384\n  c-1.98,0.076-3.34,0.394-4.076,0.965c-0.724,0.571-1.092,1.207-1.092,1.893c0,0.927,0.597,2.26,1.778,4.025l7.745,11.568\n  l8.966-11.353c1.041-1.333,1.676-2.248,1.917-2.743c0.229-0.508,0.355-1.016,0.355-1.537s-0.152-0.978-0.457-1.372\n  c-0.368-0.521-0.838-0.889-1.409-1.092c-0.571-0.216-1.752-0.331-3.53-0.356v-1.384h17.893v1.384\n  c-1.41,0.076-2.565,0.292-3.467,0.661c-1.333,0.571-2.565,1.346-3.683,2.311c-1.117,0.965-2.692,2.755-4.724,5.358L370.217,387.709\n  L370.217,387.709L370.217,387.709z\" />\n    </g>\n</svg>","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"的用法输入UTF-8字符）。","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"直接在Microsoft Store上下载Windows Terminal，打开软件后进入设置界面： (Image: 打开Windows Teminal设置)","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"可以直接在界面中运行julia命令，或者将Julia添加到终端中。","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"左侧导航栏划至最下，新建配置文件，这里这就复制Windows Powershell的（有兴趣可以复制Cmd的试试）。 (Image: Winwdos Termianl 新建设置文件)","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"在新建的配置文件里面编辑设计即可，详细如图： (Image: Julia终端设置)","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"注：终端界面的图标自己找一个，如果懒着找，就接着使用Powershell的也行。","category":"page"},{"location":"StepByStep/02-emqx消息服务器准备/#消息服务器准备","page":"消息服务器准备","title":"消息服务器准备","text":"","category":"section"},{"location":"StepByStep/02-emqx消息服务器准备/#消息服务器简介","page":"消息服务器准备","title":"消息服务器简介","text":"","category":"section"},{"location":"StepByStep/02-emqx消息服务器准备/","page":"消息服务器准备","title":"消息服务器准备","text":"消息服务器，也常被称为消息代理（Message Broker）或消息中间件，是一种在分布式应用系统中处理、存储和传递消息的软件应用。消息服务器允许各个应用组件或系统之间进行通信，而无需直接连接或知道彼此的存在，提供了一种松耦合、可伸缩和可靠的通信方式。","category":"page"},{"location":"StepByStep/02-emqx消息服务器准备/","page":"消息服务器准备","title":"消息服务器准备","text":"以下是消息服务器的一些核心概念和特性：","category":"page"},{"location":"StepByStep/02-emqx消息服务器准备/","page":"消息服务器准备","title":"消息服务器准备","text":"发布/订阅模式 (Pub/Sub)：在此模式中，发送者（发布者）发布消息到特定的主题，而接收者（订阅者）则订阅它们感兴趣的主题。当消息被发布到某个主题时，所有订阅了该主题的订阅者都会收到这个消息。\n点对点 (Point-to-Point)：在这种模式下，消息被放入队列，然后由单个接收者获取和消费。即使有多个消费者，每个消息也只会被处理一次。\n持久化 (Persistence)：很多消息服务器支持消息的持久化，即使在系统故障或重启的情况下，也能确保消息不会丢失。\n消息确认和重试：为确保消息的可靠传递，消息服务器通常提供消息确认机制。如果消息未被正确处理，系统可以选择重试发送或采取其他行动。\n过滤和路由：基于消息的内容或属性，消息服务器可以决定如何路由消息或决定哪些订阅者应该收到特定的消息。\n事务处理：某些消息服务器支持事务，确保在处理多个操作时维持一致性。\n安全：消息服务器通常提供身份验证、授权和加密功能，确保消息的安全传递。","category":"page"},{"location":"StepByStep/02-emqx消息服务器准备/","page":"消息服务器准备","title":"消息服务器准备","text":"常见的消息服务器软件有：RabbitMQ、Apache Kafka、ActiveMQ、MQTT (如 EMQ X 和 Mosquitto) 和 Microsoft Message Queue (MSMQ)，等等。","category":"page"},{"location":"StepByStep/02-emqx消息服务器准备/","page":"消息服务器准备","title":"消息服务器准备","text":"总的来说，消息服务器提供了一种方式来在分布式环境中传递信息，确保消息的可靠性、持久性和有序性，并允许系统组件以解耦合的方式进行交互。","category":"page"},{"location":"StepByStep/02-emqx消息服务器准备/#emqx简介","page":"消息服务器准备","title":"emqx简介","text":"","category":"section"},{"location":"StepByStep/02-emqx消息服务器准备/","page":"消息服务器准备","title":"消息服务器准备","text":"EMQ X 是一款开源的 MQTT 消息代理，专为 IoT (物联网)、M2M (机器对机器的通信) 和移动应用设计。它支持大规模的 MQTT 客户端连接，提供高吞吐、低延迟的实时消息路由。","category":"page"},{"location":"StepByStep/02-emqx消息服务器准备/","page":"消息服务器准备","title":"消息服务器准备","text":"以下是 EMQ X 的一些核心特点和概念：","category":"page"},{"location":"StepByStep/02-emqx消息服务器准备/","page":"消息服务器准备","title":"消息服务器准备","text":"高性能：EMQ X 优化了 MQTT 消息传递路径，提供了高吞吐和低延迟的消息代理服务。\n分布式：EMQ X 支持分布式节点连接，能够实现水平扩展以满足大规模设备连接的需求。\n插件系统：EMQ X 提供了强大的插件系统，允许开发者根据需要扩展其功能，例如：多种认证/授权方式、消息存储、集成其他系统等。\n协议支持：尽管 MQTT 是其主要的协议，但 EMQ X 也支持多种其他的 IoT 协议，如 MQTT-SN、CoAP、LwM2M、STOMP 等。\n安全性：EMQ X 支持基于 TLS/SSL 的加密通信，提供 ACL (访问控制列表) 基于的细粒度的订阅/发布权限控制，以及多种身份验证方法，如：用户名/密码、JWT、客户端证书等。\n持久化和桥接：EMQ X 支持消息的持久化存储，以及与其他 MQTT 代理或系统的桥接功能。\n监控和管理：EMQ X 提供了详细的监控统计和管理接口，帮助管理员实时监控系统状态，进行故障排查和性能优化。","category":"page"},{"location":"StepByStep/02-emqx消息服务器准备/","page":"消息服务器准备","title":"消息服务器准备","text":"EMQ X 的广泛应用领域包括：智能家居、车联网、智能制造、智慧城市等。由于其开源的特性、高性能和扩展性，EMQ X 已经吸引了许多大型企业和组织的使用。","category":"page"},{"location":"StepByStep/02-emqx消息服务器准备/#使用docker-compose安装emqx","page":"消息服务器准备","title":"使用docker-compose安装emqx","text":"","category":"section"},{"location":"StepByStep/02-emqx消息服务器准备/","page":"消息服务器准备","title":"消息服务器准备","text":"使用 docker-compose 来安装和运行 EMQ X 时，以下是一般的步骤：","category":"page"},{"location":"StepByStep/02-emqx消息服务器准备/#使用-docker-compose-安装-EMQ-X-的步骤：","page":"消息服务器准备","title":"使用 docker-compose 安装 EMQ X 的步骤：","text":"","category":"section"},{"location":"StepByStep/02-emqx消息服务器准备/","page":"消息服务器准备","title":"消息服务器准备","text":"准备环境：\n确保您已经在机器上安装了 Docker 和 Docker Compose。\n创建 docker-compose.yml 文件：\n在一个目录中，创建一个名为 docker-compose.yml 的文件，该文件将包含启动 EMQ X 的所有配置。\n配置 EMQ X：\n在 docker-compose.yml 文件中，定义 EMQ X 服务，包括所需的镜像、端口映射、网络和卷。\n启动服务：\n在终端或命令提示符中，导航到包含 docker-compose.yml 文件的目录。\n使用命令 docker-compose up -d 启动服务。\n验证 EMQ X 的运行：\n访问 EMQ X 的管理界面（通常是在 http://<host_ip>:18083）或使用 MQTT 客户端测试连接。\n关闭或删除服务（如果需要的话）：\n使用 docker-compose down 命令停止并删除服务。","category":"page"},{"location":"StepByStep/02-emqx消息服务器准备/#一个典型的-docker-compose.yml-文件","page":"消息服务器准备","title":"一个典型的 docker-compose.yml 文件","text":"","category":"section"},{"location":"StepByStep/02-emqx消息服务器准备/","page":"消息服务器准备","title":"消息服务器准备","text":"以下是一个典型的 docker-compose.yml 文件：","category":"page"},{"location":"StepByStep/02-emqx消息服务器准备/","page":"消息服务器准备","title":"消息服务器准备","text":"version: '3.2'\n\nservices:\n\n  emqx:\n    image: emqx/emqx:5.1.4\n    container_name: ai4e_emqx\n    restart: always\n    ports:\n      - \"1883:1883\"\n      - \"8883:8883\"\n      - \"8083:8083\"\n      - \"8084:8084\"\n      - \"18083:18083\"\n    # volumes:\n    #   - ./emqx_data:/opt/emqx/data\n    #   - ./emqx_log:/opt/emqx/log\n    #   - ./emqx_etc:/opt/emqx/etc\n    networks:\n      ai4e_net:\n        ipv4_address: 172.20.0.117\n\nnetworks:\n  ai4e_net:\n    ipam:\n      config:\n        - subnet: 172.20.0.0/16\n","category":"page"},{"location":"StepByStep/02-emqx消息服务器准备/","page":"消息服务器准备","title":"消息服务器准备","text":"我们来解释下：","category":"page"},{"location":"StepByStep/02-emqx消息服务器准备/","page":"消息服务器准备","title":"消息服务器准备","text":"version: '3.2'\n\nservices:\n  emqx:\n    image: emqx/emqx:5.1.4 # 使用 EMQ X 5.1.4 版本的 Docker 镜像。\n    container_name: ai4e_emqx # 定义容器的名字为 ai4e_emqx。\n    restart: always # 如果容器退出，总是重新启动它。\n    ports: # 映射宿主机与容器之间的端口。\n      - \"1883:1883\"\n      - \"8883:8883\"\n      - \"8083:8083\"\n      - \"8084:8084\"\n      - \"18083:18083\"\n    networks: # 指定容器使用的网络。\n      ai4e_net:\n        ipv4_address: 172.20.0.117\n\nnetworks:\n  ai4e_net:\n    ipam:\n      config:\n        - subnet: 172.20.0.0/16","category":"page"},{"location":"StepByStep/02-emqx消息服务器准备/","page":"消息服务器准备","title":"消息服务器准备","text":"版本：此配置使用的 docker-compose 文件版本为 3.2。\n服务：\nemqx：定义名为 emqx 的服务，使用版本为 5.1.4 的 EMQ X 镜像。\n端口映射：将容器内部的端口映射到宿主机的端口。例如，宿主机的 1883 端口映射到容器的 1883 端口。\n网络：定义了一个名为 ai4e_net 的自定义网络，并为 EMQ X 容器分配了 172.20.0.117 的静态 IP 地址。\nIPAM：定义网络的 IP 地址管理 (IPAM) 配置。在这里，它定义了一个子网 172.20.0.0/16，从中分配 IP 地址。","category":"page"},{"location":"StepByStep/02-emqx消息服务器准备/","page":"消息服务器准备","title":"消息服务器准备","text":"这个 docker-compose.yml 文件为 EMQ X 定义了基本的运行配置，包括使用的镜像、端口映射和网络设置。","category":"page"},{"location":"Tools/3-ssh-git实操/#SSH、Git与Git图形化软件","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"tip: Tip\nContents：SSH、Git与Git的图形化软件Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"本文介绍ssh、git与git的图形化软件。他们之间的关系为：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git基于ssh通讯操作\ngit图形化软件是操作git的图形化软件","category":"page"},{"location":"Tools/3-ssh-git实操/#SSH使用","page":"SSH、Git与Git图形化软件","title":"SSH使用","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/#SSH是什么","page":"SSH、Git与Git图形化软件","title":"SSH是什么","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"SSH是一种网络协议，用于计算机之间的加密登录。一个用户从本地计算机，使用SSH协议登录另一台远程计算机，就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。","category":"page"},{"location":"Tools/3-ssh-git实操/#SSH密钥登录原理","page":"SSH、Git与Git图形化软件","title":"SSH密钥登录原理","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"客户端发出认证请求；\n服务器端使用客户端发送的公钥对一个随机的256位的字符串进行加密，并发送给 客户端；\n客户端使用私钥对字符串进行解密，并生成一个MD5值发送给服务器端；\n服务器端根据原始随机字符串生成MD5值进行匹配, 确认客户端身份；\n至此, 双方互相确认对方身份并建立加密信道, 可以正式进行安全通信。","category":"page"},{"location":"Tools/3-ssh-git实操/#SSH的两种认证方式","page":"SSH、Git与Git图形化软件","title":"SSH的两种认证方式","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"1.基于口令的安全认证 ：提供正确的用户口令后可以登录远程服务器。","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"操作方式：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"(默认端口为22)","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"ssh user@host\n\nexample：\nssh root@127.0.0.1\nssh yjy@152.20.45.154","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"然后输入登录密码进行登录 使用p参数，可以修改端口","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"ssh -p 端口号 user@host\n\nexample：\nssh -p 8080 yjy@152.20.45.154 ","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"上面这个例子是以8080端口登录","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"2.基于密钥的安全认证 ：使用公钥和私钥对的方式对用户进行认证。","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"密钥登录首先需要产生公钥和私钥。","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"公钥放在服务端，私钥放在需要远程登录服务端的客户端","category":"page"},{"location":"Tools/3-ssh-git实操/#产生公钥和私钥","page":"SSH、Git与Git图形化软件","title":"产生公钥和私钥","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"ssh-keygen -t rsa","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"在~/.ssh文件夹（~为用户目录，windows和linux目录下都会有）下会出现idrsa与idrsa.pub两个文件。","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"idrsa是私钥，idrsa.pub是公钥。","category":"page"},{"location":"Tools/3-ssh-git实操/#修改配置文件","page":"SSH、Git与Git图形化软件","title":"修改配置文件","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"之后，在远程主机的ssh配置文件(/etc/ssh/sshd_config)中做如下修改，开启权限。这几项有些是新加上的，有些原来是no：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"RSAAuthentication yes\nPubkeyAuthentication yes\nAuthorizedKeysFile .ssh/authorized_keys","category":"page"},{"location":"Tools/3-ssh-git实操/#在服务端存放公钥","page":"SSH、Git与Git图形化软件","title":"在服务端存放公钥","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"方法一：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"将公钥中的一大串字符添加到服务端~/.ssh/authorized_keys文件中去，如果已经存在，那么在后面再添上一条。不建议覆盖，因为这样其它客户端远程登录的公钥就会被覆盖！","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"方法二：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"也可以用一段代码自动加过去","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"ssh root@111.20.45.124 \"mkdir -p .ssh && cat >> .ssh/authorized_keys\" < ~/.ssh/id_rsa.pub","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"这条命令由多个语句组成，依次分解开来看：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"（1）\"$ ssh user@host\"，表示登录远程主机；\n（2）双引号中的mkdir .ssh && cat >> .ssh/authorized_keys，表示登录后在远程shell上执行的命令：\n（3）\"$ mkdir -p .ssh\"的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；\n（4）'cat >> .ssh/authorizedkeys' < ~/.ssh/idrsa.pub的作用是，将本地的公钥文件~/.ssh/idrsa.pub，重定向追加到远程文件authorizedkeys的末尾。","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"写入authorized_keys文件后，公钥登录的设置就完成了。","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"现在就可以远程免密登录了！","category":"page"},{"location":"Tools/3-ssh-git实操/#可能出现的问题","page":"SSH、Git与Git图形化软件","title":"可能出现的问题","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"基本都是文件权限的问题，比如报错too open。Linux和Windows都会出现这样的情况，相关的解决方案很多，可以直接查找。","category":"page"},{"location":"Tools/3-ssh-git实操/#登录github或者码云","page":"SSH、Git与Git图形化软件","title":"登录github或者码云","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"用ssh怎么操作呢？","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"做一个转换，github相当于就是服务端，只需要把公钥放在服务端就可以了。在github上更加方便，因为它都是图形化软件操作。进入设置软件，选择ssh就可以进行调试了（码云同理）。","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"配置好了之后，可以进行如下测试：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"ssh -T git@github.com\n（ssh -T git@gitee.com）","category":"page"},{"location":"Tools/3-ssh-git实操/#git的使用","page":"SSH、Git与Git图形化软件","title":"git的使用","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/#git和ssh的关联","page":"SSH、Git与Git图形化软件","title":"git和ssh的关联","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"之前讲了那么多ssh的知识，有什么作用呢？ 会了ssh，git基本就会了一半了！","category":"page"},{"location":"Tools/3-ssh-git实操/#git的关键要素","page":"SSH、Git与Git图形化软件","title":"git的关键要素","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"本地工作区（自己电脑的文件夹）\n远程仓库（远端服务器上的文件夹）","category":"page"},{"location":"Tools/3-ssh-git实操/#git基本操作","page":"SSH、Git与Git图形化软件","title":"git基本操作","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"初始化本地仓库\n从远端拉取\n在本地编写文件\n文件暂存\n提交修改\n提交到远程","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"1.初始化本地仓库","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"通过git bash或者cmd进入仓库文件夹 输入：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git init","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"简单配置(相关教程也很多，不赘述)：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git config user.name \"Your Name\"\ngit config user.email \"email@example.com\"","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"链接到仓库的地址，相当于后面的操作就不需要输入地址了： （origin相当于变量，储存远端的地址）","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git remote add origin \"仓库的ssh地址\"","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"2.从远端拉取","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"拉取origin的master分支","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git pull origin master","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"3.本地编写文件 编写hello.txt","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"4.提交暂存","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git add .\n##或者\ngit add hello.txt","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"5.提交修改","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git commit -m \"文件说明\"","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"6.推送到远端","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git push origin master","category":"page"},{"location":"Tools/3-ssh-git实操/#git进阶操作","page":"SSH、Git与Git图形化软件","title":"git进阶操作","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"提交多个版本的文件\n回退","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"1. 提交多个版本的文件 hello.txt 版本1：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"i love you","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"提交暂存并修改","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git add hello.txt\ngit commit -m \"first\"","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"hello.txt 版本2：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"i love you\nI love you","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"提交暂存并修改","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git add hello.txt\ngit commit -m \"second\"","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"hello.txt 版本3：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"i love you\nI love you\nI love you too much","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"提交暂存并修改","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git add hello.txt\ngit commit -m \"third\"","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"接下来查看日志：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git log","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"如图： (Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"可以看到，HEAD 指向的是最新版本（head可以理解为当前版本，也就说如果要推到远程就是推这个版本）","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"2.回退 接下来回退到上一个版本：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git reset --hard HEAD^ ##回退到上上个就是：HEAD^^","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"那么可以看到head确实变了","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"又不想回退了，还是要回到第三次改变的最新版本","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git reset --hard 3ed54(commid的id，只能这样操作)","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"其实回退了之后就看不到id了，如果想要回到最新版本，就要记下id，所以说善变是有代价的！","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"可以方便查看id与修改信息：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git log --pretty=oneline","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"3.Push 在善变之后，找到了真爱，不管是谁吧，反正证还是要领的。最后就是把文件推送到远端了。","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git push origin master","category":"page"},{"location":"Tools/3-ssh-git实操/#git图形化软件","page":"SSH、Git与Git图形化软件","title":"git图形化软件","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git图形化软件的好处就是，把以上对git的操作图形化。","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"常用且免费的有：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"sourcetree\nvscode中内嵌的git操作页面\ngitkraken（团队版付费，个人免费）","category":"page"},{"location":"Tools/3-ssh-git实操/#sourcetree示例","page":"SSH、Git与Git图形化软件","title":"sourcetree示例","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"软件如下：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"比如说clone：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"某一个链接仓库的工作软件：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/3-ssh-git实操/#vscode示例","page":"SSH、Git与Git图形化软件","title":"vscode示例","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"(Image: 图 4)  ","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"更多操作见vscode中使用git","category":"page"},{"location":"Tools/3-ssh-git实操/#gitkraken示例","page":"SSH、Git与Git图形化软件","title":"gitkraken示例","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"gitkraken网址","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"(Image: 图 5)  ","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"不管什么软件，拉取、提交、暂存等等都是相同的！","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"如果你明白git的操作原理了，那么这个无师自通，因为本质上sourcetree就是提供一个图形化的操作软件。再没有其它新鲜玩意了！","category":"page"},{"location":"StepByStep/04-go-zero环境准备/#准备go-zero环境","page":"准备go-zero环境","title":"准备go-zero环境","text":"","category":"section"},{"location":"StepByStep/04-go-zero环境准备/#go-zero介绍","page":"准备go-zero环境","title":"go-zero介绍","text":"","category":"section"},{"location":"StepByStep/04-go-zero环境准备/","page":"准备go-zero环境","title":"准备go-zero环境","text":"go-zero 是一个专注于微服务的 Go 语言框架，旨在通过其丰富的功能和工具集使开发、部署和维护微服务变得更加简单和高效。以下是关于 go-zero 的一些核心特点和功能简介：","category":"page"},{"location":"StepByStep/04-go-zero环境准备/","page":"准备go-zero环境","title":"准备go-zero环境","text":"简洁的 API 设计：go-zero 提供了一套简单且高效的 API 设计工具，使得开发者可以更快地创建和维护 API 端点。\n强大的并发模型：框架采用了类似于 Erlang 的并发模型，结合了 Go 语言原生的 goroutine，以实现高效、可靠的并发处理。\n内置中间件支持：go-zero 附带了多种常用的中间件，如限流、缓存、鉴权等，以便更容易地构建安全、高效的微服务。\n自动生成代码：通过 goctl 工具，开发者可以自动生成大量代码，包括 API 定义、数据模型等，大大加速了开发速度。\n弹性设计：框架内置了故障恢复、熔断、负载均衡等机制，帮助开发者构建更加弹性和稳定的系统。\n高性能：通过其优化的并发模型和内置功能（如缓存），go-zero 旨在提供高性能的微服务。\n易于集成：它可以与其他 Go 语言库和框架轻松集成，提供了很大的灵活性。","category":"page"},{"location":"StepByStep/04-go-zero环境准备/","page":"准备go-zero环境","title":"准备go-zero环境","text":"总之，go-zero 是一个高效、灵活的微服务框架，它为 Go 语言的开发者提供了一个简单且功能强大的工具集，使得微服务的开发、部署和维护变得更加简单和高效。","category":"page"},{"location":"StepByStep/04-go-zero环境准备/#goctl安装","page":"准备go-zero环境","title":"goctl安装","text":"","category":"section"},{"location":"StepByStep/04-go-zero环境准备/","page":"准备go-zero环境","title":"准备go-zero环境","text":"go-zero 是一个用于构建微服务的框架，而 goctl 是 go-zero 的命令行工具，用于生成、管理和维护 go-zero 项目。以下是为 go-zero 准备环境并安装 goctl 的步骤：","category":"page"},{"location":"StepByStep/04-go-zero环境准备/","page":"准备go-zero环境","title":"准备go-zero环境","text":"安装 Go   在使用 go-zero 之前，你首先需要确保已经正确安装了 Go 语言。你可以访问 Go 的官方下载页面 获取适合你操作系统的安装包。\n配置 Go 环境变量   确保你的 GOPATH 和 GOBIN 环境变量已经正确设置，并且 $GOBIN 或 $GOPATH/bin 在你的 PATH 中。这样，当你安装 Go 工具或库时，你可以在任何地方从命令行运行它们。\n设置 GOPATH:  \nexport GOPATH=$HOME/go\n设置 GOBIN:  \nexport GOBIN=$GOPATH/bin\n把 GOBIN 添加到 PATH:  \nexport PATH=$PATH:$GOBIN\n注意: 上述命令是针对 Unix-like 系统的 (如 Linux 或 MacOS)。如果你使用的是 Windows，你需要修改系统环境变量。\n安装 goctl   使用 go get 命令，你可以轻松安装 goctl:\nGO111MODULE=on go install github.com/zeromicro/go-zero/tools/goctl@latest\n验证安装   通过运行以下命令验证 goctl 是否已正确安装：\ngoctl version\n如果安装成功，它应该会显示 goctl 的当前版本号。\n开始使用 goctl   有了 goctl，你现在可以开始创建、管理和维护 go-zero 项目了。为了更深入地了解如何使用这个工具，你可以运行 goctl help 以获取相关命令和说明。","category":"page"},{"location":"StepByStep/04-go-zero环境准备/","page":"准备go-zero环境","title":"准备go-zero环境","text":"按照上述步骤，你应该能够成功设置 go-zero 环境并安装 goctl 工具。","category":"page"},{"location":"StepByStep/04-go-zero环境准备/#protoc的安装","page":"准备go-zero环境","title":"protoc的安装","text":"","category":"section"},{"location":"StepByStep/04-go-zero环境准备/","page":"准备go-zero环境","title":"准备go-zero环境","text":"protoc 是一个用于生成代码的工具，它可以根据 proto 文件生成C++、Java、Python、Go、PHP 等多重语言的代码，而 gRPC 的代码生成还依赖 protoc-gen-go，protoc-gen-go-grpc 插件来配合生成 Go 语言的 gRPC 代码。","category":"page"},{"location":"StepByStep/04-go-zero环境准备/","page":"准备go-zero环境","title":"准备go-zero环境","text":"通过 goctl 可以一键安装 protoc，protoc-gen-go，protoc-gen-go-grpc 相关组件，你可以执行如下命令：","category":"page"},{"location":"StepByStep/04-go-zero环境准备/","page":"准备go-zero环境","title":"准备go-zero环境","text":"$ goctl env check --install --verbose --force","category":"page"},{"location":"StepByStep/04-go-zero环境准备/","page":"准备go-zero环境","title":"准备go-zero环境","text":"安装完毕后，你可以执行如下指令来验证是否安装成功：","category":"page"},{"location":"StepByStep/04-go-zero环境准备/","page":"准备go-zero环境","title":"准备go-zero环境","text":"$ goctl env check --verbose","category":"page"},{"location":"StepByStep/04-go-zero环境准备/#goctl-vscode插件的安装","page":"准备go-zero环境","title":"goctl-vscode插件的安装","text":"","category":"section"},{"location":"StepByStep/04-go-zero环境准备/","page":"准备go-zero环境","title":"准备go-zero环境","text":"在 Visual Studio Code (VSCode) 中，有一个扩展市场，使你可以搜索并安装各种插件来增强编辑器的功能。以下是在 VSCode 中安装 goctl 插件的步骤：","category":"page"},{"location":"StepByStep/04-go-zero环境准备/","page":"准备go-zero环境","title":"准备go-zero环境","text":"启动 VSCode   如果还没有启动 VSCode，首先启动它。\n进入扩展市场   在左侧边栏上，点击四个方块形成的图标（或按 Ctrl+Shift+X）进入扩展市场。\n搜索插件   在扩展市场的搜索框中输入 goctl。\n安装插件   在搜索结果中找到 goctl 插件。点击安装按钮来安装它。\n重新加载VSCode   安装完插件后，可能需要重新加载 VSCode 以确保插件能够正常工作。有些插件在安装时会提示你重新加载，但并不是所有的都需要。\n配置 (如有必要)   根据你的需要，进入 VSCode 的设置，定制 goctl 插件的配置。","category":"page"},{"location":"StepByStep/04-go-zero环境准备/","page":"准备go-zero环境","title":"准备go-zero环境","text":"现在，你应该在 VSCode 中成功安装了 goctl 插件，并可以开始使用其功能了。","category":"page"},{"location":"StepByStep/04-go-zero环境准备/","page":"准备go-zero环境","title":"准备go-zero环境","text":"注意：随着时间的推移，VSCode 或插件的具体细节可能会发生变化。如果上述步骤在未来变得不准确，建议参考 VSCode 和 goctl 插件的官方文档。","category":"page"}]
}
