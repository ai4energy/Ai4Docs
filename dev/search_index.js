var documenterSearchIndex = {"docs":
[{"location":"CSBase/9-dll生成与调用实操/#动态链接库(DLL)的生成与调用实操","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"","category":"section"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"tip: Tip\nContents：Julia调用DllContributor: 杨月宝Email:812987139@qq.com如有错误，请批评指正。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/#问题的产生与解决过程概述","page":"动态链接库(DLL)的生成与调用实操","title":"问题的产生与解决过程概述","text":"","category":"section"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"我们试图使用Julia来调用热流问题数值计算课程的代码。这些代码是在2003年重新整理的Fortran代码。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"第一步：我们生成了Fortran动态链接库（dll），并尝试使用C语言调用该dll。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"第二步：接着，我们尝试使用C++来调用该dll，并试图使用Julia来调用它。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"第三步：我们配置了VS2013，生成了64位的dll，并使用64位的Julia来调用该dll。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/#工作环境","page":"动态链接库(DLL)的生成与调用实操","title":"工作环境","text":"","category":"section"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"Julia版本：Julia 1.7.0-beta2\n使用的Fortran编译器：Intel.Visual.Fortran.Composer.XE.2013-SP1，这是在VS2013中的Fortran编译器。\n开发环境：VSCode（Visual Studio Code）","category":"page"},{"location":"CSBase/9-dll生成与调用实操/#实践过程","page":"动态链接库(DLL)的生成与调用实操","title":"实践过程","text":"","category":"section"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"<!–  1.使用Fortran生成dll","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"2.使用VS2013开发人员命令提示查看dll位数","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"3.使用C++调用dll","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"4.使用Julia调用dll –>","category":"page"},{"location":"CSBase/9-dll生成与调用实操/#使用Fortran生成dll","page":"动态链接库(DLL)的生成与调用实操","title":"使用Fortran生成dll","text":"","category":"section"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"新建一个Fortran动态链接库项目","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"(Image: 1)","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"在Resource Files中添加一个f90文件，并输入如下内容","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"SUBROUTINE OUTPUT(a, b, sum)\n    !MS$ ATTRIBUTES DLLEXPORT::OUTPUT\n    !声明本函数为输出函数\n    IMPLICIT NONE\n    INTEGER a, b, sum\n    sum = a + b\nEND SUBROUTINE OUTPUT","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"这段Fortran代码定义了一个名为\"OUTPUT\"的子程序（SUBROUTINE），它接受三个参数：a、b和sum。代码的解释如下：","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"!MS$ ATTRIBUTES DLLEXPORT::OUTPUT：这是一个特定于编译器的注释（directive），用于指示将该函数声明为输出函数（export function），以便其他程序或语言可以调用它。\nIMPLICIT NONE：这是一个编译器指令，用于禁用隐式类型声明。它要求所有变量都必须显式地声明其类型。\nINTEGER a, b, sum：这是变量声明的部分，它指定了a、b和sum都是整数类型的变量。\nsum = a + b：这一行将a和b的值相加，并将结果赋给变量sum。这行代码的作用是计算a和b的和，并将结果存储在sum变量中。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"因此，这段代码定义了一个名为\"OUTPUT\"的子程序，它接受两个整数参数a和b，并计算它们的和，并将结果存储在sum变量中。通过!MS$ ATTRIBUTES DLLEXPORT::OUTPUT的声明，该子程序可以被导出为一个可供其他程序或语言调用的函数。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"Fortran通过下句表示dll输出函数","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"!MS$ ATTRIBUTES DLLEXPORT::OUTPUT","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"配置编译器属性，选择64位的编译器来生成64位的dll","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"(Image: 1) (Image: 1) (Image: 1) (Image: 1)","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"编译文件后生成项目，就可以在.\\x64\\Debug文件夹下找到生成的dll文件","category":"page"},{"location":"CSBase/9-dll生成与调用实操/#使用VS2013开发人员命令提示查看dll位数","page":"动态链接库(DLL)的生成与调用实操","title":"使用VS2013开发人员命令提示查看dll位数","text":"","category":"section"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"VS2013的工具路径在安装目录下","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":".\\Microsoft Visual Studio 12.0\\Common7\\Tools\\Shortcuts","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"选择VS2013开发人员命令提示，可以使用dumpbit命令获得dll信息","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"dumpbin /headers 路径","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"读取上段生成dll，部分结果：","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"(Image: 1)","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"以下是更多的参考：","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"在Windows下，可以使用以下方法来查看DLL文件的位数：","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"打开文件资源管理器（Windows资源管理器）。\n导航到包含所需DLL文件的目录。\n右键单击DLL文件，然后选择\"属性\"。\n在属性对话框中，切换到\"详细信息\"选项卡。\n在\"属性\"部分中，查找\"位数\"或\"架构\"相关的信息。通常会显示为\"32位\"或\"64位\"。\n查看该信息以确定DLL文件的位数。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"另外，您还可以使用命令行来查看DLL文件的位数：","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"打开命令提示符（CMD）或PowerShell。\n使用cd命令导航到包含DLL文件的目录。\n运行以下命令来查看DLL文件的位数：\ndumpbin /headers <DLL文件名>\n将 <DLL文件名> 替换为实际的DLL文件名。\n在输出中查找 \"x86\" 表示32位，\"x64\" 表示64位。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"通过这些方法，您可以方便地查看DLL文件的位数，以确定其兼容性和与其他程序的配合情况。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/#使用C调用dll","page":"动态链接库(DLL)的生成与调用实操","title":"使用C++调用dll","text":"","category":"section"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"这里采用动态调用方法，根据网上找到的资料和Fortran程序设计课程讲义，我重新整理了C++代码。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"这部分代码把那几个冒号去了就是C的代码（就是说实质是c语言代码）。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"调试或启动exe文件前，请将dll文件放于EXE文件所在的Debug文件夹内。我的是在E:\\Programs\\program VS2013\\HF_first\\ForDllCreat\\x64\\Debug","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"我的解决方案名和Fortran生成dll的方案同名了，请不要混淆。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"#include <stdio.h>\n#include <windows.h> // 调用 WINDOWS API 函数所需的头文件\n\ntypedef void(*Func)(int *, int *, int *);//定义一个函数指针类型，这个指针类型与被调用函数的输入类型要一一对应\n\nint main()\n{\n int a = 1, b = 2, sum;\n\n //宏定义函数指针类型\n HMODULE hLibrary = ::LoadLibrary(L\"ForDLLCreat.dll\"); //加载动态库文件，dll名前不加L会报错\n if (hLibrary == NULL)\n {\n  printf(\"No DLL file exist!\\n\");\n  return -1;\n }\n Func dllPro = (Func)::GetProcAddress(hLibrary, \"OUTPUT\");\n //获得 Fortran 导出函数的地址\n if (dllPro == NULL)\n {\n  printf(\"Can not fine the address of the function!\\n\");\n  return -2;\n }\n dllPro(&a, &b, &sum);\n printf(\"%d + %d = %d\\n\", a, b, sum);\n FreeLibrary(hLibrary); //卸载动态库文件\n return 0;\n}","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"这段代码是一个使用C语言调用动态链接库（DLL）中函数的示例代码，其解释如下：","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"#include <stdio.h>：包含了标准输入输出函数的头文件。\n#include <windows.h>：包含了调用Windows API函数所需的头文件。\ntypedef void(*Func)(int *, int *, int *);：定义了一个函数指针类型Func，该指针类型与被调用函数的输入类型一一对应，即接受三个int型指针作为参数且没有返回值。\nint main()：主函数的入口。\nint a = 1, b = 2, sum;：声明整型变量a、b和sum，并分别初始化a和b的值。\nHMODULE hLibrary = ::LoadLibrary(L\"ForDLLCreat.dll\");：加载名为\"ForDLLCreat.dll\"的动态库文件。LoadLibrary函数返回一个句柄（HMODULE），用于后续操作。\nif (hLibrary == NULL)：检查动态库文件是否加载成功，如果返回的句柄为空，则说明加载失败，打印错误信息并退出程序。\nFunc dllPro = (Func)::GetProcAddress(hLibrary, \"OUTPUT\");：通过GetProcAddress函数获取动态库中名为\"OUTPUT\"的函数的地址，并将其赋给函数指针变量dllPro。\nif (dllPro == NULL)：检查函数地址是否获取成功，如果返回的地址为空，则说明获取失败，打印错误信息并退出程序。\ndllPro(&a, &b, &sum);：通过函数指针调用函数，将a、b和sum的地址作为参数传递给被调用函数。\nprintf(\"%d + %d = %d\\n\", a, b, sum);：打印计算结果。\nFreeLibrary(hLibrary);：卸载动态库文件，释放资源。\nreturn 0;：程序正常结束返回值。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"总体而言，该代码加载了一个名为\"ForDLLCreat.dll\"的动态库文件，并通过函数指针调用了其中的\"OUTPUT\"函数，将a和b的值作为输入，计算它们的和并将结果存储在sum中，最后打印出计算结果。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/#使用Julia调用dll","page":"动态链接库(DLL)的生成与调用实操","title":"使用Julia调用dll","text":"","category":"section"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"Julia官方文档地址：Calling C and Fortran Code","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"在开始前，请务必确认Julia的位数与所用dll位数相同，否则会报错dll不是一个可用的Win32应用。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"ForDllCreate.dll与ForDllCreate.64.dll内部包含和前文相同的函数，区别是前者是32位，后者是64位。 在64位REPL上载入32位dll会报错。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"ERROR: LoadError: could not load library \"e:\\yyb\\HF_first\\ForDllCreat.dll\"\n%1 is not a valid Win32 application.\nStacktrace:\n [1] top-level scope\n   @ e:\\yyb\\HF_first\\test.jl:15\nin expression starting at e:\\yyb\\HF_first\\test.jl:15","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"如果你想在Julia中使用ccall函数来调用DLL中的函数，你可以按照以下步骤进行操作：","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"假设你有一个名为\"example.dll\"的DLL文件，其中包含一个名为\"add_numbers\"的函数，用于将两个整数相加。\n在Julia中，使用ccall函数来加载和调用DLL中的函数。以下是一个示例：","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"# 调用ccall函数加载DLL文件\nconst lib = \"example.dll\"\nconst handle = ccall((:LoadLibraryA, lib), Ptr{Cvoid}, (Cstring,), lib)\n\n# 定义要调用的函数的签名\nconst add_numbers = ccall((:add_numbers, lib), Cint, (Cint, Cint))\n\n# 调用函数并获取结果\nresult = add_numbers(5, 3)\nprintln(result)  # 输出 8\n\n# 卸载DLL\nccall((:FreeLibrary, lib), Cint, (Ptr{Cvoid},), handle)","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"在上面的示例中，我们首先使用ccall函数加载名为\"example.dll\"的DLL文件。通过指定函数名称和DLL文件的句柄，我们可以获取要调用的函数的指针。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"然后，我们定义了一个名为add_numbers的Julia函数，并使用ccall函数将其与DLL中的add_numbers函数关联起来。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"最后，我们调用add_numbers函数，并将参数5和3传递给它。返回的结果存储在result变量中，并打印到控制台。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"最后，我们使用ccall函数卸载DLL文件，以释放资源。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"请注意，示例中的函数签名和参数类型可能需要根据DLL中的实际函数进行调整。确保使用正确的参数类型和返回类型。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"使用ccall函数直接调用DLL函数时，需要小心处理内存管理和类型匹配，确保传递正确的参数和返回类型。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"以下是我们针对自己生成的dll的调用的例子：","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"#error\na = [1]\nb = [2]\nc = [0]\nccall((:OUTPUT, \".\\\\ForDllCreat.dll\"), Cvoid, (Ptr{Cint}, Ptr{Cint}, Ptr{Cint}), pointer_(a), pointer(b), pointer(c))\nprint(c)\n\n#work\na = [1]\nb = [2]\nc = [0]\nccall((:OUTPUT, \".\\\\ForDllCreat64.dll\"), Cvoid, (Ptr{Cint}, Ptr{Cint}, Ptr{Cint}), pointer_from_objref(a) + 0x40, pointer_from_objref(b) + 0x40, pointer_from_objref(c) + 0x40)\nprint(c)","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"解释：","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"在第一段代码中，使用了名为ForDllCreat.dll的 DLL 文件来执行函数调用。函数名称为OUTPUT，该函数接受三个整型指针作为参数，并将结果存储在指针c指向的位置。通过ccall函数来调用 DLL 中的函数，并传递指针参数。最后打印出指针c所指向的值。\n在第二段代码中，使用了名为ForDllCreat64.dll的 DLL 文件来执行函数调用。其他部分与第一段代码类似，但是在传递指针参数时，对每个指针都进行了偏移，即将指针从对象引用中提取后加上0x40的偏移量。最后同样打印出指针c所指向的值。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"请注意，这段代码中的部分函数和对象引用是特定于编程语言的，并且需要正确配置和具备相应的 DLL 文件才能正常运行。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"Julia可用通过ccall函数调用C和Fortran编译的dll文件，输入格式为","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"  ccall((function_name, library), returntype, (argtype1, ...), argvalue1, ...)\n  ccall(function_name, returntype, (argtype1, ...), argvalue1, ...)  \n  ccall(function_pointer, returntype, (argtype1, ...), argvalue1, ...)","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"这里通过第一种调用方法来调用我们编译的ForDllCreat64.dll，","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"function_name是调用的函数名称。引用时即可以用:OUTPUT表示，也可以用\"OUTPUT\"表示。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"C语言与Fortran输出dll时函数名不变，C++输出函数有命名粉碎，自制dll尽量采用C输出，一定要确定被调用函数的名字才能成功引用。可看此视频","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"library是被调用dll的路径，用字符串表示。调用C标准库中的函数时，library可以略去。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"#调用C标准库函数，不用写引用\nt = ccall(:clock, Int32, ())","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"returntype是被调函数的返回类型。Fortran的subroutine返回类型是空，即void，在Julia中表示为Cvoid。数据类型对应的表格可以参考下文表格，也可以查看官方文档。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"(argtype1, ...)是一个tuple，与被调函数的输入变量类型要一一对应，类似在C++中定义一个与被调函数输入变量类型一一对应的函数原型。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"argvalue1, ...  这部分是输入变量，类型要与(argtype1, ...)一一对应，并与被调函数对应。输入变量不用tuple表示。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"不同语言间调用dll，最重要的就是数据类型的匹配。下表是从Julia官方文档中复制的数据类型对应表。更多细节请查看官方文档。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"(Image: 图 1)  ","category":"page"},{"location":"CSBase/9-dll生成与调用实操/#更多julia的信息","page":"动态链接库(DLL)的生成与调用实操","title":"更多julia的信息","text":"","category":"section"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"Julia中指针的用法 （以下内容暂时不用那么细，先忽略，需用到时查julia的官方文档。）","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"数组类型基本上通过指针传递。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"Julia中，指针有两种，Ptr{T}与Ref{T}","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"Ptr表示的是从变量获得的地址，这类地址是否被销毁不由Julia管理，一般是“危险的”（unsafe)。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"Ref是由Julia分配的地址，这类地址的任何更改都由Julia进行，因此是“安全的”。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"但是Ref能用的方法似乎不多，目前为止我没学明白这个怎么用。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"Julia中获得变量地址的函数有pointer和pointerformobjref，他们获得的指针都是Ptr型的 pointer获得的地址被标明了数据类型，并且总比pointerformobjref的返回值多出一个数据类型的bit数；pointerformobjref获得的地址是无数据类型的。 在官方文档中，pointerfromobjref是对C提供接口的方法(C_Interface)","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"a=\"大家好\"\nb=pointer(a)\nc=pointer_from_objref(a)\nprintln(b)\nprintln(c)\nprintln(b-c)\n\nprintln(\"a[1]的字节数是\",sizeof(typeof(a[1])))#UInt8的字节数是1,但是Char类型的字节数是4","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"由地址获得值的方法是unsafepointerto_objref，这个函数也是官方文档中C接口的函数。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"对一个Ptr指针，用pointer获得的指针要减去一个数据类型的bit数才能获得指针内的值。","category":"page"},{"location":"CSBase/9-dll生成与调用实操/","page":"动态链接库(DLL)的生成与调用实操","title":"动态链接库(DLL)的生成与调用实操","text":"a=[1.23]\n\nb=pointer(a)\nc=pointer_from_objref(a)\n\nd=unsafe_pointer_to_objref(b-0x40)\ne=unsafe_pointer_to_objref(c)\n\nprintln(\"d=\",d)\nprintln(\"e=\",e)","category":"page"},{"location":"Tools/CSV_jl_use/#CSV.jl使用简介","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"tip: Tip\nContents：CSV文本读入Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"note: Note\nCSV.jl是一个快速灵活的纯 Julia包，用于处理带分隔符的文本文件。","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"在建立模型与模型计算的过程中，可以很好的解决数据导入问题，它能自动辨识文本数据类型，并将数据分隔。","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"它的应用场景是：使用数据之前的输入导入。","category":"page"},{"location":"Tools/CSV_jl_use/#基本实现","page":"CSV.jl使用简介","title":"基本实现","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"文件内容：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"col1,col2,col3,col4,col5,col6,col7,col8\n,1,1.0,1,one,2019-01-01,2019-01-01T00:00:00,true\n,2,2.0,2,two,2019-01-02,2019-01-02T00:00:00,false\n,3,3.0,3.14,three,2019-01-03,2019-01-03T00:00:00,true","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"使用以下代码导入文件","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\") #file为文件名，如\"data.csv\"、\"data.txt\"","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"默认情况下，CSV.File会自动检测这个文件的分隔符','，以及每列的类型。默认情况下，它将“空字段”视为missing（本示例中的整个第一列）。它还自动处理提升类型，例如第 4 列，其中前两个值为Int，但第 3 行具有Float64值 ( 3.14)。","category":"page"},{"location":"Tools/CSV_jl_use/#自定义分隔符","page":"CSV.jl使用简介","title":"自定义分隔符","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"文件内容：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"col1::col2\n1::2\n3::4","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"使用以下代码导入文件","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; delim=\"::\")","category":"page"},{"location":"Tools/CSV_jl_use/#无标题情况","page":"CSV.jl使用简介","title":"无标题情况","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"文件内容：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"1,2,3\n4,5,6\n7,8,9","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"在没有标题的情况下，会默认把第一行当作标题，可以给定参数取消，使用以下代码导入文件","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; header=false) #取消标题","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"或者也可以手动给定标题","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; header=[\"col1\", \"col2\", \"col3\"]) #手动给定标题","category":"page"},{"location":"Tools/CSV_jl_use/#指定数据行数","page":"CSV.jl使用简介","title":"指定数据行数","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"文件内容：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"col1,col2,col3\nmetadata1,metadata2,metadata3\nextra1,extra2,extra3\n1,2,3\n4,5,6\n7,8,9","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"假如我们期望的内容是从第四行开始，可以使用以下代码","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; skipto=4) #从第四行开始","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"或者","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; datarow=4)","category":"page"},{"location":"Tools/CSV_jl_use/#读取数据段","page":"CSV.jl使用简介","title":"读取数据段","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"文件内容：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"col1,col2,col3\n1,2,3\n4,5,6\n7,8,9\n10,11,12\n13,14,15\n16,17,18\n19,20,21","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"只需要读入某一段数据段","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; skipto=4，limit=1) #从第四行开始,读取1行","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"或者","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; skipto=4，footerskip=1) #从第四行开始,除去最后一行","category":"page"},{"location":"Tools/CSV_jl_use/#转置","page":"CSV.jl使用简介","title":"转置","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"文件内容：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"col1,1,2,3\ncol2,4,5,6\ncol3,7,8,9","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"用如下代码导入","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; transpose=true) #从第四行开始,读取1行","category":"page"},{"location":"Tools/CSV_jl_use/#数据操作","page":"CSV.jl使用简介","title":"数据操作","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"我们以一下文件输入为例：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"col1,col2,col3\n1,2,3\n4,5,6\n7,8,9\n10,11,12\n13,14,15\n16,17,18\n19,20,21","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"用如下代码导入","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"data = CSV.File(\"data.txt\") ","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"现在相当于把数据储存到变量data中了，data是CSV.File类型的数据，可以通过typeof函数来查看一下：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"typeof(data)","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"现在调用某一列的数字：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"println(data.col1) #显示第一列\nprintln(data.col2) #显示第二列\nprintln(data.col3) #显示第三列","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"它的结果是：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"[1, 4, 7, 10, 13, 16, 19]","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"[2, 5, 8, 11, 14, 17, 20]","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"[3, 6, 9, 12, 15, 18, 21]","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"查看一列的数据类型","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"typeof(data.col1)","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"它的结果是：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"Vector{Int64}","category":"page"},{"location":"Tools/CSV_jl_use/#小结","page":"CSV.jl使用简介","title":"小结","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"可以发现，data是CSV.File类型，但是通过data调用的每一列数据是vector类型","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"说明可以把每一列当作平常的vector来处理，相关的方法都能够匹配。","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"比如：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"sum(data.col1)\na = data.col1 .* data.col2","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"tip: Tip\n推荐一个好用的数据展示包DataFrames，它一般与CSV.jl结合起来使用在julia的包模式下安装：add DataFrames将data漂亮的输出，只需要：using DataFrames\ndisplay(DataFrame(data))","category":"page"},{"location":"JuliaIntro/3-julia的语法要点/#julia的语法要点","page":"julia的语法要点","title":"julia的语法要点","text":"","category":"section"},{"location":"JuliaIntro/3-julia的语法要点/","page":"julia的语法要点","title":"julia的语法要点","text":"当您开始学习Julia的基本语法时，以下是一些简单的介绍和示例：","category":"page"},{"location":"JuliaIntro/3-julia的语法要点/","page":"julia的语法要点","title":"julia的语法要点","text":"变量声明和赋值： 在Julia中，您可以使用变量来存储数据。变量名以字母或下划线开头，可以包含字母、数字和下划线。您可以使用等号=将值赋给变量。\nx = 10\ny = \"Hello, Julia!\"\n基本数据类型： Julia支持多种基本数据类型，包括整数（Integers）、浮点数（Floats）、布尔值（Booleans）、字符（Characters）和字符串（Strings）。\nx = 10\ny = 3.14\nis_true = true\nchar = 'a'\nstr = \"Hello, Julia!\"\n数学运算： Julia支持常见的数学运算，包括加法、减法、乘法、除法和取余等。\nx = 10\ny = 5\nsum = x + y\ndifference = x - y\nproduct = x * y\nquotient = x / y\nremainder = x % y\n条件语句： 您可以使用条件语句在特定条件下执行不同的操作。Julia中的条件语句使用if-else结构。\nx = 10\nif x > 5\n    println(\"x is greater than 5\")\nelse\n    println(\"x is less than or equal to 5\")\nend\n循环： 您可以使用循环结构重复执行特定的代码块。Julia中的循环结构包括for循环和while循环。\n# 使用for循环\nfor i in 1:5\n    println(i)\nend\n\n# 使用while循环\nx = 1\nwhile x <= 5\n    println(x)\n    x += 1\nend\n函数定义： 您可以定义自己的函数来执行特定的任务。函数由函数名、参数和函数体组成。您可以使用function关键字来定义函数，并使用return语句返回值。\nfunction greet(name)\n    println(\"Hello, $name!\")\nend\n\ngreet(\"Alice\")","category":"page"},{"location":"JuliaIntro/3-julia的语法要点/","page":"julia的语法要点","title":"julia的语法要点","text":"这些只是Julia语法的一些基础知识。Julia是一种功能强大且灵活的语言，提供了许多高级功能和数据结构，可以用于更复杂的编程任务。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/#Windows下安装gcc编译器和CLion","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"","category":"section"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/#编译器和集成开发环境简介","page":"Windows下安装gcc编译器和CLion","title":"编译器和集成开发环境简介","text":"","category":"section"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"编译器和集成开发环境（IDE）是软件开发中常用的工具。下面是对它们的概括介绍：","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"编译器： 编译器是一种将源代码转换为可执行文件的工具。它接收编写的源代码作为输入，经过一系列的词法分析、语法分析、语义分析和代码优化等过程，生成可执行的目标代码或者字节码。编译器可以将高级编程语言（如C、C++、Java等）转换为机器码或者中间代码，以便计算机能够执行。\n在Windows系统中，GCC（GNU Compiler Collection）是一个非常流行的编译器套件。它支持多种编程语言，包括C、C++、Java等，并且可以在Windows上进行安装和使用。\n集成开发环境（IDE）： 集成开发环境是为了提供一个集成的开发环境，将编码、调试和构建等开发任务整合到一个界面中。IDE通常包括代码编辑器、编译器、调试器和其他开发工具，旨在提高开发效率。\nCLion是JetBrains开发的一款跨平台C/C++集成开发环境。它提供了代码编辑器、自动完成、调试器等功能，使得C和C++开发更加便捷。CLion还集成了CMake构建系统，可以帮助您轻松管理项目的构建过程。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/#Windows下安装msys2、gcc以及CLion","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装msys2、gcc以及CLion","text":"","category":"section"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"在Windows系统下，可以通过以下步骤安装GCC和CLion并使用MSYS2：","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"安装MSYS2：\n下载MSYS2安装程序并运行它：https://www.msys2.org/\n按照安装向导的指示完成安装过程。\n安装GCC：\n打开MSYS2 Shell（通过开始菜单中的MSYS2程序组找到）。\n运行以下命令来更新MSYS2软件包管理器：\npacman -Syu\n更新完成后，运行以下命令安装GCC：\npacman -S mingw-w64-x86_64-toolchain\n安装CLion：\n下载CLion安装程序并运行它：https://www.jetbrains.com/clion/\n按照安装向导的指示完成安装过程。\n配置CLion：\n打开CLion，并按照提示进行初始化设置。\n在\"Toolchains\"设置中，选择\"MinGW\"作为编译器，并指定MSYS2的安装路径。\n创建或导入您的项目，并开始编写、调试和构建您的代码。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"这样，您就可以在Windows系统下使用GCC和CLion进行C和C++的开发了。希望这些信息对您有所帮助！","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/#msys2是什么？","page":"Windows下安装gcc编译器和CLion","title":"msys2是什么？","text":"","category":"section"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"当谈到在Windows系统上进行开发时，MSYS2是一个常用的工具，它为Windows用户提供了类似于Unix或Linux环境的开发体验。以下是对MSYS2的补充介绍：","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"MSYS2（Minimal SYStem 2）是一个开源的软件发布和管理工具，旨在为Windows提供类似于GNU/Linux系统的开发环境。它基于Cygwin（Cygwin是一个在Windows上运行的类Unix环境）并扩展了其功能。MSYS2提供了一组工具和软件包，使开发者能够在Windows上使用常见的开发工具和软件。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"主要特点和功能：","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"软件包管理器：MSYS2使用自己的软件包管理器（称为pacman），它允许您轻松地安装、更新和删除开发所需的各种工具和库。通过pacman，您可以方便地安装GCC、CMake、Python等常用的开发工具和库。\n命令行环境：MSYS2提供了一个命令行界面（称为MSYS2 Shell），类似于Linux终端。它使用Bash作为默认的Shell，并提供了一系列的命令和工具，使得在Windows上进行命令行开发变得更加方便。\nGNU工具链支持：MSYS2提供了一组GNU工具，包括GCC编译器、GNU Make构建工具和其他常用的开发工具。这使得您可以在Windows上使用这些工具进行C、C++和其他编程语言的开发。\n环境隔离：MSYS2提供了一个隔离的环境，使得开发所需的工具和库可以与系统环境相互独立。这意味着您可以使用MSYS2提供的工具链，而不会与系统环境中的工具发生冲突。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"总结起来，MSYS2为Windows用户提供了一个方便和强大的开发环境，使得在Windows上进行跨平台开发变得更加容易。通过安装和使用MSYS2，您可以轻松地获取常用的开发工具和库，并在类Unix的环境下进行命令行开发。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/#再说说mingw和mingw64","page":"Windows下安装gcc编译器和CLion","title":"再说说mingw和mingw64","text":"","category":"section"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"当谈到在Windows系统上进行C和C++开发时，MinGW和MinGW-w64是两个常用的工具集，它们提供了在Windows环境下使用GNU工具链进行编译的能力。以下是对MinGW和MinGW-w64的介绍：","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"MinGW（Minimalist GNU for Windows）： MinGW是一个开源的工具集，旨在为Windows系统提供基于GNU工具的编译能力。它包括了一系列的GNU工具，如GCC编译器、GNU Binutils（包含链接器和汇编器）以及其他辅助工具。MinGW使用Windows API来编写原生Windows应用程序。\nMinGW的目标是提供一种轻量级的方式，在Windows上进行C和C++的编译，生成可在Windows环境下运行的可执行文件。它通过使用MinGW提供的工具链，将C和C++代码编译为与Windows操作系统兼容的可执行文件。\nMinGW-w64： MinGW-w64是MinGW的一个分支，它对原始的MinGW进行了扩展和改进。MinGW-w64的主要目标是支持64位Windows系统，并提供更好的兼容性和功能。\nMinGW-w64继承了MinGW的基本功能，同时添加了对64位Windows系统的支持。它提供了一套完整的工具链，包括GCC编译器、GNU Binutils和其他开发工具，用于在64位Windows系统上进行C和C++的编译和构建。\nMinGW-w64不仅支持64位Windows系统，还可以用于开发32位应用程序。它提供了对多种目标平台和架构的支持，包括x86、x86-64、ARM等。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"总结起来，MinGW和MinGW-w64是在Windows系统上进行C和C++开发的工具集，它们提供了GNU工具链，包括GCC编译器和其他辅助工具。MinGW主要用于32位Windows系统，而MinGW-w64扩展了对64位系统的支持，并提供更多功能和兼容性。通过使用MinGW或MinGW-w64，开发者可以在Windows环境下进行C和C++代码的编译和构建。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/#也许初学者需要Gcc的介绍","page":"Windows下安装gcc编译器和CLion","title":"也许初学者需要Gcc的介绍","text":"","category":"section"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"当谈到C和C++编程时，GCC（GNU Compiler Collection）是一个常用且强大的编译器套件，特别适合初学者。下面是对GCC的介绍：","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"GCC是由GNU开发的自由软件编译器集合，支持多种编程语言，包括C、C++、Objective-C、Fortran、Ada和其他一些语言。它被广泛用于各种操作系统和架构上，包括Linux、Windows、macOS等。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"GCC的主要特点和优势包括：","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"开源自由：GCC是自由软件，具有开源的特性。这意味着您可以自由地使用、修改和分发GCC，无需支付费用。\n跨平台支持：GCC可在多个操作系统上使用，包括Linux、Windows、macOS等。这使得您可以使用相同的编译器在不同的平台上进行开发。\n多语言支持：GCC支持多种编程语言，使得您可以在同一个编译器环境下开发不同语言的程序。特别是对于C和C++开发者来说，GCC提供了广泛的语言功能和标准支持。\n优化能力：GCC具有强大的代码优化能力，可以对生成的机器码进行各种优化，提高程序的执行效率和性能。\n标准兼容性：GCC遵循C和C++的标准规范，并不断更新以支持最新的语言标准。这使得您可以编写符合标准的代码，并享受语言提供的新特性和改进。\n开发工具集成：GCC集成了一系列的开发工具，如调试器（GDB）、性能分析工具（gprof）等，使得开发者能够进行调试和性能优化。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"对于初学者来说，GCC是一个非常有价值的工具，因为它易于获取、使用和学习。您可以通过安装GCC，将C和C++源代码编译为可执行文件，从而开始学习和开发自己的程序。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"请注意，对于Windows系统，您可以使用MSYS2或MinGW-w64来安装和使用GCC。这些工具集提供了在Windows环境下使用GCC的能力，并使得在Windows上进行C和C++开发变得更加便捷。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/#GNU好像也必须提一下","page":"Windows下安装gcc编译器和CLion","title":"GNU好像也必须提一下","text":"","category":"section"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"当谈到GCC时，确实有必要提及GNU（GNU's Not Unix）项目，因为GCC是GNU项目的一部分。以下是对GNU的简要介绍：","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"GNU是一个由理查德·斯托曼（Richard Stallman）发起的自由软件运动，旨在创建一个自由、开放和用户可控的操作系统。GNU项目致力于为用户提供自由软件的选择，使他们能够运行、修改、分发和改进软件。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"GNU项目不仅包括GCC编译器集合，还涵盖了许多其他重要的软件和工具，如GNU核心工具（包括shell、文本编辑器等）、GNU库（提供通用的功能库）以及GNU操作系统（GNU Hurd）等。这些工具和软件都是自由软件，可以免费使用、修改和分发。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"GNU的目标是创建一个完全自由的操作系统，以替代传统的专有操作系统。尽管GNU操作系统的核心（GNU Hurd）目前还没有广泛使用，但许多GNU工具和软件被广泛地集成到各种操作系统中，包括Linux、FreeBSD等。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"通过GNU项目，许多重要的开源软件和工具得以发展和推广，为开源社区做出了重要贡献。GCC作为GNU项目的一部分，是其中最受欢迎和广泛使用的组件之一。它提供了强大的编译能力，支持多种编程语言，并在开发者社区中广泛使用。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"总结起来，GNU是一个自由软件项目，旨在为用户提供自由、开放和用户可控的软件。GCC作为GNU项目的一部分，是一个功能强大且广泛使用的编译器套件，为开发者提供了可靠和高效的编译工具。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/#最后还是补充一下编译器、连接器、调试器、集成开发环境的概述及其相互关系","page":"Windows下安装gcc编译器和CLion","title":"最后还是补充一下编译器、连接器、调试器、集成开发环境的概述及其相互关系","text":"","category":"section"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"当进行软件开发时，以下是对编译器、连接器、调试器和集成开发环境（IDE）的概述及其相互关系的补充：","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"编译器： 编译器是一种将高级编程语言（如C、C++、Java等）编写的源代码转换为机器可执行代码（二进制文件）的工具。它负责将源代码进行词法分析、语法分析、优化和代码生成等步骤，最终生成可供计算机执行的可执行文件。\n连接器： 连接器（或链接器）是将编译后的目标文件（由编译器生成）和其他所需的库文件合并在一起，形成最终的可执行文件的工具。连接器负责解析和解决代码中的符号引用，将不同模块之间的代码进行链接，并处理动态链接库等外部依赖。\n调试器： 调试器是一种开发工具，用于帮助开发者识别和修复程序中的错误（bug）。它提供了诸如断点设置、变量查看、单步执行等功能，允许开发者逐行或逐语句地执行程序，并检查其状态以进行调试和排除故障。\n集成开发环境（IDE）： 集成开发环境是一个综合的开发工具，集成了编译器、连接器、调试器以及其他辅助开发工具。IDE提供了一个统一的界面，使开发者能够在一个环境中进行代码编写、编译、调试和测试等开发活动。它通常具有代码编辑器、项目管理、自动完成、调试器集成和构建系统等功能。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"这些工具之间存在着紧密的关联和相互依赖关系。编译器将源代码转换为目标文件，连接器将目标文件和库文件链接为可执行文件，而调试器允许开发者在执行过程中检查和修改代码。IDE则集成了这些工具，并提供了一个方便的开发环境，使开发者能够在一个界面中进行代码编写、编译、调试和测试等开发活动。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"使用IDE可以极大地提高开发效率，因为它们提供了许多辅助功能，如自动代码完成、语法检查、版本控制集成等。此外，IDE还提供了项目管理和构建系统，使开发者能够更好地组织和管理他们的代码。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"总结起来，编译器、连接器、调试器和集成开发环境是软件开发中常用的工具和环境。编译器将源代码转换为可执行文件，","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"连接器将目标文件链接为最终的可执行文件，调试器帮助开发者进行代码调试和故障排除，而IDE集成了这些工具，并提供了一个便捷的开发环境。这些工具相互协作，使开发者能够更轻松地编写、构建和调试他们的代码。","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/#视频地址","page":"Windows下安装gcc编译器和CLion","title":"视频地址","text":"","category":"section"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"msys2安装","category":"page"},{"location":"CSBase/4-Windows下安装gcc编译器和CLion/","page":"Windows下安装gcc编译器和CLion","title":"Windows下安装gcc编译器和CLion","text":"CLion安装及Fortran插件设置","category":"page"},{"location":"AIandML/1-机器学习和人工智能/#机器学习","page":"机器学习","title":"机器学习","text":"","category":"section"},{"location":"AIandML/1-机器学习和人工智能/#机器学习范围","page":"机器学习","title":"机器学习范围","text":"","category":"section"},{"location":"AIandML/1-机器学习和人工智能/#神经网络","page":"机器学习","title":"神经网络","text":"","category":"section"},{"location":"AIandML/1-机器学习和人工智能/#深度神经网络","page":"机器学习","title":"深度神经网络","text":"","category":"section"},{"location":"AIandML/1-机器学习和人工智能/#强化学习","page":"机器学习","title":"强化学习","text":"","category":"section"},{"location":"AIandML/1-机器学习和人工智能/#统计学习","page":"机器学习","title":"统计学习","text":"","category":"section"},{"location":"AIandML/1-机器学习和人工智能/#CNN-RNN-LSTM","page":"机器学习","title":"CNN RNN LSTM","text":"","category":"section"},{"location":"AIandML/1-机器学习和人工智能/#一层又一层抽象（手动实现一个神经网络来理解）","page":"机器学习","title":"一层又一层抽象（手动实现一个神经网络来理解）","text":"","category":"section"},{"location":"Modeling/MTK_tips/#MTK常见问题","page":"MTK常见问题","title":"MTK常见问题","text":"","category":"section"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"tip: Tip\nContents：建模、MTK、外部函数Contributor: YYBEmail: 812987139@qq.com如有错误，请批评指正。","category":"page"},{"location":"Modeling/MTK_tips/#UndefVarError","page":"MTK常见问题","title":"UndefVarError","text":"","category":"section"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"目前官方在此方面可能有bug，可以关注模型边界条件尝试避开问题","category":"page"},{"location":"Modeling/MTK_tips/#key-not-found","page":"MTK常见问题","title":"key not found","text":"","category":"section"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"在structural_simplify后，有些等式条件会自动微分，导致变量数没变，但是方程增加，进而导致模型不平衡","category":"page"},{"location":"Modeling/MTK_tips/#xxx-are-missing-from-variables-map","page":"MTK常见问题","title":"xxx are missing from variables map","text":"","category":"section"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"可能是初值没有设置。建议所有模型均设置初值，动态模型初值直接输入至defaults参数。","category":"page"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"@connector function flowPortNode(; name)\n    #通流元件节点，在热力学节点上包装了体积、质量流量 \n    #如果同时需要标记connect类型，还要赋值，那么一定要括起来\n    #initialValue写作Dict或者数组都可以\n    sts = @variables begin\n        p(t)\n        T(t)\n        (qm(t), [connect = Flow])\n        (rho(t), [connect = Stream])\n        (mu(t), [connect = Stream])\n        (qv(t), [connect = Stream])\n    end\n    initialValue = [\n        p => 1.013e5\n        T => 300\n        qm => 0\n        rho => 1.2\n        mu => 1.819e-5\n        qv => 0\n    ]\n    eqs = [\n        0 ~ stateEquation(p, rho, T)\n        mu ~ 1.819e-5\n        #qm ~ rho * qv\n        qv ~ qm / rho\n    ]\n    ODESystem(eqs, t, sts, []; name=name, defaults=initialValue)\nend","category":"page"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"在生成问题前再统一传入初值。","category":"page"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"u01 = [\n    d_temp => 0\n]\n\na = ModelingToolkit.defaults(sys1)\nfor i in keys(a)\n    global u01\n    u01 = [u01; i => a[i]]\nend","category":"page"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"该问题的产生原因与DAE问题的求解算法有关。将DAE问题降指数为ODE问题后，模型可能需要更多的初始条件作为输入。","category":"page"},{"location":"Control/MTKMPC/#MTK求解MPC问题","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"","category":"section"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"tip: Tip\nContents：MTK、ControlContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"note: Note\nMPC = Model Predict ControlMTK = ModelingToolkit.jlOptimizationSystem为MTK中的系统类型之一","category":"page"},{"location":"Control/MTKMPC/#MTK中的ControlSystem","page":"MTK求解MPC问题","title":"MTK中的ControlSystem","text":"","category":"section"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"在ModellingToolkit的Optimal Control中，有关于ControlSystem的描述。但经过实验测试，ControlSystem并不能很好地求解“过程控制量”的值。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"因为MTK使用rungekuttadiscretize（龙格库塔离散）函数将问题离散。问题离散后，传入OptimizationSystem，而OptimizationSystem目前有一个缺陷——不能接受问题的约束。所以，即使用龙格库塔离散离散出控制过程中的多个状态量，在变量没有约束时，优化结果没有意义。（离散的概念在微分方程参数辨识中有提及） 在实例过后，这一点会有清晰的体现。","category":"page"},{"location":"Control/MTKMPC/#MTK中的OptimizationSystem","page":"MTK求解MPC问题","title":"MTK中的OptimizationSystem","text":"","category":"section"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"为了简单起见，手动构建一个MPC优化问题，通过OptimizationSystem来求解。通过构建优化目标方程，调用不同优化器求解该优化问题。那么从控制问题到优化问题这一过程可以看成是手动离散。相当于自己实现了rungekuttadiscretize。构建完优化问题，就可以直接把它推给OptimizationProblem求解，这是可以做到的。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"上述过程的核心就是把控制中的状态量手写出来。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"可行的做法是，通过MTK符号建模体系建立优化变量，同时构建Loss方程关于优化变量的符号表达。通过OptimizationSystem生成用符号体系构建的优化问题，把构建的OptimizationSystem推给OptimizationProblem，最后选择合适的求解器求解。","category":"page"},{"location":"Control/MTKMPC/#实例：加热器问题","page":"MTK求解MPC问题","title":"实例：加热器问题","text":"","category":"section"},{"location":"Control/MTKMPC/#问题描述","page":"MTK求解MPC问题","title":"问题描述","text":"","category":"section"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"现在有一个物体加热，它的温度由加热项和散热项决定。α是散热系数，β是加热系数，环境温度为T_out。那么控制方程: ","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"T = α*(T_out - T) + β*Q(t)","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"现在可以改变加热功率，那么我们构建一个优化问题：调节加热功率，使得物体的温度从T_0开始，迅速上升并且稳定在某一个温度（比如说58℃）。问题的数学表达为，通过优化控制变量Q(t) 使得损失函数最小:","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"Loss = sum_i 580-T(t_i)","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"而Q(t_i)就是未来一段时间域内，不同时间点上的控制量（控制科学中称为状态量）。通过改变这些值，能够控制温度的走势，这是控制的内涵。若使温度达到一个让人满意的状态（这里是维持在58℃，也可以是使温度线性上升等等），这是最优控制的内涵。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"所以，最优控制或者模型预测控制最根本的数学内涵是优化——多变量优化。这也是为什么能用OptimizationProblem来处理控制问题。","category":"page"},{"location":"Control/MTKMPC/#构建问题","page":"MTK求解MPC问题","title":"构建问题","text":"","category":"section"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"首先明确问题。现在假设以一个恒定功率（p=80）加热物体，环境温度18℃，初始温度20℃,散热系数α = 0.2,加热系数β = 0.1。先求解该问题。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"using Plots,DifferentialEquations\nTout = 18.0\nα = 0.2\nβ = 0.1\nf(x,p,t) = α*(Tout - x) + β*p\ntspan=(0.0,40.0)\nu0 = 20.0\np = 80.0\npr = ODEProblem(f,u0,tspan,p)\nsol = solve(pr)\nplot(sol,ylimit=(10,60))","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"得到的结果是： (Image: 图 1)  ","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"很清晰可以看到，温度缓慢上升最后稳定在58℃。那么作为我们拍脑袋的控制策略来说，这个控制问题很简单。我们可以先让功率在前期比较大（比如说150），等温度到了58℃附近，再把功率调回80，就可以实现“温度迅速上升并最后稳定在58度”。","category":"page"},{"location":"Control/MTKMPC/#优化求解","page":"MTK求解MPC问题","title":"优化求解","text":"","category":"section"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"using Symbolics,ModelingToolkit,GalacticOptim,Optim\nN = 20\nTout = 18.0\nT0 = 20.0\ndt = 4/N\nLoss = 0.0\nT = T0\nα = 0.2\nβ = 0.1\n@variables u[1:N]\nfor i = 1:N\n    global T = T + (α*(Tout - T) + β*u[i])*dt\n    global Loss += (T - 58.0)^2\nend","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"u是符号量，离散的个数为N，上面选择离散为20个变量。通过一个for循环，就可以迭代求解20个点上的温度值并且构建Loss方程。这里的20个变量，就是控制的核心，通过改变这20个不同时间点上的控制量（加热功率）的值，使得被控量（温度）接近“更好、更快”地接近目标——58℃。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"可以看到Loss方程的结果：","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"(Image: 图 2)  ","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"有些许复杂，但在情理之中。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"@named sys = OptimizationSystem(Loss,[u[i] for i in 1:N],[],inequality_constraints=inequ)\nu0 = [u[i] => 1.0 for i in 1:N]\nlb = [0.0 for i in 1:N]\nub = [200.0 for i in 1:N]\nprob = OptimizationProblem(sys,u0,[],lb = lb,ub = ub,grad=true,hess=true)\ns = solve(prob,Optim.LBFGS())","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"然后构建System和OptimizationProblem，给定上下限。这里功率上限设为200，最后求解！","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"结果为：","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"u: 20-element Vector{Float64}:\n 199.99999999999997\n 199.99999999999997\n 199.99999999999997\n 199.99999999999997\n 199.99999999999997\n 199.99999999999997\n 199.99999999999997\n 199.99999999999994\n 199.99999999999991\n 199.9999999999999\n 199.99999999999957\n 199.99999999996504\n  82.18673442597857\n  79.99995550035416\n  80.0000502201614\n  79.99991729083732\n  80.00001272875645\n  80.00004827285969\n  79.99999940246633\n  79.99997217751334","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"(Image: 图 3)  ","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"应该说是非常理想的。和我们设想的一样。先以最大功率加热到58℃附近，然后迅速将到稳态维持58℃的功率80，这样2s就完成了控制过程，而之前以恒定功率80加热，耗费了20s!","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"从图中可以很容易看出局限性，加热功率先猛加，以最高限度200直接加热到58，然后功率在恒定在80维持恒温58摄氏度。这种直上直下的调节，很显然不那么让人满意。可以想象，假如不给变量设置上下限，那么优化的结果一定是：第一个离散的变量加热功率上万，相当于在一瞬间使用超大且精准的功率把温度加到58摄氏度。第二个往后的状态量为80——维持恒温58摄氏度的加热功率。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"这在数学上是合理的，在实际中却没有意义。所以在控制中一般需要加一些约束，比如加热功率上下限、加热功率变化幅度。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"所以，为了处理约束，可以使用JuMP来做MPC。","category":"page"},{"location":"WorkFlow/DocStructure/#文档（docs）编写方法","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"","category":"section"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"tip: Tip\nContents：文档编写方法介绍Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"WorkFlow/DocStructure/#文档结构","page":"文档（docs）编写方法","title":"文档结构","text":"","category":"section"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"在包的根目录下，都有一个/docs文件夹，里面就是文档的所有内容。","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"/docs结构如下：","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"docs/\n├── src/\n│   ├── index.md\n│   ├── components/   \n│   │   ├──MTKMPC.md\n│   │   └──...\n│   └── MyApp.jl\n├── build/\n│   ├── index.html\n│   └── ...\n├── .gitignore\n├── Project.toml\n└── make.jl","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"/src里包含了文档的内容，即很多markdown文件。对应关系如下：","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"(Image: 图 1)  ","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":".gitignore里的内容是在git提交时忽略的内容。例如/build的内容就会全部忽略。","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"Project.toml是julia的环境文件，说明了docs环境中需要用到的包。","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"make.jl是生成的html页面的主文件。运行make.jl，则生成/build文件夹，在默认浏览器中打开/build/index.html就能看到文档，和网页版的一模一样。本质上也是一样的，Github部署也是部署的它。这是本地版，github提交时，会自动运行make.jl生成然后部署。所以/build不用上传。","category":"page"},{"location":"WorkFlow/DocStructure/#编写方法","page":"文档（docs）编写方法","title":"编写方法","text":"","category":"section"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"新添加文档只需要两步操作：","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"创建新的文档(.md文件)\n在make.jl中链接文档路径","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"make.jl中的page链接了全部文档。 (Image: 图 2)  ","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"图中的\"Modeling\"是子目录，在/src里可看到对应文件夹。","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"如果没有在make.jl中链接，就不会在html中显示。没链接等于没写🤣🤣🤣。","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"note: Note\n某些库会设计自动链接，如果自动链接了就不需要手动添加了。","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/#Julia换源(更换国内镜像站)","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"","category":"section"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"tip: Tip\nContents：JuliaPkgContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"打开julia的安装路径，找到文件夹 julia-1.x.x(如1.6.1) 如图","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"进入该文件夹找到etc","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"进入etc 再进入一个文件夹，有一个startup.jl","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"这个startup.jl就很方便了，在启动julia的时候，会首先自动运行里面的内容。","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"所以，打开它，在里面输入一行","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"ENV[\"JULIA_PKG_SERVER\"]=\"https://mirrors.pku.edu.cn/julia/\"","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"就像这样 (Image: 在这里插入图片描述) 保存就完事了。","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"ENV是julia的全局环境变量，能够直接在repl中修改环境变量，但不是永久的。所以放在startup.jl里。这样等价于永久改变了，因为每次启动都会repl自动执行它。","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"在repl中输入ENV如下： (Image: 在这里插入图片描述)","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"还有一些其它的比如LOADPATH 和DEPOTPATH等等，这些都是环境变量。更多可以看中文文档 (Image: 在这里插入图片描述)","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"PS: 不换也行，最新版的julia好像能自动选取一个最快的源。","category":"page"},{"location":"WorkFlow/vscodePlugin/#VScode开发环境配置","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"","category":"section"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"tip: Tip\nContents：VScode插件介绍Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"WorkFlow/vscodePlugin/#插件位置","page":"VScode开发环境配置","title":"插件位置","text":"","category":"section"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"打开插件面板，并搜索。","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 13)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/#Julia","page":"VScode开发环境配置","title":"Julia","text":"","category":"section"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"Julia官方出的Julia插件","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 1) ","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"Shift+Enter可以运行单行代码","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"Tab键补全代码","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"如：","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: )","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"体验和jupyter类似。","category":"page"},{"location":"WorkFlow/vscodePlugin/#Mardown","page":"VScode开发环境配置","title":"Mardown","text":"","category":"section"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"轻量级标记语言，文档编写必备，教程官方。","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"推荐这个3个插件，都装。","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 2)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 11)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 3)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"点击预览打开markdown预览。","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 4)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"右键 可导出PDF文件，很方便。","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 6)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/#markdown辅助贴图插件","page":"VScode开发环境配置","title":"markdown辅助贴图插件","text":"","category":"section"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 7)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"设置该扩展的图片粘贴位置，如果是Ai4E的相关开发，文档中图片的路径一般为：/docs/src/assets","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 10)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"随后右键，选择粘贴图片，自动生成markdown的图片插入语法。很方便！","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 9)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/#语言插件","page":"VScode开发环境配置","title":"语言插件","text":"","category":"section"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 12)  ","category":"page"},{"location":"Modeling/WathMTKdo/#MTK的\"前世今生\"","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"","category":"section"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"tip: Tip\nContents：建模、MTK、SymbolicsContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"note: Note\nMTK = ModelingToolkit.jlSymbolics.jl为MTK依赖的符号计算包ModelingToolkit.jl为基于符号系统的建模工具包。DifferentialEquations.jl为处理时间微分的求解建模工具包。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"MTK似乎很强大，本篇介绍MTK在建模中承担的角色。","category":"page"},{"location":"Modeling/WathMTKdo/#模块化思想","page":"MTK的\"前世今生\"","title":"模块化思想","text":"","category":"section"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"首先，我们聊一聊程序设计中的模块化思想。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"个人认为，模块化其实不单单是一种软件设计的思想。毫不夸张地说，模块化也是一种组织与架构的哲学。模块化的含义可以用一个词语概括——各司其职。若是在软件开发中，需要加上一个限定词——精细化。即，精细化的各司其职。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"模块化解决问题的核心在于，把问题分成若干个部分，每个部分由特定的对象完成。当每个对象的任务都完成之后，问题也就解决了。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"从软件开发到社会的组织架构，都由模块化的影子。课程的小组合作，每个人负责一个小部分；上市公司分为市场部、研发部、财务部...。那么在程序中，这些模块的“对象”就是函数。每个函数完成各的任务，当全部执行完成之后，问题解决了。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"例如，有一个变量var。问题是：计算10 * var + var * var + 1的结果。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"对于这样一个问题，我们习惯于直接把表达式输入得到结果：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"result = 10 * var + var * var + 1","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"但采用模块化的思想，不会这么做。模块化会把这个活分给三个函数去做——乘法函数、平方函数、求和函数。当这个三个函数完成了各自的事情之后，问题解决了。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"function mult(a,b)\n    return a * b\nend\nfunction square(a)\n    return a * a\nend\nfunction sum(a...)\n    s = 0\n    for i in 1:length(a)\n        s += a[i]\n    end\n    return s\nend\nresult = sum(mult(10,var),square(var),1) ","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"当然，对于这样一个问题非要用模块化思想那是闲的。若是针对一个复杂的系统，没有人能完成所有细节的解决方案，那么模块化思想就会变得尤为重要。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"主要有两个方面的好处：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"从自上而下的角度。作为上层的调用者，不需要关心底层函数怎样解决问题。只需要知道，传递什么数据能获得什么结果。这对于复杂问题的解决非常重要。大问题分为几个小问题，小问题再分为更小的问题。作为架构师只需要关心核心部分的拆解即可。这是高效的“各司其职”。\n从自下而上的角度。把问题细分到不能再分，那么其会具有解决任何问题的潜力。什么意思呢？如果把一个表达式作为一个整体求解，这是完全没有问题的。但如果把一个表达式拆解成四则运算分别求解，就如上面的例子。由该问题设计的四则运算函数，对它们进行合理组合能够解决任何一个求解表达式问题。孰高孰低，立见高下。也可以说，模块化后的解决方案具有普适性，解决了复杂问题中的基本共性问题（足够细分的情况下）。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"所以在软件设计领域，有这样一种说法——每一个函数编写时只需要解决一个很小的问题。","category":"page"},{"location":"Modeling/WathMTKdo/#MTK在建模仿真中的角色","page":"MTK的\"前世今生\"","title":"MTK在建模仿真中的角色","text":"","category":"section"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"在DifferentialEquations建模方法从发现问题到获得计算结果，在现代计算科学中一般分为两步：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"把问题抽象可量化、可处理的数学问题\n把数学问题设计成可用计算机处理与计算的可计算问题","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"进一步细分有：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"抽象问题\n符号建模\n模型化简\n生成迭代格式\n迭代求解","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"毫无疑问，第一步由人来完成。剩下的步骤可以由MTK完成。那么新的问题在于，从2-5是否全由MTK从零开始构建呢？答案是否定的！","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"实际上，在建模仿真这样的大问题中，仍然是模块化的思想。具体的分工如下：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"Symbolics.jl：负责符号运算\nModelingToolkit.jl：负责模型化简，生成迭代格式\nDifferentialEquations.jl：负责求解","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"ModelingToolkit的核心在于各种System，System作为一种数据结构，本质是存储的是变量以及由变量构成的方程。而变量的定义与方程的定义由Symbolics完成。所以说，Symbolics是符号计算的基石，MTK在Symbolics的基础之上进一步处理方程与变量，处理成DE能够求解的形式，传递给DE计算。最终得到结果。它们三者的关系如图：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"(Image: 图 6)  ","category":"page"},{"location":"Modeling/WathMTKdo/#Symbolics实例","page":"MTK的\"前世今生\"","title":"Symbolics实例","text":"","category":"section"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"符号定义：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"@variables t α σ(..) β[1:2]\n@variables w(..) x(t) y z(t, α, x)\n@variables A[1:5, 1:3] b[1:3]","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"方程定义：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"using Symbolics\n\n@variables x y;\n@variables A[1:3, 1:3] B[1:3, 1:3];\nx ~ y\nx - y ~ 0\nA ~ B\nA .~ 3x","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"微分运算：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"@variables t\nD = Differential(t)\nz = t + t^2\nD(z)\nexpand_derivatives(D(z)) ","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"化简与符号赋值：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"B = simplify.([t + t^2 + t + t^2  2t + 4t\n               x + y + y + 2t     x^2 - x^2 + y^2])\nsimplify.(substitute.(B, (Dict(x => y^2),)))","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"还有计算雅可比矩阵、函数符号化等等符号计算的内容可查看官方文档。","category":"page"},{"location":"Modeling/WathMTKdo/#小结与启示","page":"MTK的\"前世今生\"","title":"小结与启示","text":"","category":"section"},{"location":"Modeling/WathMTKdo/#启示：文档查询","page":"MTK的\"前世今生\"","title":"启示：文档查询","text":"","category":"section"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"从模块化的角度看待MTK，我们就能知道。MTK能做什么与不能做什么。又或者说，遇到了问题，应该找谁。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"问题类型一：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"符号数组应该如何使用与计算？\nRegister如何使用？\n如何批量处理符号？","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"这样的问题应该去看Symbolics.jl的文档。因为MTK就是在它的基础上构建的。它不支持的，MTK也没办法使用。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"问题类型二：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"求解的结果如何处理？\n如何确定精度？\nCallback如何使用？","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"这样的问题应该去看DifferentialEquations.jl的文档。因为真正的求解工作是DE完成的。solution的结果也从DE中来（MTK会提供关于符号与solution的接口，但DE中solution handling能用的功能，MTK中也一定能用）。","category":"page"},{"location":"Modeling/WathMTKdo/#启示：函数使用","page":"MTK的\"前世今生\"","title":"启示：函数使用","text":"","category":"section"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"在MTK文档没有写上的功能，但DE与Symbolics的文档中有。一般而言都能使用。例如，符号数组的矩阵运算，MTK中一定能用（某些特殊功能不一定）。DE中关于Problem类型的一些参数调用，MTK也可以使用。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"每个包有每个包的特性，包与包之间的依赖关系不是功能的交集，而是功能的并集。底层依赖包的功能在上层调用包一般都能使用。只要有了这一点认识。就能够将SCIML生态的功能充分利用起来。这是贯通的其生态的关键。","category":"page"},{"location":"Simulation/steadyRC/#MTK稳态系统仿真实例","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"","category":"section"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"tip: Tip\nContents：MTK、组件化建模Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"note: Note\nMTK = ModelingToolkit.jlModelingToolkit.jl Acausal Component-Based Modeling the RC Circuit介绍了组件化建模的例子","category":"page"},{"location":"Simulation/steadyRC/#动态与瞬态","page":"MTK稳态系统仿真实例","title":"动态与瞬态","text":"","category":"section"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"从内涵来说，稳态问题是动态问题的子集。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"对于稳态动态问题，当微分代数方程中对时间项的微分为0时，则由动态问题过渡为稳态问题。也就是说，稳态问题是动态问题的特殊形式，动态问题是问题的一般形式。微分在实际中代表着“变化”，当该“变化”项为0时，意味着“变化”停止，此时则进入了稳态阶段。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"例如，对于这样一个问题：","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"fracdxdt = 1-xx_0=0","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"从物理演化的角度看，初始时刻，x的变化率为1，x将会不断增大。系统发展到最后，当x增大到1的时候。fracdxdt=0，此时此刻变化就停止了。所以x将进入稳态，即x=1。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"这是因为，从物理的角度理解，微分代表一种变化趋势！上述方程的走势如下图，与分析的情况一致。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"(Image: 图 1)  ","category":"page"},{"location":"Simulation/steadyRC/#MTK的稳态求解技巧","page":"MTK稳态系统仿真实例","title":"MTK的稳态求解技巧","text":"","category":"section"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"求解以下稳态电路问题：","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"(Image: 图 4)  ","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"该问题的电路状态是确定值，不随时间而改变。而DE和MTK处理的是关于时间的微分方程，单纯的代数方程无法求解。对于这样稳态问题，应该怎样求解呢？","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"这里主要运用一个技巧——设定一个变化为0的量加入到方程中。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"什么意思呢？问题必须含有关于时间微分的微分方程，在这一基础之上，让fracdxdt=0不就实现了一种稳态么?x可以代表任何变量，电阻值、电源电压值、电流源值等等。于是，微分变为一种形式，只是让问题能够被求解器求解，对于问题的内涵并没有任何改变。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"@MTK版本：8.5.5","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"using ModelingToolkit, Plots, DifferentialEquations\n\n@variables t\n@connector function Pin(; name)\n    sts = @variables v(t) = 1.0 i(t) = 1.0 [connect = Flow]\n    ODESystem(Equation[], t, sts, []; name=name)\nend\n\nfunction Ground(; name)\n    @named g = Pin()\n    eqs = [g.v ~ 0]\n    compose(ODESystem(eqs, t, [], []; name=name), g)\nend\n\nfunction GroundDIFF(; name)\n    @named g = Pin()\n    sts = @variables v(t)\n    D = Differential(t)\n    eqs = [\n        g.v ~ 0,\n        D(v) ~ 0\n    ]\n    compose(ODESystem(eqs, t, sts, []; name=name), g)\nend\n\nfunction OnePort(; name)\n    @named p = Pin()\n    @named n = Pin()\n    sts = @variables v(t) = 1.0 i(t) = 1.0\n    eqs = [\n        v ~ p.v - n.v\n        0 ~ p.i + n.i\n        i ~ p.i\n    ]\n    compose(ODESystem(eqs, t, sts, []; name=name), p, n)\nend\n\nfunction Resistor(; name, R=1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters R = R\n    eqs = [\n        v ~ i * R\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction ConstantVoltage(; name, V=1.0)\n    @named oneport = OnePort()\n    @unpack v = oneport\n    ps = @parameters V = V\n    eqs = [\n        V ~ v\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction ConstantCurrent(; name, I=1.0)\n    @named oneport = OnePort()\n    @unpack i = oneport\n    ps = @parameters I = I\n    # D = Differential(t)\n    eqs = [\n        i ~ I\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\n\n@named resistor1 = Resistor(R=5.0)\n@named resistor2 = Resistor(R=5.0)\n@named resistor3 = Resistor(R=30.0)\n@named resistor4 = Resistor(R=20.0)\n@named Isource = ConstantCurrent()\n@named Vsource1 = ConstantVoltage(V=30.0)\n@named Vsource2 = ConstantVoltage(V=5.0)\n@named ground = GroundDIFF()\n\n\nrc_eqs = [\n    connect(Vsource1.p, resistor1.p)\n    connect(resistor1.n, resistor2.p, Isource.p)\n    connect(resistor2.n, resistor3.p, resistor4.p)\n    connect(resistor4.n, Isource.n, Vsource2.p)\n    connect(Vsource1.n, Vsource2.n, resistor3.n, ground.g)\n]\n\n@named _rc_model = ODESystem(rc_eqs, t)\n@named rc_model = compose(_rc_model,\n    [resistor1, resistor2, resistor3, resistor4,\n        Isource, Vsource1, Vsource2, ground])\n\nsys = structural_simplify(rc_model)\n\nusing Plots\n\nu0 = [\n    ground.v => 0.0\n]\nprob = ODAEProblem(sys, u0, (0, 10.0))\nsol = solve(prob, Tsit5())\nobserved(sys)\nplot(sol[resistor4.n.i])\n","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"代码中的关键在于函数GroundDIFF()，这个函数中添加的微分项为电势变化为0，即","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"fracdVdt=0","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"并且这个V没有任何意义，既不是接地的电势，也没有和电路中的任何变量产生关联。它只是为了让问题能够被求解而存在。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"最后求解的结果为：","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"(Image: 图 1)  ","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"可以看到，求解的结果在时间轴上是不变的。随然问题看似是一个动态问题，本质上其实是稳态。因为其没有任何改变，时间轴上的任何状态与其前后状态都一样。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"思想的核心其实就是——稳态是动态的一个子集，当动态过程中状态不再改变则进入稳态。这里不过是将问题设置为状态不发生变化的动态，其本质就是稳态。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"tip: Tip\n稳态电路本质是代数方程组，若加上了微分方程，则变成了微分代数方程组。代码中定义的问题是ODAEProblem而不是ODEProblem。DE只有求解微分代数方程的接口而没有求解代数方程的接口。所以需要构造成微分代数问题。","category":"page"},{"location":"Modeling/MTK_intro/#ModelingToolkit建模方法","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"","category":"section"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"tip: Tip\nContents：建模、MTKContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"note: Note\nMTK = ModelingToolkit.jlModelingToolkit.jl为基于符号系统的建模工具包。MTK-Version:8.5 及以上","category":"page"},{"location":"Modeling/MTK_intro/#符号计算内涵","page":"ModelingToolkit建模方法","title":"符号计算内涵","text":"","category":"section"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"符号计算的内涵很简单，其本质就是处理、简化方程的未知数。例如: (x+y)z = xy + yz 又例如: $\\frac{dy}{dt} = 2t => y = t^2 + C $ 它们本质上都是数学符号的推演，而没有涉及到数字的计算。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"一般的情况下，可以计算问题都是人为地把计算推演到数字计算的层面，中间的符号推演、化简的过程都不由计算机处理。随着计算机能力的日益强大，以及计算理论的发展。计算机也能开始进行符号计算。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"例如，(x+y)z = xy + yz就完全能由计算机计算并得到结果。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"MTK，就是这样一种符号计算包。在DE中，我们构建的是方程（function），通过方程来建立模型。而在MTK中，我们构建的是符号，通过符号建立模型。","category":"page"},{"location":"Modeling/MTK_intro/#MTK符号计算实例","page":"ModelingToolkit建模方法","title":"MTK符号计算实例","text":"","category":"section"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"考虑洛伦兹方程：","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"fracdxdt  = sigma(y-x)  fracdydt  = x(rho-z)-y  fracdzdt = xy - beta z","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"通过MTK构建：","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"using ModelingToolkit\nusing DifferentialEquations\n\n@variables t u(t)[1:3]\n@parameters p[1:3]\n\nD = Differential(t)\neqs =[\n    D(u[1]) ~ p[1]*(u[2]-u[1])\n    D(u[2]) ~ u[1]*(p[2]-u[3]) - u[2]\n    D(u[3]) ~ u[1]*u[2] - p[3]*u[3]\n]\n@named Sys = ODESystem(eqs)","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"其中：","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"t是时间变量\nu是关于时间的依赖变量向量\n参数向量p\n微分符号D\neqs本质是一个描述符号方程的数组","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"@variables定义了符号变量，@parameters p[1:3]定义了参数。方程由ODESystem结构体储存，可以看到其中描述“=”的符号为“~”。这些表明，上述代码在处理符号，这是一套符号描述体系！","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"因为是处理符号时，当然也可以更加具象，将符号定义为xyz","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"using ModelingToolkit\nusing DifferentialEquations\n\n@variables t x(t) y(t) z(t)\n@parameters  σ ρ β\nD = Differential(t)\neqs =[\n    D(x) ~ σ*(y-x)\n    D(y) ~ x*(ρ-z) - y\n    D(z) ~ x*y - β*z\n]\n@named sys = ODESystem(eqs)","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"由于符号运算的展现形式更加贴近自然语言，我们几乎可以不加处理地建立与原数学方程几乎一样的符号方程描述，这是符号计算的优势之一。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"在明确MTK的系统构建之后，与DifferentialEquations一样，最后需要明确定义的问题以及初值等要素。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"tspan = (0.0,100.0)\nu0 =[\n    x => 1.0\n    y => 0.0\n    z => 0.0\n]\np=[\n    σ => 10.0\n    ρ => 28.0\n    β => 8/3\n]\nprob = ODEProblem(sys,u0,tspan,p)\nsol = solve(prob,Tsit5())","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"与DE不同是，MTK传值时需要指定具体变量（参数的值）。 最后能得到与DE计算同样的结果。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"全部代码：","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"using ModelingToolkit\nusing DifferentialEquations\n@variables t x(t) y(t) z(t)\n@parameters  σ ρ β\nD = Differential(t)\neqs =[\n    D(x) ~ σ*(y-x)\n    D(y) ~ x*(ρ-z) - y\n    D(z) ~ x*y - β*z\n]\n@named sys = ODESystem(eqs)\ntspan = (0.0,100.0)\nu0 =[\n    x => 1.0\n    y => 0.0\n    z => 0.0\n]\np=[\n    σ => 10.0\n    ρ => 28.0\n    β => 8/3\n]\nprob = ODEProblem(sys,u0,tspan,p)\nsol = solve(prob,Tsit5())\nusing Plots\nplot(sol, idxs=(x,y,z))","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"","category":"page"},{"location":"Modeling/MTK_intro/#DE与MTK的对比","page":"ModelingToolkit建模方法","title":"DE与MTK的对比","text":"","category":"section"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"同一问题，可用MTK与DE来求解。但它们并不完全等价，异同是客观存在的：","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"不同之处：   ModelingToolkit基于符号体系描述问题，等价于在DifferentialEquations问题描述的上层添加了一层符号系统，通过求解符号系统之后，能得到真正的微分方程问题。\n相同之处：   它们最终得到的问题形式是一样的，比如说最终都会生成ODEProblem，也就是说它们可以通过同一个求解器求解。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"MTK凭借着符号计算，在模型建立时会更加方便，更加友好。符号推演功能相当于减轻了模型构造时的工作量，即在数学模型到计算机可计算的模型这个过程中，计算机又往前前进了一步。所以，MTK从某种程度上来说会比DE好用很多。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"从另一个角度来看，DE是MTK的底层求解器，意味着其比MTK更加直接，速度更快。MTK在DE基础之上构建了符号计算系统，其形式与功能上让人惊叹。但要明白的是，这种提供便捷的符号计算系统是要使用资源的，MTK需要花费更多资源去计算、化简符号。好用意味着大量的资源消耗在用户友好方面，效率高意味着资源消耗在真正的问题解决上。这是软件发展过程中始终存在的矛盾。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"note: Note\n就像Linux与Windows一样。大家在开发环境中都愿意用Windows，但在服务器端都用的是Linux。也像是Python与C之间的矛盾。Python代码易用，但运行效率却远远比不上C代码。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"关于DE与MTK的取舍，根据问题的特性选择即可。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"此外，MTK的符号系统还有更大的妙用，在后面的章节中会逐渐展开。","category":"page"},{"location":"CSAdv/2-数据抽象/#数据抽象","page":"数据抽象","title":"数据抽象","text":"","category":"section"},{"location":"CSAdv/2-数据抽象/","page":"数据抽象","title":"数据抽象","text":"sicp的第2章，我慢慢写","category":"page"},{"location":"EMS/1-能源管理信息系统/#能源管理信息系统","page":"能源管理信息系统","title":"能源管理信息系统","text":"","category":"section"},{"location":"EMS/1-能源管理信息系统/","page":"能源管理信息系统","title":"能源管理信息系统","text":"物联网 微服务 edgex mainflux 云计算 鉴权 大数据 前后端分离","category":"page"},{"location":"WorkFlow/julia-call-c7fortran/#julia调用dll中的函数","page":"julia调用dll中的函数","title":"julia调用dll中的函数","text":"","category":"section"},{"location":"Tools/CoolProp/#CoolProp使用介绍","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"","category":"section"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"tip: Tip\nContents：CoolPropContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"note: Note\nCoolProp为开源物性包。 Unitful.jl为计算单位的包","category":"page"},{"location":"Tools/CoolProp/#CoolProp是什么","page":"CoolProp使用介绍","title":"CoolProp是什么","text":"","category":"section"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"这是一个开源的调用物性包，通过几行代码就可以很容易的调用流体的物性，对于需要进行工程计算的小伙伴很有帮助！因为使用这个包之后，就可以可以省去大量查表的麻烦！","category":"page"},{"location":"Tools/CoolProp/#Python使用CoolProp","page":"CoolProp使用介绍","title":"Python使用CoolProp","text":"","category":"section"},{"location":"Tools/CoolProp/#.CoolProp安装","page":"CoolProp使用介绍","title":"1.CoolProp安装","text":"","category":"section"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"打开cmd命令行，输入","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"pip install CoolProp","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"即可安装完成 (Image: 图1)","category":"page"},{"location":"Tools/CoolProp/#.-使用示例","page":"CoolProp使用介绍","title":"2. 使用示例","text":"","category":"section"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"import CoolProp.CoolProp as CP\n\na = CP.PropsSI('H','P',1.0E6,'T',500,'Water')\n\n#H代表输出的需要查找的参数，H为焓\n#P为压强，T为温度，第二个和第四个参数就是状态\n#这个例子就是查询1MPa气压与500K的温度下，水蒸气的焓（如果是液体的话就是液体性质）\n\nprint(a)\n","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"查询时，输入任意两个参数，就能够查询第三个参数。 具体的属性为可以看下表","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"状态量 参数名称 单位\n比焓 H J/kg\n比熵 S J/mol/K\n压强 P Pa\n温度 T K\n密度 D kg/m^3","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"更多参数，可以查看官网文档。","category":"page"},{"location":"Tools/CoolProp/#Julia使用Coolprop","page":"CoolProp使用介绍","title":"Julia使用Coolprop","text":"","category":"section"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"在2022的2月，Coolprop完成了Julia包的更新。可以直接在Julia中调用，而不需要通过python了！","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"using Pkg\nPkg.add(\"CoolProp\")\n\nusing CoolProp\nPropsSI(\"T\", \"P\", 101325.0, \"Q\", 0.0, \"Water\")\n373.1242958476844","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"在Julia中支持单位处理包——Unitful","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"using CoolProp\nusing Unitful: °C, Pa\n\nPropsSI(\"P\", \"T\", 100°C, \"Q\", 0.0, \"Water\")\n101417.99665788244 Pa","category":"page"},{"location":"Optimization/参数辨识实例_MTK/#MTK非线性参数辨识实例","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"","category":"section"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"tip: Tip\nContents：参数辨识、优化、MTKContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"note: Note\nMTK = ModelingToolkit.jlNLP = NonlinearnProblem，非线性问题OptimizationSystem为MTK中的系统类型之一","category":"page"},{"location":"Optimization/参数辨识实例_MTK/#参数辨识概念","page":"MTK非线性参数辨识实例","title":"参数辨识概念","text":"","category":"section"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"系统中的参数作为优化变量，找到一组参数，使得通过模型计算结果与实际值误差最小，实际值一般为一系列数值。参数辨识本质为回归问题。数学表达如下：","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"y = f(ab)\nmin (y_real - y)^2","category":"page"},{"location":"Optimization/参数辨识实例_MTK/#实例","page":"MTK非线性参数辨识实例","title":"实例","text":"","category":"section"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"考虑下面的模型：","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"y = ax^2+sin(bx)a=15b=08","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"采用生成数据的方法构造真实的数据y_real。 方法为通过模型计算出准确值并加上随机误差。","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"##### 生成真实数据 ####\nx = collect(-1:0.01:1)\nN = length(x)\n# 产生随机误差，范围在-0.1~0.1之间\nrands = rand(-0.1:0.01:0.1, N)\na1 = 1.5\na2 = 0.8\n# 计算y值\ny = @. a1 * x^2 + sin(a2 * x) + rands\n","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"因为测试数据集y_real本身即来自模型，同时添加的扰动范围不大，可以认为数据集的内涵就是模型y = ax^2+sin(bx) 接下来构建问题并且求解：","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"# 计算损失Loss\n@variables para[1:2]\nerrors = @. (para[1] * x^2 + sin(para[2] * x) - y)^2\n\n# 计算方差和，采用均方差亦可\nLoss = sum(errors)\n\n# 构建问题并求解\n@named sys = OptimizationSystem(Loss, [para[i] for i in 1:2], [])\na0 = [0.1,0.1]\nprob = OptimizationProblem(sys, a0, [], grad=true, hess=true, reltol=1e-8, abstol=1e-8)\ns = solve(prob, Optim.Newton())","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"最后的结果为:","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"u: 2-element Vector{Float64}:\n 1.502064883762093\n 0.7908724806965902","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"和我们的真实值a=15b=08比较接近。 优化成功！","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"tip: Tip\n影响优化效果的因素有初值\n生成扰动大小可以尝试修改它们并查看求解效果。","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"全部代码：","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"using ModelingToolkit, OptimizationOptimJL\n\nLoss = 0.0\n#number of samples\nypre = 0\n#y-predict\nx = collect(-1:0.01:1)\nN = length(x)\nrands = rand(-0.1:0.01:0.1, N)\na1 = 1.5\na2 = 0.8\ny = @. a1 * x^2 + sin(a2 * x) + rands\n\n\n@variables para[1:2]\nerrors = @. (para[1] * x^2 + sin(para[2] * x) - y)^2\nLoss = sum(errors)\n\n#Opt\n@named sys = OptimizationSystem(Loss, [para[i] for i in 1:2], [])\na0 = [0.1, 0.1]\nprob = OptimizationProblem(sys, a0, [], grad=true, hess=true, reltol=1e-8, abstol=1e-8)\ns = solve(prob, Optim.Newton())","category":"page"},{"location":"JuliaIntro/8-julia的元编程/#julia的元编程","page":"julia的元编程","title":"julia的元编程","text":"","category":"section"},{"location":"JuliaIntro/8-julia的元编程/#简介","page":"julia的元编程","title":"简介","text":"","category":"section"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"Julia的元编程是其强大功能之一，它允许您在运行时操作和生成代码，以实现自动化、抽象化和灵活性。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"元编程是一种编程技术，它涉及编写能够生成或操作代码的代码。在Julia中，您可以使用元编程来动态创建函数、修改函数的行为、生成优化的代码等。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"以下是一些常见的元编程技术和功能：","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"宏（Macros）： Julia的宏是一种元编程的工具，允许您编写代码来自动展开和转换。通过定义宏，您可以在编译时生成代码，以根据特定的模式或规则转换代码。宏可以帮助您消除重复的代码、增加语言的表达能力，并在一些特定场景下提高性能。\n元类型（Metaprogramming）： 元类型是一种在Julia中操作和查询类型信息的能力。您可以使用元类型来检查和访问类型的属性、函数、字段等。这种能力使您能够在运行时编程，根据类型信息来生成和操作代码。\n表达式操作（Expression Manipulation）： Julia的表达式是一种数据结构，可以表示代码片段。您可以使用表达式操作技术来分析、修改和生成代码。通过操作表达式，您可以创建函数、修改函数体、生成代码片段等。\n代码生成（Code Generation）： 元编程允许您动态生成代码，以便在运行时执行。您可以生成优化的代码，根据特定的参数或条件来生成不同的代码路径，从而提高性能和灵活性。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"通过元编程，您可以根据特定的需求和场景来扩展和定制Julia的行为。它使您能够以更高级别的抽象来编写代码，减少冗余，提高代码的可维护性和可扩展性。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"虽然元编程是一个强大的工具，但也需要谨慎使用，因为复杂的元编程技术可能会增加代码的复杂性和难以理解。因此，建议在需要时使用元编程，并确保代码的可读性和可维护性。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/#Meta.Parse的例子","page":"julia的元编程","title":"Meta.Parse的例子","text":"","category":"section"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"当使用 Julia 的元编程时，可以使用 meta.parse 函数将字符串解析为 Julia 表达式。这样，您可以动态地创建和操作代码。下面是一个示例：","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"# 导入 meta.parse 函数\nusing Meta\n\n# 定义一个字符串表示的 Julia 代码\ncode_str = \"2 + 3\"\n\n# 使用 meta.parse 解析字符串为表达式\ncode_expr = Meta.parse(code_str)\n\n# 打印解析后的表达式\nprintln(code_expr)\n\n# 求值表达式\nresult = eval(code_expr)\n\n# 打印结果\nprintln(result)","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"在这个例子中，我们使用 meta.parse 函数将字符串 \"2 + 3\" 解析为一个 Julia 表达式，并将其赋值给变量 code_expr。然后，我们使用 eval 函数对表达式进行求值，并将结果打印出来。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"运行上述代码，输出如下：","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"2 + 3\n5","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"您可以根据需要动态地生成代码字符串，并使用 meta.parse 解析它们为表达式。这使得您能够以编程的方式生成和执行代码，从而实现更高级别的抽象和自动化。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"请注意，在使用 meta.parse 解析字符串时，请确保字符串中的代码是可信的，以避免潜在的安全风险。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/#Meta.show_sexpr例子","page":"julia的元编程","title":"Meta.show_sexpr例子","text":"","category":"section"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"在 Julia 中，可以使用 Meta.show_sexpr 函数来显示表达式的抽象语法树（Abstract Syntax Tree，AST）。这对于调试和了解代码的结构非常有用。下面是一个示例：","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"# 导入 Meta.show_sexpr 函数\nusing Meta\n\n# 定义一个 Julia 表达式\nexpr = :(2 + 3)\n\n# 使用 Meta.show_sexpr 显示表达式的抽象语法树\nMeta.show_sexpr(expr)","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"在这个示例中，我们使用 Meta.show_sexpr 函数来显示表达式 2 + 3 的抽象语法树。表达式被表示为 :(2 + 3)，它是一个具体的语法结构。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"运行上述代码，输出如下：","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"(:call, :+, 2, 3)","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"输出的结果是一个元组，其中第一个元素 :call 表示函数调用，第二个元素 :+ 表示加法运算符，后面的 2 和 3 是加法的操作数。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"Meta.show_sexpr 函数可以帮助您深入了解代码的结构和组织方式，特别是当您使用元编程和宏时，可以更好地理解代码的转换和展开过程。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/#宏","page":"julia的元编程","title":"宏","text":"","category":"section"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"宏（Macros）是 Julia 中强大的元编程工具，它允许您以编程的方式生成和转换代码。通过定义宏，您可以在编译时操作表达式，并在代码展开阶段对其进行转换。下面是一个简单的宏的例子：","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"# 定义一个简单的宏，将输入的表达式展示出来\nmacro show_expr(expr)\n    println(\"Expression: \", expr)\n    return esc(expr)\nend\n\n# 使用宏\n@show_expr 2 + 3","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"在上面的例子中，我们定义了一个名为 show_expr 的宏。它接受一个表达式作为输入，并将该表达式打印出来。然后，宏返回输入的表达式本身。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"最后，我们使用 @show_expr 宏来展示表达式 2 + 3。宏展开后，会首先打印出 \"Expression: 2 + 3\"，然后返回表达式本身，即 2 + 3。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"运行上述代码，输出如下：","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"Expression: 2 + 3\n5","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"这个例子展示了宏的基本用法。宏可以根据输入的表达式生成自定义的代码，以实现更高级别的抽象和自动化。您可以根据需要定义更复杂的宏，执行更复杂的代码转换。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"请注意，在使用宏时，需要小心处理输入表达式，并确保生成的代码是正确和安全的。了解宏的展开机制和作用域规则非常重要，以避免潜在的错误。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/#使用宏来改变AST","page":"julia的元编程","title":"使用宏来改变AST","text":"","category":"section"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"宏在 Julia 中的一个强大之处是可以操作抽象语法树（AST）来进行代码转换。通过访问和修改 AST，您可以在编译时对代码进行更高级别的转换。下面是一个简单的示例，演示如何使用宏来操作 AST：","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"# 定义一个宏，将表达式中的加法操作替换为乘法操作\nmacro replace_add_with_mul(expr)\n    new_expr = Expr(:call, :*, expr.args...)\n    return new_expr\nend\n\n# 使用宏\n@replace_add_with_mul 2 + 3","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"在上面的例子中，我们定义了一个名为 replace_add_with_mul 的宏。宏接受一个表达式作为输入，并将该表达式中的加法操作替换为乘法操作。宏通过创建一个新的表达式对象 new_expr 来实现替换。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"然后，我们使用 @replace_add_with_mul 宏来转换表达式 2 + 3。宏展开后，将创建一个新的表达式 2 * 3。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"运行上述代码，输出如下：","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"6","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"通过宏操作 AST，我们成功将加法操作替换为乘法操作，并获得了正确的结果。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"这个例子只是展示了宏操作 AST 的基本概念。实际上，您可以编写更复杂的宏来进行更复杂的代码转换和操作。使用 Expr 类型和其他相关函数，您可以访问和修改表达式的不同部分，以实现更灵活和高级的代码转换。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"请注意，在使用宏操作 AST 时，需要小心处理表达式的结构，并确保生成的新表达式是正确的和安全的。对于复杂的代码转换，建议详细了解 Julia 的 AST 结构和相关操作。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/#AST是啥","page":"julia的元编程","title":"AST是啥","text":"","category":"section"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"AST 是抽象语法树（Abstract Syntax Tree）的缩写，是在编译器和解释器中常用的一种数据结构。它表示了程序源代码的抽象语法结构，并以树形结构的形式展现出来。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"在编程语言中，源代码是由一系列语法规则组成的，这些规则定义了程序语法的合法结构和语义。当我们编写代码时，编译器或解释器会将源代码转换为抽象语法树，以便进行后续的分析、优化和执行。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"抽象语法树由节点组成，每个节点代表一个语法结构，比如表达式、语句、函数定义等。节点之间通过父子关系和兄弟关系来表示语法结构之间的层次关系。树的根节点表示整个程序的结构，而叶节点表示最基本的语法单元。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"通过遍历和操作抽象语法树，编译器和解释器可以进行各种操作，例如语法分析、语义分析、代码生成、代码优化等。同时，开发者也可以通过访问和修改抽象语法树来实现自定义的代码转换和元编程。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"在 Julia 中，您可以使用 dump 函数来查看表达式的抽象语法树。下面是一个简单的示例：","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"expr = :(2 + 3)\ndump(expr)","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"运行上述代码，输出如下：","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"Expr\n  head: Symbol call\n  args: Array{Any}((3,))\n    1: Symbol +\n    2: Int64 2\n    3: Int64 3","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"这个例子展示了表达式 2 + 3 的抽象语法树。树的根节点是一个 Expr 对象，其头部是 :call，表示函数调用。args 数组中的元素分别是操作符 :+，以及两个操作数 2 和 3。","category":"page"},{"location":"JuliaIntro/8-julia的元编程/","page":"julia的元编程","title":"julia的元编程","text":"通过理解抽象语法树的结构和节点的含义，您可以更好地理解代码的组织方式，以及在元编程中操作和转换代码的能力。","category":"page"},{"location":"WorkFlow/REPL-of-Julia/#julia-的-REPL","page":"julia 的 REPL","title":"julia 的 REPL","text":"","category":"section"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"命令 julia 为我们提供了一个简易但足够强大的编程环境。这就是 REPL 环境。REPL就是Read-Eval-Print Loop，就是“读取-求值-输出-循环”，也就是julia跟我们打交道的交互式对话界面。我们启动julia后，面对的就是julia的REPL。像Python、Ruby这类现代的动态编程语言大都具备REPL环境。","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"Julia 的 REPL 环境非常有用，尤其是在我们进行试验性编程的时候。我们可以在其中试着执行一些代码片段，并在确认无误之后把这些片段在源码文件中组装起来，形成真正的程序。因此，REPL 环境绝对算得上一个优秀的编程学习助手。","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"在Julia的REPL中共有四种模式，分别是正常（交互）模式、package模式、help模式和shell模式。","category":"page"},{"location":"WorkFlow/REPL-of-Julia/#（1）help模式","page":"julia 的 REPL","title":"（1）help模式","text":"","category":"section"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"在Julia提示符下按“？”键进入help模式，该模式下可用来查询操作用法。","category":"page"},{"location":"WorkFlow/REPL-of-Julia/#（2）shell模式","page":"julia 的 REPL","title":"（2）shell模式","text":"","category":"section"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"在Julia提示符下按“;”键进入shell模式，可以在此模式下执行shell命令。linux下是执行shell命令，windows下则是执行对应的命令提示符下的命令。","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"因此，可以在该模式下使用如下代码，运行该文件夹下的“.jl”文件：","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"julia hello_julia.jl","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"也可以执行如下的代码显示当前目录下的文件列表：","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"pwd","category":"page"},{"location":"WorkFlow/REPL-of-Julia/#（3）package模式","page":"julia 的 REPL","title":"（3）package模式","text":"","category":"section"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"在Julia提示符下按“]”键进入package模式，在该模式下进行安装包和卸载包的操作。此模式是用来管理程序包的。比如，在该模式下输入add <程序包的名称>就可以安装某个新的程序包。又比如，输入update <程序包的名称>就可以更新某个已安装的程序包。还比如，仅输入up并回车就可以更新所有已安装的程序包。输入rm <程序包的名称>则可以删除某个程序包。","category":"page"},{"location":"WorkFlow/REPL-of-Julia/#（4）正常（交互）模式","page":"julia 的 REPL","title":"（4）正常（交互）模式","text":"","category":"section"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"在以上三种模式中，按“backspace”键回到正常模式。julia>是 Julia 的 REPL 环境下的提示符。在这种模式下，我们可以输入 Julia 语言的任何表达式，并让它帮我们计算结果。","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"在正常模式下，我们可以尝试运行一下如下代码看看系统的反应：","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"a = 5 * 8; println(a)","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"也可以使用“Pkg”这个包查看安装使用了哪些包，代码如下：","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"using Pkg\nPkg.status()","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"可以使用以下代码升级安装的库：","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"Pkg.update()","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"使用以下代码查看所在的文件路径，并且切换文件路径","category":"page"},{"location":"WorkFlow/REPL-of-Julia/","page":"julia 的 REPL","title":"julia 的 REPL","text":"pwd()\ncd(\"c:\\\\Users\\\\mingt\\\\Desktop\")","category":"page"},{"location":"IotBigdataCloud/2-消息件/#物联网的消息件","page":"物联网的消息件","title":"物联网的消息件","text":"","category":"section"},{"location":"IotBigdataCloud/2-消息件/#物联网的消息件简介","page":"物联网的消息件","title":"物联网的消息件简介","text":"","category":"section"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"物联网中的消息队列（Message Queue）是一种基于异步通信的机制，用于在物联网系统中传递和处理消息。它起到了解耦和异步处理的作用，将消息的发送者和接收者解耦开来，使它们可以独立进行工作。","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"以下是物联网中消息队列的一些关键特点和作用：","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"异步通信：消息队列实现了异步通信机制，发送者可以将消息发送到队列中，而不需要等待接收者的实时响应。这允许系统中的各个组件以异步的方式进行通信和处理，提高了系统的吞吐量和响应性能。\n解耦：消息队列解耦了发送者和接收者之间的直接依赖关系。发送者只需将消息发送到队列中，而不需要知道消息的接收者是谁。接收者则可以独立地从队列中获取消息并进行处理。这种解耦性使得系统的组件可以灵活地进行扩展和修改，而不会对其他组件产生影响。\n可靠性：消息队列通常提供持久化存储机制，确保即使在消息发送或接收过程中出现故障，消息仍然能够安全存储和传递。这提高了消息的可靠性和系统的稳定性。\n缓冲能力：消息队列充当了缓冲区的作用，可以平衡不同组件之间的速度差异。如果某个组件的处理速度较慢，消息可以在队列中积压，直到该组件准备好处理它们。这样可以避免消息丢失或过载的问题。\n扩展性：通过使用消息队列，系统可以更容易地进行扩展。新的组件可以通过订阅队列来接收消息，并独立处理它们。这种松耦合的设计使得系统更加灵活和可扩展。","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"常见的物联网消息队列协议包括MQTT（Message Queuing Telemetry Transport）和AMQP（Advanced Message Queuing Protocol）。这些协议提供了可靠的消息传递机制和语义，并广泛应用于物联网系统中。","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"总结起来，物联网中的消息队列是一种重要的通信机制，通过解耦、异步和可靠的消息传递，实现了系统的灵活性、扩展性和可靠性。它为物联网系统中的各个组件提供了高效的消息传递和处理能力。","category":"page"},{"location":"IotBigdataCloud/2-消息件/#常用的消息件","page":"物联网的消息件","title":"常用的消息件","text":"","category":"section"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"常用的消息件包括以下几种：","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"RabbitMQ：RabbitMQ是一个开源的消息队列软件，它实现了AMQP（Advanced Message Queuing Protocol）协议。它支持多种编程语言，并提供了可靠的消息传递、消息持久化和灵活的路由等功能。\nApache Kafka：Apache Kafka是一个分布式流处理平台和消息队列系统。它具有高吞吐量、持久性存储和水平扩展等特性。Kafka适用于大规模数据处理和实时流处理场景，提供了可靠的消息传递和持久化存储能力。\nActiveMQ：ActiveMQ是一个开源的消息队列软件，实现了JMS（Java Message Service）规范。它支持多种传输协议和消息模式，并提供了可靠的消息传递、消息持久化和事务支持等功能。\nMQTT（Message Queuing Telemetry Transport）：MQTT是一种轻量级的发布/订阅消息传递协议，特别适用于资源受限的物联网设备。它具有低开销、可靠性和简单性的特点，被广泛应用于物联网中的消息传递和实时数据处理。\nZeroMQ：ZeroMQ是一个开源的高性能消息库，支持多种消息传递模式和传输协议。它提供了简单的消息队列、消息路由和异步通信等功能，适用于构建高性能和可扩展的分布式系统。","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"这些消息件都具有不同的特点和适用场景，可以根据具体的需求选择适合的消息件来实现物联网系统中的消息传递和处理。","category":"page"},{"location":"IotBigdataCloud/2-消息件/#以mqtt为例，来一个发布主题、订阅主题、获得数据、转存数据的例子","page":"物联网的消息件","title":"以mqtt为例，来一个发布主题、订阅主题、获得数据、转存数据的例子","text":"","category":"section"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"我无法直接演示和运行实际的服务器和客户端代码。然而，我可以提供给你一个基本的示例代码，你可以在本地环境中运行它来实现你所描述的功能。","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"首先，你需要安装一个MQTT代理服务器。其中，Eclipse Mosquitto是一个流行的开源MQTT代理服务器，你可以从其官方网站（https://mosquitto.org/）下载并安装。","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"接下来，你可以使用Python语言和paho-mqtt库来编写客户端代码。以下是一个简单的示例：","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"客户端发布主题（publish.py）：","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"import paho.mqtt.publish as publish\n\n# MQTT代理服务器的地址和端口\nbroker = \"mqtt.example.com\"\nport = 1883\n\n# 发布主题和消息\ntopic = \"temperature\"\nmessage = \"25\"\n\n# 发布消息\npublish.single(topic, payload=message, hostname=broker, port=port)","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"客户端订阅主题并存储数据（subscribe.py）：","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"import paho.mqtt.client as mqtt\nimport sqlite3\n\n# MQTT代理服务器的地址和端口\nbroker = \"mqtt.example.com\"\nport = 1883\n\n# MQTT回调函数，处理接收到的消息\ndef on_message(client, userdata, message):\n    # 解析消息中的数据\n    data = message.payload.decode()\n\n    # 将数据存储到数据库中\n    store_data(data)\n\ndef store_data(data):\n    # 连接数据库\n    conn = sqlite3.connect('data.db')\n    c = conn.cursor()\n\n    # 创建数据表（如果不存在）\n    c.execute('''CREATE TABLE IF NOT EXISTS temperature\n                 (timestamp DATETIME, value REAL)''')\n\n    # 将数据插入数据库表中\n    c.execute(\"INSERT INTO temperature VALUES (datetime('now'), ?)\", (data,))\n\n    # 提交更改并关闭数据库连接\n    conn.commit()\n    conn.close()\n\n# 创建MQTT客户端\nclient = mqtt.Client()\n\n# 设置回调函数\nclient.on_message = on_message\n\n# 连接到MQTT代理服务器\nclient.connect(broker, port)\n\n# 订阅主题\nclient.subscribe(\"temperature\")\n\n# 保持MQTT客户端循环，处理消息\nclient.loop_forever()","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"在上述示例代码中，你需要将broker变量的值更改为你所使用的MQTT代理服务器的地址。在客户端发布主题的代码中，你可以将topic和message更改为你自己的主题和消息。在客户端订阅主题并存储数据的代码中，你需要将数据库连接的相关代码适配到你所使用的数据库系统。","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"请确保你已经安装了Python和paho-mqtt库，并根据需要进行适当的配置和修改。然后，你可以在命令行中分别运行publish.py和subscribe.py来模拟发布和订阅MQTT主题，并将接收到的数据存储到数据库中。","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"请注意，以上示例代码仅供参考，并未包含所有的","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"错误处理和完整的功能。在实际应用中，你需要根据自己的需求和具体情况进行适当的调整和优化。","category":"page"},{"location":"IotBigdataCloud/2-消息件/#更多的参考信息","page":"物联网的消息件","title":"更多的参考信息","text":"","category":"section"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"看完并实操过如下三个链接的内容，应该就能有所理解了。","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"MQTT系列教程1（基本概念介绍）","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"MQTT系列教程2（消息服务器EMQ的搭建和使用）","category":"page"},{"location":"IotBigdataCloud/2-消息件/","page":"物联网的消息件","title":"物联网的消息件","text":"MQTT系列教程3（客户端工具MQTTBox的安装和使用）","category":"page"},{"location":"JuliaIntro/6-创建julia包/#创建julia包","page":"创建julia包","title":"创建julia包","text":"","category":"section"},{"location":"JuliaIntro/6-创建julia包/#来个例子","page":"创建julia包","title":"来个例子","text":"","category":"section"},{"location":"JuliaIntro/6-创建julia包/","page":"创建julia包","title":"创建julia包","text":"当您想要共享和分发自己的Julia代码时，可以创建一个Julia包。一个Julia包是一个具有特定结构和功能的项目，可以被其他人使用和引用。下面是创建一个简单的Julia包的步骤：","category":"page"},{"location":"JuliaIntro/6-创建julia包/","page":"创建julia包","title":"创建julia包","text":"创建包目录结构： 首先，创建一个新的文件夹作为您的包的根目录。您可以为该文件夹选择一个合适的名称，比如\"MyPackage\"。\n创建Manifest.toml和Project.toml文件： 在您的包的根目录中，使用以下命令来创建Manifest.toml和Project.toml文件：\nusing Pkg\nPkg.generate(\"MyPackage\")\n这将在包的根目录下生成两个文件：Manifest.toml和Project.toml。这些文件将用于管理包的依赖关系和配置。\n编辑Project.toml文件： 打开Project.toml文件并编辑它，添加包的元数据信息。您可以指定包的名称、版本号、作者等信息。例如，您可以在Project.toml文件中添加以下内容：\nname = \"MyPackage\"\nversion = \"0.1.0\"\nauthors = [\"Your Name <yourname@example.com>\"]\n您还可以根据需要添加其他信息，例如描述、许可证等。\n编写代码： 在您的包的根目录下，创建一个名为\"src\"的文件夹。在该文件夹中编写您的Julia代码。您可以创建多个模块文件以组织和管理代码。\n导入包的依赖关系： 如果您的包依赖于其他包，您可以在Project.toml文件的[deps]部分中添加这些依赖关系。例如，如果您的包依赖于名为\"Example\"的包，您可以添加以下行：\n[deps]\nExample = \"...\"\n在\"...\"处，您可以指定依赖包的版本号或Git仓库的URL。\n测试您的包： 在您的包的根目录中，创建一个名为\"test\"的文件夹。在该文件夹中编写测试代码，以确保您的包的功能正常。\n注册包： 如果您打算将包发布到Julia软件包注册表，您需要在https://github.com/JuliaRegistries/General 上提出一个请求。详细的步骤可以在该页面上找到。","category":"page"},{"location":"JuliaIntro/6-创建julia包/","page":"创建julia包","title":"创建julia包","text":"这些是创建一个简单的Julia包的基本步骤。完成上述步骤后，您就可以在其他Julia项目中使用和引用您的包了。","category":"page"},{"location":"CSAdv/8-Ascend等解构/#能源领域一些仿真软件解构","page":"能源领域一些仿真软件解构","title":"能源领域一些仿真软件解构","text":"","category":"section"},{"location":"CSAdv/8-Ascend等解构/","page":"能源领域一些仿真软件解构","title":"能源领域一些仿真软件解构","text":"像Ascend啊、modelica啊等等。","category":"page"},{"location":"IotBigdataCloud/1-物联网/#物联网","page":"物联网","title":"物联网","text":"","category":"section"},{"location":"IotBigdataCloud/1-物联网/#物联网简介","page":"物联网","title":"物联网简介","text":"","category":"section"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"物联网（Internet of Things，简称IoT）是指通过互联网连接和通信的智能设备网络。它将传感器、执行器、嵌入式系统、软件和网络服务等物理设备互相连接，并通过数据交换和互操作性实现智能化和自动化。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"物联网的核心思想是让物理世界与数字世界相互连接，使得物体能够感知环境、获取数据，并通过网络进行交流和协调。这些物联网设备可以是家用电器、智能手表、工业传感器、交通系统、农业设备等各种物体。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"通过物联网，我们能够实现许多便捷和智能化的功能。例如，在智能家居中，我们可以通过手机远程控制灯光、温度和安防系统；在智慧城市中，我们可以实时监测交通流量、优化能源利用和改善公共服务；在工业领域，物联网可以实现智能制造、远程监控和预测性维护等。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"物联网的实现依赖于多种技术，包括传感器技术、嵌入式系统、通信协议、云计算和人工智能等。同时，物联网也面临一些挑战，如安全和隐私问题、标准化和互操作性、数据管理等。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"总的来说，物联网正在改变我们的生活和工作方式，带来更智能、高效和便捷的体验。它有着广阔的应用前景，并在各个领域中发挥着越来越重要的作用。","category":"page"},{"location":"IotBigdataCloud/1-物联网/#传感器","page":"物联网","title":"传感器","text":"","category":"section"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"传感器将测量到的物理量（如温度、压力、湿度等）转换为电信号。在很多情况下，使用4-20mA的电流信号进行传输是一种常见的方式。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"电流信号的优势在于相对于电压信号，它对电线阻抗变化不敏感。由于电线本身具有一定的电阻，如果使用电压信号传输，电压信号会在电线上产生压降，从而引入误差。而电流信号传输则不会受到电线阻抗的影响，因为它不依赖于电路中的电压值。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"使用4-20mA的标准传输，其中4mA通常对应着测量物理量的最小值，20mA则对应着最大值。传输的电流大小表示了所测量物理量的相对大小。在接收端，数据采集仪或控制系统会根据事先定义好的规范来解析电流信号，并将其转换为相应的物理量数值，从而实现对所测量参数的准确解读和处理。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"因此，使用电流信号作为传输标准可以减少由于电阻变化而引起的误差，并提供可靠的数据采集和控制基础。","category":"page"},{"location":"IotBigdataCloud/1-物联网/#通讯协议","page":"物联网","title":"通讯协议","text":"","category":"section"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"物联网中使用的通信协议有多种，具体选择取决于应用场景、设备要求和通信需求。以下是一些常见的物联网通信协议：","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"Wi-Fi（无线保真）：Wi-Fi是一种广泛应用于家庭、办公场所和公共场所的无线局域网技术。它提供高速的无线数据传输和较长的通信距离，适用于需要高带宽和大量数据传输的应用。\n蓝牙（Bluetooth）：蓝牙是一种短距离无线通信技术，适用于设备之间的点对点连接。它广泛应用于消费电子产品、智能家居设备和低功耗传感器等领域。\nZigbee：Zigbee是一种低功耗无线通信协议，专为低速、低功耗的传感器和控制设备设计。它适用于物联网中的低功耗应用，例如智能家居、工业自动化和智慧城市。\nZ-Wave：Z-Wave是一种专门为智能家居设计的无线通信协议。它具有低功耗、高可靠性和较长的通信距离，可以实现设备之间的互联和远程控制。\nLoRaWAN：LoRaWAN（长距离低功耗广域网）是一种适用于广域物联网的无线通信协议。它具有较长的通信距离和低功耗特性，适用于远程监测和智能城市等场景。\nNB-IoT（窄带物联网）：NB-IoT是一种窄带低功耗的蜂窝网络技术，专为物联网设备提供广域覆盖和长电池寿命。它适用于大规模设备连接和低功耗要求的物联网应用。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"除了上述协议外，还有许多其他的物联网通信协议，如LTE-M、Sigfox、Thread等，每种协议都有自己的特点和适用场景。在选择通信协议时，需要考虑设备类型、功耗需求、通信距离、网络覆盖等因素，以确保最佳的通信性能和效果。","category":"page"},{"location":"IotBigdataCloud/1-物联网/#Modbus、Profibus和CAN","page":"物联网","title":"Modbus、Profibus和CAN","text":"","category":"section"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"Modbus、Profibus和CAN（Controller Area Network）是常见的工业通信协议，它们在工业自动化和控制系统中得到广泛应用。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"Modbus：Modbus是一种串行通信协议，用于在不同设备之间进行数据通信。它通常用于连接传感器、执行器、PLC（可编程逻辑控制器）和监控系统等设备。Modbus协议简单易用，支持点对点和多点通信，广泛应用于工业领域。\nProfibus：Profibus（Process Field Bus）是一种用于工业自动化领域的通信协议。它支持高速数据传输和实时控制，并且适用于连接各种设备，如传感器、执行器、PLC等。Profibus可以用于工厂自动化、过程控制和机械控制等应用。\nCAN（Controller Area Network）：CAN是一种广泛应用于汽车和工业领域的串行通信协议。它具有高可靠性、抗干扰能力和实时性能，适用于连接车辆电子系统、工业设备和控制系统。CAN协议可以支持多个设备在同一个总线上进行通信。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"这些协议都是为工业领域的通信需求设计的，它们提供了稳定、可靠和实时的数据传输，并在工业自动化、控制系统和监控领域中发挥着重要作用。它们在物联网中的应用也很常见，特别是在工业物联网中连接和集成各种工业设备和系统。","category":"page"},{"location":"IotBigdataCloud/1-物联网/#消息传递协议","page":"物联网","title":"消息传递协议","text":"","category":"section"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"在物联网中，常见的消息传递协议包括MQTT（Message Queuing Telemetry Transport）和Kafka。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"MQTT：MQTT是一种轻量级的发布/订阅消息传递协议，特别适用于资源受限的物联网设备。它采用发布/订阅模型，允许设备发布消息和订阅感兴趣的消息主题。数据可以通过MQTT协议发布到数据平台，并通过订阅者接收和处理。MQTT提供了可靠的消息传递机制和低网络开销，被广泛用于物联网中的消息传递和实时数据处理。\nKafka：Kafka是一个分布式流处理平台和消息队列系统。它具有高吞吐量、可持久化存储和水平扩展等特性。Kafka适用于大规模数据处理和实时流处理场景，包括物联网中的数据传输和存储。数据可以通过Kafka进行发布和订阅，然后存储到数据库或其他数据存储系统中。Kafka的优势在于能够处理高并发的数据流，并提供数据持久化和分布式处理能力。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"无论是MQTT还是Kafka，它们都是用于实现物联网中的消息传递和数据处理的工具。它们提供了可靠的数据传输和处理机制，将物联网设备生成的数据发送到数据平台，并通过存储到数据库或其他数据存储系统中进行后续的数据管理和分析。选择使用哪种协议取决于具体的应用需求和系统架构。","category":"page"},{"location":"IotBigdataCloud/1-物联网/#执行器","page":"物联网","title":"执行器","text":"","category":"section"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"执行器是物联网系统中的一种设备，用于执行控制命令并产生相应的动作或效果。它可以接收来自物联网平台或其他控制系统的指令，并转换为实际的动力或操作。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"执行器可以是各种形式的设备，例如电机、阀门、继电器、电磁锁、气缸等。它们可以用于自动化系统、智能家居、工业控制和机械设备等领域。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"根据应用需求，执行器可能需要实现以下功能：","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"执行控制命令：执行器接收来自物联网平台或控制系统的命令，并按照要求进行相应的动作或操作。例如，控制电机启停、开关阀门、锁定或解锁等。\n反馈状态：有些执行器具备反馈机制，可以向控制系统报告其当前状态或执行结果。这种反馈信息可以用于监控和验证执行器的操作是否成功。\n与其他设备的联动：执行器可能需要与其他设备进行联动，实现协同操作。例如，一个执行器可以与传感器进行配合，实现自动调节或响应环境变化。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"执行器的选择取决于具体的应用场景和需求。在设计物联网系统时，需要考虑执行器的类型、控制接口、通信协议和功耗等因素，以确保与其他设备的兼容性和系统的整体性能。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"总结起来，执行器在物联网系统中起着关键的作用，通过接收指令并执行相应的动作，实现远程控制和自动化操作。","category":"page"},{"location":"IotBigdataCloud/1-物联网/#物联网平台软件","page":"物联网","title":"物联网平台软件","text":"","category":"section"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"在物联网系统中，软件起着至关重要的作用，它们负责管理、控制和处理物联网设备和数据。以下是一些常见的软件组件和功能：","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"物联网平台：物联网平台是一个中央化的软件系统，用于管理和控制连接的物联网设备。它提供设备注册、身份验证、数据传输、远程配置和控制等功能。物联网平台通常具备数据存储、设备管理、安全性和可扩展性等特性。\n数据管理和分析：物联网系统生成大量的数据，这些数据需要进行收集、存储和分析。数据管理和分析软件负责处理和分析物联网设备生成的数据，提取有用的信息和洞察，并支持实时监控、数据可视化和决策支持。\n应用程序和界面：为了使用户能够与物联网系统进行交互，开发应用程序和界面是必要的。这些应用程序可以是Web应用、移动应用或桌面应用，用于远程监控、控制设备、配置设置和查看数据等功能。\n云计算和边缘计算：物联网系统通常涉及云计算和边缘计算的概念。云计算提供强大的计算和存储资源，支持物联网数据的处理和分析。而边缘计算将部分计算和数据处理移至设备的边缘，以减少数据传输和延迟。软件需要支持云计算和边缘计算架构，并确保数据的安全和高效传输。\n安全性和隐私保护：由于物联网系统涉及大量的设备和数据，安全性和隐私保护是至关重要的方面。软件需要具备安全认证、数据加密、访问控制和漏洞修补等功能，以保护物联网系统免受潜在的安全威胁。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"除了上述的软件组件和功能，物联网系统还可能涉及其他软件，如设备驱动程序、通信协议栈、数据传输协议和远程监控工具等。","category":"page"},{"location":"IotBigdataCloud/1-物联网/","page":"物联网","title":"物联网","text":"需要根据具体的物联网应用场景和需求，选择适合的软件组件和工具，以实现物联网系统的功能和目标。","category":"page"},{"location":"Optimization/JuMP参数辨识/#JuMP非线性参数辨识实例","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"","category":"section"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"tip: Tip\nContents：参数辨识、优化、JuMPContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"note: Note\nJuMP = JuMP.jlNLP = NonlinearnProblem，非线性问题JuMP是计算优化问题的Julia软件包。","category":"page"},{"location":"Optimization/JuMP参数辨识/#JuMP介绍","page":"JuMP非线性参数辨识实例","title":"JuMP介绍","text":"","category":"section"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"JuMP是一种特定领域的建模语言，用于嵌入Julia中的数学优化。可以用于解决各类优化问题。JuMP的指南中列出了可用的求解器，以及能够求解问题的类型。","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"JuMP建模的思路主要分为3步：","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"定义求解器\n明确问题\n求解","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"使用MTK非线性参数辨识实例中的参数优化问题作为求解实例展开介绍","category":"page"},{"location":"Optimization/JuMP参数辨识/#求解实例","page":"JuMP非线性参数辨识实例","title":"求解实例","text":"","category":"section"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"为了优化下面模型中的参数ab：","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"y = ax^2+sin(bx)a=15b=08","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"人为生成数据，","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"##### 生成真实数据 #####\nx = collect(-1:0.01:1)\nN = length(x)\n# 产生随机误差，范围在-0.1~0.1之间\nrands = rand(-0.1:0.01:0.1, N)\na1 = 1.5\na2 = 0.8\n# 计算y值\ny = @. a1 * x^2 + sin(a2 * x) + rands","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"JuMP优化：","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"首先，定义求解器：","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"###### 定义求解器 #######\nmodel = Model(Ipopt.Optimizer)","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"随后，定义优化变量，在参数辨识问题中，被优化的参数为ab：","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"###### 定义变量 #######\n@variable(model, para[1:2])","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"其次，构建优化问题的数学表达，需要用@NLexpression生成非线性优化中的中间表达Loss。使用@NLobjective，从Loss中构建最小化优化问题。参数优化问题没有变量约束，也可以说是全局优化问题。","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"tip: Tip\n@NLobjective、@NLexpression与非线性优化问题有关，在线性优化问题中，使用@expression。不同问题类型使用不同的宏，是JuMP问题构建的特点。","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"###### 构建问题 #######\n@NLexpression(model, Loss,\n    sum((para[1] * x[i]^2 + sin(para[2] * x[i]) - y[i])^2 for i in 1:N))\n@NLobjective(model, Min, Loss)","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"最后求解","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"###### 赋初值 #######\nfor i in 1:2\n    set_start_value(para[i], 0.3)\nend\n###### 求解 #######\nJuMP.optimize!(model)\nJuMP.value.(para)","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"结果：","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"2-element Vector{Float64}:\n 1.4989653389675912\n 0.8133014851045581","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"warning: Warning\n优化的求解器不是万能的，当一个参数辨识问题无法求解时有很多原因，例如：用来描述系统的数学模型不精确上述例子中，优化数据集本身就来自于模型，所以可以肯定数据的本质一定是我们选定的模型。在实际中，面对大量的数据，数学模型准不准确往往是未知的。优化问题较为复杂多变量的复合函数，以及多优化目标的优化问题。在数学上可能有多个局部最优解。有些结果往往不太理想，典型的表现上是不同的初值获得不同的结果。或表现为初值敏感，当初值有微小改变，也能引起结果的巨大不同。面对这些数学上的难点，需要采取一些其它的策略。优化模型或者采取更加强大的求解器......","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"全部代码：","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"using JuMP, Ipopt\n\n##### 生成真实数据 ####\nx = collect(-1:0.01:1)\nN = length(x)\n# 产生随机误差，范围在-0.1~0.1之间\nrands = rand(-0.1:0.01:0.1, N)\na1 = 1.5\na2 = 0.8\n# 计算y值\ny = @. a1 * x^2 + sin(a2 * x) + rands\n\nmodel = Model(Ipopt.Optimizer)\n@variable(model, para[1:2])\n@NLexpression(model, Loss,\n    sum((para[1] * x[i]^2 + sin(para[2] * x[i]) - y[i])^2 for i in 1:N))\n@NLobjective(model, Min, Loss)\nfor i in 1:2\n    set_start_value(para[i], 0.3)\nend\n\nJuMP.optimize!(model)\nJuMP.value.(para)","category":"page"},{"location":"CSAdv/6-领域特定语言/#领域特定语言DSL","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"","category":"section"},{"location":"CSAdv/6-领域特定语言/","page":"领域特定语言DSL","title":"领域特定语言DSL","text":"我们会讲到cellml、sbml、ascend、modelica、gpromsd等等dsl。也会给出做个玩具语言的参考链接。","category":"page"},{"location":"Control/JuMPMPC/#JuMP求解MPC问题","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"","category":"section"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"tip: Tip\nContents：JuMP、ControlContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"note: Note\nJuMP是计算优化问题的Julia软件包。","category":"page"},{"location":"Control/JuMPMPC/#MTK中的OptimizationSystem、ControlSystem","page":"JuMP求解MPC问题","title":"MTK中的OptimizationSystem、ControlSystem","text":"","category":"section"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"通过MTK中的OptimizationSystem、ControlSystem构建MPC问题都是可行的，但是其一个致命的问题是，System会忽略约束！换一句话说，System只接受Loss方程。这是MTK优化体系不完善的地方。那么，Julia中较为成熟的优化包是JuMP、Optim和NLopt。JuMP的集成度比较好，在JuMP中可以根据不同的优化问题使用不同的求解器。所以尝试用JuMP解决。","category":"page"},{"location":"Control/JuMPMPC/#实例：加热器问题","page":"JuMP求解MPC问题","title":"实例：加热器问题","text":"","category":"section"},{"location":"Control/JuMPMPC/#问题描述","page":"JuMP求解MPC问题","title":"问题描述","text":"","category":"section"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"现在有一个物体加热，它的温度由加热项和散热项决定。α是散热系数，β是加热系数，环境温度为T_out。那么控制方程: ","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"T = α*(T_out - T) + β*Q(t)","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"现在可以改变加热功率，那么我们构建一个优化问题：调节加热功率，使得物体的温度从T_0开始，迅速上升并且稳定在某一个温度（比如说58℃）。问题的数学表达为，通过优化控制变量Q(t) 使得损失函数最小:","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"Loss = sum_i 580-T(t_i)","category":"page"},{"location":"Control/JuMPMPC/#构建问题","page":"JuMP求解MPC问题","title":"构建问题","text":"","category":"section"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"首先明确问题。现在假设以一个恒定功率（p=80）加热物体，环境温度18℃，初始温度20℃,散热系数α = 0.2,加热系数β = 0.1。先求解该问题。","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"using Plots,DifferentialEquations\nTout = 18.0\nα = 0.2\nβ = 0.1\nf(x,p,t) = α*(Tout - x) + β*p\ntspan=(0.0,40.0)\nu0 = 20.0\np = 80.0\npr = ODEProblem(f,u0,tspan,p)\nsol = solve(pr)\nplot(sol,ylimit=(10,60))","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"得到的结果是： (Image: 图 1)  ","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"很清晰可以看到，温度缓慢上升最后稳定在58℃。那么作为我们拍脑袋的控制策略来说，这个控制问题很简单。我们可以先让功率在前期比较大（比如说150），等温度到了58℃附近，再把功率调回80，就可以实现“温度迅速上升并最后稳定在58度”。","category":"page"},{"location":"Control/JuMPMPC/#优化求解","page":"JuMP求解MPC问题","title":"优化求解","text":"","category":"section"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"using JuMP,Ipopt\nN = 40\nTout = 18.0\nT0 = 20.0\ndt = 8/N\nLoss = 0.0\nT = T0\nα = 0.2\nβ = 0.1\nmodel = Model(Ipopt.Optimizer)\n@variable(model, 0 <= u[1:N] <= 200)\nfor i in 1:N\n    global T = @expression(model,T + (α*(Tout - T) + β*u[i])*dt)\n    global Loss += @expression(model,(T - 58.0)^2)\nend\nfor i = 1:N-1\n    @constraint(model,-5 <= u[i]-u[i+1] <= 5)\nend\n@objective(model, Min, Loss)\noptimize!(model)\nJuMP.value.(u)","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"u是符号量，离散的个数为N，上面选择离散为40个变量。通过一个for循环，就可以迭代求解40个点上的温度值并且构建Loss方程。同时添加约束，约束的物理含义是控制加热器功率的改变幅度不能太大，这里设置为（-5，5）。","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"PS：这里的离散方法，对微分方程求解来说实际上是最简单的欧拉法，精度有待提高，后退欧拉法，亚当斯方法，龙格库塔方法等等方法都可以用来构建Loss方程，只不过方程表达式会很复杂。","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"最后我们可以看到整个定义的问题。","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"print(model)","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"表达式非常复杂，就不放图了。","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"加热功率的变化为：","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"plot([(i -1)*dt for i in 1:N],value.(u))","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"(Image: 图 2)  ","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"温度的变化为：","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"(Image: 图 3)  ","category":"page"},{"location":"Control/JuMPMPC/#调节约束","page":"JuMP求解MPC问题","title":"调节约束","text":"","category":"section"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"结果有些许波动，调一下功率变化的幅度限制，把约束范围调成（-10，10）","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"加热功率的变化为：","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"plot([(i -1)*dt for i in 1:N],value.(u))","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"(Image: 图 1)  ","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"温度的变化为：","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"(Image: 图 4)  ","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"比刚刚好多了！","category":"page"},{"location":"JuliaIntro/9-ijulia/#IJulia","page":"IJulia","title":"IJulia","text":"","category":"section"},{"location":"JuliaIntro/9-ijulia/#jupyter简介","page":"IJulia","title":"jupyter简介","text":"","category":"section"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"Jupyter是一个基于Web的交互式计算环境，它支持多种编程语言，包括Julia、Python、R等。它的名字源自三种主要编程语言的缩写：Ju（Julia）、Py（Python）和R。","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"Jupyter的主要组件是Jupyter Notebook和Jupyter Lab：","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"Jupyter Notebook： Jupyter Notebook提供了一个可交互的环境，可以在Web浏览器中创建和共享文档，其中包含代码、文本、公式、图表和可视化结果。每个文档由多个单元格组成，每个单元格可以包含代码或文本。您可以逐个单元格地执行代码，并实时查看结果。这使得Jupyter Notebook非常适合于数据分析、机器学习、报告编写和教学等领域。\nJupyter Lab： Jupyter Lab是Jupyter的下一代用户界面，它提供了更丰富的功能和更灵活的界面布局。它支持同时打开多个Notebook、文件浏览器、终端、代码编辑器等。您可以通过拖放方式调整单元格和组件的布局，以满足不同的工作流需求。","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"以下是使用Jupyter的一些主要优点和基本使用方式：","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"交互性：Jupyter提供了一个交互式环境，您可以在单元格中编写代码，并通过逐个单元格地执行代码来获取即时结果。\n文档编写：Jupyter Notebook支持Markdown标记语言，使您可以在代码单元格之间插入文本、标题、公式、链接等，创建结构化的文档。\n可视化支持：Jupyter可以集成各种数据可视化库，如Matplotlib、Plotly、Bokeh等，使您能够绘制图表、绘图和动画，并将其嵌入到文档中。\n代码共享：Jupyter Notebook可以保存为.ipynb文件，并且可以轻松共享给他人。其他人可以加载您的Notebook，并与您一起编辑、运行和修改代码。","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"要开始使用Jupyter，您需要完成以下步骤：","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"安装Jupyter：您可以使用pip或conda命令在命令行中安装Jupyter。\n启动Jupyter：在命令行中运行jupyter notebook或jupyter lab，它会在浏览器中打开Jupyter的界面。\n创建新的Notebook：在Jupyter界面中，您可以创建一个新的Notebook，并选择所需的编程语言。\n编写和执行代码：在Notebook的单元格中，您可以编写代码，并使用Shift+Enter或点击运行按钮来执行代码并查看结果。\n保存和共享Notebook：您可以将Notebook保存为.ipynb文件，并与他人","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"共享。","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"Jupyter是一个强大的工具，可以帮助您以交互和可视化的方式编写、测试和共享代码。它在数据科学、机器学习、教育和科学研究等领域广泛应用。","category":"page"},{"location":"JuliaIntro/9-ijulia/#在jupyter中的julia","page":"IJulia","title":"在jupyter中的julia","text":"","category":"section"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"当需要在Julia中创建可交互的文档、笔记本或报告时，iJulia是一个非常有用的工具。iJulia是一种Julia语言的Jupyter内核，它允许您在Web浏览器中编写和运行Julia代码，并将代码、文本和可视化结果组合成一个交互式文档。","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"以下是使用iJulia的一些主要优点和基本使用方式：","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"交互性： iJulia提供了一个交互式环境，您可以在Jupyter笔记本中编写和运行Julia代码。您可以逐个单元格地执行代码，并实时查看结果。这种交互性使得试验和调试代码变得更加方便和直观。\n文档编写： iJulia允许您在Julia代码中插入富文本、Markdown和LaTeX等标记语言。您可以使用标记语言编写说明文本、标题、列表、公式等，并与代码交替排列。这使得您可以创建丰富的文档，以便更好地记录和展示代码和结果。\n可视化支持： iJulia支持各种数据可视化库，如Plots、Gadfly和PyPlot。您可以使用这些库绘制图表、绘图和动画，并将其直接嵌入到文档中。这样，您可以通过可视化方式更好地解释和展示数据。\n资源共享： iJulia笔记本是可共享的资源，您可以将笔记本文件保存为.ipynb文件，然后与他人共享或将其发布到各种平台上，如GitHub、Jupyter Notebook Viewer等。这使得其他人可以轻松阅读、运行和修改您的代码和文档。","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"要开始使用iJulia，您需要完成以下步骤：","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"安装Jupyter Notebook：您可以使用pip命令或conda命令在命令行中安装Jupyter Notebook。\n安装iJulia内核：在Julia的REPL中，运行using Pkg; Pkg.add(\"IJulia\")来安装iJulia内核。\n启动Jupyter Notebook：在命令行中运行jupyter notebook，它将在浏览器中打开Jupyter Notebook的界面。\n创建新的Julia笔记本：在Jupyter Notebook界面中，选择Julia内核来创建一个新的Julia笔记本。然后您就可以在笔记本中编写和运行Julia代码了。","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"使用iJulia，您可以创建交互式的Julia文档，结合代码和解释，使您的学生能够更好地理解和学习Julia编程。","category":"page"},{"location":"JuliaIntro/9-ijulia/#最后介绍一下julia原生的notebook工具Pluto","page":"IJulia","title":"最后介绍一下julia原生的notebook工具Pluto","text":"","category":"section"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"当需要创建交互式、可执行的Julia文档时，Pluto.jl是一个非常有用的工具。Pluto.jl 是一个Julia语言的笔记本工具，它提供了一个可交互的环境，允许您在浏览器中编写、运行和共享Julia代码和文档。","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"以下是使用Pluto.jl的一些主要优点和基本使用方式：","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"交互性： Pluto.jl 提供了一个实时交互式环境，您可以在浏览器中编写和执行Julia代码。您可以逐个单元格地执行代码，并实时查看结果。这种交互性使得试验、调试和学习变得更加方便和直观。\n文档编写： Pluto.jl 使用可编辑的Markdown单元格，允许您在Julia代码中插入富文本、Markdown和LaTeX等标记语言。您可以使用标记语言编写说明文本、标题、列表、公式等，并与代码交替排列。这使得您可以创建结构化的文档，以便更好地记录和展示代码和结果。\n自动重新执行： Pluto.jl 可以自动重新执行依赖于前面单元格的代码，以确保所有单元格的执行顺序正确无误。这意味着您可以随时更改先前的单元格，并且后续的单元格将自动重新执行，确保结果的一致性。\n共享和协作： Pluto.jl 笔记本可以保存为.pjl 文件，并且可以轻松共享给他人。其他人可以加载您的笔记本，并与您一起编辑和运行代码。这使得团队合作和知识共享变得更加方便。","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"要开始使用Pluto.jl，您需要完成以下步骤：","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"安装 Pluto.jl 包：在Julia的REPL中，运行using Pkg; Pkg.add(\"Pluto\")来安装Pluto.jl 包。\n启动 Pluto.jl：在Julia的REPL中，运行using Pluto; Pluto.run()来启动Pluto.jl 的服务。\n在浏览器中打开Pluto.jl：在启动Pluto.jl 后，会生成一个本地链接，您可以将其复制到浏览器中打开Pluto.jl 的界面。\n创建新的Pluto.jl 笔记本：在Pluto.jl 界面中，您可以创建一个新的笔记本，并在单元格中编写和执行Julia代码。","category":"page"},{"location":"JuliaIntro/9-ijulia/","page":"IJulia","title":"IJulia","text":"使用Pluto.jl，您可以创建交互式的Julia文档，结合代码、解释和可视化结果，使您和您的学生能够更好地探索和学习Julia编程。","category":"page"},{"location":"Tools/vscode_git/#VScode中使用Git","page":"VScode中使用Git","title":"VScode中使用Git","text":"","category":"section"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"tip: Tip\nContents：VScode,GitContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"本篇介绍在vscode中使用git的方法(以码云为例，githup是同样的操作)","category":"page"},{"location":"Tools/vscode_git/#初始化仓库","page":"VScode中使用Git","title":"初始化仓库","text":"","category":"section"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"如图所示，等价于git init","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/#生成公钥","page":"VScode中使用Git","title":"生成公钥","text":"","category":"section"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"ssh-keygen -t rsa -C \"xxxxxx@qq.com\"","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"一路回车，有y/n则y。在红框中的文件夹中去找公钥文件。","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"idrsa是私钥，idrsa.pub是公钥","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"使用公钥私钥匹配就可以免去登录验证","category":"page"},{"location":"Tools/vscode_git/#配置公钥","page":"VScode中使用Git","title":"配置公钥","text":"","category":"section"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"githup与gitee是同样的方式，将id_rsa.pub的乱码复制到下图的地方。","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/#VScode中添加远程仓库","page":"VScode中使用Git","title":"VScode中添加远程仓库","text":"","category":"section"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"首先复制地址，选ssh","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"添加远程仓库","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"在框中输入复制过来的ssh地址，点击从URL添加远程仓库","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"输入仓库名字，指的是在vscode的仓库名字，随意填 (Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/#提交与推送","page":"VScode中使用Git","title":"提交与推送","text":"","category":"section"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"先暂存更改","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"在...中可以进行一系列操作，本质上就是有一个图形化的git操作界面，","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"一般选择拉取自，或推送到","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Modeling/MTK_register/#ModelingToolkit调用外部函数","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"","category":"section"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"tip: Tip\nContents：建模、MTK、外部函数Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"note: Note\nMTK = ModelingToolkit.jlModelingToolkit.jl为基于符号系统的建模工具包。MTK-Version:8.5 及以上","category":"page"},{"location":"Modeling/MTK_register/#提出问题","page":"ModelingToolkit调用外部函数","title":"提出问题","text":"","category":"section"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"在前面的ModelingToolkit建模方法中提到，符号系统是MTK的基石。那么，如果想加入一个外部函数，应该怎么解决？例如方程：","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"f(xy) + x + y = 1","category":"page"},{"location":"Modeling/MTK_register/#解决方案","page":"ModelingToolkit调用外部函数","title":"解决方案","text":"","category":"section"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"把函数的调用符号化——@register_symbolic，一切问题就解决了！","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"也就是说，把函数名称放入符号系统中去。和定义符号变量类型，对相关函数进行声明，声明该函数纳入符号系统，即可完成操作。","category":"page"},{"location":"Modeling/MTK_register/#实例","page":"ModelingToolkit调用外部函数","title":"实例","text":"","category":"section"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"考虑一个简单系统：","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"fracdydt  = u(y)  u(y)= leftbeginaligned\n10  y10 \n-10  y geq 100\nendalignedright ","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"这里函数u在编程时，需要用ifelse函数来定义， 也可以用@register_symbolic来注册一个符号函数。","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"通过MTK构建：","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"using ModelingToolkit,DifferentialEquations\n@variables t y(t)\nD = Differential(t)\nu(y) = ifelse(y>100.0, -10.0, 10.0)\n\n# u(y) = y>100.0 ? -10.0 : 10.0\n# @register_symbolic u(y)\n\neqs = [\n    D(y) ~ u(y)\n]\n@named sys = ODESystem(eqs)","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"可以看到得到的方程中，u被视为函数，它的参数为y(t)。","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"求解问题：","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"sys = structural_simplify(sys)\nu0=[y => 50.0]\ntspan = (0.0,20.0)\nprob = ODEProblem(sys,u0,tspan,[])\nsol = solve(prob)\nusing Plots\nplot(sol)","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"可以看到成功求解，并且y在100附近波动。这是我们期望的结果。","category":"page"},{"location":"Modeling/MTK_register/#实例——CoolProp","page":"ModelingToolkit调用外部函数","title":"实例——CoolProp","text":"","category":"section"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"CoolProp一个开源的调用物性包，通过几行代码就可以很容易的调用流体的物性。如何在符号系统中使用Coolprop函数调用物性呢？同样，也是使用外部函数，在外部函数中封装物性查询，将函数符号化即可。","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"测试问题：在1MPa下，求温度从300K-400K的水蒸气焓值累加和。（虽然这样做很没有意义，但是这是一种测试外部函数的有效并且简单的方法）","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"using ModelingToolkit,CoolProp,DifferentialEquations\n@variables t T(t)\nD = Differential(t)\nfunction u(t)\n    PropsSI(\"H\",\"P\",1.0E6,\"T\",t,\"Water\")\nend\n@register_symbolic u(t)\neqs = [\n    D(T) ~ u(t+300.0)\n]\n@named sys = ODESystem(eqs)\nsys = structural_simplify(sys)\nu0=[\n    T => 0.0\n]\ntspan = (0.0,100.0)\nprob = ODEProblem(sys,u0,tspan,[])\nsol = solve(prob)\nusing Plots\nplot(sol)","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"程序可以运行并且得到了结果，","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"MTK符号运算系统加上外部调用函数符号化，基本上可以解决各类仿真问题。","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"note: Note\n个人观点：从仿真层面来说，MTK具有了作为一个仿真引擎的所有功能。从程序开发层面来说，MTK具备搭建一个巨型系统的潜力。","category":"page"},{"location":"Modeling/DE_intro/#DifferentialEquations建模方法","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"section"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"tip: Tip\nContents：建模、DEContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"note: Note\nDE = DifferentialEquations.jlDifferentialEquations.jl为处理时间微分的求解建模工具包。","category":"page"},{"location":"Modeling/DE_intro/#浅谈建模内涵","page":"DifferentialEquations建模方法","title":"浅谈建模内涵","text":"","category":"section"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"在研究各类系统时（上至电力、能源系统、交通系统，下至RC电路、水利管网系统），当我们需要对系统进行处理时，我们都会一件相同的事情——把系统抽象成我们能够处理的对象！","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"从发现问题到获得计算结果，在现代计算科学中一般分为两步：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"把问题抽象可量化、可处理的数学问题\n把数学问题设计成可用计算机处理与计算的可计算问题","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"在这个过程中，大脑在这个过程充当了“解释器”的角色。把实际的问题层层抽象，最后让问题变得可计算。不得不感叹，人类“编译”能力之强大。也许人类在计算速度上远远不及计算机。但在深度与广度层面，远远超过计算机。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"从前牛顿等巨人的时代开始，科学家研究的主体内容，主要是是第一步的内容。近40年，计算机科学技术呈爆炸式增长。依托于计算机，社会生产的智能化日益提高。于是基于第2步的问题也发展出许多学科分支，作为科研领域重要的方向之一。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"这是一件很奇妙的事情，巨量1与0的加减运算产生了无穷的能力！就好像神经元虽然简单，只要数量够，也能组合成产生无数想法的大脑！","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"言归正传，在第一步中，描述对象的数学形式有微分方程（组）、代数方程（组）、图等等。针对对象进行计算的数学形式有求解方程问题、寻优问题、计算图等等。DifferentialEquations.jl就是处理基于时间微分的微分方程（组）求解软件包！","category":"page"},{"location":"Modeling/DE_intro/#DE使用实例","page":"DifferentialEquations建模方法","title":"DE使用实例","text":"","category":"section"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"现有洛伦兹方程为例：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"fracdxdt  = sigma(y-x)  fracdydt  = x(rho-z)-y  fracdzdt = xy - beta z","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"微分方程在DifferentialEquations.jl中含有5个要素：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"方程描述\n求解时间域\n初值（边界条件）\n方程参数\n问题类型","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"在方程定义中，有4个参数：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"function lorenz!(du,u,p,t)\n    du[1] = p[1]*(u[2]-u[1])\n    du[2] = u[1]*(p[2]-u[3]) - u[2]\n    du[3] = u[1]*u[2] - p[3]*u[3]\nend","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"其中，","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"du为微分变量向量\nu为变量向量\np为参数\nt为时间变量","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"剩下要素的定义：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"p = [10.0,28.0,8/3]\nu0 = [1.0;0.0;0.0]\ntspan = (0.0,100.0)\nprob = ODEProblem(lorenz!,u0,tspan,p)","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"其中，","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"p为参数\nu0变量的初始值\ntspan为求解时间域\nprob为通过方法ODEProblem()定义的ODE问题","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"tip: Tip\nODEProblem = Ordinary Differential Equations Problem(常微分方程)beginarrayl\nfracd xd t=sigma(y-x) \nfracd yd t=x(rho-z)-y \nfracd zd t=x y-beta z\nendarray除此之外，还有：DAEProblem = Differential Algebraic Equations Problem（微分代数方程）beginalignedfracd y_1d t =-004 y_1+10^4 y_2 y_3 fracd y_2d t =004 y_1-10^4 y_2 y_3-3 * 10^7 y_2^2 1 =y_1+y_2+y_3endalignedDDEProblem = Delay Differential Equations Problem（随机微分）beginaligned\nd x_0 =fracv_01+beta_0left(x_2(t-tau)right)^2left(p_0-q_0right) x_0(t)-d_0 x_0(t) d x_1 =fracv_01+beta_0left(x_2(t-tau)right)^2left(1-p_0+q_0right) x_0(t) +fracv_11+beta_1left(x_2(t-tau)right)^2left(p_1-q_1right) x_1(t)-d_1 x_1(t) d x_2 =fracv_11+beta_1left(x_2(t-tau)right)^2left(1-p_1+q_1right) x_1(t)-d_2 x_2(t)endaligned更多方程种类可查官方文档。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"求解并画图","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"sol = solve(prob, Tsit5())\nplot(sol,vars=(1,2,3))","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"(Image: 图 4)  ","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"全部代码：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"using DifferentialEquations,Plots\nfunction lorenz!(du,u,p,t)\n        du[1] = p[1]*(u[2]-u[1])\n        du[2] = u[1]*(p[2]-u[3]) - u[2]\n        du[3] = u[1]*u[2] - p[3]*u[3]\nend\np = [10.0,28.0,8/3]\nu0 = [1.0;0.0;0.0]\ntspan = (0.0,100.0)\nprob = ODEProblem(lorenz!,u0,tspan,p)\nsol = solve(prob, Tsit5())\nplot(sol,vars=(1,2,3))","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/#DE的Callback特性","page":"DifferentialEquations建模方法","title":"DE的Callback特性","text":"","category":"section"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"Callback的含义为，当系统运行到某个状态时，人为介入改变系统参量的值，随后继续求解。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"下面以弹球系统为例，介绍Callback的用法。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"弹球系统的特点是，当弹球碰到地面时，需要弹起。所以在模拟弹球系统时，需要考虑求解过程中速度的方法变化，这时候就用到callback。碰地的数学的描述为，弹球速度变量变为它的相反数。也就是说当弹球高度x变为0时，速度u需要变成-u。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"其数学表达为：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"x = v  v = -g","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"DE问题构建：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"function f(du,u,p,t)\n    du[1] = u[2]\n    du[2] = -p\nend","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"其中，","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"u1为x，即弹球高度\nu2为v，即弹球速度","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"建立Callback函数：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"function condition(u,t,integrator) # Event when event_f(u,t) == 0\n    u[1]\nend\nfunction affect!(integrator)\nintegrator.u[2] = -integrator.u[2]\nend\ncb = ContinuousCallback(condition,affect!)","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"condition为系统调用callback时应该满足的条件，默认为函数返回值为0（false）时的情况。即u[1]=0。 affect!为系统调用callback时的处理动作，这里为将速度变负。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"定义剩余要素并求解，在solve中需要传递callback。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"u0 = [50.0,0.0]\ntspan = (0.0,15.0)\np = 9.8\nprob = ODEProblem(f,u0,tspan,p)\nsol = solve(prob,Tsit5(),callback=cb)\nplot(sol)","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"可以得到如下结果：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"(Image: 图 5)","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"如果考虑反弹损失（每次反弹速度损失20%）：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"function affect!(integrator)\nintegrator.u[2] = -integrator.u[2]*0.8\nend","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"(Image: 图 6)  ","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"也能够得到相应的结果，妙啊！！！","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"全部代码：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"using DifferentialEquations,Plots\nfunction f(du, u, p, t)\n    du[1] = u[2]\n    du[2] = -p\nend\nfunction condition(u, t, integrator) # Event when event_f(u,t) == 0\n    u[1]\nend\nfunction affect!(integrator)\n    integrator.u[2] = -integrator.u[2]\nend\ncb = ContinuousCallback(condition, affect!)\nu0 = [50.0, 0.0]\ntspan = (0.0, 15.0)\np = 9.8\nprob = ODEProblem(f, u0, tspan, p)\nsol = solve(prob, Tsit5(), callback=cb)\nplot(sol)","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"tip: Tip\nDE中有许多特性，例如求解结果的处理（Solution Handle）、回调函数（Callback）等等。更多特性可以在官方文档中查看。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/#make和Makefile介绍","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/#程序的编译和链接","page":"make和Makefile介绍","title":"程序的编译和链接","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/#程序的编译和链接过程","page":"make和Makefile介绍","title":"程序的编译和链接过程","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"当编写C语言程序时，需要将源代码转换为可执行程序的过程包括编译和链接两个主要阶段。下面是以GCC编译器为例的程序的编译和链接过程：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"预处理（Preprocessing）： 在编译过程开始之前，预处理器会处理源代码文件（以.c为扩展名）。它执行包括宏展开、头文件包含、条件编译等任务。预处理器会根据包含的头文件和宏定义进行文本替换，生成一个被称为预处理后的源代码文件（通常以.i或.ii为扩展名）。\n编译（Compilation）： 在这一阶段，编译器会将预处理后的源代码文件转换为汇编语言代码文件（以.s为扩展名），即将C语言代码转化为特定机器平台上的汇编指令。编译器负责检查语法错误和类型错误，并进行相应的优化。\n汇编（Assembly）： 汇编器（如GNU as）将汇编语言代码文件转换为目标文件（以.o为扩展名），其中包含了机器指令和数据。目标文件是二进制文件，仍然是机器相关的。\n链接（Linking）： 在链接阶段，链接器（如GNU ld）将目标文件与所需的库文件进行合并，生成最终的可执行程序。链接器解决了符号引用的问题，它将不同目标文件中引用的函数和变量的定义连接在一起，生成一个可执行程序文件。链接器还负责处理库的链接，包括静态库和动态库。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"在链接过程中，可能会涉及两种类型的链接：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"静态链接（Static Linking）： 在静态链接中，链接器会将所有被引用的库文件的代码和数据复制到最终的可执行文件中。这样，可执行文件就包含了所有所需的库的代码，可以独立运行，而不依赖于系统上是否存在相应的库文件。\n动态链接（Dynamic Linking）： 在动态链接中，可执行文件只包含对库函数的引用，而实际的库代码和数据存储在共享库文件中。在程序运行时，操作系统的动态链接器将库文件加载到内存，并将引用与实际地址进行关联，以完成链接。这样可以实现代码的共享，减小可执行文件的大小，并允许共享库的更新和替换。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"GCC编译器将上述过程整合在一起，可以直接将源代码编译成最终的可执行程序。你可以使用GCC命令来进行整个编译和链接过程，例如：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"gcc main.c -o program","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"其中，main.c","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"是源代码文件，program是生成的可执行程序的名称。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"了解程序的编译和链接过程对于理解make和makefile的工作原理非常重要，因为make工具主要用于自动化构建过程，根据源代码的变化和依赖关系进行编译和链接。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/#分步编译和链接","page":"make和Makefile介绍","title":"分步编译和链接","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"当使用GCC编译器进行程序编译和链接时，可以将编译和链接过程分为两步来演示。我们将使用一个简单的C语言程序来进行示例，包含两个源代码文件：main.c和helper.c。main.c文件包含程序的入口函数，helper.c文件包含一个辅助函数。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"以下是演示编译和链接的步骤：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"编译（Compilation）： 首先，我们使用GCC编译器将每个源代码文件编译为目标文件（.o文件），并生成对应的汇编代码（.s文件）。\n编译main.c文件：\ngcc -c main.c -o main.o\n编译helper.c文件：\ngcc -c helper.c -o helper.o\n这将生成main.o和helper.o两个目标文件。\n链接（Linking）： 接下来，我们使用GCC编译器将目标文件链接在一起，生成最终的可执行程序。\n链接目标文件生成可执行程序：\ngcc main.o helper.o -o program\n这将生成名为program的可执行文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"完成上述步骤后，你将得到一个名为program的可执行程序，可以通过执行./program来运行它。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"需要注意的是，上述示例中的程序较简单，只包含两个源文件。对于更复杂的项目，可能涉及多个源文件和库文件，并可能需要更复杂的编译和链接规则。在这种情况下，使用make和makefile来自动化构建过程会更加方便和灵活。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/#来个例子吧","page":"make和Makefile介绍","title":"来个例子吧","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"我需要给学生展示：写个c语言源代码，然后手动编译，一步一步的编译连接生成可执行程序这个过程。使用msys2，mingw64工具链。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"当然，我可以帮你完成这个任务。以下是一个示例的C语言源代码，以及一步一步的编译连接过程，使用MSYS2和MinGW-w64工具链。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"首先，你需要安装MSYS2和MinGW-w64。你可以从官方网站下载并按照说明进行安装。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"然后，创建一个名为 hello.c 的文本文件，将以下代码复制并粘贴进去：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"#include <stdio.h>\n\nint main() {\n    printf(\"Hello, World!\\n\");\n    return 0;\n}","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"保存并关闭文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"接下来，打开MSYS2终端，进入你保存 hello.c 文件的目录。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"执行以下命令来安装所需的编译工具：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"pacman -S mingw-w64-x86_64-toolchain","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"安装完成后，执行以下命令来编译 hello.c 文件：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"gcc -o hello hello.c","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"这将使用GCC编译器将 hello.c 文件编译为可执行文件 hello.exe。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"最后，执行以下命令来运行可执行文件：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"./hello","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"终端将输出 Hello, World!。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"这就是使用MSYS2和MinGW-w64工具链编译和运行C语言程序的过程。你可以将这些步骤展示给学生，让他们了解C语言程序的编译和执行过程。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"先编译到汇编代码，然后编译到目标代码，再连接，分步展示。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"非常抱歉，我误解了你的要求。下面是一个逐步展示编译到汇编代码、编译到目标代码，以及连接的过程。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"假设你已经按照之前提到的步骤安装了MSYS2和MinGW-w64工具链。接下来，我们将使用以下C语言源代码作为示例，并命名为 hello.c：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"#include <stdio.h>\n\nint main() {\n    printf(\"Hello, World!\\n\");\n    return 0;\n}","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"请按照以下步骤逐步编译、连接和运行代码：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"步骤 1: 编译到汇编代码","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"在MSYS2终端中，进入 hello.c 文件所在的目录。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"执行以下命令，将C源代码编译为汇编代码：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"gcc -S -o hello.s hello.c","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"这将生成一个名为 hello.s 的汇编代码文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"步骤 2: 编译到目标代码","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"继续执行以下命令，将汇编代码编译为目标代码：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"gcc -c -o hello.o hello.s","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"这将生成一个名为 hello.o 的目标代码文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"步骤 3: 连接生成可执行程序","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"最后，执行以下命令将目标代码文件连接起来生成可执行程序：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"gcc -o hello hello.o","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"这将生成一个名为 hello 的可执行文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"步骤 4: 运行程序","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"执行以下命令运行可执行程序：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"./hello","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"终端将输出 Hello, World!。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"通过按照以上步骤，你可以逐步展示将C语言源代码编译到汇编代码，再编译到目标代码，最后连接生成可执行程序的过程。学生可以观察每个阶段生成的文件，以及最终的输出结果。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"请使用分立的两个源文件，便于理解连接。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"当然，我理解了你的要求。下面是一个示例，使用两个分离的源文件来展示编译、汇编、目标代码生成以及连接的过程。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"首先，创建一个名为 main.c 的文件，包含以下代码：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"#include <stdio.h>\n\nextern void printHello();\n\nint main() {\n    printHello();\n    return 0;\n}","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"接下来，创建一个名为 hello.c 的文件，包含以下代码：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"#include <stdio.h>\n\nvoid printHello() {\n    printf(\"Hello, World!\\n\");\n}","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"现在，我们将逐步展示编译、汇编、目标代码生成和连接的过程。请按照以下步骤进行：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"步骤 1: 编译到汇编代码","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"在MSYS2终端中，进入包含 main.c 和 hello.c 文件的目录。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"执行以下命令，将 main.c 编译为汇编代码 main.s：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"gcc -S -o main.s main.c","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"执行以下命令，将 hello.c 编译为汇编代码 hello.s：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"gcc -S -o hello.s hello.c","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"步骤 2: 汇编到目标代码","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"继续执行以下命令，将 main.s 和 hello.s 文件汇编为目标代码：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"gcc -c -o main.o main.s\ngcc -c -o hello.o hello.s","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"这将生成 main.o 和 hello.o 两个目标代码文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"步骤 3: 连接生成可执行程序","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"最后，执行以下命令将 main.o 和 hello.o 文件连接起来生成可执行程序：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"gcc -o hello main.o hello.o","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"这将生成一个名为 hello 的可执行文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"步骤 4: 运行程序","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"执行以下命令运行可执行程序：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"./hello","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"终端将输出 Hello, World!。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"通过按照以上步骤，你可以展示将两个分离的源文件编译为汇编代码，然后汇编为目标代码，并最终将它们连接为可执行程序的过程。这将帮助学生更好地理解连接的概念和过程。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/#小结一下","page":"make和Makefile介绍","title":"小结一下","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"不论是C还是C++，通常我们首先将源文件编译成中间代码文件，Windows下为.obj文件，UNIX下为.o文件，也被称为目标文件（Object File）。这个过程称为编译（compile）。然后，我们将大量的目标文件链接在一起，生成可执行文件，这个过程称为链接（link）。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"在编译阶段，编译器需要确保语法的正确性以及函数和变量的声明正确。对于后者，通常需要告诉编译器头文件的位置（头文件中应该只包含声明，而定义应放在C/C++文件中）。只要所有语法正确，编译器就能生成中间目标文件。一般来说，每个源文件对应一个中间目标文件（.o文件或.obj文件）。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"在链接阶段，主要是链接函数和全局变量。因此，我们可以使用这些中间目标文件（.o文件或.obj文件）来链接我们的应用程序。链接器不关心函数所在的源文件，只关心函数的中间目标文件（Object File）。通常情况下，由于源文件较多，编译生成的中间目标文件也很多，而在链接时需要明确指出中间目标文件的名称，这对编译非常不方便。因此，我们需要将中间目标文件打包。在Windows下，这种打包方式称为“库文件”（Library File），即.lib文件；而在UNIX下，称为Archive File，即.a文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"总结一下，源文件首先会生成中间目标文件，然后使用这些中间目标文件生成可执行文件。在编译阶段，编译器只检查程序的语法和函数、变量的声明。如果函数未被声明，编译器会给出警告，但仍可以生成Object File。而在链接阶段，链接器会在所有的Object File中寻找函数的实现。如果找不到，就会报告链接错误（Linker Error）。在VC（Visual C++）下，这种错误通常为Link 2001错误，表示链接器无法找到函数的实现。你需要指定函数的Object File。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/#make和Makefile","page":"make和Makefile介绍","title":"make和Makefile","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/#为什么需要make和Makefile","page":"make和Makefile介绍","title":"为什么需要make和Makefile","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"如果我们的程序依赖成千上万的源代码，而且分布在不同的目录，我们能不能自动化的进行我们程序的构建？我们修改了某个文件，依赖这个文件的所有文件都应该重新编译，而不依赖它的文件应该不需要重新编译。有没有工具实现这一点？","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"当然有了。Makefile是一个用于自动化构建过程的文件，它定义了源代码文件的编译规则和依赖关系。尽管Windows的集成开发环境（IDE）通常会为程序员处理这些工作，但了解Makefile对于成为一名优秀和专业的程序员仍然很重要，就像了解HTML标签对于成为一名专业的前端开发人员一样。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"特别是在Unix系统下的软件编译过程中，你不能不自己编写Makefile。会不会编写Makefile从某种程度上反映了一个人是否具备完成大型工程的能力，因为Makefile涉及整个工程的编译规则。在一个工程中，源文件数量众多，按照类型、功能和模块分别存放在多个目录中。Makefile定义了一系列规则，指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至可以执行更复杂的功能操作，因为Makefile就像一个Shell脚本，可以执行操作系统命令。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"Makefile的好处在于实现了\"自动化编译\"。一旦编写完成，只需要运行一个make命令，整个工程将完全自动编译，大大提高了软件开发的效率。make是一个命令工具，用于解释Makefile中的指令。通常情况下，大多数集成开发环境都提供了make命令，例如Delphi的make、Visual C++的nmake，以及Linux下的GNU make。因此，Makefile已成为工程编译的一种常用方法。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"不同厂商的make工具语法各有不同，但它们的本质都是在处理\"文件依赖性\"。下面将主要介绍GNU make，因为它是应用最广泛、使用最多的make工具，并且符合IEEE 1003.2-1992标准（POSIX.2）。我们将以C/C++源码为基础，涉及一些与C/C++编译相关的知识。关于这方面的内容，请参考相关编译器的文档。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"Makefile定义就是依赖关系和生成规则。为什么我们没有采用上文的编译规则。因为Makefile定义的是更广泛的生成规则，例如文件A从它所依赖的文件B如何生成出来，而不仅仅是程序源文件的编译。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/#Makefile的一个例子","page":"make和Makefile介绍","title":"Makefile的一个例子","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"当涉及到分步编译和链接的过程时，Makefile可以帮助我们自动化这个过程。下面是一个简单的Makefile示例，展示了如何使用Makefile来编译和链接一个简单的C程序：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"# 定义编译器和编译选项\nCC = gcc\nCFLAGS = -Wall -g\n\n# 定义目标文件和依赖关系\nTARGET = myprogram\nOBJS = main.o utils.o\n\n# 默认目标，即执行make命令时的默认动作\nall: $(TARGET)\n\n# 链接目标文件生成可执行文件\n$(TARGET): $(OBJS)\n\t$(CC) $(CFLAGS) $^ -o $@\n\n# 编译每个源文件生成目标文件\n%.o: %.c\n\t$(CC) $(CFLAGS) -c $< -o $@\n\n# 清理生成的目标文件和可执行文件\nclean:\n\trm -f $(OBJS) $(TARGET)","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"在这个示例中，我们定义了以下几个内容：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"CC：编译器的名称，这里使用gcc。\nCFLAGS：编译选项，这里使用-Wall和-g，表示开启所有警告并生成调试信息。\nTARGET：目标可执行文件的名称，这里设为myprogram。\nOBJS：目标文件的名称列表，这里包括main.o和utils.o。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"Makefile中的规则包括：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"all：默认目标，执行make命令时的默认动作，依赖于TARGET。\n$(TARGET)：链接目标文件生成可执行文件，依赖于OBJS。\n$(OBJS)：编译每个源文件生成目标文件，依赖于对应的.c文件。\n%.o：通配符规则，用于编译每个源文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"最后，Makefile还包括了一个清理规则：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"clean：用于删除生成的目标文件和可执行文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"要使用这个Makefile，将其保存为名为\"Makefile\"（注意大小写）的文件，并将其与源文件放在同一目录下。然后在命令行中运行make命令即可自动编译和链接程序。如果需要清理生成的文件，可以运行make clean命令。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"请注意，该示例中的Makefile只是一个简单的示例，实际项目中可能需要更复杂的Makefile来处理更多的源文件和依赖关系。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/#时间戳是Make和Makefile决定哪些文件需要重新构建的依据","page":"make和Makefile介绍","title":"时间戳是Make和Makefile决定哪些文件需要重新构建的依据","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"时间戳是Make和Makefile决定哪些文件需要重新构建的依据之一。Make工具会比较目标文件和依赖文件的时间戳，根据时间戳的差异确定是否需要重新构建目标文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"在Makefile中，每个目标都有一组依赖文件，表示生成该目标所需要的源文件或其他中间文件。当执行make命令时，Make会检查目标文件和依赖文件的时间戳，如果依赖文件的时间戳比目标文件的时间戳更新，或者目标文件不存在，那么Make就会执行相应的规则重新构建目标文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"通过比较时间戳，Make可以避免无需重新构建的部分，从而提高编译的效率。只有在源文件或依赖文件发生了变化，或者目标文件不存在时，Make才会重新构建目标文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"需要注意的是，时间戳并不是唯一的依据，Make还会根据文件的依赖关系、规则和命令等进行判断。但时间戳是其中一个重要的判断因素，用于确定哪些文件需要重新构建。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/#make的一些变种","page":"make和Makefile介绍","title":"make的一些变种","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"除了传统的Makefile，还有一些Makefile的变种工具，每个工具都有自己的特点和使用场景。下面是一些常见的Makefile变种工具：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"QMake：QMake是Qt框架提供的一个构建工具。它使用一种简化的语法来描述项目的构建过程，并能够自动生成传统Makefile。QMake主要用于Qt项目的构建，可以跨平台使用。\nNMake：NMake是微软提供的用于Windows平台的构建工具。它使用一种类似于Makefile的语法，并支持Windows平台上的命令和工具。NMake通常与Microsoft Visual Studio一起使用，用于构建Windows平台上的C/C++项目。\nWmake：WMake是OpenFOAM（开源计算流体力学软件）项目中自定义的构建工具，用于管理和构建OpenFOAM的源代码和应用程序。OpenFOAM是一个开源的数值计算软件库，用于模拟流体动力学问题。\nCMake：CMake是一个跨平台的构建工具，它可以生成不同平台上的原生构建脚本（如Makefile、Visual Studio项目等）。CMake使用一种类似于脚本的语法描述项目的构建过程，并具有很高的可移植性和灵活性。CMake广泛应用于C/C++项目的构建。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"这些变种工具都是为了简化和自动化项目的构建过程，并提供特定平台或框架的支持。根据项目的需求和开发环境的不同，可以选择合适的构建工具来管理和构建项目。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/#关于cmake再多说一点","page":"make和Makefile介绍","title":"关于cmake再多说一点","text":"","category":"section"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"CMake是一个跨平台的开源构建工具，用于管理和自动生成用于构建项目的原生构建脚本，例如Makefile、Visual Studio项目等。它旨在简化跨平台项目的构建过程，提供高度可移植性和灵活性。CMake使用一种名为CMakeLists.txt的文本文件来描述项目的构建规则。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"CMakeLists.txt是CMake的配置文件，其中包含了项目的构建规则和指令。下面是一个简单的CMakeLists.txt示例：","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"cmake_minimum_required(VERSION 3.12)  # 指定所需的最低CMake版本\n\nproject(MyProject)  # 设置项目名称\n\n# 添加源文件\nset(SOURCES\n    src/main.cpp\n    src/foo.cpp\n    src/bar.cpp\n)\n\n# 添加可执行目标\nadd_executable(myapp ${SOURCES})\n\n# 添加头文件搜索路径\ninclude_directories(include)\n\n# 添加链接库\ntarget_link_libraries(myapp mylib)","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"在CMakeLists.txt中，首先使用cmake_minimum_required指令指定所需的最低CMake版本。然后使用project指令设置项目名称。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"接下来，通过使用set指令定义一个变量（这里是SOURCES），用于存储源文件的路径。可以根据项目的实际情况添加更多的源文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"使用add_executable指令创建一个可执行目标，将变量SOURCES中的源文件编译为可执行文件（这里是myapp）。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"使用include_directories指令添加头文件搜索路径，以便编译器能够找到所需的头文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"最后，使用target_link_libraries指令添加链接库（这里是mylib）到目标可执行文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"CMakeLists.txt还支持其他各种指令和选项，可以根据项目的需求进行配置。CMake具有丰富的文档和社区支持，可以更深入地了解其功能和用法。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"要构建项目，可以在命令行中使用CMake来生成适用于特定构建系统的构建文件（例如Makefile或Visual Studio项目），然后使用生成的构建文件来进行编译和构建。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"总的来说，CMake提供了一种简洁而强大的方式来管理项目的构建过程，使得在不同平台和构建系统上的项目构建变得更加灵活和可维护。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"注意：CMake可以根据CMakeLists.txt生成Makefile或者Visual studio的项目文件。","category":"page"},{"location":"CSBase/5-make和Makefile介绍/","page":"make和Makefile介绍","title":"make和Makefile介绍","text":"关于make和Makefile可以参考这里获得更多的信息。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#以CoolProp为例的实操","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/#引言","page":"以CoolProp为例的实操","title":"引言","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"热力学图表是所有能动学生都会要用到的工具。通常是在学习工程热力学时发的热力学图表。图表主要是用来查水的物性，焓、熵等。水会发生相变。热力学图表的知识参考工程热力学教材。现在学生们都用纸本的，远远落后于时代。我们要是能做个网页，可以在网页上查看不同的图多酷啊，要是还能导出相应的数值就更好了，而且提供api调用就完美了。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"理解从背后计算到前台漂亮的页面是如何实现的，这是我们此篇文档的目的。至于物性到底如何计算，那则是能动学院科研工作之一。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#RefProp是什么","page":"以CoolProp为例的实操","title":"RefProp是什么","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"Refprop 是一个流体物性计算程序，用于计算和估算各种流体的热力学和传输性质。它由美国国家标准技术研究所（NIST）开发，旨在提供精确和可靠的流体物性数据。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"Refprop 可以计算多种流体的性质，包括气体、液体和超临界流体。它可以计算的性质包括密度、压力、温度、比热容、粘度、导热系数、表面张力等。这些性质对于工程领域中的设计和分析非常重要，特别是在化学工程、能源系统和制冷空调等领域。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"Refprop 使用的基础是经过验证和广泛接受的热力学模型和实验数据。它包含了大量的流体物性数据，可以用于估算各种温度、压力和组分条件下的性质。用户可以通过输入流体的组分、温度和压力等参数，获得所需的物性计算结果。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"Refprop 还提供了一个用户友好的界面，使用户能够轻松地进行输入和输出。它支持多种编程语言，如Fortran、C++、Python等，可以与其他软件和模拟工具集成使用。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"需要注意的是，Refprop 是一款商业软件，需要购买和许可才能使用。NIST 提供了关于 Refprop 的详细文档和支持，帮助用户正确使用和理解软件的功能和限制。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"总而言之，Refprop 是一款流体物性计算程序，可用于计算和估算各种流体的热力学和传输性质。它是工程领域中重要的工具，用于设计和分析化学工程、能源系统和制冷空调等领域的应用。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#CoolProp又是什么","page":"以CoolProp为例的实操","title":"CoolProp又是什么","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"CoolProp 是一个开源的流体物性计算库，用于计算和估算各种流体的热力学和传输性质。它由一组开发者在多个国家合作开发，旨在提供高精度、可靠且易于使用的流体物性数据。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"与 Refprop 不同，CoolProp 是一个免费的开源软件，可以在各种操作系统上使用，包括 Windows、Linux 和 macOS。它支持多种编程语言，如Python、C++、Matlab 等，可以与其他软件和模拟工具进行集成。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"CoolProp 提供了广泛的流体物性计算功能，可以计算包括气体、液体、超临界流体在内的多种流体的性质。它可以计算的性质包括密度、压力、温度、比热容、粘度、导热系数、表面张力等。除了常见的单组分流体，CoolProp 还支持混合物和多组分流体的计算。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"CoolProp 的优势之一是它提供了多种流体物性模型和方程式，以适应不同流体和应用的需求。它包括了广泛验证的热力学模型和实验数据，以提供准确的计算结果。此外，CoolProp 还提供了适用于不同工程领域的专用函数和接口，简化了复杂流体系统的建模和分析过程。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"CoolProp 的开源特性使得用户可以自由地使用、修改和分享代码。同时，它也有一个活跃的社区，用户可以通过论坛和邮件列表获取支持和交流。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"总结起来，CoolProp 是一个免费的开源流体物性计算库，用于计算和估算各种流体的热力学和传输性质。它提供了广泛的计算功能和模型选择，并支持多种编程语言和操作系统。CoolProp 在工程领域中被广泛应用于化学工程、能源系统、制冷空调等领域的设计和分析。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#Step-by-Step","page":"以CoolProp为例的实操","title":"Step by Step","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"找本工程热力学书看一看，找一本热力学图表看一看，理解一下热力学图表。\n看一看这里, 看看网页形式如何呈现。\n看一看CoolProp的在线接口https://ibell.pythonanywhere.com/， 了解如何通过网页查取相应的数据。\n编译RefProp，生成相应的dll。（此篇覆盖）\n使用julia安装一下CoolProp，使用一下其julia界面。（此篇不覆盖）\n使用http.jl把coolprop封装成一个服务。（此篇不覆盖）\n用JavaScript做个前端页面。（此篇不覆盖）","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#编译RefProp生成dll","page":"以CoolProp为例的实操","title":"编译RefProp生成dll","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/#获取RefProp安装包","page":"以CoolProp为例的实操","title":"获取RefProp安装包","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"获取RefProp的安装包。（通过baidu搜索）","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"Refprop 是一款商业软件，需要购买和许可才能获取安装包。您可以通过以下步骤获取 Refprop 的安装包：","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"访问美国国家标准技术研究所（NIST）的网站：https://www.nist.gov/srd/refprop\n在 NIST 网站上，您可以找到关于 Refprop 的详细信息和文档。阅读相关信息，了解软件的功能、价格和许可方式。\n在 NIST 网站上选择 \"Order Refprop\" 或类似的选项，该选项将引导您到购买页面。\n根据您的需求选择合适的许可类型（例如个人、教育或商业许可）和版本（例如 Windows 或 Linux），然后点击 \"Add to Cart\"（添加到购物车）。\n跟随购买流程，提供所需的信息，并完成支付。购买后，您将收到许可证和相关的安装文件。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"请注意，购买 Refprop 是需要支付费用的，具体费用和许可方式可能因版本和许可类型而有所不同。建议在购买前仔细阅读 NIST 网站上的相关信息，确保了解软件的使用限制和许可条款。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"如果您需要更详细的购买指南或有其他问题，建议直接与 NIST 或 Refprop 的官方联系，以获取准确的购买信息和支持。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#安装RefProp","page":"以CoolProp为例的实操","title":"安装RefProp","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"安装 Refprop 需要购买该商业软件并获得许可证。一旦您购买了 Refprop 的许可证，并收到了安装文件，可以按照以下步骤安装 Refprop：","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"下载安装文件：从获得许可证的来源（通常是 NIST）下载 Refprop 的安装文件。确保下载与您的操作系统兼容的版本。\n解压安装文件：将下载的安装文件解压缩到您选择的目标位置。这将创建一个包含 Refprop 安装所需文件的文件夹。\n运行安装程序：进入解压后的文件夹，并找到安装程序。根据您的操作系统，可能是一个可执行文件（.exe）或脚本文件。双击运行该程序。\n跟随安装向导：安装程序会启动一个安装向导，引导您完成安装过程。按照屏幕上的指示逐步进行，选择安装选项、目标文件夹和其他配置选项。\n完成安装：安装程序将复制所需的文件并配置系统设置。完成安装后，您将收到安装成功的确认消息。\n激活许可证：根据您的许可证要求，可能需要在安装过程中或安装完成后激活许可证。按照提供的指南和说明进行操作，确保许可证被正确激活。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"请注意，Refprop 是一款专业的流体物性计算软件，使用前需要购买合法的许可证。确保遵守相关许可协议和使用条款。如果您在安装过程中遇到问题或需要更多支持，请联系 Refprop 的官方渠道或与购买许可证的机构进行联系。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#RefProp如何使用？","page":"以CoolProp为例的实操","title":"RefProp如何使用？","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"Refprop提供了基于图形用户界面（GUI）的安装程序，用于在Windows系统上使用。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"以下是使用Refprop GUI界面的一般步骤：","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"安装Refprop：按照之前提到的步骤购买和安装Refprop软件。确保您选择了适合您操作系统的版本。\n启动Refprop GUI：安装完成后，在您的计算机上找到Refprop安装目录。在该目录中，您应该能够找到一个可执行文件（.exe），通常命名为Refprop.exe。双击运行该文件以启动Refprop GUI。\n导入或输入数据：在Refprop GUI中，您可以通过导入数据文件或手动输入数据来定义要计算的流体和条件。根据Refprop的界面设计，提供相关的输入框、下拉菜单和按钮等，以便您输入组分、温度、压力等参数。\n运行计算：配置完输入数据后，通过点击运行按钮或相关选项启动计算。Refprop将使用您提供的输入数据进行流体物性计算。\n查看和分析结果：一旦计算完成，Refprop GUI将提供计算结果的可视化和分析选项。您可以查看计算得到的物性数据、图表或其他结果。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"请注意，Refprop GUI的界面和操作方式可能会因不同版本和更新而有所不同。确保参考Refprop的文档、帮助文件或相关指南，以了解如何使用特定版本的GUI界面。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"如果您在使用Refprop GUI过程中遇到任何问题，我建议您查阅Refprop的文档、联系Refprop的支持团队或查找相关的用户社区和论坛，以获取更详细的指导和支持。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#RefProp的编程语言调用接口","page":"以CoolProp为例的实操","title":"RefProp的编程语言调用接口","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"Refprop 提供了几种编程语言的调用接口，使开发者能够在自己的程序中集成和调用 Refprop 的功能。以下是一些常用的编程语言调用接口：","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"C/C++ 接口：Refprop 提供了 C/C++ 的接口，允许开发者使用 C/C++ 语言调用 Refprop 的函数和子程序。这种接口允许直接的编程访问和控制 Refprop 的计算过程。\nFortran 接口：Refprop 还提供了 Fortran 的接口，允许开发者使用 Fortran 语言调用 Refprop 的子程序。这个接口与 Fortran 语言的特性和调用约定相匹配，方便 Fortran 开发者集成 Refprop。\nMATLAB 接口：Refprop 还提供了用于 MATLAB 的接口。这个接口允许 MATLAB 用户在 MATLAB 环境中直接调用 Refprop 的函数和计算物性。\nPython 接口：Refprop 提供了用于 Python 的接口，允许开发者使用 Python 调用 Refprop。这个接口使用了 Python 的 C API，并提供了 Pythonic 的接口风格，方便 Python 开发者进行流体物性计算。\nExcel 接口：Refprop 还提供了用于 Excel 的接口，使用户能够在 Excel 中使用自定义的函数和公式来调用 Refprop 进行计算。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"这些接口提供了调用 Refprop 功能的便捷方式，使开发者能够在自己的程序中利用 Refprop 的流体物性计算能力。通过使用这些接口，开发者可以按照自己的需要调用 Refprop 的函数，传递输入参数并获取计算结果。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"具体使用每种编程语言的接口时，需要参考 Refprop 的官方文档和相关的编程指南，以了解接口的具体用法和调用方法。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"请注意，不同的编程语言接口可能有所不同，并且在使用这些接口之前，您需要确保正确配置和连接 Refprop 的库和头文件，并遵循相应的调用约定和接口规范。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"参考这里获得官方的例子","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#RefProp的编译","page":"以CoolProp为例的实操","title":"RefProp的编译","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"官方的说明在这里。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"我们进入REFPROP安装目录，可以看到有个FORTRAN文件夹， 这里就是RefProp的源代码。看到有个REFPROP.EXE，这就是RefProp的可执行文件。还有个refprop.dll，这就是计算内核，是一个动态链接库。还有个REFPRP64.DLL是64位的动态链接库。我们编译RefProp就是从fortran源文件生成这个dll。至于想学它的fortran代码是如何写的，可以打开FORTRAN 文件夹中的文件，研究一下。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"RefProp的编译流程如下：","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"克隆 REFPROP-cmake 仓库：通过执行以下命令来克隆 REFPROP-cmake 仓库到本地：","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"git clone --recursive https://github.com/usnistgov/REFPROP-cmake.git","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"复制 REFPROP 安装目录下的 FORTRAN 文件夹：将 REFPROP 安装目录下的 FORTRAN 文件夹复制到克隆的代码库的根目录中。\n打开命令行终端：在克隆的代码库根目录下打开命令行终端。\n创建 build 目录：执行以下命令创建一个名为 build 的目录：","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"mkdir build","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"进入 build 目录：执行以下命令进入 build 目录：","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"cd build","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"配置 CMake 构建系统：执行以下命令配置 CMake 构建系统：","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"cmake .. -DCMAKE_BUILD_TYPE=Release","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"这将使用 Release 模式配置 CMake 构建系统，生成 Release 版本的库。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"构建 RefProp：执行以下命令开始构建 RefProp 库：","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"cmake --build .","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"这将根据 CMake 配置文件开始构建 RefProp，并生成相应的库文件。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"完成上述步骤后，将生成的共享库文件放置在操作系统能够找到的位置。在 Windows 上，可以将库文件添加到 PATH 环境变量中。在 macOS 上，可以放置在默认的共享库位置之一。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"请注意，在不同的操作系统上可能会有一些特定的配置步骤和注意事项。如果遇到问题，建议查阅 RefProp 的官方文档和相关的编译指南，以获取更详细的指导和解决方案。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#到底如何调用呢？","page":"以CoolProp为例的实操","title":"到底如何调用呢？","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"我们写的文档已经说过了如何调用dll，这个问题逻辑上已经解决。而且RefProp官方提供了不同的语言调用的例子。","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"再说一次，参考这里获得官方的例子","category":"page"},{"location":"CSBase/8-以CoolProp为例的实操/#最后再多说一句","page":"以CoolProp为例的实操","title":"最后再多说一句","text":"","category":"section"},{"location":"CSBase/8-以CoolProp为例的实操/","page":"以CoolProp为例的实操","title":"以CoolProp为例的实操","text":"我们发现好多东西都在github上啊。请自行学习github是啥，如何使用。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/#Windows的命令提示符简介","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"","category":"section"},{"location":"CSBase/1-Windows命令提示符介绍/#命令提示符初接触","page":"Windows的命令提示符简介","title":"命令提示符初接触","text":"","category":"section"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"很多同学计算机方面一上来接触的就是Windows系统，很容易认为计算机就是拿鼠标点点点。即使学了编程入门的一些课程（如C语言、Fortran语言等），也只是在集成开发环境（IDE，Integrated Development Environment）上点点鼠标，难以理解系统是如何工作的。那我们就非常简要的介绍一下命令行界面（Command Line Interface，CLI）和图形用户界面（Graphical User Interface，GUI）。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"我们刚接触计算机那会儿，微软的操作系统还是DOS系统，就是命令行界面。就是要做什么事都通过打一条命令告诉电脑。后来微软进一步开发了图形用户界面系统（Windows），此时看起来就很友好，并且很多事情可以通过鼠标点击来完成。实际上，Windows系统保留了对命令行界面的兼容，可以在开始菜单找到命令提示符（本质就是cmd.exe）。我们打开命令提示行程序，可以看到它长这样：","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"(Image: 图 1)","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"我们可以在这个界面里头输入dir回车，就会显示当前目录下的内容列表。我们可以用cd切换目录。我们可以用copy进行文件复制。具体这些都是DOS的基本命令，可以查看相应的手册获得更多的认识。在DOS时代，我们会区分内部命令和外部命令。内部命令常驻内存，而外部命令是一条单独的可执行文件。这样说来可能有点抽象。我们可以以一个例子来说明。我们平时使用的浏览器如Edge, 它本质是一个命令msedge.exe，这是一个文件提供的，在我的系统里是\"C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe\"。这可以认为是一个外部命令。而之前提到的dir、cd等可以认为是内部命令，就是有命令提示符自己就提供了的。那我们的外部写的程序实际上都可以通过命令行启动。如上面提到的msedge.exe，我们在命令提示符下输入msedge.exe回车。系统会提示找不到'msedge.exe'不是内部或外部命令。这是因为系统找不到msedge.exe这个文件。那我们可以给全路径，输入C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe 这个来定位，这里因为路径中有空格，我们再使用\"\"把它包起来，输入\"C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe\"回车就启动了Edge浏览器。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"我们的桌面上或者开始菜单里头有很多的快捷方式，供我们点它的时候启动对应的程序。实际上我们在这些快捷方式上右键，选择属性，在“目标”那里就可以看到具体的启动命令。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/#CMD简介","page":"Windows的命令提示符简介","title":"CMD简介","text":"","category":"section"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"Windows 的命令提示符（Command Prompt，简称 CMD）是一种在 Windows 操作系统上使用的命令行界面。它允许用户通过键入特定命令来与计算机进行交互和执行各种任务。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"CMD 提供了一种以文本形式输入和执行命令的方式，可以控制文件和文件夹的操作，管理系统设置，运行脚本和程序等。下面是一些 CMD 命令的常见用途和示例：","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"目录操作：\ncd：改变当前目录。例如，cd Documents 将当前目录更改为 \"Documents\"。\ndir：列出当前目录中的文件和文件夹。\nmkdir：创建新文件夹。例如，mkdir MyFolder 将创建名为 \"MyFolder\" 的文件夹。\n文件操作：\ncopy：复制文件。例如，copy file1.txt file2.txt 将文件 \"file1.txt\" 复制到 \"file2.txt\"。\ndel：删除文件。例如，del file.txt 将删除名为 \"file.txt\" 的文件。\nrename：重命名文件。例如，rename old.txt new.txt 将文件名从 \"old.txt\" 改为 \"new.txt\"。\n系统信息：\nsysteminfo：显示关于计算机系统的详细信息，如操作系统版本、安装日期等。\nipconfig：显示网络配置信息，如 IP 地址、子网掩码等。\ntasklist：列出当前正在运行的进程。\n网络操作：\nping：测试与特定 IP 地址的连接。例如，ping www.example.com 将向 \"www.example.com\" 发送网络请求并显示响应时间。\ntracert：跟踪数据包的路径，显示从源到目的地经过的网络节点。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"这只是 CMD 命令的一小部分，还有许多其他命令可用于不同的任务。您可以在命令提示符窗口中键入 help 或 /? 来获取关于特定命令的更多帮助信息。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"请记住，在使用 CMD 时要小心，确保您了解您要执行的命令的含义和影响，以免意外删除或更改了重要文件。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/#如何进入CMD","page":"Windows的命令提示符简介","title":"如何进入CMD","text":"","category":"section"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"您可以按照以下步骤在 Windows 中进入 CMD（命令提示符）：","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"打开开始菜单：单击桌面左下角的 Windows 图标或按下键盘上的 Windows 键。\n打开 CMD：在开始菜单的搜索栏中，键入 \"cmd\"（不包括引号）。\nWindows 10 及更高版本：在搜索结果中，点击 \"命令提示符\" 或 \"Command Prompt\"。\nWindows 8 和 8.1：在开始菜单中，直接输入 \"cmd\"，然后点击 \"命令提示符\"。\nWindows 7：在开始菜单中，点击 \"所有程序\"，找到 \"附件\" 文件夹，然后点击 \"命令提示符\"。\n运行 CMD：点击打开的 \"命令提示符\" 程序，将打开一个新的命令提示符窗口。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"另外，还有一种快捷方式是使用键盘快捷键：","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"按下 Windows 键 + R 组合键，将打开 \"运行\" 对话框。\n在 \"运行\" 对话框中，键入 \"cmd\"（不包括引号）并按下回车键。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"无论您使用哪种方式，都将打开一个命令提示符窗口，您可以在其中输入和执行各种命令。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/#快捷方式与命令行启动程序的关系","page":"Windows的命令提示符简介","title":"快捷方式与命令行启动程序的关系","text":"","category":"section"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"快捷方式和命令行启动程序是两种不同的方式来打开应用程序或执行命令。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"快捷方式是一个指向特定应用程序或文件的快速访问方式。它通常是一个图标，您可以在桌面、开始菜单、任务栏或文件夹中找到。通过点击快捷方式，您可以快速启动相应的应用程序或打开文件。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"命令行启动程序是通过在命令提示符（CMD）或终端窗口中输入特定命令来启动应用程序或执行命令的过程。通过在命令提示符中键入应用程序的可执行文件的路径和参数，您可以直接启动应用程序，而无需依赖图形界面中的快捷方式。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"虽然快捷方式提供了一种图形化的、可视化的方式来打开应用程序，但命令行启动程序提供了更灵活和精确的控制。通过命令行，您可以指定特定的参数、选项和路径，从而自定义应用程序的行为。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"例如，在快捷方式上，您可以单击图标来启动文本编辑器应用程序并打开一个文件。而通过命令行，您可以在命令提示符中输入编辑器的可执行文件路径以及文件的路径和名称，实现同样的效果。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"总而言之，快捷方式提供了一种直观、可视化的方式来访问应用程序，而命令行启动程序则提供了一种更直接、可自定义的方式来控制应用程序的启动和行为。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/#如何查看快捷方式的实质？","page":"Windows的命令提示符简介","title":"如何查看快捷方式的实质？","text":"","category":"section"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"要查看快捷方式的实质（即指向的目标），您可以执行以下步骤：","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"找到要查看的快捷方式。它可能位于桌面、开始菜单、任务栏或文件夹中。\n右键单击该快捷方式，然后从弹出菜单中选择 \"属性\"（或类似的选项）。这将打开快捷方式属性对话框。\n在属性对话框的 \"快捷方式\" 选项卡中，您将看到一些关于该快捷方式的信息。\n\"目标\" 字段显示了快捷方式指向的实际目标文件或应用程序的路径。例如，对于一个指向 \"C:\\Program Files\\Example\\app.exe\" 的快捷方式，\"目标\" 字段将显示该路径。\n\"起始位置\" 字段指示快捷方式所在的文件夹路径。\n\"快捷键\" 字段显示了为快捷方式设置的热键组合（如果有的话）。\n\"运行\" 字段允许您选择以何种方式运行该快捷方式，如普通窗口、最大化、最小化等。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"通过查看 \"目标\" 字段，您可以确定快捷方式实际指向的文件或应用程序的位置。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"请注意，某些快捷方式可能指向其他快捷方式，而不是直接指向目标文件。在这种情况下，您可以重复上述步骤来查看目标快捷方式的属性，直到找到最终的目标文件或应用程序。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"此外，您还可以直接右键单击快捷方式，然后选择 \"打开文件位置\" 或类似的选项，以在资源管理器中打开快捷方式所在的文件夹。从文件夹中，您可以进一步探索目标文件或应用程序的位置和属性。","category":"page"},{"location":"CSBase/1-Windows命令提示符介绍/#视频地址","page":"Windows的命令提示符简介","title":"视频地址","text":"","category":"section"},{"location":"CSBase/1-Windows命令提示符介绍/","page":"Windows的命令提示符简介","title":"Windows的命令提示符简介","text":"命令提示符和环境变量","category":"page"},{"location":"CSBase/3-环境变量及其设置/#环境变量简介","page":"环境变量简介","title":"环境变量简介","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/#环境变量初接触","page":"环境变量简介","title":"环境变量初接触","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"我们都听过环境、环境变量等等名词。那么，它的本质到底是什么呢？","category":"page"},{"location":"CSBase/3-环境变量及其设置/#命名","page":"环境变量简介","title":"命名","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"假设现在有一个程序对象：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"akdhihei","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"你知道这是个什么高级语法吗？","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"对的，这就是我胡乱打的，我也不知道它是什么。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"那么再看一个对象：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"path","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"这可能就有些熟悉了，配置过环境的同学都知道，path是我们的环境变量。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"再看：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"a","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"a又是什么呢？与上面的path类比，那么a就是一个变量呗！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"那么这个变量有什么含义吗？没有！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"那么现在再反问，上面的path有意义吗？","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"你可能说：有！它是环境变量！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"但是上面那个path是谁的环境变量，它又指向了谁！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"你可能有一点点明白了！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"这些变量：akdhihei、path、a他们都是变量，本质可以说是容器可以存放值，也可以说是一个程序的对象，它本身没有意义！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"它就是一个名称罢了，我们称之为命名。","category":"page"},{"location":"CSBase/3-环境变量及其设置/#环境","page":"环境变量简介","title":"环境","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"那么，怎样才能让命名有意义呢？","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"没错，就是给他赋值！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"也可以说，没有值的变量并没有存在的意义","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"（你是不是联想到了，你写Python，Java的时候，当你没有使用某个变量，没有赋值，只是定义的时候，编辑器会有小波浪，向你提出warnings！）","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"现在你应该明白了，定而不用，就是没有意义，没有价值，浪费内存资源。因为这个内存（地址）就被占了。用一句话概括就是，占着茅坑不拉屎！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"为了让它有意义，应该干嘛？赋值！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"比如:","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"#define a 5\n\n#define akdhihei 8","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"那么现在可以说，这些被命名的对象们有了意义。它们和某一个具体的值联系起来了，后面的程序中，你看到a就知道它代表5！看到akdhihei就知道它代表8！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"print(a + 1)","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"你一定知道这个程序的结果是什么。而在a被赋值之前，你并不知道！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"那么这个操作的本质是什么呢？","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"是值与符号进行关联，关联之后，又可以通过符号提取数值。那么这是怎么做到的呢？解释器会维护着这样一种储存能力，以便保持着有关的名字-值对偶的关联！","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"而这种存储，就被称之为环境，（更加准确是，全局环境），那么局部变量，和其它不同作用域，就是不同的环境！这就是环境的本质！","category":"page"},{"location":"CSBase/3-环境变量及其设置/#path环境变量","page":"环境变量简介","title":"path环境变量","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"刚刚所说的是广义的环境。那么以path代表的环境变量是环境概念下的子集。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"以python环境为例，在没有配置python环境之前，你在CMD终端中输入python，会显示","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"'python' 不是内部或外部命令，也不是可运行的程序或批处理文件。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"而你把python环境配置一下之后，就可以了。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"那其中到底干了什么呢？","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"其本质就是，path是一个变量，里面储存着一些文件的路径。在CMD命令行中输入命令的时候，系统会去path里面找相应的程序（或者在写程序的时候对调用path的路径等等）。比如说你的python.exe 路径为\"E:/\"，你把\"E:/\"加入到环境变量path中，那么就可以找到了，就可以在终端中运行了。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"那么，这个概念依旧是名字-值的关联。path是名字，文件路径是\"E:/\"，环境变量这个狭义概念的赋予是因为，在windows系统中，CMD会通过path中提供的路径去搜寻，如果没有在path中配置（把路径赋值给path），就找不到，就可以通过CMD执行（你手动进入那个文件夹，鼠标点击运行是一点问题也没有的！）。这相当于在Windows下的一个CMD运行环境path，CMD是系统级别的，所以这个环境比较高级。上面的a=5这个环境就很不重要了！但他们的本质都是一样的——","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"那就是字符（名称）-值的关联。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"配置环境=把变量（path）和值（文件路径）关联上这一行为过程","category":"page"},{"location":"CSBase/3-环境变量及其设置/#再解释一下","page":"环境变量简介","title":"再解释一下","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"我们在命令提示符下输入msedge.exe时提示不是内部或者外部命令，而输入全路径（目录）的时候就没有问题。实际上，我们输入命令的时候，系统会在一些目录里去寻找是否有对应的命令。如果有就执行它，如果没有就冒出上面的提示。而如果输入全路径，则在给定的路径（目录）里去寻找对应的命令。这里说到的“一些目录”就是有系统的一个环境变量（PATH）所记录的目录。Windows下的PATH环境变量是以\";\"分割的若干个值，每个值是一个目录。Windows下的PATH环境变量可以通过\"此电脑\"->\"属性\"->\"高级系统设置\"->\"环境变量\"打开，选中Path，再点\"编辑\"就可以修改Path环境变量了。如果我们新建一条，把msedge.exe所在的目录加进去，然后确认退出。那再在命令提示符下就可以直接以msedge.exe启动浏览器了，而不需要再输入全路径。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"Linux下的PATH环境变量是以\":\"分割的若干个值，每个值就是一个目录。如果使用的是bash，可以以export PATH=/new/directory:\\$PATH命令临时修改PATH环境变量。也可以放在~/.bashrc里使得每次登录Linux的时候对PATH的修改都是有效。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"linux下最重要的几个环境变量是PATH、INCLUDE_PATH 和 LD_LIBRARY_PATH。PATH决定命令到哪里去找（目录间有优先级哦，越靠近前面优先级越高），INCLUDE_PATH 决定编译程序的时候系统到哪里去找那些被包含的头文件，LD_LIBRARY_PATH 决定系统到哪里去找加载的共享链接库。Windows下类似。","category":"page"},{"location":"CSBase/3-环境变量及其设置/#到底什么是环境变量","page":"环境变量简介","title":"到底什么是环境变量","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"环境变量是操作系统中存储和管理配置信息的一种机制。它们是在操作系统中定义的命名值对，用于指定应用程序、脚本和系统组件之间的通信和交互。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"在Windows和Linux系统中，环境变量包含一些重要的配置信息，如系统路径、程序的安装路径、临时文件夹路径等。这些变量可以在系统的任何位置被访问和使用，而不需要硬编码在应用程序或脚本中。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"环境变量在操作系统和应用程序之间起到了桥梁的作用。它们提供了一种标准化的方法，使不同的程序能够共享配置信息，而不必直接修改源代码。通过使用环境变量，可以轻松地更改系统的配置，而无需重新编译或重新安装应用程序。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"在Windows系统中，可以使用图形界面或命令行工具（如系统属性、控制面板或set命令）来管理环境变量。在Linux系统中，可以通过命令行工具（如export、setenv等）来设置和修改环境变量。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"一些常见的环境变量包括：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"PATH：指定可执行程序的搜索路径，当我们在命令行中输入命令时，操作系统会按照PATH变量指定的路径搜索可执行程序。\nHOME：指定当前用户的主目录路径。\nJAVA_HOME：指定Java开发环境的安装路径。\nTEMP（或TMP）：指定用于存储临时文件的目录路径。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"通过设置环境变量，可以方便地配置系统和应用程序的行为，提高应用程序的灵活性和可移植性，并简化系统管理和部署的过程。","category":"page"},{"location":"CSBase/3-环境变量及其设置/#Windows下如何设置环境变量","page":"环境变量简介","title":"Windows下如何设置环境变量","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"在Windows系统中，有多种方法可以设置环境变量。下面我将介绍两种常用的方法：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"方法一：使用系统属性设置环境变量","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"右键点击计算机（或此电脑）图标，选择\"属性\"。\n在打开的窗口中，点击\"高级系统设置\"。\n在\"系统属性\"窗口中，点击\"环境变量\"按钮。\n在\"用户变量\"或\"系统变量\"部分，可以分别对当前用户或整个系统设置环境变量。选择对应的部分，点击\"新建\"按钮。\n输入环境变量的名称和值，然后点击\"确定\"。\n完成后，点击\"确定\"关闭所有打开的窗口。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"方法二：使用命令行设置环境变量","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"打开命令提示符（按Win+R，输入\"cmd\"，然后点击\"确定\"）或者使用PowerShell。\n使用以下命令设置用户级环境变量：\nsetx 变量名 \"变量值\"\n例如，要设置名为\"JAVA_HOME\"的环境变量，可以使用以下命令：\nsetx JAVA_HOME \"C:\\Java\\jdk\"\n如果要设置系统级环境变量，需要使用管理员权限运行命令提示符或PowerShell。\n执行命令后，将显示一个成功的消息。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"请注意，使用第一种方法设置的环境变量不会立即在已经打开的命令提示符或PowerShell窗口中生效。需要重新启动窗口或打开新的窗口才能使用新设置的环境变量。使用第二种方法设置的环境变量只会在当前回话中有效。","category":"page"},{"location":"CSBase/3-环境变量及其设置/#Linux下如何设置环境变量","page":"环境变量简介","title":"Linux下如何设置环境变量","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"在Linux系统中，可以通过在bash shell的配置文件中设置环境变量。以bash为例，下面是一种常用的方法：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"打开终端，进入到当前用户的主目录。\n使用文本编辑器（如vi、nano等）打开.bashrc文件，这是bash的配置文件之一。\nvi ~/.bashrc\n在文件的末尾添加你想要设置的环境变量，例如：\nexport JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64\n这里将JAVA_HOME环境变量设置为Java安装路径。\n保存并关闭文件。\n在终端中执行以下命令，使配置生效：\nsource ~/.bashrc\n或者直接注销并重新登录。\n验证环境变量是否设置成功，可以使用以下命令：\necho $JAVA_HOME\n如果显示了设置的路径，则说明环境变量设置成功。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"通过在.bashrc文件中设置环境变量，每次打开新的终端窗口时，bash shell都会自动加载这些变量。这样，你就可以在终端中使用这些环境变量，或者在脚本中引用它们。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"请注意，如果你需要在系统级别设置环境变量，可以编辑/etc/environment文件或在/etc/profile.d/目录下创建一个.sh文件，并在其中设置环境变量。但这些操作可能需要管理员权限。","category":"page"},{"location":"CSBase/3-环境变量及其设置/#有哪些重要的环境变量","page":"环境变量简介","title":"有哪些重要的环境变量","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"以下是其中一些常见的重要环境变量：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"PATH：指定可执行程序的搜索路径。当你在终端中输入命令时，系统会按照PATH变量指定的路径搜索可执行程序。\nINCLUDE_PATH: 指定编译器在编译过程中查找头文件（header files）的路径。头文件包含了程序中所需的函数和数据结构的声明。\nLD_LIBRARY_PATH：指定动态链接库（shared libraries）的搜索路径。当你运行依赖于动态链接库的可执行程序时，系统会在该路径下查找所需的库文件。\nHOME：指定当前用户的主目录路径。通常在命令行中使用波浪符（~）表示该路径。\nUSER：当前登录用户的用户名。\nSHELL：指定当前用户所使用的Shell程序的路径。\nPS1：定义命令行提示符的格式。你可以自定义命令行提示符的外观，例如设置为显示当前目录或用户名。\nLANG：指定系统默认的语言环境。\nLC_ALL：指定所有区域设置（Locale）的设置。它会覆盖其他与区域设置相关的环境变量，如LC_COLLATE、LC_TIME等。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"这只是一小部分常见的重要环境变量。实际上，系统和应用程序可以定义和使用许多其他环境变量，以满足特定的需求和配置要求。","category":"page"},{"location":"CSBase/3-环境变量及其设置/#PATH","page":"环境变量简介","title":"PATH","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"PATH是一个非常重要的环境变量，用于指定可执行程序的搜索路径。当你在终端或命令提示符中输入命令时，系统会按照PATH变量指定的路径来查找可执行程序。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"操作系统会按照PATH环境变量中指定的路径顺序逐个搜索命令，直到找到匹配的可执行程序或搜索完所有路径。如果找到匹配的可执行程序，系统将执行该程序；如果没有找到匹配的程序，系统将显示\"命令未找到\"（Command not found）的错误。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"在PATH环境变量中，不同的路径由冒号（Linux、Unix系统）或分号（Windows系统）分隔开。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"示例：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"上述示例中的PATH环境变量包含了5个路径，每个路径都是可执行程序的搜索路径。当你在终端中输入一个命令时，系统会按照这些路径的顺序依次搜索命令。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"可以通过修改PATH环境变量来添加或修改可执行程序的搜索路径。这对于安装新的软件、使用自定义的脚本或工具以及管理系统的执行环境非常有用。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"注意，为了避免安全风险，应小心管理PATH环境变量，确保只包含可信任的路径，并避免在PATH中包含当前目录（.）或不受信任的目录。这可以减少恶意软件或攻击者利用恶意程序替代系统命令的风险。","category":"page"},{"location":"CSBase/3-环境变量及其设置/#INCLUDE_PATH","page":"环境变量简介","title":"INCLUDE_PATH","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"INCLUDE_PATH是一个常见的环境变量，用于指定编译器在编译过程中查找头文件（header files）的路径。头文件包含了程序中所需的函数和数据结构的声明。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"当编译源代码时，编译器需要访问相关的头文件来了解函数和数据结构的定义。如果头文件位于非标准位置，编译器默认不会自动查找它们。这时，可以通过设置INCLUDE_PATH环境变量告诉编译器额外的头文件搜索路径。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"具体的设置方式因编译器而异。在常见的C/C++编译器中，如GCC（GNU Compiler Collection）或Clang，可以通过以下方式设置INCLUDE_PATH环境变量：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"在bash shell中：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"export INCLUDE_PATH=/path/to/include","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"在Windows的命令提示符中：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"set INCLUDE_PATH=C:\\path\\to\\include","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"请注意，上述命令中的/path/to/include或C:\\path\\to\\include应替换为实际的头文件所在目录路径。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"设置了INCLUDE_PATH环境变量后，编译器将在指定的路径下搜索头文件，使其可被源代码正确引用。这样可以更方便地组织头文件的位置，特别是在项目中使用了自定义的头文件或第三方库的头文件时。","category":"page"},{"location":"CSBase/3-环境变量及其设置/#LD_LIBRARY_PATH","page":"环境变量简介","title":"LD_LIBRARY_PATH","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"LD_LIBRARY_PATH是一个用于指定动态链接库（shared libraries）搜索路径的环境变量。在Linux系统中，可执行程序在运行时可能需要依赖某些共享库，而LD_LIBRARY_PATH变量可以告诉系统在哪些目录中搜索这些共享库。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"当你运行一个可执行程序时，操作系统会使用预定义的默认路径搜索共享库。然而，有时共享库可能位于非标准位置，或者你希望在运行时使用其他版本的共享库。这时，可以通过设置LD_LIBRARY_PATH环境变量来指定额外的共享库搜索路径。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"具体的设置方式如下：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"在bash shell中：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"export LD_LIBRARY_PATH=/path/to/lib","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"在Windows的命令提示符中：","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"set LD_LIBRARY_PATH=C:\\path\\to\\lib","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"请注意，上述命令中的/path/to/lib或C:\\path\\to\\lib应替换为实际的共享库所在目录路径。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"设置了LD_LIBRARY_PATH环境变量后，可执行程序在运行时将在指定的路径下搜索共享库。这样可以方便地使用自定义的共享库或指定特定版本的共享库，而不必将其放置在默认的系统库路径下。","category":"page"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"需要注意的是，LD_LIBRARY_PATH是一个影响系统范围的环境变量，所以在设置时要谨慎。错误的设置可能导致系统出现问题或安全风险。一般建议仅在特定需求下使用LD_LIBRARY_PATH，并避免滥用。","category":"page"},{"location":"CSBase/3-环境变量及其设置/#视频地址","page":"环境变量简介","title":"视频地址","text":"","category":"section"},{"location":"CSBase/3-环境变量及其设置/","page":"环境变量简介","title":"环境变量简介","text":"命令提示符和环境变量","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/#容器化和k8s","page":"容器化和k8s","title":"容器化和k8s","text":"","category":"section"},{"location":"IotBigdataCloud/5-容器化和k8s/#容器化","page":"容器化和k8s","title":"容器化","text":"","category":"section"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"容器化是一种将应用程序及其所有依赖项打包在一起的技术，以创建可移植、一致和可重复部署的环境。容器化将应用程序与其运行环境隔离开来，使应用程序能够在不同的计算环境中以相同的方式运行。容器化技术如Docker使用容器来封装应用程序、库和其他依赖项，从而实现更高效、可扩展和可移植的应用程序部署。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"当从虚拟机转向容器化时，有几个关键的变化和逻辑转变：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"虚拟机的隔离性与资源占用：在虚拟机中，每个虚拟机都是一个完整的操作系统实例，它们互相隔离，并且每个虚拟机需要独立的操作系统、内核和资源。这导致了较高的资源消耗和较慢的启动时间。\n容器的轻量级隔离与资源共享：相比之下，容器是在宿主操作系统上的轻量级隔离环境。它们共享宿主操作系统的内核和资源，可以更高效地运行，并且启动时间更快。容器之间通过命名空间和控制组等机制进行隔离，使得它们能够相互独立运行。\n容器镜像的概念：虚拟机使用基于磁盘映像的方式进行部署，而容器使用容器镜像。容器镜像是一个只读的文件，包含了应用程序及其运行所需的依赖项和配置。容器镜像可以在不同的环境中进行快速部署和复制，确保了环境的一致性。\n管理工具和编排：在容器化环境中，管理工具如Docker、Kubernetes等被广泛使用。它们提供了容器的构建、部署、管理和编排的功能，简化了容器化应用程序的生命周期管理。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"通过容器化，可以实现更快速、高效、可伸缩和可移植的应用程序部署和管理。容器化技术使得开发人员和运维团队能够更好地管理应用程序的依赖项、版本控制和资源利用，从而提高开发和交付效率，并降低了应用程序的运行成本。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/#docker简介","page":"容器化和k8s","title":"docker简介","text":"","category":"section"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"现在让我们来介绍一下 Docker。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"Docker 是一个开源的容器化平台，它以容器的形式打包和运行应用程序及其所有依赖项。Docker 的核心概念是容器镜像和容器实例。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"容器镜像是一个只读的模板，其中包含了运行应用程序所需的文件系统、库、依赖项和配置等。镜像可以从一个基础镜像构建，通过添加或修改文件系统的层来创建一个新的镜像。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"容器实例是基于容器镜像创建的运行实体。它可以被启动、停止、重启和销毁。每个容器实例是相互隔离的，拥有自己的文件系统、进程空间和网络接口。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"Docker 提供了一系列命令和工具，使得容器的管理和操作变得简单和高效。使用 Docker，您可以快速构建、部署和扩展应用程序，无论是在开发、测试还是生产环境中。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"以下是一些常用的 Docker 命令：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"docker build：基于 Dockerfile 构建镜像。\ndocker run：创建并运行一个新的容器实例。\ndocker stop：停止一个运行中的容器实例。\ndocker start：启动一个已停止的容器实例。\ndocker rm：删除一个容器实例。\ndocker images：列出本地的镜像。\ndocker pull：从镜像仓库拉取一个镜像。\ndocker push：将一个镜像推送到镜像仓库。\ndocker exec：在运行中的容器实例中执行命令。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"除了基本的命令之外，Docker 还有其他高级功能，如容器网络、数据卷、容器编排等，可以帮助您更好地管理和扩展容器化应用程序。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"通过 Docker，您可以实现应用程序的快速交付、环境的一致性以及资源的高效利用，从而加快开发和部署的速度，简化应用程序的管理和维护。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/#docker实操","page":"容器化和k8s","title":"docker实操","text":"","category":"section"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"让我们在WSL2里启用systemd，再来个docker实操吧。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"在WSL2中启用systemd需要进行一些额外的配置。以下是启用systemd的步骤：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"打开WSL2终端。\n创建一个新的文件 /etc/wsl.conf（如果不存在）并打开它。\nsudo nano /etc/wsl.conf\n在 wsl.conf 文件中添加以下内容：\n[wsl2]\nkernelCommandLine = systemd.unified_cgroup_hierarchy=1\n保存文件并退出编辑器。\n重新启动WSL2分发版。\nwsl --shutdown\n打开WSL2终端，检查是否已启用systemd。\nsystemctl","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"现在您应该能够在WSL2中使用systemd。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"关于Docker的实操，请提供一些具体的操作场景或需求，我将尽力提供相应的指导。例如，构建镜像、运行容器、管理容器等。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"下面我们用docker运行一个hello world。 要在 Docker 中运行 \"Hello World\"，请按照以下步骤进行操作：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"打开终端或命令行窗口。\n检查您的 Docker 是否已经安装并正确配置。可以运行以下命令检查 Docker 版本：\ndocker version\n如果 Docker 尚未安装，请根据您的操作系统和环境，按照 Docker 官方文档提供的说明进行安装。\n确认 Docker 运行正常后，执行以下命令来拉取并运行 \"Hello World\" 镜像：\ndocker run hello-world\nDocker 将从 Docker Hub 上下载 \"Hello World\" 镜像并创建一个容器实例。容器将执行一些测试操作并输出一条 \"Hello from Docker!\" 消息以及一些其他信息。\n您可以在终端或命令行窗口中看到输出结果。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"通过执行以上步骤，您将成功运行 \"Hello World\" 容器。这是一个简单的示例，您可以使用类似的方式运行其他 Docker 镜像和容器。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"docker运行nginx 要在 Docker 中运行 Nginx Web 服务器，您可以按照以下步骤进行操作：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"打开终端或命令行窗口。\n确保您已经安装并正确配置了 Docker。可以运行以下命令检查 Docker 版本：\ndocker version\n如果 Docker 尚未安装，请根据您的操作系统和环境，按照 Docker 官方文档提供的说明进行安装。\n执行以下命令来拉取并运行 Nginx 镜像：\ndocker run -d -p 80:80 nginx\n-d 参数表示以后台（守护进程）模式运行容器。\n-p 80:80 参数表示将主机的 80 端口映射到容器的 80 端口，使得可以通过主机的 IP 地址访问 Nginx。\nDocker 将从 Docker Hub 上下载 Nginx 镜像并创建一个容器实例。容器将在后台运行 Nginx Web 服务器。\n确认容器是否正在运行，可以执行以下命令：\ndocker ps\n您应该看到类似如下的输出，表示 Nginx 容器正在运行：\nCONTAINER ID   IMAGE   COMMAND                  CREATED        STATUS       PORTS                                   NAMES\n<ContainerID>  nginx   \"/docker-entrypoint.…\"   <Time ago>     Up <Time>     0.0.0.0:80->80/tcp, :::80->80/tcp       <ContainerName>\n在您的 Web 浏览器中，通过访问 http://localhost 或 http://主机IP地址，应该能够看到 Nginx 的欢迎页面。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"通过执行以上步骤，您将成功运行一个 Nginx 容器，并可以通过浏览器访问 Nginx 欢迎页面。您可以使用类似的方式运行其他 Docker 镜像和容器，以扩展和定制您的应用程序环境。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"下面我来解释一下docker。 docker根据镜像模板（image）构建容器（container），然后运行这个容器。这些image就像洋葱一样，有的人构建了一个内部小洋葱，比如设置好了linux基本系统，构建一个镜像a，有的人又在它的上面安装了一些必要的软件，构建了镜像b。一层一层的。这些镜像可以都存在镜像仓库中，并且是以delta的方式存储，以减小磁盘空间。然后我们要运行容器的时候，先拉取这个镜像，然后构建容器。容器中的改变也可以commit到本地的镜像。容器中改变了，但是容器一旦销毁，内部的内容也就随之丢失。为了能永久保存在容器里的改变，我们可以设置volume，就是类似于磁盘挂载，把host的某个目录映射成容器的某个目录。在容器里存到这个目录中的文件实际上是存到了host的目录。当销毁容器的时候，存储的内容因为在host的目录里而得以保留。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"镜像（Image）是一个不可变的文件，它包含了运行一个应用程序所需的所有文件系统、库、依赖项和配置等。镜像可以通过一层一层的方式构建，每一层都是在前一层的基础上进行修改或添加。这种分层的结构使得镜像在构建和传输时更加高效，并且可以共享和复用。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"镜像可以存储在镜像仓库（例如 Docker Hub）中，以便其他人可以拉取和使用。镜像仓库可以存储大量的镜像，并且它们可以以增量的方式存储，这意味着只需要存储每个镜像层的差异部分，可以节省存储空间。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"当您要创建一个容器（Container）时，会使用镜像作为模板。容器是镜像的一个运行实例，它可以被启动、停止、重启和销毁。容器提供了一个隔离的运行环境，包括自己的文件系统、进程空间和网络接口。容器中的任何更改都只影响该容器本身，不会影响其他容器或镜像。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"可以通过将容器中的更改提交（commit）为一个新的镜像来永久保存容器中的更改。这样可以创建一个新的镜像，其中包含了容器的修改，以便后续可以基于这个镜像再次创建容器。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"为了在容器中永久保存数据或文件，可以使用数据卷（Volume）。数据卷可以将主机的某个目录或文件挂载到容器中的特定位置，使得容器中的数据可以持久保存在主机上。这样即使容器被销毁，数据卷中的内容仍然保留。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"总结来说，Docker 的工作流程是使用镜像构建容器，容器中的更改可以提交为新的镜像，而数据卷则用于在容器和主机之间实现数据的持久化存储。这种方式使得应用程序的开发、测试和部署更加方便和高效。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"当使用 Docker 构建镜像时，可以使用 Dockerfile 文件来定义构建镜像的步骤和配置。以下是一个简单的 Dockerfile 示例：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"# 使用官方的 Python 镜像作为基础镜像\nFROM python:3.9\n\n# 设置工作目录\nWORKDIR /app\n\n# 复制当前目录下的所有文件到容器的 /app 目录\nCOPY . /app\n\n# 安装应用程序的依赖项\nRUN pip install --no-cache-dir -r requirements.txt\n\n# 暴露容器的端口\nEXPOSE 8000\n\n# 定义容器启动时运行的命令\nCMD [\"python\", \"app.py\"]","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"上述 Dockerfile 的示例展示了一个用于构建 Python 应用程序镜像的简单示例。以下是每个指令的作用：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"FROM：指定基础镜像，这里使用官方的 Python 3.9 镜像作为基础。\nWORKDIR：设置工作目录为 /app，后续的命令将在该目录下执行。\nCOPY：将当前目录下的所有文件复制到容器的 /app 目录下。\nRUN：在容器中执行命令，这里是安装应用程序的依赖项。\nEXPOSE：声明容器将监听的端口号，这里是将容器的 8000 端口暴露出来。\nCMD：定义容器启动时运行的命令。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"通过使用以上 Dockerfile 文件，您可以使用 docker build 命令构建镜像。例如，假设 Dockerfile 文件位于当前目录下，可以执行以下命令来构建镜像：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"docker build -t myapp .","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"上述命令将使用 Dockerfile 构建一个名为 \"myapp\" 的镜像，. 表示 Dockerfile 文件所在的当前目录。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"这只是一个简单的 Dockerfile 示例，实际的 Dockerfile 可以更复杂，可以包含更多的指令和配置，以满足具体的应用程序构建需求。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"对于更多的 Docker 命令和用法，建议参考 Docker 官方文档或者使用 Docker 命令行工具的 --help 选项获取更详细的信息。此外，您也可以随时向 ChatGPT 提问有关 Docker 的问题，我会尽力提供帮助和回答您的疑问。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/#集群简介","page":"容器化和k8s","title":"集群简介","text":"","category":"section"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"我们以高性能计算集群为例说明一下。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"\"Beowulf 集群\" 是一个计算集群的名称，它以 Beowulf 史诗中的角色命名。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"Beowulf 集群是一种高性能计算（HPC）集群，通常由多个普通计算机节点组成，这些节点通过网络连接在一起。这些节点共同工作以提供并行计算能力和更高的计算性能。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"Beowulf 集群通常使用开源软件和技术，例如 Linux 操作系统、MPI（Message Passing Interface）等，以实现任务的并行处理和分布式计算。这种集群架构可以用于高性能计算、科学研究、数据分析和其他需要大规模计算能力的应用领域。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"Beowulf 集群是一种基于普通计算机节点组成的计算集群，旨在通过并行计算和分布式计算来提供更高的计算性能和处理能力。这种集群模型的概念起源于1994年由 Thomas Sterling 和 Donald Becker 提出的 Beowulf 架构。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"Beowulf 集群通常由以下组件和特点组成：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"节点：集群由多个普通计算机节点组成，每个节点都是标准的个人计算机或服务器。这些节点通过局域网或高速网络连接在一起，形成一个共享资源的计算环境。\n网络通信：节点之间通过网络进行通信和协调。高速网络（如以太网）通常用于实现低延迟和高带宽的数据传输，以支持节点之间的并行计算和数据交换。\n分布式计算：Beowulf 集群利用节点的并行计算能力，将计算任务分割为多个子任务，并在各个节点上同时执行这些子任务，从而实现任务的并行处理和加速。\n软件和工具：集群使用开源的软件和工具来管理和协调节点之间的计算任务。常见的软件包括 Linux 操作系统、MPI（Message Passing Interface）库用于节点间的消息传递、作业调度器（如 Slurm、PBS）用于任务调度和资源管理等。\n可扩展性：Beowulf 集群通常具有良好的可扩展性，可以根据需要增加或减少节点的数量，以适应不同规模和复杂度的计算任务。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"Beowulf 集群的设计目标是通过组合普通计算机节点的计算能力来实现高性能计算，并提供灵活的计算环境，使科学、工程和其他领域的研究人员能够有效地进行大规模计算和数据处理。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"请注意，Beowulf 集群只是一个通用的概念和架构模型，具体的实现和配置可能因组织、应用领域和技术选择而有所不同。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"假如我有5台一样配置的电脑。它们有2个不同的交换机相连，1个是千兆网，1个是infiniband。请来个step by step的设置这个集群的过程。首先是安装linux系统。然后安装nis用户认证。然后头结点设置nfs。计算节点挂载nfs。然后设置infiniband网络，接下来设置一下任务调度器。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"下面是一个基本的步骤指南来设置您描述的集群环境：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"安装 Linux 系统：\n在每台计算机上安装所选择的 Linux 操作系统，可以是常见的发行版如 Ubuntu、CentOS 等。\n确保每台计算机都安装了相同版本的操作系统和软件包。\n安装 NIS 用户认证：\n在头结点（Master 节点）上设置和配置 NIS 服务器，用于提供集中化的用户认证和授权管理。\n在每个计算节点上设置并加入 NIS 域，以实现节点之间的统一身份验证和访问控制。\n头结点设置 NFS：\n在头结点上安装和配置 NFS 服务器，用于提供共享文件系统。\n在头结点上创建共享目录，并设置正确的权限和访问控制。\n配置 NFS 服务器以允许计算节点挂载共享目录。\n计算节点挂载 NFS：\n在每个计算节点上安装 NFS 客户端软件包。\n配置计算节点以挂载头结点上的共享目录，使其可在计算节点上访问。\n设置 InfiniBand 网络：\n安装和配置适当的 InfiniBand 驱动程序和软件栈，以支持 InfiniBand 网络连接。\n在每台计算机上设置 InfiniBand 网络接口，并确保网络适配器驱动程序正确加载。\n设置任务调度器：\n在头结点上安装和配置任务调度器，例如 Slurm、PBS 或其他适合您的需求的调度器。\n配置调度器以管理集群中的计算资源和作业分发。\n在计算节点上安装适当的调度器客户端，以便节点可以与调度器通信并接收任务分配。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"请注意，上述步骤只是一个大致的指南，实际的设置过程可能因为您的特定环境、软件选择和网络配置而有所不同。建议您在进行实际设置之前参考相关的文档、手册和指南，以确保正确配置和操作您的集群环境。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"当涉及网络通信和互联网连接时，理解公网 IP 地址、内网 IP 地址和网络地址转换（NAT）是很重要的。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"公网 IP 地址：\n公网 IP 地址是在互联网上唯一标识一个设备或网络的地址。它可以用于在全球范围内与其他设备进行通信。\n公网 IP 地址由互联网服务提供商（ISP）分配给用户或组织，以使其设备能够直接与互联网通信。\n内网 IP 地址：\n内网 IP 地址是在私有网络（如家庭网络、企业网络或局域网）中使用的地址，用于在局域网内部进行设备之间的通信。\n内网 IP 地址是在私有地址空间中分配的，这些地址不在全球互联网上路由，而是在局域网内部进行本地通信使用。\n常见的内网 IP 地址范围包括 10.0.0.0 到 10.255.255.255、172.16.0.0 到 172.31.255.255、192.168.0.0 到 192.168.255.255。\n网络地址转换（NAT）：\n网络地址转换是一种网络技术，用于将内网设备使用私有 IP 地址与互联网上的公网 IP 地址进行通信。\nNAT 允许多个内网设备通过共享单个公网 IP 地址与互联网通信。\nNAT 通过在网络设备（如路由器或防火墙）上维护转换表和端口映射来实现。\n当内网设备与外部服务器通信时，网络地址转换会将内网设备的私有 IP 地址映射为公网 IP 地址。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"网络地址转换（NAT）的使用允许在具有有限数量公网 IP 地址的情况下连接多个内网设备到互联网，这在家庭网络和企业网络中非常常见。通过使用 NAT，内网设备可以在局域网内部共享公共互联网连接。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/#容器编排之docker-compose","page":"容器化和k8s","title":"容器编排之docker-compose","text":"","category":"section"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"docker-compose编排容器，就好比是虚拟化的集群。我这样说对吧？","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"部分正确。Docker Compose 是一个用于定义和运行多个 Docker 容器的工具，可以简化容器的编排和部署过程。它可以将多个容器定义为一个应用程序，并协调它们之间的通信和依赖关系。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"与虚拟化的集群不同，Docker Compose 并没有直接实现虚拟化。它更侧重于在单个主机上创建一个容器化的应用程序环境，其中不同的容器可以协同工作以提供所需的功能。Docker Compose 提供了一个简洁的方式来定义和管理这些容器之间的关系，以及它们如何相互交互。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"虚拟化集群通常指的是在物理主机上运行多个虚拟机，每个虚拟机都可以运行独立的操作系统和应用程序。而 Docker Compose 是在容器级别进行编排，将多个容器组合成一个应用程序，并提供一种简化的方式来管理容器之间的通信和依赖关系。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"因此，虽然 Docker Compose 提供了一种类似于虚拟化集群的编排方式，但它并不是直接实现虚拟化。它更关注于容器化应用程序的管理和部署。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"那你来一步一步的说一说，docker-compose的安装和使用吧。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"当您安装和使用 Docker Compose 时，可以按照以下步骤进行操作：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"安装 Docker Compose：\n确保您已经安装了 Docker。Docker Compose 是 Docker 的一个独立组件，但它通常与 Docker 一起安装。\n访问 Docker Compose 官方文档的安装页面：https://docs.docker.com/compose/install/\n根据您的操作系统，按照文档中的说明进行安装。官方文档提供了各种操作系统的安装指南。\n创建 Docker Compose 文件：\n在您的项目目录中创建一个名为 docker-compose.yml 的文件。\n在该文件中定义您的容器服务。使用 YAML 格式来描述每个服务的配置、依赖关系、映射端口等。\n编写 Docker Compose 配置：\n在 docker-compose.yml 文件中，定义您的服务。每个服务都应该有一个唯一的名称，并指定使用的镜像、映射的端口、环境变量等。\n您还可以定义服务之间的依赖关系，以确保它们按正确的顺序启动。\n启动 Docker Compose 服务：\n打开终端或命令提示符，导航到包含 docker-compose.yml 文件的目录。\n运行命令 docker-compose up 来启动所有定义的服务。\nDocker Compose 将会下载所需的镜像（如果不存在）并启动相应的容器。\n停止和清理服务：\n若要停止 Docker Compose 中的服务，可以在终端中使用 Ctrl+C 组合键。\n要完全停止并删除服务的容器和网络，可以运行 docker-compose down 命令。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"这些步骤提供了一个基本的概述来安装和使用 Docker Compose。在实际使用中，您可以根据需要进一步探索 Docker Compose 的功能和选项，例如映射卷、环境变量管理、容器间的网络通信等。您可以参考 Docker Compose 的官方文档（https://docs.docker.com/compose/）以获取更多详细信息和示例。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"你给个简单的docker-compose.yml，演示一遍啊。并且请解释一下docker-compose.yml文件。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"当然，以下是一个简单的示例 docker-compose.yml 文件的内容：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"version: '3'\nservices:\n  web:\n    image: nginx:latest\n    ports:\n      - 80:80\n    volumes:\n      - ./html:/usr/share/nginx/html\n    restart: always","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"解释 docker-compose.yml 文件的各个部分：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"version：指定 Docker Compose 文件的版本。这里使用的是版本 3。\nservices：定义了要运行的服务列表。\nweb：服务的名称，您可以根据需要自定义。\nimage：指定服务使用的 Docker 镜像。这里使用的是官方的 nginx 镜像，并指定使用最新版本。\nports：将主机的端口映射到容器的端口。这里将主机的 80 端口映射到容器的 80 端口，以便通过浏览器访问。\nvolumes：将容器内的目录或文件与主机上的目录或文件进行映射。这里将主机的 ./html 目录映射到容器的 /usr/share/nginx/html 目录，以便持久化存储网页内容。\nrestart：指定容器在退出后的重启策略。这里设置为 always，表示容器将始终自动重启。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"这个示例的 docker-compose.yml 文件定义了一个名为 web 的服务，它使用 nginx 镜像并将主机的 80 端口映射到容器的 80 端口。此外，它还将主机上的 ./html 目录与容器内的 /usr/share/nginx/html 目录进行映射，以便持久化存储网页内容。每次容器退出后，它都会自动重启。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"通过使用 docker-compose up 命令，可以根据上述配置启动服务，并根据定义的镜像和配置创建并运行容器。您可以根据需要在此基础上进行更复杂的配置，例如添加其他服务、设置环境变量、配置网络等。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"我需要有2个容器的例子。 如果您需要在 docker-compose.yml 文件中定义两个容器，可以按照以下示例进行编写：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"version: '3'\nservices:\n  web:\n    image: nginx:latest\n    ports:\n      - 80:80\n    volumes:\n      - ./html:/usr/share/nginx/html\n    restart: always\n\n  db:\n    image: mysql:latest\n    ports:\n      - 3306:3306\n    environment:\n      - MYSQL_ROOT_PASSWORD=secret\n    volumes:\n      - ./data:/var/lib/mysql\n    restart: always","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"在上面的示例中，我们添加了一个名为 db 的服务，使用了 mysql 镜像，并将主机的 3306 端口映射到容器的 3306 端口。同时，我们设置了 MySQL 的 root 密码为 \"secret\"。还使用了一个数据卷将容器内的 /var/lib/mysql 目录与主机上的 ./data 目录进行映射，以便持久化存储数据库文件。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"通过使用 docker-compose up 命令，可以启动这两个服务，并在单个主机上运行两个容器。这样，您就可以同时运行一个 nginx 容器和一个 MySQL 容器。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"您可以根据需要在此基础上进行更多的配置，例如添加其他服务、设置网络连接等。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"docker-compose down -v 命令用于停止并删除通过 Docker Compose 启动的容器，并删除相关的网络和数据卷。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"具体的操作如下：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"打开终端或命令行界面。\n进入包含 docker-compose.yml 文件的目录。\n运行以下命令：\n$ docker-compose down -v\n这将停止并删除通过 docker-compose up 启动的容器，并删除相关的网络和数据卷。选项 -v 是用来删除关联的数据卷。\n注意：这个命令会完全清理掉由 docker-compose up 创建的容器、网络和数据卷。请确保在使用该命令之前已经备份了您需要保留的数据。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"通过运行 docker-compose down -v 命令，您可以轻松地清理掉通过 Docker Compose 启动的容器及其关联的资源，以便重新开始或清理环境。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"端口映射，类似于nat，没错吧？","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"是的，端口映射的概念类似于网络地址转换（NAT）。在 Docker 中，使用端口映射可以将主机上的端口映射到容器内部的端口，从而使得可以通过主机的 IP 地址和指定的端口访问运行在容器内的应用程序。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"类比于网络地址转换（NAT），端口映射的过程可以理解为将主机上的公网 IP 地址和指定的端口（公共端口）转换为容器的 IP 地址和内部的端口（私有端口）。这样，通过在主机上的特定端口访问，可以将流量传递到容器中运行的应用程序。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"使用端口映射，您可以在一个主机上运行多个容器，并通过不同的端口映射，使得这些容器中的应用程序可以通过不同的端口进行访问，避免了端口冲突的问题。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"总结起来，端口映射在 Docker 中起到了类似于网络地址转换（NAT）的作用，将主机上的公网 IP 地址和指定的端口映射到容器内部的 IP 地址和端口，实现对容器内应用程序的访问。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/#在云服务器上运行容器","page":"容器化和k8s","title":"在云服务器上运行容器","text":"","category":"section"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"当您在阿里云的 ECS（Elastic Compute Service）上运行 Docker Compose，您需要确保已经完成以下几个步骤：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"在 ECS 实例上安装 Docker：在 ECS 实例上执行适合您操作系统版本的 Docker 安装步骤。您可以参考 Docker 官方文档或阿里云提供的文档进行安装。\n安装 Docker Compose：在 ECS 实例上安装 Docker Compose，可以通过以下步骤进行：\n下载 Docker Compose 二进制文件：\n$ sudo curl -L \"https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose\n授予执行权限：\n$ sudo chmod +x /usr/local/bin/docker-compose\n验证安装是否成功：\n$ docker-compose --version\n编写 docker-compose.yml 文件：创建一个适合您的应用程序的 docker-compose.yml 文件，定义服务、映射端口、设置环境变量等。确保文件中的镜像名称和其他配置正确。\n在 ECS 实例上创建一个网络：通过使用 Docker Compose，您可以创建自定义网络以供容器之间进行通信。在 docker-compose.yml 文件中添加网络配置，如下所示：\nnetworks:\n  mynetwork:\n在 ECS 实例上运行 Docker Compose：使用以下命令在 ECS 实例上启动 Docker Compose：\n$ docker-compose up -d\n这将根据 docker-compose.yml 文件中的配置启动容器，并将它们以守护进程方式运行。\n验证容器是否正常运行：通过运行以下命令检查容器的状态：\n$ docker-compose ps\n它将显示您在 docker-compose.yml 文件中定义的服务，并列出每个服务运行的容器的状态。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"这样，您就可以在阿里云的 ECS 实例上使用 Docker Compose 运行和管理多个容器。请确保已经在阿里云上创建了相应的 ECS 实例，并按照上述步骤进行操作。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/#k8s","page":"容器化和k8s","title":"k8s","text":"","category":"section"},{"location":"IotBigdataCloud/5-容器化和k8s/#k8s简介","page":"容器化和k8s","title":"k8s简介","text":"","category":"section"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"Kubernetes（通常简称为K8s）是一个开源的容器编排和管理平台，用于自动化部署、扩展和管理容器化应用程序。它提供了一个强大的工具集，使您能够轻松地管理容器化应用程序的生命周期，从应用程序的部署到伸缩、负载均衡、自愈能力和滚动更新等。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"以下是 Kubernetes 的一些关键概念和特点：","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"集群：Kubernetes 由多个节点组成，这些节点可以分布在不同的物理机器上，形成一个集群。每个节点可以是物理机或虚拟机，它们一起协同工作来运行和管理应用程序。\n容器编排：Kubernetes 提供了强大的容器编排功能，可以自动调度和管理容器的部署。它可以根据资源需求和可用性将容器放置在适当的节点上，并确保容器按预期方式运行。\n服务发现和负载均衡：Kubernetes 具有内置的服务发现和负载均衡功能。它可以为应用程序提供稳定的网络地址和服务名称，并将流量动态分发到容器化应用程序的多个实例之间。\n自动扩展：Kubernetes 允许根据应用程序的负载情况自动扩展容器实例的数量。根据定义的规则，Kubernetes 可以根据负载情况自动增加或减少容器实例，以确保应用程序的高可用性和性能。\n滚动更新：Kubernetes 支持滚动更新，可以逐步替换应用程序的旧版本。这样可以避免中断或服务不可用，并实现无缝的应用程序更新。\n健康检查和自愈能力：Kubernetes 提供了健康检查机制，可以定期检查容器的状态并响应任何故障。如果容器不健康或出现故障，Kubernetes 可以自动重启容器或替换不可用的容器实例。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"总的来说，Kubernetes 是一个功能强大的容器编排和管理平台，可以帮助您简化和自动化容器化应用程序的部署、扩展和管理。它具有丰富的特性和弹性，适用于构建和管理复杂的容器化环境，并提供高可用性、可扩展性和自愈能力。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/#从docker-compose到k8s","page":"容器化和k8s","title":"从docker-compose到k8s","text":"","category":"section"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"可不可以说，docker和docker-compose是去拉取（pull）任务，而k8s是推送任务（push）？k8s推送的是pod，其实就是一组容器？","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"在 Docker 和 Kubernetes 中，有一个概念上的区别可以与“拉取”和“推送”相关联，尽管这个比喻并不完全准确。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"Docker：当使用 Docker 时，您可以通过拉取（pull）镜像来获取应用程序的容器镜像。Docker 镜像通常存储在镜像仓库中，例如 Docker Hub。当您运行容器时，Docker 引擎会从镜像仓库拉取所需的镜像，并在本地构建和运行容器。\nDocker Compose：Docker Compose 是一个工具，用于定义和运行多个相关容器组成的应用程序。通过编写 docker-compose.yml 文件，您可以定义多个容器及其相互之间的关系和依赖关系。然后，通过运行 docker-compose up 命令，Docker Compose 将根据定义的配置拉取所需的镜像，并创建和管理容器。\nKubernetes：Kubernetes 是一个容器编排平台，其中的工作单元被称为“Pod”。Pod 是一个抽象概念，它可以包含一个或多个容器，并作为最小的可部署单元。当您在 Kubernetes 上运行应用程序时，Kubernetes 控制器会根据定义的 Pod 规范创建和管理 Pod 实例。Kubernetes 并不是直接推送 Pod 到节点，而是根据 Pod 的定义和调度策略来动态创建和调度 Pod。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"总体而言，Docker 和 Docker Compose 是通过拉取容器镜像来创建和管理容器的工具，而 Kubernetes 则是一个容器编排平台，可以根据定义的规范和策略创建和管理一组容器，这组容器被组织为一个或多个 Pods。因此，可以说 Kubernetes 是在一定程度上基于推送任务的概念，即根据定义的规范推送 Pod 到集群中的节点。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/#小结一下","page":"容器化和k8s","title":"小结一下","text":"","category":"section"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"容器很好用，把服务都放到不同的容器中，隔离。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"容器又可以互相配合。构成集群。","category":"page"},{"location":"IotBigdataCloud/5-容器化和k8s/","page":"容器化和k8s","title":"容器化和k8s","text":"容器编排可以自动化，使用docker-compose或者k8s之类的。","category":"page"},{"location":"CSAdv/3-再说说递归/#再说说递归","page":"再说说递归","title":"再说说递归","text":"","category":"section"},{"location":"CSAdv/3-再说说递归/","page":"再说说递归","title":"再说说递归","text":"递归很有用。我们会用递归来说一下加减乘除四则混合运算，再说一说符号求导。说一说碳足迹的计算，再说说能源系统组件化建模。","category":"page"},{"location":"Simulation/MTK_heattran/#MTK手动空间离散求解PDE","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"tip: Tip\nContents：MTK、PDE、手动空间离散Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"note: Note\nMTK = ModelingToolkit.jlPDE = Partial Differential EquationModelingToolkit.jl 符号建模包","category":"page"},{"location":"Simulation/MTK_heattran/#MTK的PDE求解技巧","page":"MTK手动空间离散求解PDE","title":"MTK的PDE求解技巧","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"在之前介绍的例子中，所有的微分都是基于时间的微分。从数学的角度来说，微分变量只有一个。而对于有多个微分变量的PDE问题，能否通过MTK手动求解呢？例如，对时间对空间微分的PDE问题。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"答案是肯定的。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"求解PDE的数值方法有这么几步：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"建立数学描述方程\n对变量进行离散\n迭代求解","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"MTK用法中，提供了基于时间的一条龙求解。至于多变量的PDE，也有对应的PDESystem。但是目前来说，PDESystem还不是很完善。其离散方法涉及NeuralPDE.jl的相关内容。就MTK.jl本身来说，没有打通PDE的建模与求解过程。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"所以，使用MTK求解PDE的缺口在于，没有针对其它变量的离散——空间离散。那么，如果我们能够手动完成空间离散，这个问题就解决了。事实上，手动空间离散是可行的。","category":"page"},{"location":"Simulation/MTK_heattran/#数值传热学实例","page":"MTK手动空间离散求解PDE","title":"数值传热学实例","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"考虑一个正方形铸件的散热过程，正方形铸件初始温度1000℃，环境温度为0℃。如图","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"(Image: 图 1)  ","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"传热的控制方程为：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"rho c_p fracpartial Tpartial t=lambda(fracpartial^2 Tpartial x^2 +fracpartial^2 Tpartial y^2)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"将参数统一在等式右端，即","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"fracpartial Tpartial t=a(fracpartial^2 Tpartial x^2+fracpartial^2 Tpartial y^2)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"其中，","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"rho密度单位为frackgm^3","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"c_p物体热容单位为fracJkgcdot k","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"lambda导热系数单位为fracWmcdot k","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"a热扩散系数单位为fracm^2s","category":"page"},{"location":"Simulation/MTK_heattran/#内部节点空间离散","page":"MTK手动空间离散求解PDE","title":"内部节点空间离散","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"对方程进行空间离散，采用二阶中心差分，有：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"fracpartial T_ijpartial t=a (fracT_i+1 j^n- 2 T_i j^n+T_i-1 j^nDelta x^2+fracT_i j+1^n- 2 T_i j^n+T_i j-1^nDelta y^2)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"若使用化简表达，","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"Delta x = Delta y = deltaT_i j=T_PT_i+1 j=T_WT_i-1 j=T_ET_i j-1=T_NT_i j+1=T_S","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"则有内部节点的空间离散：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"fracpartial Tpartial t=fracadelta^2(T_W^n+T_E^n+T_N^n+T_S^n - 4T_P^n)","category":"page"},{"location":"Simulation/MTK_heattran/#边边界空间离散","page":"MTK手动空间离散求解PDE","title":"边边界空间离散","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"下面考虑边界条件。以W边为例。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"(Image: 图 2)  ","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"边界条件使用第三类边界条件。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"delta h(T_f-T_W^n)=delta lambda fracT_W^n-T_P^nfracdelta2","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"为了消去T_W^n，考虑该式子的等比式：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"frac(T_f-T_W^n)frac1h=fracT_W^n-T_P^nfracdelta2 lambda=frac(T_f-T_P^n)frac1h+fracdelta2 lambda taga","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"note: Note\n当对流散热系数h足够大时，frac2lambdadelta happrox0，即T_W approx T_f。第三类边界条件可以近似为第一类边界条件——壁温恒定为环境温度，如下式推导：T_W=frach T_f+frac2 lambdadelta T_P^nh+frac2 lambdadelta=fracT_f+frac2 lambdadelta h T_P^n1+frac2 lambdadelta h approx T_f这是从数学上的一种理解，后面并没使用到该近似。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"对边界采用附加源法进行分析。T_W为边界点温度，T_P节点的能量守恒方程为：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"beginarraycdelta lambda fracT_E^n-T_P^ndelta+delta lambda fracT_N^n-T_P^ndelta+delta lambda fracT_S^n-T_P^ndelta+delta lambda fracT_W^n-T_P^nfracdelta2=rho c delta^2 fracpartial T_Ppartial tendarray","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"将式(a)的第三项代入上式中的T_W-T_P项并化简，最终能得到边边界的边界方程：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"beginarraycfracpartial T_Ppartial t=fraca delta^2(T_E^n+T_N^n + T_S^n)-(fracafraclambda deltah+fracdelta^22+frac3 a delta^2) T_P^n+fraca fraclambda deltah+fracdelta^22 T_fendarray","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"同理可得其它3个边的边边界方程。","category":"page"},{"location":"Simulation/MTK_heattran/#角边界空间离散","page":"MTK手动空间离散求解PDE","title":"角边界空间离散","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"最后考虑角边界。以铸件左上角为例进行分析，下如图所示的角边界。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"(Image: 图 3)  ","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"分析方法同边边界的分析方法，最后可得：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"fracpartial T_Ppartial t=fracadelta^2(T_E^n+T_N^n+T_S^n)-(fracafraclambda deltah+fracdelta^22+frac2adelta^2) T_P^n+frac2afraclambda deltah+fracdelta^22 T_f","category":"page"},{"location":"Simulation/MTK_heattran/#离散方程汇总","page":"MTK手动空间离散求解PDE","title":"离散方程汇总","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"经过以上推导，得到了内节点表达式、边边界表达式和角边界表达式。为了方便程序表达，对方程的系数进行化简，令，","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"A = fracadelta^2B = fracafraclambdadeltah+fracdelta^22","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"note: Note\n当h很大时，fraclambda deltahapprox 0，所以B approx 2A。和前面边界条件的理解相似。同样的，这只是一种理解方式，并没有使用。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"内节点：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"fracpartial T_Ppartial t=A(T_W^n+T_E^n+ T_N^n+T_S^n - 4T_P^n)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"边边界节点：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"fracpartial T_Ppartial t=A(T_W^n+T_N^n+T_S^n)-(B+3A)T_P^n+BT_f","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"角边界节点：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"fracpartial T_Ppartial t=A(T_E^n + T_N^n )-(2B+2A)T_P^n+2BT_f","category":"page"},{"location":"Simulation/MTK_heattran/#求解实例","page":"MTK手动空间离散求解PDE","title":"求解实例","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"求解的全部代码如下：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"using ModelingToolkit, DifferentialEquations\n\n# 参数设定\na = 1.27E-5\nn = 10\nL = 0.2\nδ = L / n\nλ = 50\nh = 1.0E9\nTf = 0.0\nA = a / δ^2\nB = a / (δ^2 / 2 + δ * λ / h)\n\n@variables t (T(t))[1:n, 1:n]\n\nD = Differential(t)\n\n# 内节点代码\ninsides = [\n    D(T[i, j]) ~ A * (T[i+1, j] + T[i-1, j] + T[i, j+1] + T[i, j-1] - 4 * T[i, j])\n    for i in 2:n-1 for j in 2:n-1]\n\n# 边边界代码\nWb = [\n    D(T[i, 1]) ~ A * (T[i+1, 1] + T[i-1, 1] + T[i, 2]) - (3B + A) * T[i, 1] + B * Tf\n    for i in 2:n-1\n]\nEb = [\n    D(T[i, n]) ~ A * (T[i+1, n] + T[i-1, n] + T[i, n-1]) - (3B + A) * T[i, n] + B * Tf\n    for i in 2:n-1\n]\nNb = [\n    D(T[1, i]) ~ A * (T[1, i+1] + T[1, i-1] + T[2, i]) - (3B + A) * T[1, i] + B * Tf\n    for i in 2:n-1\n]\nSb = [\n    D(T[n, i]) ~ A * (T[n, i+1] + T[n, i-1] + T[n-1, i]) - (3B + A) * T[1, i] + B * Tf\n    for i in 2:n-1\n]\n\n# 4 corner boundary\ncorner = [\n    D(T[1, 1]) ~ A * (T[2, 1] + T[1, 2]) - (2B + 2A) * T[1, 1] + 2B * Tf,\n    D(T[n, n]) ~ A * (T[n-1, n] + T[n, n-1]) - (2B + 2A) * T[n, n] + 2B * Tf,\n    D(T[n, 1]) ~ A * (T[n, 2] + T[n-1, 1]) - (2B + 2A) * T[n, 1] + 2B * Tf,\n    D(T[1, n]) ~ A * (T[2, n] + T[1, n-1]) - (2B + 2A) * T[1, n] + 2B * Tf\n]\n\neqs = append!(insides, Wb, Eb, Nb, Sb, corner)\n\n@named sys = ODESystem(eqs, t)\n\nsys = structural_simplify(sys)\n\n# u0 = [1000.0 for i in 1:n for j in 1:n]\nu0 = Dict(T[i, j] => 1000.0 for i in 1:n for j in 1:n)\nprob = ODEProblem(sys, u0, (0, 100), [], saveat=0.1)\nsol = solve(prob, Tsit5())\n","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"值得一提的是：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"MTK变量定义:","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"这是有效的变量数组（矩阵）的定义方式，也就是说MTK支持变量数运算。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"@variables t (T(t))[1:n, 1:n]","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"ODESystem定义","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"ODESystem定义时，既没有传递变量，也没有传递参数，甚至连t也可以不用传递，这都是可行的。ODESystem定义时能够自动检查（check）方程结构，从方程中获得变量信息。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"@named sys = ODESystem(eqs, t)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"tip: Tip\nODESystem定义时，若传递变量数组或者参数数组，check时不能通过。目前来说这是一个bug，所以可以不写。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"MTK初值设定","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"初值或者参数传递时，以下两种方式都可以。但也有区别。在符号计算中，符号在数组中的位置是不确定的。假如以数组的形式传递进去，那么就不知道哪个初值传递给了哪个变量（如果初值或参数都相同那就无所谓）。所以，初值传递需要精确到变量时，最好使用Dict。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"\nu0 = [1000.0 for i in 1:n for j in 1:n]\n\nu0 = Dict(T[i, j] => 1000.0 for i in 1:n for j in 1:n)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"saveat","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"saveat是solution handle中的内容。其作用是使sol中结果存储结果的时间步长为给定步长。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"当然，也可以使用sol()获得任意时刻的值。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"sol(2.5)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"但是这样会丢失变量的顺序，就是无法得知变量与数值的对应关系了。能否解决这个问题，这里还有许多可测试与探索的空间。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"page"},{"location":"Simulation/MTK_heattran/#可视化","page":"MTK手动空间离散求解PDE","title":"可视化","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"tip: Tip\nJulia生态中，可视化也是很强的！Plots.ji远比想象的强大！","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"最后，动画走你！","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"an_len= length(sol[T[1,1]])\nusing Plots, GR\nres = rand(n,n,an_len)\nfor t in 1:an_len\n    for i in 1:n\n        for j in 1:n\n            res[i,j,t] = sol[T[i,j]][t]\n        end\n    end\nend\nxs = LinRange(0.0, L, n)\nys = LinRange(0.0, L, n)\ncontourf!(xs, ys, res[:,:,10])\nanim = @animate for i ∈ 1:50\n    contourf!(xs, ys, res[:,:,i])\nend\ngif(anim, \"anim.gif\", fps = 24)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"(Image: )","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"物体温度是下降的，在不断散热。","category":"page"},{"location":"WorkFlow/ julia-binary-wrappers/#julia对外部程序的加壳","page":"julia对外部程序的加壳","title":"julia对外部程序的加壳","text":"","category":"section"},{"location":"WorkFlow/ julia-binary-wrappers/","page":"julia对外部程序的加壳","title":"julia对外部程序的加壳","text":"上面我们讲了julia可以很方便的调用外部的动态链接库中的函数。有很多的外部的库都可以编译成动态链接库，然后写个julia函数去调用。但是编译这些外部库，在不同的环境下还是要做很多的设置的。julia的JuliaBinaryWrappers组织做了很多基础的工作，维护很多外部程序编译的要求。","category":"page"},{"location":"WorkFlow/ julia-binary-wrappers/","page":"julia对外部程序的加壳","title":"julia对外部程序的加壳","text":"比如https://github.com/JuliaBinaryWrappers/CoolPropjll.jl，在其src/wrappers目录中是不用的平台（linux、windows、macosx）和不同的编译器组合对应的编译规则文件。实际上我们不用管那么多，只需要知道我们如果add CoolPropjll包就会调用合适脚本去抓取源码，然后编译成对应的动态链接库。实际上这些代码也都是由BinaryBuilder.jl自动产生的，不是手动维护的。","category":"page"},{"location":"WorkFlow/ julia-binary-wrappers/","page":"julia对外部程序的加壳","title":"julia对外部程序的加壳","text":"进一步的则可以写一个wrapper把所要的函数写个接口暴露出来。如https://github.com/CoolProp/CoolProp.jl，就是依赖了CoolProp_jll，把libcoolprop给加载了，然后写好了函数的接口。仅此而已。","category":"page"},{"location":"WorkFlow/ julia-binary-wrappers/","page":"julia对外部程序的加壳","title":"julia对外部程序的加壳","text":"类似的做法还有很多， 比如SCIP、Ipopt等等。他们的编译设置文件也都是由BinaryBuilder.jl自动产生的，不是手动维护的。","category":"page"},{"location":"WorkFlow/ julia-binary-wrappers/","page":"julia对外部程序的加壳","title":"julia对外部程序的加壳","text":"核心要义是理解这个工作方式和流程。","category":"page"},{"location":"#Ai4EDocs","page":"Home","title":"Ai4EDocs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: 图 4)  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"tip: Tip\n智慧能源：从概念到实践 \nOptControl.jl 对MTK中ODESystem的最优控制支持包。\nAi4ELab 虚拟仿真实验室\nAi4EComponentLib.jl 组件库\nAi4EMetaPSE.jl 微分方程的Json文件解析器\nAi4Server 基于Genie.jl架构的Ai4E后端服务框架。","category":"page"},{"location":"#Ai4EDocs简介","page":"Home","title":"Ai4EDocs简介","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ai4EDocs是Ai4E小组在学习中整理的一些可操作案例。案例的核心主要与建模仿真优化控制相关。文档主要特点为：","category":"page"},{"location":"","page":"Home","title":"Home","text":"既有数学层面的探究，也包含了应用层面的案例。\n包含大量Julia生态中软件包的使用\n兼顾建模仿真优化控制核心与拓展\n分享对理论抽象问题的认识\n分享软件使用过程中的技巧\n分享学习的心路历程与对库使用的理解\nAi4Energy组的合作开发流程","category":"page"},{"location":"","page":"Home","title":"Home","text":"供学习参考。","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable)","category":"page"},{"location":"","page":"Home","title":"Home","text":"欢迎贡献文档！","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable)","category":"page"},{"location":"#文档内容","page":"Home","title":"文档内容","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"dirs = [\"Frameworks\",\"Modeling\",\"Simulation\",\"Optimization\",\"Control\",\"CSBase\",\"JuliaIntro\",\"IotBigdataCloud\",\"CSAdv\",\"Tools\",\"WorkFlow\"]\n\n\"总篇数：$(sum(map(file -> length(readdir(joinpath(@__DIR__,\"..\",\"src\",file))), dirs)))\"","category":"page"},{"location":"#编程基础入门知识","page":"Home","title":"编程基础入门知识","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"CSBase\", file), readdir(\"CSBase\"))","category":"page"},{"location":"#Julia入门","page":"Home","title":"Julia入门","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"JuliaIntro\", file), readdir(\"JuliaIntro\"))","category":"page"},{"location":"#理解计算进阶","page":"Home","title":"理解计算进阶","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"CSAdv\", file), readdir(\"CSAdv\"))","category":"page"},{"location":"#建模","page":"Home","title":"建模","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"Modeling\", file), readdir(\"Modeling\"))","category":"page"},{"location":"#仿真","page":"Home","title":"仿真","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"Simulation\", file), readdir(\"Simulation\"))","category":"page"},{"location":"#优化","page":"Home","title":"优化","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"Optimization\", file), readdir(\"Optimization\"))","category":"page"},{"location":"#控制","page":"Home","title":"控制","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"Control\", file), readdir(\"Control\"))","category":"page"},{"location":"#物联网、大数据和云计算","page":"Home","title":"物联网、大数据和云计算","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"IotBigdataCloud\", file), readdir(\"IotBigdataCloud\"))","category":"page"},{"location":"#Ai4Energy系统框架","page":"Home","title":"Ai4Energy系统框架","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"Frameworks\", file), readdir(\"Frameworks\"))","category":"page"},{"location":"#附录之工具准备","page":"Home","title":"附录之工具准备","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"Tools\", file), readdir(\"Tools\"))","category":"page"},{"location":"#附录之工作流程","page":"Home","title":"附录之工作流程","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"WorkFlow\", file), readdir(\"WorkFlow\"))","category":"page"},{"location":"#附录之Julia资源传送门","page":"Home","title":"附录之Julia资源传送门","text":"","category":"section"},{"location":"#基础文档","page":"Home","title":"基础文档","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia中文文档\nJulia官方文档\nSciml总站","category":"page"},{"location":"#数值计算","page":"Home","title":"数值计算","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DifferentialEquations.jl（常微分方程求解包）\nNeuralPDE.jl（偏微分方程求解包）\nJuMP.jl（优化求解器包）\nDiffEqParamEstim.jl（基于DE的参数辨识包）\nFlux.jl Julia机器学习包(The Julia Machine Learning Library)\nEquationsSolver 自制的小型方程（组）求解器\nOptimization.jl(Sciml优化包)","category":"page"},{"location":"#符号计算","page":"Home","title":"符号计算","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ModelingToolkit.jl（符号建模包）\nSymbolics.jl（MTK依赖的符号求解包）\nSymPy.jl 符号计算包（可求方程解析解），与Matlab中的符号工具包类似","category":"page"},{"location":"#计算图形学","page":"Home","title":"计算图形学","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Meshes.jl 纯Julia的CGAL（计算图形学算法库）实现\nGmsh.jl gmsh的Julia接口","category":"page"},{"location":"#数据处理","page":"Home","title":"数据处理","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FileIO.jl Julia中不同类型文件读入的统一接口（包括MeshIO）\nCSV.jl\nDataFrames.jl（大规模数据批量处理包）\nUnitful（单位计算包）\nJSON3.jl JSON到类型的读入\nJSON.jl","category":"page"},{"location":"#可视化","page":"Home","title":"可视化","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Plots.ji（可视化包）\nPkg.jl 包管理\nMakie.jl 高性能绘图包。\nPlotlyJS.jl 网页绘图，图可拖动。","category":"page"},{"location":"#WEB框架","page":"Home","title":"WEB框架","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Geine.jl and Stipple.jl Julia Web 框架Geine和Stipple的文档\nHTTP.jl","category":"page"},{"location":"#附录之其它资源传送门","page":"Home","title":"附录之其它资源传送门","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CoolProp\nAPMonitor-github\nAPMonitor\nGreet\nMqtt系列教程\nMixed Integer Distributed Ant Colony Optimization(midaco-solver)\nPython的GUI开发工具PYQT\nMathematica","category":"page"},{"location":"Optimization/4-优化问题的求解过程/#优化问题的求解过程","page":"优化问题的求解过程","title":"优化问题的求解过程","text":"","category":"section"},{"location":"Optimization/4-优化问题的求解过程/","page":"优化问题的求解过程","title":"优化问题的求解过程","text":"优化问题的求解过程是一个复杂而动态的过程，可以根据具体问题和实践经验进行不同的改进和优化。以下是一些更深入的认识和注意事项：","category":"page"},{"location":"Optimization/4-优化问题的求解过程/","page":"优化问题的求解过程","title":"优化问题的求解过程","text":"决策变量的选择： 决策变量的选择对于问题的建模和求解至关重要。合理的决策变量选择可以简化问题的复杂性、提高求解效率，并确保决策变量与问题的实际需求相匹配。\n约束条件的建模： 约束条件的正确建模对问题的可行性和解的质量至关重要。约束条件应该准确地描述问题的限制，并尽量避免冗余或不必要的约束。合适的约束条件建模可以提高求解效率和精度。\n目标函数的定义： 目标函数的定义应准确反映问题的优化目标，并与约束条件相一致。在定义目标函数时，需要权衡不同的优化目标，并根据实际需求选择合适的目标函数形式。\n优化算法的选择： 不同的优化问题可能需要不同的优化算法来求解。在选择优化算法时，需要考虑问题的性质（如线性、非线性、凸性等）、约束条件的复杂性、求解时间要求等因素。了解各种优化算法的优劣势，并结合问题的特点进行选择。\n初始解和参数设置： 优化算法的求解结果很大程度上依赖于初始解和参数设置。提供一个合适的初始解可以加速求解过程，并有助于避免陷入局部最优解。此外，合适的参数设置也可以提高算法的收敛性和稳定性。\n结果分析和验证： 在获得优化结果后，对结果进行详细的分析和验证是十分重要的。验证结果是否满足约束条件，对决策变量的物理可行性进行检查，并评估结果的合理性和可行性。结果分析的准确性和深入程度可以提供更全面的洞见和决策支持。\n敏感性分析和场景分析： 通过敏感性分析和场景分析，可以评估决策变量对目标函数的敏感性，了解参数变化对结果的影响，并帮助识别问题的脆弱性和潜在风险。这有助于制定鲁棒和可持续的决策方案。","category":"page"},{"location":"Optimization/4-优化问题的求解过程/","page":"优化问题的求解过程","title":"优化问题的求解过程","text":"总之，优化问题的求解是一个迭代的过程，需要不断优化和改进。随着对问题的理解和经验的积累，可以更好地把握求解过程中的关键要素，并获得更准确、可行的解决方案。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#PowerShell和Windows-Terminal","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#PowerShell初印象","page":"PowerShell和Windows Terminal","title":"PowerShell初印象","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"新时代，Windows也在向Linux学习。它现在有了新的强大命令行工具，PowerShell。并且微软现在赋予了它强大的命令行下管理能力。很多修改电脑的设置都可以在PowerShell下使用命令来完成。比如说在Windows下安装WSL（Windows Subsystem for Linux）就可以用管理员打开PowerShell，通过wsl --install命令来完成。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"另外，PowerShell可以 先以管理员执行Set-ExecutionPolicy RemoteSigned，再在配置文件中设置Set-PSReadLineOption -EditMode emacs来开启Emacs键绑定，从而可以使用ctrl+e等命令进行光标快速移动。这一点仅仅是可以提高输入效率，可以先忽略。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#PowerShell简介","page":"PowerShell和Windows Terminal","title":"PowerShell简介","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"PowerShell 是一种强大的命令行工具和脚本语言，由 Microsoft 开发并广泛用于管理和自动化 Windows 系统和任务。与传统的命令提示符（CMD）相比，PowerShell 提供了更丰富的功能和更直观的语法，使系统管理员和开发人员能够更高效地管理和操作计算机系统。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"以下是一些 PowerShell 的特点和功能：","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"对象导向：PowerShell 基于对象导向的编程模型，可以使用和操作.NET Framework 中的对象。这使得在 PowerShell 中处理数据和执行操作更加灵活和直观。\n强大的命令和模块：PowerShell 提供了大量的内置命令，称为 cmdlet，用于执行各种系统管理任务。这些 cmdlet 具有一致的命名约定和参数结构，使得编写和执行命令更加简单和可预测。此外，PowerShell 还支持模块化，您可以导入和使用其他人编写的模块来扩展其功能。\n脚本和自动化：PowerShell 是一种脚本语言，可以编写和执行脚本文件以自动化重复的任务或进行批量操作。使用 PowerShell 脚本，您可以创建复杂的工作流程，处理和转换数据，访问系统资源，管理用户和权限等。\n远程管理：PowerShell 提供了强大的远程管理功能，可以通过网络远程管理其他计算机或服务器。您可以在本地计算机上使用 PowerShell 命令来执行远程计算机上的任务，访问远程计算机的文件和注册表，或者执行远程会话。\n跨平台支持：除了 Windows 系统外，PowerShell 还提供了跨平台支持，可以在 macOS、Linux 和其他操作系统上运行。这使得使用 PowerShell 进行系统管理和自动化成为跨平台环境中的一种强大工具。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"PowerShell 是一项功能强大且灵活的技术，可以用于各种任务，从简单的命令执行到复杂的系统管理和自动化。它是系统管理员、开发人员和 IT 专业人员的重要工具之一，提供了更高效、一致和可编程的方式来管理计算机系统。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#如何打开PowerShell","page":"PowerShell和Windows Terminal","title":"如何打开PowerShell","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"在 Windows 操作系统中，有几种方式可以打开 PowerShell。以下是其中一些常见的方法：","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"使用开始菜单：\n单击桌面左下角的 Windows 图标来打开开始菜单。\n在开始菜单中，找到 \"Windows PowerShell\" 或 \"PowerShell\" 的文件夹。在该文件夹中，您将找到不同版本的 PowerShell，如 PowerShell、PowerShell 7、PowerShell 5.1 等。\n点击所需的 PowerShell 版本，将打开 PowerShell 窗口。\n使用快捷键：\n按下 Windows 键 + R 组合键，将打开 \"运行\" 对话框。\n在 \"运行\" 对话框中，键入 \"powershell\"（不包括引号）并按下回车键，将打开 PowerShell 窗口。\n使用 CMD 启动 PowerShell：\n打开命令提示符（CMD）窗口。您可以按下 Windows 键 + R，然后键入 \"cmd\"（不包括引号）并按下回车键，或者按照我之前所述的步骤在开始菜单中找到并打开命令提示符。\n在命令提示符窗口中，键入 \"powershell\"（不包括引号）并按下回车键，将从 CMD 切换到 PowerShell。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"无论您选择哪种方法，都将打开一个 PowerShell 窗口，您可以在其中输入和执行 PowerShell 命令、编写和运行 PowerShell 脚本，以及进行系统管理和自动化任务。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#PowerShell可以执行Windows管理任务吗？","page":"PowerShell和Windows Terminal","title":"PowerShell可以执行Windows管理任务吗？","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"PowerShell 是一种功能强大的工具，可以执行大部分 Windows 系统管理任务，但并不是所有任务都可以完全由 PowerShell 完成。大多数 Windows 管理任务都可以通过 PowerShell 来实现，因为它提供了广泛的系统管理 cmdlet 和功能。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"以下是 PowerShell 可以执行的常见任务：","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"文件和文件夹操作：PowerShell 可以创建、复制、移动和删除文件和文件夹，以及管理文件和文件夹的权限和属性。\n进程和服务管理：PowerShell 可以列出、启动、停止和监控正在运行的进程和服务。\n注册表操作：PowerShell 可以读取、修改和删除 Windows 注册表中的键值。\n网络配置和管理：PowerShell 可以配置网络适配器、查看和修改网络设置，以及执行网络诊断任务。\n用户和组管理：PowerShell 可以创建、修改和删除用户账户和组，管理用户权限和访问控制。\n远程管理：PowerShell 提供了强大的远程管理功能，可以通过网络远程管理其他计算机或服务器。\n脚本编写和自动化：PowerShell 是一种脚本语言，可以编写脚本来自动化重复的任务，批量操作和工作流程。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"尽管 PowerShell 能够处理大多数 Windows 管理任务，但仍有一些特定任务可能需要使用其他工具或界面。一些特定的系统配置、管理工具或应用程序可能具有自己的命令行界面或API，需要使用专门的工具或命令来执行相关任务。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"综上所述，PowerShell 是一个非常强大和全面的工具，能够执行大部分 Windows 系统管理任务。但对于某些特定的任务，您可能需要使用其他工具或结合多种工具来实现所需的功能。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#Windows-Terminal简介","page":"PowerShell和Windows Terminal","title":"Windows Terminal简介","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"Windows Terminal 是一款新一代的命令行工具，由 Microsoft 开发并在 Windows 操作系统中提供。它为用户提供了一个现代化、高度可定制的命令行界面，使得同时使用多个命令行工具和 Shell 变得更加方便和强大。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"下面是 Windows Terminal 的一些特点和功能：","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"多标签和分屏：Windows Terminal 支持多个标签页和分屏布局，您可以在同一个窗口中同时打开多个命令行会话，方便同时进行多个任务或操作。\n支持多种 Shell：Windows Terminal 可以同时运行多个不同的 Shell，如 PowerShell、命令提示符（CMD）、Windows Subsystem for Linux (WSL)、Azure Cloud Shell 等。这使得用户可以根据需要选择不同的 Shell，而无需切换窗口或应用程序。\n高度可定制：Windows Terminal 允许用户自定义外观、颜色主题、字体、快捷键等，以满足个人偏好和风格需求。用户可以根据自己的喜好创建和应用自定义配置文件，定制 Terminal 的外观和行为。\n支持 Unicode 和 Emoji：Windows Terminal 全面支持 Unicode 字符和 Emoji 表情符号，使得在命令行界面中可以正确显示和处理各种语言字符和图形符号。\nGPU 加速和图形效果：Windows Terminal 基于 Windows 的 Universal Windows Platform (UWP) 技术，可以利用 GPU 加速和硬件加速，提供流畅的滚动、动画效果和图形渲染。\n快速启动和分层渲染：Windows Terminal 采用了快速启动机制和分层渲染技术，使得打开和切换会话更加迅速和高效。\n扩展性和开放性：Windows Terminal 是开源项目，允许开发人员通过扩展来增加新的功能和定制选项。用户可以从社区贡献的插件和扩展中获益，或者自己开发和分享自定义的扩展。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"总体而言，Windows Terminal 是一个现代化、可定制化和功能丰富的命令行工具，为用户提供了更好的命令行体验和更高效的工作环境。它是 Windows 平台上命令行操作的新选择，可以满足开发人员、系统管理员和技术爱好者对于命令行工具的需求。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#如何安装Windows-Terminal","page":"PowerShell和Windows Terminal","title":"如何安装Windows Terminal","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"要安装 Windows Terminal，您可以按照以下步骤进行操作：","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"打开 Microsoft Store：在 Windows 10 操作系统中，可以通过点击任务栏上的 \"Microsoft Store\" 图标来打开 Microsoft Store 应用商店。\n搜索 Windows Terminal：在 Microsoft Store 的搜索框中输入 \"Windows Terminal\"，然后按下回车键或点击搜索按钮。\n选择 Windows Terminal 应用：在搜索结果中，找到 Windows Terminal 应用，并点击它的图标以打开应用页面。\n安装 Windows Terminal：在 Windows Terminal 应用页面上，点击 \"获取\"（或 \"安装\"）按钮。系统会开始下载和安装 Windows Terminal 应用。\n启动 Windows Terminal：安装完成后，您可以在开始菜单或任务栏中找到 Windows Terminal 图标。点击图标即可启动 Windows Terminal。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"注意：为了安装 Windows Terminal，您的计算机必须运行 Windows 10 1903 或更高版本。如果您的操作系统版本较旧，请考虑更新到最新版本以获得更好的兼容性和功能支持。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"另外，Windows Terminal 也可以从 GitHub 上的源代码进行构建和安装，这需要更高级的技术知识和步骤。如果您对此感兴趣，可以访问 Windows Terminal 的 GitHub 仓库（https://github.com/microsoft/terminal）获取更多详细信息和指南。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#如何使用PowerShell的emacs键绑定？","page":"PowerShell和Windows Terminal","title":"如何使用PowerShell的emacs键绑定？","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"Set-PSReadLineOption 是 PowerShell 的一个命令，用于设置和自定义 PowerShell 的交互式命令行编辑器 PSReadLine 的选项。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"PSReadLine 是一个用于 PowerShell 的增强型命令行编辑器，提供了更强大的命令行编辑和自动完成功能。Set-PSReadLineOption 命令允许您配置和调整 PSReadLine 的各种选项，以适应个人偏好和需求。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"以下是一些常用的 Set-PSReadLineOption 命令的选项和用法示例：","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"更改提示符样式：\nSet-PSReadLineOption -Prompt 'PS> '\n这将将 PowerShell 的提示符更改为 'PS> '。\n启用语法高亮显示：\nSet-PSReadLineOption -Colors @{Command = 'Green'}\n这将启用命令的绿色语法高亮显示。\n启用自动完成：\nSet-PSReadLineOption -PredictionSource HistoryAndFileSystem\n这将启用从历史记录和文件系统中自动完成命令和路径的功能。\n修改键绑定：\nSet-PSReadLineKeyHandler -Key Tab -Function Complete\n这将将 Tab 键绑定到自动完成功能。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"这只是一些 Set-PSReadLineOption 命令的示例，您可以根据需要使用其他选项来自定义和配置 PSReadLine。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"请注意，Set-PSReadLineOption 命令只会影响当前 PowerShell 会话中的 PSReadLine 设置。如果您希望在每次启动 PowerShell 时自动应用这些设置，可以将它们添加到 PowerShell 配置文件（$PROFILE）中。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"Set-PSReadLineOption -EditMode 是用于设置 PowerShell PSReadLine 编辑模式的命令。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"在 PowerShell 中，PSReadLine 提供了多种编辑模式，用于自定义命令行的编辑行为。通过 Set-PSReadLineOption -EditMode 命令，您可以指定所需的编辑模式。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"以下是一些常见的 PSReadLine 编辑模式：","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"Emacs 模式：这是默认的 PSReadLine 编辑模式，它基于 Emacs 文本编辑器的键绑定方式。\nWindows 模式：该模式模仿了 Windows 命令行的键绑定方式，类似于 CMD 的编辑行为。\nVi 模式：该模式模仿了 Vi/Vim 文本编辑器的键绑定方式，允许您使用 Vi 风格的编辑命令。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"要设置 PSReadLine 的编辑模式，请使用以下命令示例：","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"# 设置为 Emacs 模式\nSet-PSReadLineOption -EditMode Emacs\n\n# 设置为 Windows 模式\nSet-PSReadLineOption -EditMode Windows\n\n# 设置为 Vi 模式\nSet-PSReadLineOption -EditMode Vi","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"通过运行上述命令中的任何一个，您可以在当前 PowerShell 会话中设置 PSReadLine 的编辑模式。请注意，这只会影响当前会话，不会在其他会话中生效。如果您希望每次启动 PowerShell 时都使用特定的编辑模式，请将相应的命令添加到 PowerShell 配置文件（$PROFILE）中。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#我碰到了执行策略不允许的错误","page":"PowerShell和Windows Terminal","title":"我碰到了执行策略不允许的错误","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"Set-ExecutionPolicy 命令用于设置 PowerShell 脚本的执行策略。执行策略是一种安全措施，用于限制 PowerShell 脚本的执行，以防止恶意脚本的运行。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"具体而言，Set-ExecutionPolicy 命令中的参数 RemoteSigned 是一种执行策略级别。当执行策略设置为 RemoteSigned 时，意味着在本地计算机上的脚本必须由信任的发布者签名，但在远程计算机上执行的脚本不需要签名。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"设置执行策略为 RemoteSigned 的目的是增加 PowerShell 脚本的安全性，确保只有经过签名的脚本或本地编写的脚本可以在本地计算机上执行。这样可以减少潜在的恶意脚本或未经授权的脚本对系统的影响。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"需要注意的是，执行策略是一个系统级别的设置，适用于整个计算机。因此，更改执行策略可能需要管理员权限。在执行 Set-ExecutionPolicy RemoteSigned 命令之前，您需要以管理员权限运行 PowerShell 会话。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"请注意，执行策略仅提供了一层基本的安全保护，并不能完全阻止所有潜在的安全风险。在运行任何脚本之前，仍然需要审查和确保脚本的来源和内容是可信的。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#EditMode的emacs键绑定有什么好处？","page":"PowerShell和Windows Terminal","title":"EditMode的emacs键绑定有什么好处？","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"在 Windows Terminal 中，EditMode 是一个配置选项，用于设置 PowerShell 的 PSReadLine 编辑模式。当 EditMode 设置为 \"emacs\" 时，Windows Terminal 将使用 Emacs 键绑定来提供编辑功能。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"Emacs 键绑定是基于 Emacs 文本编辑器的经典键盘快捷键，它提供了丰富的命令和编辑操作，使您可以更高效地编辑和处理文本。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"下面是一些常用的 Emacs 键绑定示例：","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"移动光标：\nCtrl + B：向后移动一个字符（相当于箭头左键）。\nCtrl + F：向前移动一个字符（相当于箭头右键）。\nCtrl + P：向上移动一行（相当于箭头上键）。\nCtrl + N：向下移动一行（相当于箭头下键）。\nCtrl + A：移到行首。\nCtrl + E：移到行尾。\nAlt + B：向后移动一个单词。\nAlt + F：向前移动一个单词。\n编辑操作：\nCtrl + D：删除光标处的字符。\nCtrl + K：删除光标到行尾的内容。\nCtrl + Y：粘贴删除的文本。\nCtrl + W：删除光标前的单词。\nCtrl + T：交换光标前后的字符。\n撤销和重做：\nCtrl + /：撤销上一次操作。\nCtrl + _：撤销上一次操作（类似于撤销）。\nCtrl + Shift + -：重做上一次操作。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"这只是一小部分 Emacs 键绑定的示例，Windows Terminal 中的 Emacs 编辑模式提供了更多的键盘快捷键，以及其他类似于 Emacs 的编辑命令和操作。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"通过在 Windows Terminal 中设置 EditMode 为 \"emacs\"，您可以在 PowerShell 会话中使用这些 Emacs 键绑定来进行编辑和操作，提高您的命令行效率和体验。","category":"page"},{"location":"CSBase/2-PowerShell和WindowsTerminal/#Linux下的shell","page":"PowerShell和Windows Terminal","title":"Linux下的shell","text":"","category":"section"},{"location":"CSBase/2-PowerShell和WindowsTerminal/","page":"PowerShell和Windows Terminal","title":"PowerShell和Windows Terminal","text":"在linux操作系统下，类似的也有命令行模式，而且是更常用的模式。尽管很多ubuntu用户首先接触到的是其gui界面，但是事实上cli更为常用一些。大多数的系统默认的是bash。操作系统内部管理文件、设备的是kernel。我们用户通过shell来跟kernel打交道。而这个bash就是shell的一种。跟Windows下的命令提示符类似，我们在shell的提示符下可以输入不同的命令来完成一些工作。比如ls是列出当前文件夹下的内容。cp是复制文件的命令。cd是改变目录的命令等等。具体这些内容可以参考linux入门书看一看，或者看一看linux cheatsheet。","category":"page"},{"location":"CSAdv/5-代码生成/#代码生成","page":"代码生成","title":"代码生成","text":"","category":"section"},{"location":"CSAdv/5-代码生成/","page":"代码生成","title":"代码生成","text":"计算，就是用计算机处理模型。处理模型有时候是生成另一套代码，我们讲一讲代码生成。","category":"page"},{"location":"CSAdv/5-代码生成/","page":"代码生成","title":"代码生成","text":"从替换、模板到ast，介绍一下。","category":"page"},{"location":"WorkFlow/gitworkflow/#Ai4E组织合作开发流程","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"tip: Tip\nContents：基于Gitkraken的合作开发流程Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"note: Note\nGitkraken为Git图形化软件。预计实践时间：60min - 120min","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"Pages = [\"gitworkflow.md\"]","category":"page"},{"location":"WorkFlow/gitworkflow/#开发流程简介","page":"Ai4E组织合作开发流程","title":"开发流程简介","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"Github是一个非常流行的代码托管平台，上面有许许多多的前辈与“他们的牛逼代码”。为了充分与国际接轨，我们（Ai4Energy）组织也选择Github。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"Ai4Energy组织可以视为一个大的代码仓库，每个人都可以向组织中贡献代码。Github基于Git，有完善且高效的多人协作的开发流程（所谓开发流程其实就是如何向Ai4Energy组织中提交代码做贡献）。","category":"page"},{"location":"WorkFlow/gitworkflow/#准备工作","page":"Ai4E组织合作开发流程","title":"准备工作","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"Github注册账户\n下载Gitkraken\n用Github账户登录Gitkraken（重要），然后建立Gitkraken的profile（个人形象，不重要）\n建立SSH登录验证方式（点击下面的绿色按钮，Gitkraken自动生成并且上传），如下图。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"(Image: 图 3)  ","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"tip: Tip\n稳定连接Github，推荐一个免费加速器Watt Toolkit，在微软应用商店。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"接下来是开发的逻辑介绍。","category":"page"},{"location":"WorkFlow/gitworkflow/#开发逻辑","page":"Ai4E组织合作开发流程","title":"开发逻辑","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"应用场景是这样的：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"在某师兄云盘里有一份报告，师兄给2个师弟说你们合作把这份报告改一改（假设两位师弟一个在美国一个在日本，且不认识，只有云盘的地址）。小师弟先改第一版，大师弟改第二版。他们需要干以下的操作：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"小师弟把文件先添加到自己的云盘资源里\n假设云盘没有在线编辑功能，小师弟修改文件只有一种选择：把文件下载到本地修改。\n小师弟修改报告\n小师弟把修改完成的报告上传至自己的云盘。\n修改完成之后，小师弟就可以对师兄说：我改完了，文件在我自己的云盘里，如果可以的话，我就把你的那一份原来的报告覆盖了。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"接下来的选择就有两种：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"师兄说：改的不错，覆盖吧。然后大师弟重复1-5步骤\n师兄说：改的不行，重改吧。然后小师弟重复2-5步骤","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"以上，就是我们工作流程的实际内涵：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"1: 这个行为叫Fork。Fork的意思是在自己的个人账号下建立一个一样的别人的仓库，而且会显示你这个仓库是fork别人的。 (Image: 图 1)","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"2: 这个行为叫Pull。一般而言，第一次在本地建仓时，会自动Pull。本地仓库建好了，若云端仓库文件有更新，这个时候本地文件要更新的话，就有相应的Pull操作。 (Image: 图 2)","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"3: 这个行为叫开发🤣。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"4: 这个行为叫Push。 (Image: 图 3)","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"5: 这个行为叫Pull Request（合并到主分支）。为要先推送到自己仓库的副本而不是直接覆盖别人的那个仓库呢？🤣","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"整体的逻辑图如下：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"(Image: 图 2)  ","category":"page"},{"location":"WorkFlow/gitworkflow/#操作步骤与方法","page":"Ai4E组织合作开发流程","title":"操作步骤与方法","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"方法对应以上5个步骤。","category":"page"},{"location":"WorkFlow/gitworkflow/#Step1:-Fork","page":"Ai4E组织合作开发流程","title":"Step1: Fork","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"(Image: 图 4)  ","category":"page"},{"location":"WorkFlow/gitworkflow/#Step2:-Pull","page":"Ai4E组织合作开发流程","title":"Step2: Pull","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"首先是本地建仓：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"(Image: 图 2)","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"拉取之后点击Open Now，我们就能看到操作页面。同时在左侧需要点击Add。GitKraken自动检测到我们Fork了一个包，它会认为你可能需要通过修改别人的代码然后上传到你自己的库里，所以它给了一个添加自己Fork的库的一个选项（如果点上，也可以手动添加远程仓库）。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"(Image: 图 5)","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"note: Note\n在Step2中，如果是从自己Fork的仓库地址建立本地仓库，也可以，只不过要手动添加Ai4的远程地址了。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"中间的蓝色绿色圈是啥呢？是文件修改的记录。","category":"page"},{"location":"WorkFlow/gitworkflow/#Step3:-本地进行内容编辑——开发","page":"Ai4E组织合作开发流程","title":"Step3: 本地进行内容编辑——开发","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/#Step4:-Push","page":"Ai4E组织合作开发流程","title":"Step4: Push","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"编辑完成之后（任何改动都会被检测到）有几个关键步骤：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"给本次修改命名，表示干了什么（例如：add a file）\n右边上方暂存修改\n右边底下提交更改\n在修改的圈那里右键，点击UpStream，修改推送地点。一定要选择自己的库，组织的库没有权限推送上去。\n最后点击Push","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"(Image: 图 6)","category":"page"},{"location":"WorkFlow/gitworkflow/#Step5:-Pull-Request（合并到主分支）","page":"Ai4E组织合作开发流程","title":"Step5: Pull Request（合并到主分支）","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"Gitkraken有图形化的方式创建Pull Request。如下：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"(Image: 图 7)","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"Pull Request就是申请将你做的修改合并到Ai4的某个仓库（任何别人的仓库）。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"tip: Tip\n为什么能合并呢？因为首先把别人的库给拉取过来了，只是做了一些修改（增加或删减内容），仓库的“根”是一致的所以能合并。就类似，小师弟把师兄的文件复制过来了，在它的基础上改，改完之后把自己的内容复制，在师兄的文件中覆盖粘贴，这是没有问题的。 所以，如果选择两个不同“根”的仓库去Pull Request，那是行不通的。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"完成之后，就等“师兄审核”吧！","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"这是一套基于Gitkraken的简版Git合作开发流程，如果有兴趣，可以去了解原汁原味的Git。相关的资料很多！","category":"page"},{"location":"WorkFlow/gitworkflow/#实践","page":"Ai4E组织合作开发流程","title":"实践","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"Ai4Energy中有一个test.jl。完成以下内容：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"完成一次上述开发过程，形成具象认知。\n开发内容：在test.jl库中的src文件夹中，添加编辑一个xxx.jl的文件，（xxx为自己的名字，中文，便于\"师兄审核\"）\n文件内容任意。期望针对文档给出改进建议，也可以是一段Julia代码。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"以上是一个简单的流程，对于Git或Gitkraken来说只是冰山一角。遇到任何疑问与问题，积极思考原因，可以自行查阅相关资料，也可以积极的和Ai4组的同学交流。","category":"page"},{"location":"CSAdv/7-写个库还是创个语言/#写个库还是创个语言","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"","category":"section"},{"location":"CSAdv/7-写个库还是创个语言/","page":"写个库还是创个语言","title":"写个库还是创个语言","text":"对于我们来说，当然是写个库啦。可以借助host语言的强大威力。不用管语言的自洽和完整。多好。","category":"page"},{"location":"Control/OptimControl/#最优控制理论与应用","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"tip: Tip\nContents：JuMP、Control、EquationsSolverContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"note: Note\nJuMP是计算优化问题的Julia软件包。Symbolics.jl为符号计算包EquationsSolver自制的小型方程（组）求解器。","category":"page"},{"location":"Control/OptimControl/#问题描述","page":"最优控制理论与应用","title":"1 问题描述","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"本篇通过一个机器人的控制问题，介绍最优控制的相关理论与求解方式。问题如下：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 1)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"题目信息总结如下：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"这是一个含有三个关节的机器人。\n机器人身体的三部分与垂直方向的夹角分别为theta=theta_1theta_2theta_3。\n机器人的三个关节能够提供使机器人运动的扭矩：Q=Q_1Q_2Q_3。\n机器人关节的扭矩与夹角之间的关系（控制方程）为：Jmathbfddottheta=Ktheta+BQ。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"扭矩对夹角的控制方程的推导方法，我们并不关心。知晓它是通过动力学学分析得出即可。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"它最重要的信息是揭示了Q与theta之间的控制关系。通过该方程，我们可以知道，如果控制量Q发生了改变，被控量theta会发生何种变化。控制方程的物理含义是，夹角变化的角加速度与夹角的位置以及关节扭矩相关。具体的系数值见上图所示。","category":"page"},{"location":"Control/OptimControl/#.1-（最优）控制内涵","page":"最优控制理论与应用","title":"1.1 （最优）控制内涵","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"从这个问题中，我们可以抽象出“控制”一般性内涵：通过改变控制量来操作被控量。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"那么什么是最优控制的内涵呢？","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"假如，机器人初始状态是斜站着（theta=fracpi4fracpi4fracpi4，弧度制单位），现在要让机器人站直（theta=000）。我们可以改变关节扭矩Q。那么问题来了，Q应该：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"是否是一个随时间不变的常数？\n如果是常数，取何值？\n是否是一个随时间变化的函数？\n如果是函数，怎样变化？","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"我们从方程中可以发现，假若对Q不加限制。只是要机器人站直，那么我可以通过改变Q，让机器人可以慢慢的站、快快的站、先蹲后站，先躺后站，先俯卧撑再站，先整几个深蹲再站 :)。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"最优的含义则体现在这些“限制”里。一般而言，若对控制的效果加以限制，使控制的某种指标最大（最小），则是最优控制。例如，让机器人最快的站直，最省力的站直。在这些“最”的限制下，Q就不是任意的了（要最快的站直就不能先做个俯卧撑再站，那样就慢了 :) ），而是仅有一组最符合要求的。在数学上，最符合要求的Q则是这个最优化问题的解。这就是最优化控制的内涵。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"综上，其关键的要素有两点：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"控制方程\n控制过程中的最优化目标","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"在以上2点关键要素之下，最优控制问题的本质是优化问题：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"优化目标：控制最优化\n优化约束：控制方程代表的变量约束以及起点终点约束等。","category":"page"},{"location":"Control/OptimControl/#状态方程","page":"最优控制理论与应用","title":"2 状态方程","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"状态空间方程是控制学中非常重要的一个概念。控制学中，把变量视为状态。其本质还是将数学上的变量赋予了物理含义。状态方程的矩阵形式为：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"dotmathbfx=mathbfA(t)mathbfx+mathbfB(t)mathbfu","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"其特征如下：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"上述mathbfx为状态向量\n上述mathbfu为系统的输入向量（控制量向量）\n上述mathbfAB为系统系数矩阵，描述内部量之间的联系。\n统一以一阶导数的形式描述。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"若把机器人的控制方程写成状态方程，则有：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"leftbeginmatrixdotmathbfx_1=mathbfx_2dotmathbfx_2=mathbfJ^-1Kmathbfx_1+mathbfJ^-1BmathbfuendmatrixrightRightarrow dotmathbfx=beginbmatrix01mathbfJ^-1K0endbmatrixmathbfx+beginbmatrix0mathbfJ^-1Bendbmatrixmathbfu","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"其中，","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"mathbfA=beginbmatrix01mathbfJ^-1K0endbmatrixmathbfB=beginbmatrix0mathbfJ^-1Bendbmatrix","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"上述mathbfx_1代表角速度向量，有三个角速度分量。\n上述mathbfx_2代表角加速度向量，有三个角加速度分量。\n上述mathbfu代表扭矩向量，有三个扭矩分量。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"如此则统一了控制问题的方程描述。状态方程也好，控制方程也好，其本质是描述系统的方程。它们只是形式上的区别，在数学本质上是一致的。统一为状态方程的好处是，能够对控制问题进行普适性的推导与计算，使得状态方程下的数学推论具有普遍意义。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"note: Note\n状态方程的定义为:描述系统状态变量与输入变量之间关系的一阶微分方程组，称为系统的状态方程。状态方程表征了系统由输入量引起的内部状态变量的变化情况。","category":"page"},{"location":"Control/OptimControl/#最优控制问题解析解","page":"最优控制理论与应用","title":"3 最优控制问题解析解","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"首先，介绍系统一般性数学描述：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"系统状态方程","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"dotx(t)=Ax(t)+Bu(t)=fx(t)u(t)t","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"由于状态量都是关于时间的因变量，所以都写成关于时间的函数。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"系统始端与终端","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"x(t_0)=x_0x(t_f)=x_f ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"系统性能指标","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"J=int_t_o^t_fLx(t)u(t)tdt","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"其次，把它写优化问题的数学形式则为：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"beginmatrix\n min int_t_o^t_fLx(t)u(t)tdtsthspace6cmdotx(t)=fx(t)u(t)tx(t_0)=x_0x(t_f)=x_f \nendmatrix","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"一般的优化问题的解是数。不同于一般的优化问题，该优化的问题的解是函数。这就涉及到数学中的变分概念。这里不过多介绍，只给结论。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"tip: Tip\n一般最优化问题中，是找到相应的数值使得优化目标最小。最优化控制问题中，是找到相应的控制函数，使得优化目标最小。一个是找数值，一个是找函数。相当于自变量变为了函数。这是泛函分析解决的问题。","category":"page"},{"location":"Control/OptimControl/#.1-端点固定问题的解法","page":"最优控制理论与应用","title":"3.1 端点固定问题的解法","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"端点固定问题即t_f的数值确定。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"求解析解的方法是拉格朗日乘子法在泛函分析中的体现。首先令，","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"H = Lx(t)u(t)t + lambda(t)^Tfx(t)u(t)t","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"上式中，H称为哈密尔顿函数，lambda(t)为伴随方程。最优控制函数存在的必要条件为：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"beginmatrix\n dotlambda = -fracpartial Hpartial x\nfracpartial Hpartial u=0\nendmatrix","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"再结合控制方程与边界方程，则可以解得分析解。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"tip: Tip\n最优控制问题中有多种边界条件。端点固定问题只是其中一种。它们分别为：终端时刻t_f固定，终端向量x(t_f)自由\n终端时刻t_f固定，终端向量x(t_f)约束\n终端时刻t_f自由，终端向量x(t_f)约束在约束中，数值确定是也是约束的一种。不同的边界条件，添加不同的边界方程，在此不过多介绍，有兴趣可以翻看《最优控制理论》。","category":"page"},{"location":"Control/OptimControl/#机器人控制问题求解实例","page":"最优控制理论与应用","title":"4 机器人控制问题求解实例","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"机器人问题的状态方程为：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"beginmatrix\n dotmathbfx=mathbfAmathbfx+mathbfBmathbfu  \nmathbfA=beginbmatrix01mathbfJ^-1K0endbmatrixmathbfB=beginbmatrix0mathbfJ^-1Bendbmatrix\nendmatrix","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"设优化目标如下，可以理解为最省力的站直方式。因为其物理含义是时间域上的扭矩平方和最小。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"J=int_t_o^t_fu^2dt","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"可以得到哈密尔顿方程为：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"H=u^2+Alambda_2x_1+lambda_1x_2+lambda_2Bu","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"代入解析解存在的必要条件：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"beginmatrix\n dotlambda_1 = -fracpartial Hpartial x_1=-lambda_2x_2 dotlambda_2 = -fracpartial Hpartial x_2=-lambda_1fracpartial Hpartial u=2u+lambda_2B=0\nendmatrix","category":"page"},{"location":"Control/OptimControl/#.1-SymPy求状态方程解析解","page":"最优控制理论与应用","title":"4.1 SymPy求状态方程解析解","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"化简伴随方程，结合控制方程，可以得到：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"beginmatrix\n ddotlambda_2 - Alambda_2= 0 u=-05*lambda_2Bddotx_1=Ax_1+Bu\nendmatrix","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"为了求得上述问题的解析解，采用SymPy。SymPy是基于python的符号计算包，其开发了julia的调用接口。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"using SymPy\n@syms t A B λ() x() #定义函数及符号变量\ndiffeq = Eq(λ(t).diff(t, 2), A * λ(t)) # 定义需要求解的方程\nλt = dsolve(diffeq, λ(t)).__pyobject__.rhs # 求解得到λ\nut = -1//2 * B * λt # 计算得到u\ndiffeq2 = Eq(x(t).diff(t, t), A * x(t) + B * ut)# 定义关于x(t)的微分方程\ndsolve(diffeq2, x(t))  # 求解","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"warning: Warning\n在上述代码中，0.5需要用1//2，这样x(t)才能求得解析解，否则会报错。因为0.5是浮点数。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"得到结果如下：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 2)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"即：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"x_1(t)=(C_3+C_1fracB^2t4sqrtA)exp^-sqrtAt+(C_4-C_2fracB^2t4sqrtA)exp^sqrtAt","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"同时，对x_1(t)进行求导，得到x_2(t)。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"dsolve(diffeq2, x(t)).__pyobject__.rhs.diff(t)","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 1)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"即：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"x_2(t)=-(sqrtAC_3+C_1fracB^2t4)exp^-sqrtAt+(sqrtAC_4-C_2fracB^2t4)exp^sqrtAt+C_1fracB^2t4sqrtAexp^-sqrtAt-C_2fracB^2t4sqrtAexp^sqrtAt","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"这里一共有4个未知数:C_1C_2C_3C_4，通过4个边界调节确定：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"beginmatrix\nx_1(0)=fracpi4fracpi4fracpi4x_1(1)=000x_2(0)=000x_2(1)=000\nendmatrix","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"4个边界方程则可解出4个未知数C_1C_2C_3C_4。实际上C_1C_2C_3C_4是4个向量，每个向量分别对应机器人三部分的参数。在求解时，实际上是12个变量。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"note: Note\n也可以通过SymPy直接求解微分方程组。能获得同样的结果。using SymPy  \n@syms t A B λ1() x1() λ2() x2()\neqs = [\nEq(λ1(t).diff(t), -A * λ2(t)),\nEq(λ2(t).diff(t), -λ1(t)),\nEq(x1(t).diff(t), x2(t)),\nEq(x2(t).diff(t), A * x1(t) - B^2 / 2 * λ2(t))\n]\ndsolve(eqs)","category":"page"},{"location":"Control/OptimControl/#.2-参数矩阵求解","page":"最优控制理论与应用","title":"4.2 参数矩阵求解","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"下面介绍如何在Julia生态高效计算4个未知数。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"需要运用符号处理包——Symbolics.jl。该包在MTK的\"前世今生\"已经介绍过。本篇中也会用到。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"using Symbolics, EquationsSolver, LinearAlgebra\n# ==========================functions==================== #\nfunction initPara()\n    J1 = 1.0 / 12 * collect(I(3))\n    C1 = 0.5 * [1 2 2; 0 1 2; 0 0 2]\n    D1 = 0.5 * [1 0 0; 2 1 0; 4 2 1]\n    J = J1 + C1 * D1\n    K = 0.5 * [5 0 0; 0 3 0; 0 0 1]\n    B = [1 -1 0; 0 1 -1; 0 0 1]\n    A = inv(J) * K\n    B = inv(J) * B\n    return A, B\nend\n\nfunction x1(A, B, t, C1, C2, M1, M2)\n    A = sqrt(A)\n    B = inv(A) * B * B / 4\n    s = -(B * t) .* exp.(A * t) .* C1\n    s = s .+ exp.(A * t) .* M1\n    s = s .+ (B * t) .* exp.(-A * t) .* C2\n    s = s .+ exp.(-A * t) .* M2\n    return s\nend\n\nfunction x2(A, B, t, C1, C2, M1, M2)\n    A = sqrt(A)\n    B = B * B / 4\n    s = (-B * t .* C1 .+ A * M1 .- inv(A) * B * C1) .* exp.(A * t)\n    s = s .+ (-B * t .* C2 .- A * M2 .+ inv(A) * B * C2) .* exp.(-A * t)\n    return s\nend\n\nfunction SolvePro(eqs, init, vars)\n    pro = NLProblem(eqs, init)\n    res = solve(pro)\n    return [reshape([res[var[i]] for i in 1:3], (3, 1)) for var in vars]\nend\n\nfunction condition(θfields, A, B, tfields, C1, C2, M1, M2)\n    res = x1(A, B, tfields[1], C1, C2, M1, M2)\n    eqs = [res[i] ~ θfields[1][i] for i in 1:3]\n    res = x1(A, B, tfields[2], C1, C2, M1, M2)\n    append!(eqs, [res[i] ~ θfields[2][i] for i in 1:3])\n    res = x2(A, B, tfields[1], C1, C2, M1, M2)\n    append!(eqs, [res[i] ~ θfields[3][i] for i in 1:3])\n    res = x2(A, B, tfields[2], C1, C2, M1, M2)\n    append!(eqs, [res[i] ~ θfields[4][i] for i in 1:3])\n    return eqs\nend\n\nfunction Problem(A, B, θfields, tfields)\n    vars = @variables C1[1:3] C2[1:3] M1[1:3] M2[1:3]\n    C1, C2, M1, M2 = [reshape(collect(var), 3, 1) for var in vars]\n    eqs = condition(θfields, A, B, tfields, C1, C2, M1, M2)\n    init = Dict(var[i] => 0.0 for var in vars for i in 1:3)\n    return SolvePro(eqs, init, vars)\nend\n\n\n# ==========================main==================== #\nA, B = initPara()\n# 分别为x1(0) x1(t) x2(0) x2(t)的边界值\nθfields = [[π / 3, -π / 4, π / 2], [0, 0, 0], [0, 0, 0], [0, 0, 0]]\ntfields = (fill(0.0, 3, 1), fill(1.0, 3, 1))\nN = 100\nC1, C2, M1, M2 = Problem(A, B, θfields, tfields)\nt = (0, 1)\n\ndegrees = [x1(A, B, fill(i, 3, 1), C1, C2, M1, M2) for i in range(t[1], t[2], length=N)]\nvelocity = [x2(A, B, fill(i, 3, 1), C1, C2, M1, M2) for i in range(t[1], t[2], length=N)]","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"warning: Warning\nSolvePro()中，fracB^2t4sqrtA等含有除以矩阵A的式子，在编写时都要写为左乘A的逆矩阵。这是由数学含义决定的，否则结果错误。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"上述代码的核心思想为：将符号计算与数字计算在形式上统一。核心为函数x1()与x2()。其便捷性在于，若把符号矩阵作为传递给x1()，则x1()计算结果为符号矩阵，若传递数值，则计算结果为数值解。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"符号计算解参数：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"function SolvePro(eqs, init, vars)\n    pro = NLProblem(eqs, init)\n    res = solve(pro)\n    return [reshape([res[var[i]] for i in 1:3], (3, 1)) for var in vars]\nend\nfunction condition(θfields, A, B, tfields, C1, C2, M1, M2)\n    res = x1(A, B, tfields[1], C1, C2, M1, M2)\n    eqs = [res[i] ~ θfields[1][i] for i in 1:3]\n    res = x1(A, B, tfields[2], C1, C2, M1, M2)\n    append!(eqs, [res[i] ~ θfields[2][i] for i in 1:3])\n    res = x2(A, B, tfields[1], C1, C2, M1, M2)\n    append!(eqs, [res[i] ~ θfields[3][i] for i in 1:3])\n    res = x2(A, B, tfields[2], C1, C2, M1, M2)\n    append!(eqs, [res[i] ~ θfields[4][i] for i in 1:3])\n    return eqs\nend\nfunction Problem(A, B, θfields, tfields)\n    vars = @variables C1[1:3] C2[1:3] M1[1:3] M2[1:3]\n    C1, C2, M1, M2 = [reshape(collect(var), 3, 1) for var in vars]\n    eqs = condition(θfields, A, B, tfields, C1, C2, M1, M2)\n    init = Dict(var[i] => 0.0 for var in vars for i in 1:3)\n    return SolvePro(eqs, init, vars)\nend","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"在Problem()函数中，定义了12个未知数。\n将符号作为参数传递给condition()并通过其构建待求解方程。如果兴趣可以在函数中Print待求解方程结果。\n通过SolvePro()调用EquationsSolver方程求解器求解。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"最终可得到12个参数的结果","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"数字计算算结果：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"在计算出4个参数向量后，SolvePro()经过结果处理返回参数向量值，再调用x1()与x2()时，则能够得到各时间点的数值。具体的操作方式如下：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"t = (0, 1)\ndegrees = [x1(A, B, fill(i, 3, 1), C1, C2, M1, M2) for i in range(t[1], t[2], length=N)]\nvelocity = [x2(A, B, fill(i, 3, 1), C1, C2, M1, M2) for i in range(t[1], t[2], length=N)]","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"在调用x1()与x2()时，不过是传递了不同的参数，就能得到不同结果的类型。传递符号就计算符号，传递数值就计算数值。符号与数值本在数学形式上是一致的，在Julia中则完美地实现了这一点！","category":"page"},{"location":"Control/OptimControl/#.3-解析解可视化","page":"最优控制理论与应用","title":"4.3 解析解可视化","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"degrees = real.(degrees)\nvelocity = real.(velocity)\nusing Plots\nfilename = \"./a.gif\"\nlen = 1\nanim = @animate for i in 1:N\n    strings = \"t=$(i/N*(t[2]-t[1])+t[1])  \"\n    strings *= \"v₁=\" * string(round.(velocity[i][1], digits=2))\n    strings *= \" v₂=\" * string(round.(velocity[i][2], digits=2))\n    strings *= \" v₃=\" * string(round.(velocity[i][3], digits=2))\n    l = collect(0:0.01:len)\n    xs1 = l .* sin(degrees[i][1])\n    ys1 = l .* cos(degrees[i][1])\n    xs2 = l .* sin(degrees[i][2]) .+ xs1[end]\n    ys2 = l .* cos(degrees[i][2]) .+ ys1[end]\n    xs3 = l .* sin(degrees[i][3]) .+ xs2[end]\n    ys3 = l .* cos(degrees[i][3]) .+ ys2[end]\n    plot([xs1, xs2, xs3], [ys1, ys2, ys3],\n        ylims=(0, 4), xlims=(-3, 3), w=3,\n        grid=false, showaxis=false, legend=false,\n        title=strings)\nend\ngif(anim, filename, fps=24)","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"上面的实例计算的是机器人初态为theta=fracpi3-fracpi4fracpi2的情况。动图如下：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 2)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"机器人初态为theta=fracpi3fracpi4fracpi5的情况：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 3)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"机器人初态为theta=fracpi18fracpi6fracpi4的情况：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 4)  ","category":"page"},{"location":"Control/OptimControl/#数值解","page":"最优控制理论与应用","title":"5 数值解","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"该问题使用数值解则很好解决，优化问题使用JuMP则迎刃而解。","category":"page"},{"location":"Control/OptimControl/#.1-求解方法","page":"最优控制理论与应用","title":"5.1 求解方法","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"首先看一个示例：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"using JuMP, LinearAlgebra, Ipopt, Statistics\n\nθ = [π / 3, -π / 4, π / 2]\nθ = [π / 18, π / 6, π / 4]\nθ = [π / 3, π / 4, π / 5]\nN = 100\ntf = 4.0\n\n#---------------------------------------------#\nfunction initPara()\n    J1 = 1.0 / 12 * collect(I(3))\n    C1 = 0.5 * [1 2 2; 0 1 2; 0 0 2]\n    D1 = 0.5 * [1 0 0; 2 1 0; 4 2 1]\n    J = J1 + C1 * D1\n    K = 0.5 * [5 0 0; 0 3 0; 0 0 1]\n    B = [1 -1 0; 0 1 -1; 0 0 1]\n    A = inv(J) * K\n    B = inv(J) * B\n    return A, B\nend\nA, B = initPara()\nmodel = Model(Ipopt.Optimizer)\n@variables(model, begin\n    -π / 2 <= x1[1:N, 1:3] <= π / 2\n    x2[1:N, 1:3]\n    -10 <= u[1:N, 1:3] <= 10\nend)\ninitzeros = zeros(3)\nfor j in 1:3\n    @NLconstraint(model, x1[1, j] == θ[j])\n    @NLconstraint(model, x2[1, j] == initzeros[j])\n    @NLconstraint(model, x1[N, j] == initzeros[j])\n    @NLconstraint(model, x2[N, j] == initzeros[j])\nend\nfor i in 1:N-1\n    a1 = x1[i, :] + (x2[i+1, :] + x2[i, :]) * 0.5 * tf / N\n    a2 = x2[i, :] + (A * (x1[i+1, :] + x1[i, :]) + B * (u[i+1, :] + u[i, :])) * 0.5tf / N\n    for j in 1:3\n        @NLconstraint(model, x1[i+1, j] == a1[j])\n        @NLconstraint(model, x2[i+1, j] == a2[j])\n    end\nend\n@NLobjective(model, Min, sum(20 / π * x1[i, j]^2 + u[i, j]^2 for i in 1:N-1 for j in 1:3))\nJuMP.optimize!(model)\ndegrees = JuMP.value.(x1)\nvelocity = JuMP.value.(x2)\n\n\nusing Plots\nfilename = \"./u_x_a4.gif\"\nlen = 1\nanim = @animate for i in 1:N\n    strings = \"Numerical t=$(i/N*tf)  \"\n    strings *= \"v₁=\" * string(round(velocity[i, 1], digits=2))\n    strings *= \" v₂=\" * string(round(velocity[i, 2], digits=2))\n    strings *= \" v₃=\" * string(round(velocity[i, 3], digits=2))\n    l = collect(0:0.01:len)\n    xs1 = l .* sin(degrees[i, 1])\n    ys1 = l .* cos(degrees[i, 1])\n    xs2 = l .* sin(degrees[i, 2]) .+ xs1[end]\n    ys2 = l .* cos(degrees[i, 2]) .+ ys1[end]\n    xs3 = l .* sin(degrees[i, 3]) .+ xs2[end]\n    ys3 = l .* cos(degrees[i, 3]) .+ ys2[end]\n    plot([xs1, xs2, xs3], [ys1, ys2, ys3],\n        ylims=(0, 4), xlims=(-3, 3), w=3,\n        grid=false, showaxis=false, legend=false,\n        title=strings)\nend\ngif(anim, filename, fps=24)","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"该示例包含了求解与可视化，有如下特征:","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"时间采样数（离散数）为：N = 100；\n调节时间为：tf = 4；\n优化变量（扭矩、角度）有范围限制；\n终端对速度也有约束；\n状态方程作为优化问题的约束，约束不同时刻的状态量之间的关联（不同时间的角度值为不同优化变量。角度状态，角速度状态，扭矩状态各有3N个）。状态方程变为离散结构，因为一旦涉及到数值解，必定是离散化的。离散的方式是二阶的梯形法；\n优化目标为sum_j=1^3sum_i=1^Nfrac20pix_1(ij)^2+u_(ij)^2","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"tip: Tip\n离散的概念有两种理解，一种为问题性质上的理解，即问题本身具有离散性质。另外一种是方法上的理解，即求解问题的过程中对于连续问题采用了离散化的方式。问题性质的离散，是变量本身的一种状态或特性，如开关状态的0与1是独立的状态，本身具有不连续的特性。而离散化是对于连续问题的求解方式。问题本身是连续的，但是为了使用数值计算方法求得数值解，需要取“连续”中的一些相互间隔的“离散”点来代表“连续”。例如，微分方程的数值解法欧拉法的步长则是具有“连续”性质的离散。微分方程的数值解法，一定是离散化的方法——在时间域上选取一定步长间隔的点求解。这两者都可以认为是离散问题，而离散化的方法决定了数值计算的精度以及求解的计算量。从方法的层面说，数值计算本身就是离散问题，对于使用计算机进行数值求解来说，不存在连续求解方法。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"对于以上6点，先不做说明，可以先看一些结果。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况一","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"优化目标：sum_j=1^3sum_i=1^Nu_(ij)^2；\n参数：N = 100，tf = 1；\n末速度限制为0；变量无约束。\n初态为theta=fracpi3-fracpi4fracpi2","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 5)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况二 ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"优化目标：sum_j=1^3sum_i=1^Nu_(ij)^2；\n参数：N = 100，tf = 1；\n末速度无限制；变量无约束。\n初态为theta=fracpi3-fracpi4fracpi2","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 6)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况三 ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"优化目标：sum_j=1^3sum_i=1^Nx_1(ij)^2；\n参数：N = 100，tf = 1；\n末速度限制为0；变量无约束。\n初态为theta=fracpi3-fracpi4fracpi2","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 8)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况四","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"优化目标：sum_j=1^3sum_i=1^Nx_1(ij)^2；\n参数：N = 100，tf = 2；\n末速度限制为0；变量范围限制：-10=u=10。\n初态为theta=fracpi3-fracpi4fracpi2","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 9)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况五","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"优化目标：sum_j=1^3sum_i=1^Nx_1(ij)^2+u_(ij)^2；\n参数：N = 100，tf = 4；\n末速度限制为0；变量范围限制：-10=u=10。\n初态为theta=fracpi3-fracpi4fracpi2","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 10)  ","category":"page"},{"location":"Control/OptimControl/#.2-对比分析","page":"最优控制理论与应用","title":"5.2 对比分析","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况一（站直且速度为零）与情况二（站直速度任意）为不同边界约束的结果。情况一确实不如情况二“迅猛”，情况一的机器人有些拘束，情况二的动作则一气呵成，因为约束少了。同时，情况一的解析解与数值解结果，机器人动作非常神似。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况一（最省力）、情况三（距离最短）与情况五（省力也要距离短）为不同优化条件的结果。可以看出来情况五综合了情况一个和情况二的优点。同时，情况五x_1前面的系数目的是为了平衡优化的效果——将角度值与速度值置于同一量级，即加大省距离的权重。这类似于机器学习的正则化。其实他们在内涵上有相通之处，通过权重规定了对不同优化目标的“重视程度”！","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况三与情况四的不同之处在于控制量的范围约束与调节时间限制。在数学上来说，不管给定何种始终条件，若控制量u不限制，则一定能完成控制任务（优化问题有解）。所以在条件4的控制量约束下，若是设tf=1，则在求解时找不到最优解，唯有把时间放款才能在控制量约束下找到解。这非常符合实际，控制量不能无限大，控制过程也需要时间。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"事实上，也可以通过解析解来验证这些结论，但解析解的代码量太大，不如数值解来得方便 :) 。例如，同时考虑x与u的解析解结果为 :)：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 11)  ","category":"page"},{"location":"Control/OptimControl/#总结","page":"最优控制理论与应用","title":"总结","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"由机器人的最优控制问题，介绍最优问题的解析解与数值解。从两方面基本上已经诠释了最优控制的内涵。即，为了某种目标去找到一组最合适的控制量。事实上，这只是控制的第一步，计算结果都是静态的。接下来还需要根据实际的系统反馈进行时间域上的滚动优化，滚动起来后，就能够利用系统的反馈，实现了真正意义上的控制——对反馈的处理与计算。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"另外，从整个机器人问题求解的过程也可以看出Julia生态的强大之处。当问题清楚之后，灵活使用Julia生态的各种软件包，能方便快捷地计算出结果。事实上，最优控制问题的底层数学形式为两种——求解类问题（解析解）与优化类问题（数值解）。同时，符号计算使得编写代码方便快捷。这三者恰恰是Julia计算的长处。所以Julia处理最优控制问题，可以用两个词来形容——丝滑、顺畅。","category":"page"},{"location":"JuliaIntro/2-julia的REPL/#julia的REPL","page":"julia的REPL","title":"julia的REPL","text":"","category":"section"},{"location":"JuliaIntro/2-julia的REPL/#什么是REPL","page":"julia的REPL","title":"什么是REPL","text":"","category":"section"},{"location":"JuliaIntro/2-julia的REPL/","page":"julia的REPL","title":"julia的REPL","text":"REPL是\"Read-Eval-Print Loop\"（读取-求值-输出循环）的缩写，它是一种交互式的编程环境。REPL通常是通过命令行界面提供的，允许用户输入代码、进行求值和查看结果。","category":"page"},{"location":"JuliaIntro/2-julia的REPL/","page":"julia的REPL","title":"julia的REPL","text":"在Julia中，REPL是与Julia交互的主要方式。当您打开Julia的命令行界面或终端时，您就进入了Julia的REPL环境。REPL具有以下主要功能：","category":"page"},{"location":"JuliaIntro/2-julia的REPL/","page":"julia的REPL","title":"julia的REPL","text":"读取（Read）：REPL等待用户输入Julia代码。用户可以逐行输入代码，也可以将代码块作为一次性输入。\n求值（Eval）：一旦用户输入了代码，REPL会对代码进行求值。它会将代码发送给Julia的解释器或编译器，并计算结果。\n输出（Print）：求值完成后，REPL会将结果显示在终端中。这可以是计算结果、变量的值、函数的输出或错误信息。\n循环（Loop）：一旦输出被显示，REPL会再次等待用户的输入，形成一个循环。用户可以继续输入新的代码，并重复读取、求值和输出的过程。","category":"page"},{"location":"JuliaIntro/2-julia的REPL/","page":"julia的REPL","title":"julia的REPL","text":"REPL是一个交互式的环境，它使您能够迅速尝试和调试代码，查看计算结果，并与Julia进行实时交互。它是学习、测试和探索Julia语言的重要工具。","category":"page"},{"location":"JuliaIntro/2-julia的REPL/","page":"julia的REPL","title":"julia的REPL","text":"除了在命令行中使用的REPL，还有一些基于Web的交互式Julia环境，如Jupyter Notebook和Pluto.jl，它们提供了更丰富的功能和更好的可视化支持。","category":"page"},{"location":"JuliaIntro/2-julia的REPL/#julia的REPL-2","page":"julia的REPL","title":"julia的REPL","text":"","category":"section"},{"location":"JuliaIntro/2-julia的REPL/","page":"julia的REPL","title":"julia的REPL","text":"当使用Julia的REPL（Read-Eval-Print Loop）时，您可以直接在终端中输入和执行Julia代码，以便快速尝试和调试代码片段。以下是一些关于Julia REPL的重要信息和常用命令：","category":"page"},{"location":"JuliaIntro/2-julia的REPL/","page":"julia的REPL","title":"julia的REPL","text":"启动Julia REPL：在终端中输入\"julia\"命令，然后按下回车键，即可启动Julia的REPL。您将看到一个交互式的Julia环境。\n执行代码：在Julia REPL中，您可以直接输入Julia代码，并按下回车键执行。Julia将立即执行代码并显示结果。\n多行输入：如果您有多行代码需要输入，可以使用连续的三个小数点（...）来表示多行输入。在输入完最后一行代码后，按下回车键即可执行。\n历史记录：Julia REPL会记住您在当前会话中输入的代码，并将其记录在历史记录中。您可以使用上下箭头键来浏览和重新执行之前的代码。\n帮助文档：要获取关于Julia函数、模块或类型的帮助文档，您可以在REPL中输入问号（?）后跟着您感兴趣的函数或类型的名称，然后按下回车键。Julia将显示相关的帮助文档。\n退出REPL：要退出Julia REPL，您可以输入\"exit()\"或按下Ctrl+D（在大多数系统上）。","category":"page"},{"location":"JuliaIntro/2-julia的REPL/","page":"julia的REPL","title":"julia的REPL","text":"Julia的REPL是一个强大的工具，可用于快速测试代码、尝试新功能、查看帮助文档等。它提供了一个与Julia交互的方式，使您能够更加灵活地使用和学习Julia语言。","category":"page"},{"location":"JuliaIntro/2-julia的REPL/","page":"julia的REPL","title":"julia的REPL","text":"希望这些信息能够帮助您向学生介绍Julia的REPL！如有任何进一步的问题，请随时向我提问。","category":"page"},{"location":"JuliaIntro/2-julia的REPL/#julia的REPL的4个模式","page":"julia的REPL","title":"julia的REPL的4个模式","text":"","category":"section"},{"location":"JuliaIntro/2-julia的REPL/","page":"julia的REPL","title":"julia的REPL","text":"Julia REPL提供了四个不同的模式，每个模式都有不同的用途和功能。以下是关于Julia REPL的四个模式的简要介绍：","category":"page"},{"location":"JuliaIntro/2-julia的REPL/","page":"julia的REPL","title":"julia的REPL","text":"默认模式 (Default mode)： 默认模式是Julia REPL的标准模式，也是您在启动REPL时进入的模式。在默认模式下，您可以输入和执行Julia代码，并查看代码的结果。默认模式是最常用的模式，适用于大多数日常的交互式编程任务。\n帮助模式 (Help mode)： 帮助模式是一种特殊的模式，用于查看Julia函数和类型的帮助文档。要进入帮助模式，您可以在REPL中输入问号（?）后跟着您感兴趣的函数或类型的名称，然后按下回车键。在帮助模式下，您可以浏览和搜索函数的用法、参数以及相关的示例代码。要退出帮助模式，只需按下回车键即可返回默认模式。\n包管理模式 (Package mode)： 包管理模式允许您管理Julia的软件包（Packages）。Julia的软件包是用于扩展和增强Julia功能的工具。在包管理模式下，您可以安装、更新和删除软件包，查看已安装软件包的列表，以及管理项目的依赖关系。要进入包管理模式，您可以在REPL中输入\"]\"（右方括号），然后按下回车键。在包管理模式下，您可以使用各种命令来管理软件包。要退出包管理模式，只需输入\"exit\"并按下回车键即可返回默认模式。\nShell模式 (Shell mode)： Shell模式允许您在Julia REPL中执行系统命令。在Shell模式下，您可以使用Julia REPL作为一个简单的终端来执行操作系统命令，如列出目录内容、运行脚本文件等。要进入Shell模式，您可以在REPL中输入分号（;），然后按下回车键。在Shell模式下，您可以输入系统命令并查看其输出。要退出Shell模式，只需输入\"exit\"并按下回车键即可返回默认模式。","category":"page"},{"location":"JuliaIntro/2-julia的REPL/","page":"julia的REPL","title":"julia的REPL","text":"这些不同的模式使Julia REPL成为一个更加灵活和功能丰富的工具，适用于不同的工作流程和任务。您可以根据需要切换不同的模式，以最大程度地发挥Julia REPL的潜力。","category":"page"},{"location":"JuliaIntro/2-julia的REPL/","page":"julia的REPL","title":"julia的REPL","text":"希望这些介绍有助于您了解Julia REPL的四个模式！如有任何进一步的问题，请随时向我提问。","category":"page"},{"location":"Modeling/ModelingTutorial/#组织方程的艺术——组件化（入门）","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"tip: Tip\nContents：建模思想Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Modeling/ModelingTutorial/#前言","page":"组织方程的艺术——组件化（入门）","title":"前言","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"Ai4Energy开发者总是张口闭口组件化建模，那么组件化建模的内涵到底是什么？为什么要组件化建模？这篇我们从头至尾介绍做一个组件化思想的入门介绍。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"建模用ModelingToolkit.jl；求解用DifferentialEquations.jl。","category":"page"},{"location":"Modeling/ModelingTutorial/#电路问题","page":"组织方程的艺术——组件化（入门）","title":"电路问题","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"以电路系统切入，深入探讨组件化建模的内涵是最合适不过的了。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"首先准备2个电路元件的方程。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"欧姆定律：电阻两端的电压与流过电阻电流成正比。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"U=IR","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电容器：电容两端电压的变化率与电流成正比。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"fracdVdt = fracIC","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"tip: Tip\nC是电容量，单位为法拉（F）。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"我们再准备一个电路系统，如下图:","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"(Image: 图 5)  ","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"需要求解的问题是：电容初始电压为0，当开关闭合后，电容电压电流的变化情况是？","category":"page"},{"location":"Modeling/ModelingTutorial/#手搓求解","page":"组织方程的艺术——组件化（入门）","title":"手搓求解","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"手搓的意思是电路中学的传统解法。开关闭合后，视为导线。采用节点电压法求解。标记三个节点1，2，3。节点电压分别为V_1V_2V_3，如下图。整个电路只有一条主路，所以电流为I。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"(Image: 图 6)  ","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"所以电路的方程为：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"V_1-V_3=1 (V) \nV_1-V_2=1 (Omega) * I\nfracd(V_2-V_3)dt = fracI1 (F) = I\nV_3 = 0 tag1","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"手动化简之后可以得到2种情况：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"保留I，化简掉V_1V_3V_2。开关刚闭合，有电容视为导线，则0时刻，I=1","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"frac1-Idt = -fracdIdt= I\nI_0 = 1(A) tag2","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"保留V_2，化简掉V_1V_3I","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"fracdV_2dt = 1-V_2\nV_20=0(V) tag3","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"以上微分方程式2或3，求解任何一个，把结果代回方程组1，整个电路系统的情况就可以得到了。这个问题就解决了。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"下面看一看组件化怎么做！","category":"page"},{"location":"Modeling/ModelingTutorial/#组件化求解","page":"组织方程的艺术——组件化（入门）","title":"组件化求解","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"在之前的基础之上，我们只做一件事情——引入额外的变量。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"为每个器件添加两个端口变量（地只加一个端口）。正极叫p，负极叫n。同时为器件取名，电源叫做source，电阻叫做resistor，电容叫做capacitor，地叫做ground。同时规定，器件索引其子要素的方式为“.”。例如，电阻正极电压的变量全名为resistorpV。如下图所示。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"(Image: 图 2)  ","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"那么我们新引入了14个变量：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电源的4个","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"sourcenV\nsourceni\nsourcepV\nsourcepi","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电阻的4个","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"resistornV\nresistorni\nresistorpV\nresistorpi","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电容的4个","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"capacitornV\ncapacitorni\ncapacitorpV\ncapacitorpi","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"地的两个","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"groundportV\ngroundporti","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"再研究一下变量关系，我们可以发现。所有端口电流（地端口除外）的数值都等于I，端口电压值都等于对应的电压节点的电压。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"这，貌似就是给V_1V_3V_2I这几个变量加了很多别名？一顿操作猛如虎，细想发现全白干，形式主义我最行？","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"下面才是主菜！","category":"page"},{"location":"Modeling/ModelingTutorial/#Step1:-把V_1,V_3,V_2,I**全踢掉**，如下图。","page":"组织方程的艺术——组件化（入门）","title":"Step1: 把V_1V_3V_2I全踢掉，如下图。","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"(Image: 图 3)   ","category":"page"},{"location":"Modeling/ModelingTutorial/#Step2.-分别写组件的方程，规定电流入流为正，流出为负：","page":"组织方程的艺术——组件化（入门）","title":"Step2. 分别写组件的方程，规定电流入流为正，流出为负：","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电源：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"sourcepV - sourcenV = 1 (V)\nsourcepI + sourcenI = 0","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电阻：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"resistorpV - resistornV = resistorpI * 1 (Omega)\nresistorpI + resistornI = 0","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电容：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"fracd(capacitorpV - capacitornV)dt = fraccapacitorpI1 (F) \ncapacitorpI + capacitornI = 0","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"地（规定电势为0的点，电流不做要求）：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"groundportV = 0\ngroundportI = 0","category":"page"},{"location":"Modeling/ModelingTutorial/#Step3:-构建连接关系","page":"组织方程的艺术——组件化（入门）","title":"Step3: 构建连接关系","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电源和电阻连（等价于节点1，节点电压相等、电流净流量为0）","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"sourcenV = resistorpV\nsourcenI + resistorpI = 0","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电阻和电容连（等价于节点2，节点电压相等、电流净流量为0）","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"resistornV = capacitorpV\nresistornI + capacitorpI = 0","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电容、电源和地连（等价于节点3，节点电压相等、电流净流量为0）","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"capacitornV = sourcpV = groundportV\ncapacitornI + sourcpI + groundportI= 0\n","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"稍微思考一下可以发现，上述10多个方程组成的方程大组，其数学本质与方程小组1完全等价！唯一的区别是前者多引入了很多变量，并且这些变量完全可以消去！","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"但是，前者完成了组件化的封装，由此连接关系与组件内部之间成了相互独立的关系。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"什么意思呢？以V_1为例。V_1既是电压源的出口电压又是电阻的正极电压。同时V_1作为节点电压，已经消去了电流的概念。这就意味每节点是不同的。而组件化的内涵就是把这一点拆解成了两部分：连接与组件内部。以电阻的正负极端口为例，对内建立组件内部的方程：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"resistorpV - resistornV = resistorpI * 1","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"其本质就是U=IR；对外建立与其他组件连接：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"sourcepV = resistorpV\nsourcenI + resistorpI = 0\nresistornV = capacitorpV\nresistornI + capacitorpI = 0","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"其本质就是节点电压1和2.","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"这么多方程很复杂但逻辑清晰。其实它很简单，因为化简计算机会去做。","category":"page"},{"location":"Modeling/ModelingTutorial/#求对比解","page":"组织方程的艺术——组件化（入门）","title":"求对比解","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/#手搓版","page":"组织方程的艺术——组件化（入门）","title":"手搓版","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"把节点电压法的分析过程，写成ModelingToolkit的代码。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"tip: Tip\n在VScode中，输入入V_3就能输入V₃(Image: 图 1)  在VScode中，按下Ctrl+Enter可以执行光标所在行的一行代码。以下的代码可以一行一行执行，看中间结果。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"using ModelingToolkit, DifferentialEquations\n\n# 定义变量\n@variables t\n@variables V₁(t) V₂(t) V₃(t) I(t)\n\n# 定义微分\nD = Differential(t)\n\n# 设置参数\nR = 1.0\nC = 1.0\nV = 1.0\n\n# 输入方程\nrc_eqs = [\n    V₁ - V₃ ~ V\n    V₁ - V₂ ~ I * R\n    D(V₂) ~ I / C\n    V₃ ~ 0\n]\n\n# 构建系统\n@named rc_model = ODESystem(rc_eqs, t)\n\n# 系统化简\nsys = structural_simplify(rc_model)\n\n# 设置初值\nu0 = [\n    V₂ => 0.0\n]\n# 求解时间范围\ntspan = (0.0, 10.0)\n\n# 构建问题并求解\nprob = ODAEProblem(sys, u0, tspan)\nsol = solve(prob, Tsit5())\n\n# 分别查看 V₁, V₂, V₃ 的变化\nsol[V₂]\nsol[V₁]\nsol[V₃]\n","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"再查看一下化简前的方程：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"equations(rc_model)","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"再查看一下化简后的方程：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"equations(sys)","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"方程中V_1=1，和推导的结果是一致的。","category":"page"},{"location":"Modeling/ModelingTutorial/#组件版","page":"组织方程的艺术——组件化（入门）","title":"组件版","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"把组件化的过程，写成代码。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"using ModelingToolkit, DifferentialEquations\n\n# 定义独立时间变量\n@variables t\n\n# 器件端口作为连接点\n@connector function Pin(; name)\n    sts = @variables v(t) = 1.0 i(t) = 1.0 [connect = Flow]\n    return ODESystem(Equation[], t, sts, []; name=name)\nend\n\n# 地，地的端口名字改为g，不是port\nfunction Ground(; name)\n    @named g = Pin()\n    eqs = [g.v ~ 0; g.i ~ 0]\n    return compose(ODESystem(eqs, t, [], []; name=name), g)\nend\n# 电阻元件\nfunction Resistor(; name, R=1.0)\n    @named p = Pin()\n    @named n = Pin()\n    ps = @parameters R = R\n    eqs = [\n        p.v - n.v ~ p.i * R\n        0 ~ p.i + n.i\n    ]\n    return compose(ODESystem(eqs, t, [], ps; name=name), p, n)\nend\n# 电容元件，因为不能对表达式进行微分，所以再引入一个电容的电压差变量v\nfunction Capacitor(; name, C=1.0)\n    @named p = Pin()\n    @named n = Pin()\n    ps = @parameters C = C\n    sts = @variables v(t) = 1.0\n    D = Differential(t)\n    eqs = [\n        v ~ p.v - n.v\n        D(v) ~ p.i / C\n        0 ~ p.i + n.i\n    ]\n    return compose(ODESystem(eqs, t, sts, ps; name=name), p, n)\nend\n# 电压源\nfunction ConstantVoltage(; name, V=1.0)\n    @named p = Pin()\n    @named n = Pin()\n    ps = @parameters V = V\n    eqs = [\n        V ~ p.v - n.v\n        0 ~ p.i + n.i\n    ]\n    return compose(ODESystem(eqs, t, [], ps; name=name), p, n)\nend\n\n# 定义组件\nR = 1.0\nC = 1.0\nV = 1.0\n@named resistor = Resistor(R=R) # @name可以视为给定义的组件起了个名字，Resistor(R=R)返回的组件名字就叫resistor\n@named capacitor = Capacitor(C=C)\n@named source = ConstantVoltage(V=V)\n@named ground = Ground()\n\n# 构建连接关系\nrc_eqs = [\n    connect(source.p, resistor.p)\n    connect(resistor.n, capacitor.p)\n    connect(capacitor.n, source.n, ground.g)\n]\n@named _rc_model = ODESystem(rc_eqs, t) #连接关系也需要放到ODESystem中。\n\n# 组件与组件连接关系一起构建系统\n@named rc_model = compose(_rc_model,[resistor, capacitor, source, ground])\nequations(rc_model) # 查看方程\n\n# 系统化简\nsys = structural_simplify(rc_model)\nequations(sys) # 查看方程\n\n# 定义初值\nu0 = [\n    capacitor.v => 0.0\n]\n\n# 求解\nprob = ODAEProblem(sys, u0, (0, 10.0))\nsol = solve(prob, Tsit5())\n\n# 查看\nsol[capacitor.v]\nsol[resistor.n.v]\nsol[capacitor.p.v]","category":"page"},{"location":"Modeling/ModelingTutorial/#小结","page":"组织方程的艺术——组件化（入门）","title":"小结","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"引入的组件端口变量作为内部方程与外部连接关系的桥梁，使得组件完整又独立，可以与任意外部组件相连接。连接就去干连接的活，组件内部就管组件内部的方程。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"从另一个角度说，节点电压法需要针对每一个系统做比较复杂的系统分析，因为其包含了某种化简的内涵；而组件化模式则是批量定义组件和批量处理连接关系，最后统一化简。后者更加易于理解与设计计算算法。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"组件化的意义就在于高效复用以提高系统构建效率。因为组件都是由开发者写好的，用户只需要构建连接关系，系统即可搭建好。这也是为什么说组件化是关于方程组织的艺术了，本质还是那个本质，只是换一种变量与方程的组织模式。电路系统的组件化是组件化思想的体现之一。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"组件化建模实例简要介绍了组件化建模思想。\nAi4EComponentLib.jl中系统的设计方法，都体现了组件化思想。\nAi4EComponentLib.jl设计理念介绍了更高层次的抽象组件内涵。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"最后，思考如何用节点电压法解下图的电路，以及如何用组件搭建。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"(Image: 图 2) ","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"其实思考之后就会发现组件化构建的优点：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"高复用性：节点电压法构建需要自己写组件的特性方程；组件化不需要，不管它内部是什么牛鬼蛇神，组件写好了就能拿来用。之后就一个事——连接。定义组件的过程就是对组件内部方程的重用。\n高易用性：一旦组件设计好了，构建连接关系不需要再动脑子了，照着系统图哪里有节点连哪里不就完事了？剩下精髓，是如何去设计一个系统，不再需要考虑组件底层。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"tip: Tip\n提问：我们上面手敲代码定义组件和构建连接的过程，与在Simulink中通过图形化界面拖一个组件连一个线的过程，有本质的区别吗？如果你觉得没有区别，恭喜，你已经大致掌握流程模拟仿真软件底层架构的逻辑了。","category":"page"},{"location":"Modeling/ModelingTutorial/#练习","page":"组织方程的艺术——组件化（入门）","title":"练习","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"尝试用上面写好的组件构建上图系统并求解。同样的，都假设电容电压初值为0。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/#从虚拟机到云计算","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"","category":"section"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"我这里先介绍虚拟机，然后讲解云服务器，接着讲容器和容器编排，最后介绍Kubernetes（简称K8s）。以下是每个主题的简要概述：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"虚拟机（Virtual Machine，VM）：虚拟机是一种软件仿真的计算机系统，它在物理硬件上模拟出一个完整的计算环境。通过虚拟机，可以在一台物理计算机上运行多个独立的操作系统和应用程序，实现资源的有效利用和隔离。\n云服务器：云服务器是基于云计算技术提供的一种计算资源。它可以在云服务提供商的数据中心上创建和管理，用户可以按需购买和使用，无需关心硬件设备的维护和管理。云服务器提供了灵活、可扩展的计算能力，使用户能够根据需要快速部署和管理应用程序。\n容器：容器是一种轻量级的虚拟化技术，它将应用程序及其所有依赖项打包到一个可移植的单元中。容器可以在不同的计算环境中运行，提供了更高的可移植性和可伸缩性。容器技术能够实现快速部署、高效利用资源和隔离应用程序之间的环境。\n容器编排：容器编排是指自动化管理和协调大规模容器集群的过程。它涉及到调度、扩缩容、服务发现等操作，以确保容器应用程序的高可用性和可靠性。容器编排工具可以简化容器集群的部署和管理，提供了高级的功能和抽象层，使开发人员和运维人员能够更方便地管理容器化应用。\nKubernetes（K8s）：Kubernetes是目前最流行的容器编排工具之一，它提供了丰富的功能和强大的编排能力。Kubernetes可以自动化地管理容器化应用程序的部署、伸缩、负载均衡和容错等方面。它还提供了灵活的架构和可扩展性，使得在大规模环境中部署和管理容器应用变得更加简单和可靠。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"通过这样的顺序，您可以循序渐进地介绍云计算的相关概念，从虚拟化开始，逐步引入云服务器、容器和容器编排，最后引入Kubernetes作为云原生应用程序部署和管理的解决方案","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/#虚拟机","page":"从虚拟机到云计算","title":"虚拟机","text":"","category":"section"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/#虚拟机简介","page":"从虚拟机到云计算","title":"虚拟机简介","text":"","category":"section"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"虚拟机（Virtual Machine，VM）是一种软件仿真的计算机系统，它在物理硬件上模拟出一个完整的计算环境。通过虚拟机，可以在一台物理计算机上运行多个独立的操作系统和应用程序，实现资源的有效利用和隔离。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"虚拟机可以将一台物理计算机分割为多个虚拟环境，每个环境都拥有自己的操作系统、应用程序和资源。每个虚拟机都被视为一个独立的计算机，可以进行操作系统的安装、应用程序的运行和网络的配置。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"虚拟机的好处包括：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"资源利用率高：通过虚拟机技术，一台物理计算机可以同时运行多个虚拟机，充分利用硬件资源，降低资源浪费。\n隔离性强：每个虚拟机是相互隔离的，它们运行在自己的虚拟环境中，互不干扰，提供了更高的安全性和稳定性。\n灵活性和可移植性：虚拟机可以在不同的物理计算机之间迁移，实现应用程序的高度灵活性和可移植性。\n管理和维护简便：通过虚拟机管理软件，可以对虚拟机进行集中管理、监控和维护，简化了系统管理的工作。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"虚拟机技术是云计算的基础之一，它为云服务器提供了可扩展和弹性的计算资源。通过虚拟机，用户可以根据需要快速创建和管理多个独立的虚拟服务器，实现按需分配计算资源的优势。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"有几个流行的虚拟机软件可以选择，以下是其中一些：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"VMware vSphere：VMware vSphere是一款功能强大的虚拟化平台，广泛应用于企业级环境。它提供了全面的虚拟化解决方案，包括虚拟机管理、资源调度、高可用性和故障转移等功能。\nMicrosoft Hyper-V：Hyper-V是微软的虚拟化平台，集成在Windows Server操作系统中。它提供了可靠的虚拟化技术，支持创建和管理多个虚拟机，具有良好的兼容性和集成性。\nOracle VM VirtualBox：VirtualBox是一款免费的开源虚拟机软件，适用于个人和小型企业。它支持多种操作系统，具有易用性和灵活性，适合在桌面环境中运行虚拟机。\nKVM（Kernel-based Virtual Machine）：KVM是一种基于Linux内核的虚拟化解决方案，它利用虚拟化扩展了Linux操作系统的功能。KVM提供了高性能和安全性，并且作为开源软件，广受欢迎。\nXen：Xen是一种开源的虚拟化平台，它具有高性能和安全性。Xen支持多种操作系统，并提供了强大的虚拟机管理功能和资源分配控制。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"这些是目前较为流行的虚拟机软件，每个软件都有自己的特点和适用场景。选择虚拟机软件时，您可以根据需求、预算和技术要求来进行评估和选择。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/#virtualbox安装ubuntu","page":"从虚拟机到云计算","title":"virtualbox安装ubuntu","text":"","category":"section"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"以VirtualBox为例，在Windows系统上安装Ubuntu，请按照以下步骤进行操作：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 1：下载软件","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在您的Windows主机上，打开浏览器，并访问VirtualBox的官方网站（https://www.virtualbox.org）。\n在下载页面上，选择适用于Windows主机的最新版本的VirtualBox软件，并下载安装程序。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 2：安装VirtualBox","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"打开下载的安装程序，并按照提示进行安装。这将在您的Windows主机上安装VirtualBox。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 3：下载Ubuntu镜像","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在浏览器中，访问Ubuntu官方网站（https://ubuntu.com）。\n在下载页面上，选择您想要安装的Ubuntu版本（例如Ubuntu 20.04 LTS）。\n下载适用于桌面版的Ubuntu镜像（通常是一个ISO文件）。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 4：创建虚拟机","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"打开VirtualBox应用程序。\n点击\"新建\"创建一个新的虚拟机。\n在弹出窗口中，输入虚拟机的名称（例如Ubuntu）和选择操作系统类型（Linux）。\n根据您下载的Ubuntu镜像选择相应的版本（例如Ubuntu 64位）。\n按照默认设置为虚拟机分配内存大小，或根据您的需要进行调整。\n在\"虚拟硬盘\"部分，选择\"创建虚拟硬盘\"并点击\"创建\"。\n在弹出窗口中，选择虚拟硬盘文件类型（通常选择VDI）。\n在存储位置和大小上，可以使用默认设置或按需进行调整。\n完成后，您将在VirtualBox主界面上看到新创建的虚拟机。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 5：安装Ubuntu","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"选中您创建的虚拟机，并点击\"启动\"。\n在弹出窗口中，选择您之前下载的Ubuntu镜像文件（ISO文件）。\n点击\"启动\"开始安装过程。\n在Ubuntu安装程序中，按照提示进行操作。您可以选择安装Ubuntu并跟随向导进行设置，或者选择\"试用\"以进入Ubuntu的Live模式。\n完成Ubuntu的安装后，重新启动虚拟机。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 6：享受Ubuntu","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在重新启动后，您将看到Ubuntu登录界面。\n输入您在安装过程中设置的用户名和密码，登录到Ubuntu桌面。\n现在，您可以开始使用安装在VirtualBox中的Ubuntu操作系统了。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"这是使用VirtualBox在Windows系统上安装Ubuntu的基本步骤。请注意，具体步骤可能会因VirtualBox或Ubuntu版本的不同而有所不同，但大致流程是类似的。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"如果您想要在VirtualBox中安装增强功能，以便实现更好的集成和功能支持（例如，自动调整屏幕分辨率、共享剪贴板、鼠标和键盘的无缝切换等），请按照以下步骤进行操作：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 1：启动虚拟机","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在VirtualBox主界面上，选中您安装的Ubuntu虚拟机。\n点击\"启动\"来启动虚拟机。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 2：安装VirtualBox增强功能","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在Ubuntu虚拟机启动后，在VirtualBox菜单栏中选择\"设备（Devices）\"。\n在设备菜单中，选择\"安装增强功能\"（通常在菜单的最下方）。\n这将加载一个名为\"VBoxGuestAdditions.iso\"的虚拟光驱到Ubuntu虚拟机中。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 3：安装增强功能","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在Ubuntu虚拟机中，打开终端应用程序。\n在终端中，输入以下命令来挂载并运行增强功能的安装程序：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"sudo mount /dev/cdrom /mnt\ncd /mnt\nsudo ./VBoxLinuxAdditions.run","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"这将安装增强功能到Ubuntu虚拟机中。根据提示，您可能需要输入管理员密码来继续安装过程。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 4：重新启动虚拟机","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在安装完成后，输入以下命令来重新启动Ubuntu虚拟机：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"sudo reboot","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"虚拟机将重新启动并加载增强功能。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 5：享受增强功能","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在重新启动后，您可以享受增强功能提供的各种特性，如自动调整屏幕分辨率、共享剪贴板、鼠标和键盘的无缝切换等。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"请注意，安装增强功能的步骤可能会因VirtualBox或Ubuntu版本的不同而有所不同。如果遇到任何问题，请参考VirtualBox的官方文档或Ubuntu的官方支持资源，以获取更具体的安装指南和解决方案。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/#wsl2的安装和使用（为了熟悉Linux操作）","page":"从虚拟机到云计算","title":"wsl2的安装和使用（为了熟悉Linux操作）","text":"","category":"section"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"很多同学对linux不熟悉，我们可以安装一个WSL2来学习。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"当安装WSL2（Windows Subsystem for Linux 2）以在Windows系统上使用Linux环境时，可以按照以下步骤进行：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 1：检查系统要求","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"确保同学们的计算机运行的是Windows 10操作系统的版本2004或更高版本，并且使用的是64位系统。\n还需要启用虚拟化功能（BIOS设置中的虚拟化选项）。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 2：启用WSL功能","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"打开Windows PowerShell（或命令提示符）作为管理员。右键单击开始菜单，选择\"Windows PowerShell（管理员）\"。\n运行以下命令来启用WSL功能：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 3：启用虚拟机平台功能","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"继续在管理员权限的Windows PowerShell中，运行以下命令来启用虚拟机平台功能：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 4：安装WSL2 Linux内核更新包","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"下载适用于WSL2的Linux内核更新包：\n访问https://aka.ms/wsl2kernel下载最新版本的Linux内核更新包。\n运行下载的更新包安装程序并按照提示进行安装。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 5：设置WSL2为默认版本","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"打开Windows PowerShell（管理员权限）。\n运行以下命令以将WSL2设置为默认版本：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"wsl --set-default-version 2","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 6：安装Linux发行版","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"打开Microsoft Store（Microsoft商店）应用程序。\n在搜索栏中搜索所需的Linux发行版（如Ubuntu、Debian等）。\n选择所需的发行版，并点击\"获取\"以开始安装过程。\n安装完成后，可以在开始菜单或应用程序列表中找到Linux发行版的图标。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 7：配置和使用WSL2","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"点击Linux发行版的图标启动它。第一次运行时，需要进行一些初始配置，例如创建用户名和密码。\n完成配置后，将进入Linux发行版的终端界面，可以在其中执行各种Linux命令和操作。\n同学们可以通过WSL2来运行和管理Linux应用程序，进行开发和学习。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"请注意，以上步骤提供了一个基本的指导，具体步骤可能会因Windows版本和更新的不同而有所变化。建议在指导同学们安装WSL2时，参考Microsoft的官方文档和指南，以获得最准确的信息和步骤。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在Windows Terminal中使用WSL2可以提供更好的终端体验和多个Linux发行版的集成。以下是在Windows Terminal中使用WSL2的步骤：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 1：安装Windows Terminal","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"打开Microsoft Store（Microsoft商店）应用程序。\n在搜索栏中搜索\"Windows Terminal\"。\n选择\"获取\"以开始安装Windows Terminal。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 2：启动Windows Terminal","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在开始菜单中搜索并打开\"Windows Terminal\"。\nWindows Terminal将打开并显示多个终端选项。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 3：配置Windows Terminal使用WSL2","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在Windows Terminal中，点击左上角的下拉箭头（或使用快捷键Ctrl+，）以打开设置。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 4：编辑配置文件","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在设置中，选择所需的配置文件（如Ubuntu、Debian等）。\n在配置文件的\"guid\"属性中，输入WSL2分配的唯一标识符。您可以使用命令wsl -l在Windows PowerShell或命令提示符中获取已安装的WSL2发行版的列表和标识符。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 5：保存配置文件","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在编辑完配置文件后，保存并关闭设置窗口。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 6：打开新终端","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在Windows Terminal中，点击左上角的\"+\"按钮，或按下快捷键Ctrl+Shift+T，以打开一个新的终端标签。\n在新的终端标签中，将自动使用配置文件中指定的WSL2发行版。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 7：切换和使用多个终端","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在Windows Terminal中，您可以使用下拉箭头或快捷键Ctrl+Tab来切换不同的终端标签。\n在每个终端标签中，您可以像在正常的Linux终端中一样运行和管理命令、应用程序等。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"通过以上步骤，您可以在Windows Terminal中配置和使用WSL2，并享受多个Linux发行版的集成和终端体验。请注意，具体的步骤可能因Windows Terminal的版本和配置文件的不同而有所变化。如果需要更多详细信息和配置选项，请参考Windows Terminal的官方文档和指南。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"如果您想在 MobaXterm 中使用 WSL2（Windows Subsystem for Linux 2），可以按照以下步骤进行设置：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 1：安装 MobaXterm","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在浏览器中访问 MobaXterm 的官方网站（https://mobaxterm.mobatek.net）。\n下载适用于您的 Windows 系统的 MobaXterm 安装程序。\n运行安装程序并按照提示进行安装。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 2：启动 MobaXterm","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在安装完成后，打开 MobaXterm 应用程序。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 3：配置 WSL2","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在 MobaXterm 的主界面上，点击 \"Session\"（会话）按钮打开会话窗口。\n在会话窗口中，点击 \"New session\"（新建会话）按钮。\n在左侧的会话类型列表中，选择 \"WSL\"。\n在右侧的 \"WSL settings\"（WSL 设置）部分，选择您想要使用的 WSL2 发行版。\n点击 \"OK\"。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 4：连接到 WSL2","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在会话窗口中，点击 \"Start local terminal\"（启动本地终端）按钮。\n这将打开一个新的终端窗口，连接到您选择的 WSL2 发行版。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"步骤 5：使用 WSL2","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在 MobaXterm 的终端窗口中，您可以像在任何其他终端中一样使用 WSL2。\n运行 Linux 命令、管理文件、安装和运行应用程序等。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"通过以上步骤，您可以在 MobaXterm 中配置并使用 WSL2。请注意，MobaXterm 中的具体步骤可能会因版本和配置的不同而有所变化。如果需要更多详细信息和设置选项，请参考 MobaXterm 的官方文档和指南。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"当使用WSL2时，以下是一些常用的命令示例：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"查看当前目录：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"pwd","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"列出当前目录的文件和文件夹：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"ls","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"切换目录：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"cd <目录路径>","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"创建新目录：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"mkdir <目录名称>","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"复制文件或目录：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"cp <源文件/目录> <目标路径>","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"安装软件包：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"sudo apt-get install <软件包名称>","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"这些命令可以让您在WSL2中进行常见的文件操作和软件安装。根据您的需求，可以使用这些命令作为起点，并在需要时进一步扩展和探索其他命令和操作。请记住，具体命令的使用方法和选项可能会因所使用的Linux发行版和软件版本而有所不同。如果需要更多详细信息和特定命令的使用说明，请参考所使用的Linux发行版的官方文档或在线资源。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/#云计算","page":"从虚拟机到云计算","title":"云计算","text":"","category":"section"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/#云计算简介","page":"从虚拟机到云计算","title":"云计算简介","text":"","category":"section"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"云计算是一种通过网络提供计算资源和服务的模式，它提供了便捷的、按需的、可伸缩的计算资源，从而使用户能够在不拥有实际物理基础设施的情况下使用和管理计算资源。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"云计算的核心概念包括以下几个方面：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"虚拟化：云计算通过虚拟化技术将物理计算资源（如服务器、存储设备）抽象为虚拟资源，使其能够在多个用户之间进行共享。虚拟化技术包括虚拟机和容器等。\n弹性伸缩：云计算允许根据实际需求动态调整计算资源的规模，即根据业务负载的增减自动调整资源的分配。这种弹性伸缩能力可以帮助用户在需要更多计算能力时扩展资源，并在需求减少时进行资源的释放，从而提高资源的利用率和成本效益。\n服务模型：云计算提供多种服务模型，包括基础设施即服务（IaaS）、平台即服务（PaaS）和软件即服务（SaaS）。这些服务模型层次不同，提供的服务范围也不同，用户可以根据自身需求选择合适的服务模型来构建和管理应用程序。\n公共云、私有云和混合云：公共云是由云服务提供商管理和提供的云计算资源和服务，多个用户共享这些资源。私有云是由企业或组织自己搭建和管理的云计算基础设施，仅对内部用户提供服务。混合云是公共云和私有云的结合，使企业可以在需要时灵活地将工作负载部署到公共云或私有云中。\n云安全性：云计算提供商通常采取一系列措施来保护用户的数据和应用程序安全。这些措施包括数据加密、身份认证和访问控制、备份和灾难恢复等，以确保用户数据的机密性、完整性和可用性。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"云计算的优势包括灵活性、可伸缩性、成本效益和高可用性。它为个人用户、企业和组织提供了强大的计算能力和资源，使其能够更高效地开展业务、创新和应对变化。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"需要注意的是，云计算领域有多个主要的云服务提供商，如阿里云、天翼云、华为云、亚马逊AWS、微软Azure和谷歌云平台等，它们提供各种云服务和工具，支持各种应用场景和需求。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"通俗的理解，就是云服务商把很多硬件整合在一起，切分成不同的豆腐块，每个豆腐块都进行虚拟化，然后给我们卖这样的豆腐块（虚拟机）。虽然不严谨，可以这样理解吧。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"是的，您可以这样理解云计算。云服务商通过整合大量的硬件资源（如服务器、存储设备）并进行虚拟化，将这些物理资源切分成多个虚拟化的单位，通常被称为\"云实例\"或\"豆腐块\"，这些虚拟化单位可以是虚拟机、容器或其他形式的计算资源。然后，云服务商通过提供这些虚拟化单位给用户，让用户能够按需购买和使用这些计算资源，而无需拥有和维护实际的物理基础设施。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"这种虚拟化的方式使用户可以根据自身需求灵活地使用计算资源，无需关心底层的硬件和基础设施细节。用户可以根据业务需求动态调整计算资源的规模，并通过云服务商提供的管理工具来部署、监控和管理这些虚拟化单位。云计算的优势在于其灵活性、可伸缩性和成本效益，使用户能够更高效地利用计算资源，集中精力开展业务和创新。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"虚拟化是云计算的基础技术之一，它通过将物理资源虚拟化为虚拟资源，实现了资源的共享和隔离。虚拟机是最常见的虚拟化形式之一，它将物理服务器切分为多个虚拟机实例，每个虚拟机实例都具有自己的操作系统和应用程序。通过虚拟化技术，云服务商能够提供可靠、安全且高度可扩展的计算资源给用户，让用户能够以更灵活和经济的方式使用计算能力。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"所以，您的理解是准确的，云服务商将硬件资源虚拟化为不同的虚拟化单位（如虚拟机），然后提供给用户使用。用户可以根据需求选择和购买这些虚拟化单位，并将其用于托管应用程序、存储数据等各种计算任务。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/#公有云与私有云","page":"从虚拟机到云计算","title":"公有云与私有云","text":"","category":"section"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"当谈到云计算时，常常涉及到公有云、私有云和混合云这三个概念。它们表示不同类型的云计算部署和服务模式：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"公有云（Public Cloud）：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"公有云是由云服务提供商管理和提供的云计算基础设施和服务。在公有云中，云服务提供商拥有并管理硬件设施、虚拟化资源和服务，并将其提供给多个用户进行共享。用户可以按需购买和使用这些云服务，通常采用按使用量计费的模式。公有云提供了高度可扩展的计算资源、广泛的服务选择和灵活的付费模式。用户无需关心底层的基础设施和维护工作，可以专注于应用程序的开发和业务需求。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"私有云（Private Cloud）：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"私有云是企业或组织自己搭建和管理的云计算基础设施。在私有云中，计算资源、存储和网络等基础设施资源都是专门为企业内部使用而部署的。私有云提供了更高的安全性和控制性，因为企业可以自主管理和控制整个云环境。私有云可以部署在企业的数据中心内或由第三方服务提供商托管。它可以满足特定的合规要求、安全需求或业务流程的定制化需求。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"混合云（Hybrid Cloud）：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"混合云是公有云和私有云的结合。在混合云模式下，企业可以同时利用公有云和私有云来满足不同的需求。例如，企业可以将敏感数据和关键应用部署在私有云中，以满足安全和合规性要求，同时将其他非敏感的工作负载部署在公有云中，以获得弹性和可扩展性。混合云提供了更灵活的部署模式，使企业可以根据实际需求在公有云和私有云之间进行动态迁移和资源调度。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"混合云可以充分利用公有云和私有云的优势，同时解决安全性、合规性和可扩展性等方面的需求。企业可以根据业务需求和实际情况，灵活选择合适的云计算部署模式，并进行资源的分配和管理。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/#找个云服务器实操一下","page":"从虚拟机到云计算","title":"找个云服务器实操一下","text":"","category":"section"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"当以阿里云的ECS为例，在阿里云上创建一台虚拟机并安装Ubuntu LTS的步骤如下：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"注册阿里云账号并登录到阿里云控制台（https://www.aliyun.com）。\n进入ECS控制台，在左侧导航栏中选择\"实例\"，然后点击\"创建实例\"按钮。\n在创建实例页面，按照以下步骤进行配置：\n地域和可用区：选择适合的地域和可用区。\n实例配置：选择合适的实例规格、计费方式和购买时长。\n网络和安全组：选择网络类型和安全组配置。\n系统配置：选择操作系统镜像，点击\"更多\"按钮选择Ubuntu LTS版本。\n存储和盘：选择系统盘和数据盘的配置。\n标签和备注：根据需要添加标签和备注信息。\n网络计费：根据需要选择带宽计费方式。\n安全与监控：选择是否开启云监控和安全加固等功能。\n完成配置后，点击\"立即购买\"按钮。\n确认订单信息后，点击\"去开通\"按钮。\n阿里云将开始创建并启动您的实例。请等待几分钟，直到实例状态显示为\"运行中\"。\n当实例状态为\"运行中\"时，您可以在实例列表中找到您的实例。点击实例名称，进入实例详情页。\n在实例详情页中，您可以查看实例的基本信息。找到公网IP地址或登录密码信息，并记下来。\n打开SSH客户端（如PuTTY或OpenSSH），使用您的公网IP地址和登录密码连接到您的实例。如果使用Windows系统，您可以使用SSH客户端工具（如PuTTY）来连接。\n在SSH终端中，输入您的登录用户名和密码，即可成功登录到您的Ubuntu虚拟机。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"通过以上步骤，您就可以在阿里云的ECS上成功创建并登录到一台安装了Ubuntu LTS的虚拟机。请注意，创建实例的过程中会涉及到一些配置和选项，具体根据您的需求进行相应的选择和设置。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/#登录云服务器","page":"从虚拟机到云计算","title":"登录云服务器","text":"","category":"section"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"下面分别介绍如何使用 MobaXterm 和 PuTTY 进行云服务的登录，并演示密码认证和密钥认证的步骤。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"使用 MobaXterm 登录云服务：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"下载和安装 MobaXterm（https://mobaxterm.mobatek.net/download-home-edition.html）。\n打开 MobaXterm，点击 \"Session\" 标签页。\n在 \"Session\" 标签页中，选择 \"SSH\" 作为远程会话类型。\n输入云服务的 IP 地址或主机名。\n在 \"Specify username\" 输入框中，输入登录用户名。\n在 \"Advanced SSH settings\" 中，可以选择使用密码认证或密钥认证。首先，我们使用密码认证，请确保 \"Use private key\" 复选框未选中。\n点击 \"OK\" 按钮，MobaXterm 将尝试与云服务建立 SSH 连接，并提示输入密码。\n输入您的密码，按下回车键即可登录到云服务。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"使用 PuTTY 登录云服务：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"下载和安装 PuTTY（https://www.putty.org）。\n打开 PuTTY。\n在 \"Host Name (or IP address)\" 输入框中，输入云服务的 IP 地址或主机名。\n在 \"Connection type\" 下选择 \"SSH\"。\n在 \"Specify username\" 输入框中，输入登录用户名。\n在 \"Category\" 列表中，展开 \"SSH\" 选项，然后选择 \"Auth\"。\n在 \"Auth\" 部分，可以选择使用密码认证或密钥认证。首先，我们使用密码认证，请确保 \"Attempt authentication using Pageant\" 复选框未选中。\n点击 \"Open\" 按钮，PuTTY 将尝试与云服务建立 SSH 连接，并提示输入密码。\n输入您的密码，按下回车键即可登录到云服务。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"现在我们来介绍如何设置密钥认证：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"使用 MobaXterm 设置密钥认证：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"打开 MobaXterm。\n点击 \"Settings\" 菜单，选择 \"Configuration\"。\n在 \"Configuration\" 对话框中，展开 \"SSH\"，然后选择 \"SSH keys\"。\n点击 \"Generate\" 按钮，生成新的密钥对。\n选择密钥的类型和长度，并点击 \"Generate\"。\n在 \"Key passphrase\" 输入框中，输入一个密码以保护您的密钥（可选）。\n点击 \"Save private key\" 按钮，将私钥保存到本地计算机。\n在云服务上，将公钥（保存在 MobaXterm 中的公钥）添加到您的用户账户的 ~/.ssh/authorized_keys 文件中。\n在 MobaXterm 中，返回到 \"Session\" 标签页，输入云服务的 IP 地址或主机名、登录用户名。\n在 \"Advanced SSH settings\" 中，选择 \"Use private key\"","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"复选框，并点击 \"Browse\" 选择您保存的私钥文件。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"点击 \"OK\"，然后尝试连接到云服务。MobaXterm 将使用密钥认证进行连接。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"使用 PuTTY 设置密钥认证：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"打开 PuTTY。\n在 \"Category\" 列表中，展开 \"SSH\"，然后选择 \"Auth\"。\n点击 \"Browse\" 按钮，选择您保存的私钥文件。\n返回到 \"Session\" 标签页，输入云服务的 IP 地址或主机名、登录用户名。\n点击 \"Open\" 按钮，PuTTY 将使用密钥认证进行连接。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"通过以上步骤，您可以使用 MobaXterm 和 PuTTY 进行云服务的登录，并通过密码认证或密钥认证进行身份验证。请根据您的需求选择合适的认证方式。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"下面是使用 ssh-keygen 生成密钥对并设置 authorized_keys 的步骤：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"打开终端或命令行窗口。\n输入以下命令来生成密钥对：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"ssh-keygen -t rsa -b 2048","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"这将生成一个 RSA 类型的密钥对，密钥长度为 2048 位。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"按照提示，输入密钥文件的保存路径和名称，或者直接按回车键使用默认路径和名称。\n在生成密钥对的过程中，您将被要求设置一个密码短语（passphrase）。可以选择设置密码短语以增加密钥的安全性，或者直接按回车键跳过密码短语设置。\n完成后，会在指定路径生成两个文件：id_rsa（私钥）和 id_rsa.pub（公钥）。\n将公钥内容复制到剪贴板中。您可以使用以下命令在终端中打印公钥：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"cat ~/.ssh/id_rsa.pub","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"在云服务中，登录到您的用户账户。\n打开 ~/.ssh/authorized_keys 文件，如果文件不存在，则创建一个新的。\n将剪贴板中的公钥内容粘贴到 authorized_keys 文件中，并保存文件。\n设置 authorized_keys 文件的权限为 600，确保只有当前用户具有读写权限：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"chmod 600 ~/.ssh/authorized_keys","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"现在，您可以使用私钥连接到云服务，而无需输入密码。使用以下命令进行连接：","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"ssh username@server_ip_address -i path/to/private_key","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"其中，username 是您的用户名，server_ip_address 是云服务的 IP 地址，path/to/private_key 是私钥文件的路径和名称。","category":"page"},{"location":"IotBigdataCloud/4-从虚拟机到云计算/","page":"从虚拟机到云计算","title":"从虚拟机到云计算","text":"通过以上步骤，您已经成功生成了密钥对，并将公钥添加到云服务的 authorized_keys 文件中，从而实现了密钥认证的登录方式。现在，您可以使用私钥连接到云服务，而无需每次输入密码。请确保妥善保管私钥，以确保安全性。","category":"page"},{"location":"Optimization/2-优化问题的分类/#优化问题的分类","page":"优化问题的分类","title":"优化问题的分类","text":"","category":"section"},{"location":"Optimization/2-优化问题的分类/","page":"优化问题的分类","title":"优化问题的分类","text":"在优化问题中，可以根据不同的分类标准对问题进行分类。以下是一些常见的分类标准：","category":"page"},{"location":"Optimization/2-优化问题的分类/","page":"优化问题的分类","title":"优化问题的分类","text":"问题类型：\n线性规划（Linear Programming）：目标函数和约束条件都是线性的。\n非线性规划（Nonlinear Programming）：目标函数和/或约束条件中包含非线性项。\n整数规划（Integer Programming）：决策变量被限制为整数值。\n混合整数规划（Mixed Integer Programming）：决策变量中既有连续型变量又有整数变量。\n二次规划（Quadratic Programming）：目标函数包含二次项，约束条件可以是线性或非线性。\n动态规划（Dynamic Programming）：优化问题涉及到时间序列上的决策。\n排队论（Queueing Theory）：优化问题涉及到队列的调度和排队模型。\n目标函数类型：\n单目标优化（Single-Objective Optimization）：优化问题只有一个目标函数需要最小化或最大化。\n多目标优化（Multi-Objective Optimization）：优化问题有多个冲突的目标函数需要最小化或最大化。\n约束类型：\n等式约束（Equality Constraints）：约束条件为等式形式。\n不等式约束（Inequality Constraints）：约束条件为不等式形式。\n范围约束（Bound Constraints）：决策变量有上下限范围。\n条件约束（Conditional Constraints）：约束条件是基于某些条件的。\n解空间类型：\n连续优化（Continuous Optimization）：决策变量可以取任意实数值。\n离散优化（Discrete Optimization）：决策变量受到离散值的限制。","category":"page"},{"location":"Optimization/2-优化问题的分类/","page":"优化问题的分类","title":"优化问题的分类","text":"这些分类标准有助于理解不同类型的优化问题和选择适当的优化算法。在实际问题中，可能会同时涉及多个分类标准，因此需要综合考虑问题的特点，选择适合的建模和求解方法。","category":"page"},{"location":"Optimization/2-优化问题的分类/","page":"优化问题的分类","title":"优化问题的分类","text":"还有一个特别要提一下的是混合整数非线性规划。","category":"page"},{"location":"Optimization/2-优化问题的分类/","page":"优化问题的分类","title":"优化问题的分类","text":"混合整数非线性规划（Mixed-Integer Nonlinear Programming，MINLP）是一种复杂的优化问题，它同时具有离散整数变量、连续变量和非线性函数。","category":"page"},{"location":"Optimization/2-优化问题的分类/","page":"优化问题的分类","title":"优化问题的分类","text":"在混合整数非线性规划中，目标函数和约束条件可以包含非线性项，同时还存在需要取整的决策变量。这种问题的求解困难度较高，需要使用特定的优化算法和技术来找到最优解。","category":"page"},{"location":"Optimization/2-优化问题的分类/","page":"优化问题的分类","title":"优化问题的分类","text":"MINLP问题在实际应用中广泛存在，例如在生产计划、设备配置、资源分配等领域。一些常见的应用包括：","category":"page"},{"location":"Optimization/2-优化问题的分类/","page":"优化问题的分类","title":"优化问题的分类","text":"生产调度问题：考虑生产线上的机器调度、工人分配等问题，同时考虑生产量和成本的最优化。\n设备优化配置问题：确定最佳的设备配置和使用方案，以最小化成本或最大化产出，并考虑设备容量和技术约束。\n能源系统优化：考虑能源资源的选择、供需平衡和设备调度等问题，以最小化成本或最大化能源利用效率。","category":"page"},{"location":"Optimization/2-优化问题的分类/","page":"优化问题的分类","title":"优化问题的分类","text":"求解MINLP问题的方法包括分支定界法、割平面法、混合整数线性规划与非线性规划的交替求解、松弛方法等。这些方法结合了离散整数优化和连续非线性优化的技术，旨在有效地处理复杂的混合整数非线性规划问题。","category":"page"},{"location":"Optimization/2-优化问题的分类/","page":"优化问题的分类","title":"优化问题的分类","text":"由于混合整数非线性规划的复杂性，对于大规模问题或高精度要求，求解时间可能很长，并且无法保证找到全局最优解。因此，在实际应用中，常常需要根据问题的特点和要求，进行问题简化、约束松弛或采用启发式方法等策略来求解近似最优解。","category":"page"},{"location":"Control/1-控制的本质/#控制的本质","page":"控制的本质","title":"控制的本质","text":"","category":"section"},{"location":"Control/1-控制的本质/#从bangbang到pid再到mpc","page":"控制的本质","title":"从bangbang到pid再到mpc","text":"","category":"section"},{"location":"Control/1-控制的本质/#模型预测控制详解","page":"控制的本质","title":"模型预测控制详解","text":"","category":"section"},{"location":"Control/1-控制的本质/#TCLab与工业4.0","page":"控制的本质","title":"TCLab与工业4.0","text":"","category":"section"},{"location":"Control/1-控制的本质/","page":"控制的本质","title":"控制的本质","text":"设备->PLC->工控机","category":"page"},{"location":"Control/1-控制的本质/#物联网","page":"控制的本质","title":"物联网","text":"","category":"section"},{"location":"Control/1-控制的本质/#再看微分方程的时间展开","page":"控制的本质","title":"再看微分方程的时间展开","text":"","category":"section"},{"location":"Control/1-控制的本质/#正问题、反问题","page":"控制的本质","title":"正问题、反问题","text":"","category":"section"},{"location":"Control/1-控制的本质/#数字孪生","page":"控制的本质","title":"数字孪生","text":"","category":"section"},{"location":"CSAdv/4-从符号到模型/#从符号到模型","page":"从符号到模型","title":"从符号到模型","text":"","category":"section"},{"location":"CSAdv/4-从符号到模型/","page":"从符号到模型","title":"从符号到模型","text":"补充一下符号和模型，序列化、反序列化。parser。等等。","category":"page"},{"location":"CSAdv/1-过程抽象/#过程抽象","page":"过程抽象","title":"过程抽象","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/#核心概念简要解释","page":"过程抽象","title":"核心概念简要解释","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"下面是我对每个主题的简要解释：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"过程抽象：过程抽象是指将一系列操作封装为一个单元，以便能够重复使用和组合。这有助于简化复杂的问题，提高代码的可读性和可维护性。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"数据抽象：数据抽象是指通过定义数据类型的接口，将数据的表示和实现细节与用户分离。这使得程序员可以将注意力集中在数据的高级概念上，而无需关注具体的实现。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"递归：递归是指一个函数在其定义中调用自身的过程。递归在解决需要重复执行相似操作的问题时非常有用，它可以将复杂问题分解为更小的子问题。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"从符号到模型（解析器）：这涉及将程序的源代码转换为计算机能够理解和执行的内部表示。解析器负责解析源代码，并构建出对应的抽象语法树（AST）或其他数据结构，以便进一步分析和执行。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"代码生成：代码生成是指将抽象语法树或其他中间表示转换为实际可执行的计算机指令。这是将高级代码转换为低级机器代码或字节码的过程。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"库和领域特定语言（DSL）：库是指预先编写好的可重用代码模块，用于解决特定的问题。DSL是一种专门为特定领域或特定问题而设计的编程语言，它提供了高度的表达能力和领域特定的抽象。","category":"page"},{"location":"CSAdv/1-过程抽象/#过程抽象-2","page":"过程抽象","title":"过程抽象","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"过程抽象就是函数。此函数与数学上的函数又有区别。他不是数学上的定义，而是一连串的操作实现一个功能，就算是求取数学的函数值（比如平方根），也是一系列的操作实现。这就是函数。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"没错，过程抽象在编程中通常通过函数来实现。函数是一种封装了一系列操作的代码块，用于实现特定的功能或计算。与数学中的函数不同，编程中的函数可以执行多个操作，可以接受输入参数并返回结果。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"函数在程序中起到模块化和重用的作用。通过将一组操作打包到一个函数中，我们可以将复杂的问题分解为更小的子问题，并通过函数的调用来实现这些操作。这种模块化的方式可以提高代码的可读性、可维护性和重用性。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"函数的定义通常包括函数名、参数列表和函数体。函数名是用来唯一标识函数的名称，参数列表指定函数接受的输入，函数体包含了实现函数功能的代码。当函数被调用时，传入的参数将被用于执行函数体中的操作，并根据需要返回一个值作为结果。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"例如，下面是一个简单的函数示例，用于计算一个数的平方：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"def square(x):\n    result = x * x\n    return result","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个例子中，函数名是square，它接受一个参数x。函数体中的操作是将x乘以自身，并将结果存储在result变量中，最后通过return语句返回结果。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"通过函数的抽象，我们可以将这个功能独立出来，随时在程序的其他地方调用它，而无需重复编写相同的代码。这样，我们可以更加灵活地组织和扩展程序。","category":"page"},{"location":"CSAdv/1-过程抽象/#函数可以有名字也可以没有名字","page":"过程抽象","title":"函数可以有名字也可以没有名字","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在编程中，函数是通过名称来标识和调用的，因此每个函数都必须有一个名称。函数的名称是用于唯一标识函数的，它是函数的身份标识符，使我们能够引用和调用特定的函数。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"然而，你可能提到的没有名字的函数可能指的是匿名函数（Anonymous Function），也被称为 lambda 函数。匿名函数是一种没有显式名称的函数，通常用于简单的函数操作，无需在程序中定义具名函数。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"匿名函数通常以 lambda 关键字开始，后面跟着参数列表和函数体，如下所示的 Python 示例：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"square = lambda x: x * x","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个例子中，lambda x: x * x 就是一个匿名函数，它接受一个参数 x，并返回 x 的平方。我们将这个匿名函数赋值给了变量 square，这样我们就可以通过 square 来调用这个匿名函数。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"匿名函数在需要简单的函数操作时非常有用，尤其是在需要传递函数作为参数或在一些函数式编程的场景中。虽然匿名函数没有显式的名称，但它们仍然是具有特定功能的函数对象。","category":"page"},{"location":"CSAdv/1-过程抽象/#匿名函数不同的语言的例子","page":"过程抽象","title":"匿名函数不同的语言的例子","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"Python:","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"# 使用 lambda 表达式计算两个数的和\nadd = lambda x, y: x + y\nresult = add(2, 3)  # 结果为 5\n\n# 使用 lambda 表达式筛选列表中的偶数\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\neven_numbers = filter(lambda x: x % 2 == 0, numbers)  # [2, 4, 6, 8, 10]","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"JavaScript:","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"// 使用箭头函数计算两个数的乘积\nconst multiply = (x, y) => x * y;\nconst result = multiply(3, 4);  // 结果为 12\n\n// 使用箭头函数筛选数组中的正数\nconst numbers = [-1, 2, -3, 4, -5, 6];\nconst positiveNumbers = numbers.filter(x => x > 0);  // [2, 4, 6]","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"Java:","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"import java.util.function.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        // 使用匿名函数计算两个数的差值\n        BinaryOperator<Integer> subtract = (x, y) -> x - y;\n        int result = subtract.apply(7, 3);  // 结果为 4\n\n        // 使用匿名函数判断字符串长度是否大于 5\n        Predicate<String> isLengthGreaterThanFive = s -> s.length() > 5;\n        boolean isGreaterThanFive = isLengthGreaterThanFive.test(\"Hello\");  // 结果为 false\n    }\n}","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"Julia:","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"# 使用匿名函数计算两个数的平方和\nsum_of_squares = (x, y) -> x^2 + y^2\nresult = sum_of_squares(3, 4)  # 结果为 25\n\n# 使用匿名函数筛选数组中的奇数\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nodd_numbers = filter(x -> x % 2 != 0, numbers)  # [1, 3, 5, 7, 9]","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在上述示例中，我们使用匿名函数通过->符号来定义。匿名函数可以接受参数，并在箭头后面指定函数体的操作。在第一个示例中，我们定义了一个匿名函数sum_of_squares,它接受两个参数x和y，并返回它们的平方和。在第二个示例中，我们使用匿名函数过滤出数组中的奇数。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"当然，你可以在 Julia 中使用map函数结合匿名函数进行映射操作。map函数可以将一个函数应用于一个可迭代对象（例如数组或范围），并返回一个新的经过函数处理后的可迭代对象。 Julia 的匿名函数语法相对简洁，使用->可以很方便地创建匿名函数来实现特定的功能。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"下面是在 Julia 中使用map函数和匿名函数的示例：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"# 使用匿名函数将数组中的元素平方\nnumbers = [1, 2, 3, 4, 5]\nsquared_numbers = map(x -> x^2, numbers)  # [1, 4, 9, 16, 25]\n\n# 使用匿名函数将字符串列表转换为大写\nstrings = [\"apple\", \"banana\", \"cherry\"]\nuppercase_strings = map(s -> uppercase(s), strings)  # [\"APPLE\", \"BANANA\", \"CHERRY\"]","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在上述示例中，我们使用匿名函数来定义要应用于每个元素的操作。然后，我们使用map函数将匿名函数应用于输入可迭代对象numbers和strings，并生成新的经过处理的可迭代对象squared_numbers和 uppercase_strings。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"map函数与匿名函数的结合是一种非常强大的工具，它使得对可迭代对象进行转换、映射和处理变得更加便捷和灵活。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"这些示例展示了在 Python、JavaScript、Java、julia 中使用匿名函数的用法。请注意，匿名函数在不同的编程语言中可能有不同的语法和约定，但核心思想是相似的：创建一个没有显式名称的函数以进行特定的操作。","category":"page"},{"location":"CSAdv/1-过程抽象/#函数可以给个名字，就是为了抓住它，需要它时再召唤出来","page":"过程抽象","title":"函数可以给个名字，就是为了抓住它，需要它时再召唤出来","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"是的，给函数赋予一个具名的名称可以使我们能够更方便地引用和调用它。在编程中，我们可以将函数定义为具名函数，并将其存储在变量中，以便在需要时进行调用。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"以下是在 Julia 中定义具名函数并调用的示例：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"# 定义具名函数\nfunction add(x, y)\n    return x + y\nend\n\n# 调用具名函数\nresult = add(3, 4)  # 结果为 7","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个例子中，我们使用function关键字定义了一个具名函数add，它接受两个参数x和y，并返回它们的和。然后，我们可以通过使用函数名add和传递参数来调用这个函数，并将结果存储在变量result中。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"使用具名函数可以提高代码的可读性和可维护性，因为它们可以直观地表示函数的用途和功能。而且，给函数命名后，我们可以在代码的任何位置调用这个函数，从而实现了代码的重用和模块化。","category":"page"},{"location":"CSAdv/1-过程抽象/#函数的参数就是一种约定","page":"过程抽象","title":"函数的参数就是一种约定","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"函数的参数可以被视为函数和其调用者之间的约定。通过定义函数时指定参数，我们可以规定函数需要接受的输入，并且在调用函数时传递相应的参数值。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"参数约定可以包括以下几个方面：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"1.参数数量：函数定义时可以指定需要多少个参数，调用函数时必须提供相应数量的参数。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"2.参数类型：函数定义时可以指定参数的类型，这样可以确保函数在接收参数时符合类型的要求。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"3.参数顺序：函数定义时参数的顺序很重要，调用函数时需要按照相同的顺序传递参数。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"通过参数约定，函数定义者可以定义函数的接口，并确保函数在使用时能够正确处理传入的参数。同时，函数的调用者也可以依据参数约定来使用函数，确保传入的参数与函数的期望相符。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"值得注意的是，不同的编程语言对于参数约定的方式可能有所不同。有些语言要求明确声明参数类型，有些语言允许参数的数量可变，还有一些语言支持默认参数值等特性。根据具体的编程语言和需求，我们可以选择适合的参数约定方式。","category":"page"},{"location":"CSAdv/1-过程抽象/#函数可以有返回值，也可以没有","page":"过程抽象","title":"函数可以有返回值，也可以没有","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"函数可以有返回值，也可以没有返回值。返回值是函数执行完成后向调用者返回的结果。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"如果函数有返回值，它可以通过使用关键字（如return）来指定返回的值。函数在遇到return语句时会立即停止执行，并将指定的值返回给调用者。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"以下是示例代码，展示了函数如何有返回值和没有返回值的情况：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"# 函数有返回值\ndef add(x, y):\n    result = x + y\n    return result\n\nsum = add(3, 4)  # 调用 add() 函数并将返回值赋给变量 sum\n\n# 函数没有返回值\ndef greet(name):\n    print(\"Hello, \" + name)\n\ngreet(\"Alice\")  # 调用 greet() 函数，没有返回值","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在上述示例中，add()函数有返回值，它将两个参数相加并返回结果。调用add()函数后，将返回的结果赋给变量sum。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"而greet()函数没有返回值，它仅仅打印一条问候信息到控制台。调用greet()函数后，并没有将返回值赋给任何变量。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"根据函数的需求，我们可以选择使用返回值或者不使用返回值。返回值可以使函数的结果传递给调用者，进而进行后续的操作或者处理。而没有返回值的函数则主要用于执行一些操作而不需要返回结果的场景。","category":"page"},{"location":"CSAdv/1-过程抽象/#函数可能改变参数的内容，也可能不改变","page":"过程抽象","title":"函数可能改变参数的内容，也可能不改变","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"函数可以具有副作用，这意味着它们可能会改变传递给它们的参数的内容，也可能不会改变。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在某些情况下，函数被设计为只接受参数并返回结果，而不会对传递的参数进行修改。这种类型的函数称为无副作用函数（Pure Functions），因为它们不会对外部环境产生任何影响，只根据输入产生输出。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"以下是一个无副作用函数的示例（使用Python）：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"def multiply(x, y):\n    return x * y","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个例子中，multiply()函数接受两个参数x和y，并返回它们的乘积。这个函数不会修改传递给它的参数的值，而是通过计算得到一个新的结果并将其返回。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"另一方面，有些函数被设计为具有副作用，它们可能会修改传递给它们的参数的内容，或者对外部环境产生其他的影响。这样的函数可能会更改传入的参数的值，或者与其他系统进行交互，例如修改文件、发送网络请求等。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"以下是一个具有副作用的函数的示例（使用Python）：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"def append_element(lst, element):\n    lst.append(element)","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个例子中，append_element()函数接受一个列表lst和一个元素element，并将element添加到 lst中。这个函数会直接修改传递给它的参数lst的内容，而不是返回一个新的结果。 根据函数的设计和用途，我们可以选择使用具有副作用的函数或无副作用的函数。在编写代码时，我们应该清楚函数是否具有副作用，并在使用函数时对其进行适当的处理。","category":"page"},{"location":"CSAdv/1-过程抽象/#函数可以被调用，可以被嵌套的调用","page":"过程抽象","title":"函数可以被调用，可以被嵌套的调用","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"函数可以被调用，也可以被嵌套调用。函数调用是指在程序中显式地使用函数名和参数来执行函数中定义的操作。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"函数的嵌套调用是指在一个函数内部调用另一个函数。这种嵌套调用的方式允许我们将程序的功能划分为更小的可重用部分，并通过函数之间的调用来实现复杂的任务。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"以下是一个示例，展示了函数的嵌套调用：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"def multiply(x, y):\n    return x * y\n\ndef add_and_multiply(a, b, c):\n    sum = a + b\n    result = multiply(sum, c)\n    return result\n\nproduct = add_and_multiply(2, 3, 4)\nprint(product)  # 输出：20","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个例子中，我们定义了两个函数multiply()和add_and_multiply()。函数multiply()接受两个参数并返回它们的乘积。函数add_and_multiply()接受三个参数，并在内部调用了multiply()函数来执行乘法操作。最后，我们通过调用add_and_multiply()函数，并将返回的结果赋给变量product，然后打印出product的值。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"通过函数的嵌套调用，我们可以在程序中构建出层次化的结构，将复杂的任务分解为更小的子任务，从而提高代码的可读性、可维护性和重用性。","category":"page"},{"location":"CSAdv/1-过程抽象/#一定意义上，编程就是写函数","page":"过程抽象","title":"一定意义上，编程就是写函数","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"可以说编程的核心就是编写函数。函数是编程中的基本构建块，它们封装了特定的操作或功能，并通过函数调用来执行这些操作。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"编程是通过将问题分解为更小的子问题，并为每个子问题编写函数来解决的过程。函数的编写可以使代码更加模块化和可维护，同时也促进了代码的重用性。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"通过编写函数，我们可以将复杂的任务分解为更小、更易管理的部分。这样不仅可以提高代码的可读性和可维护性，还可以使程序的开发和调试过程更加高效。函数还可以提供接口，使不同的模块之间可以相互调用和协作。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"编写函数还有助于实现抽象和封装的概念。通过将相关操作封装在函数中，我们可以隐藏内部实现细节，使代码更具可理解性，并提供一个简单的接口供其他开发人员使用。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"因此，可以说编程是函数的组织和组合，通过编写函数来解决问题和构建应用程序。函数的设计和编写能力对于成为一个优秀的程序员是非常重要的。","category":"page"},{"location":"CSAdv/1-过程抽象/#加减乘除本身就是函数，运算符就是函数","page":"过程抽象","title":"加减乘除本身就是函数，运算符就是函数","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在某种程度上，你可以将加减乘除等运算符看作是函数的一种形式。在编程语言中，这些运算符通常被称为内置函数或操作符（built-in functions/operators），它们提供了执行常见数学运算的功能。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"尽管这些运算符在语法上看起来不同于常规的函数调用，但它们背后的概念与函数相似。运算符接受输入（操作数），执行特定的操作，并返回结果。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"以下是示例，展示了加减乘除运算符的使用：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"# 加法运算符\nsum = 3 + 4  # 结果为 7\n\n# 减法运算符\ndifference = 10 - 5  # 结果为 5\n\n# 乘法运算符\nproduct = 2 * 3  # 结果为 6\n\n# 除法运算符\nquotient = 10 / 2  # 结果为 5.0","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个例子中，我们使用了加法运算符+、减法运算符-、乘法运算符*和除法运算符/来执行相应的数学运算。这些运算符接受操作数并返回运算结果。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"虽然运算符的语法和函数调用的语法有所不同，但它们本质上执行了类似的功能：接受输入并返回输出。这种函数调用和运算符的结合为我们提供了一种方便和直观的方式来进行数学运算和表达。","category":"page"},{"location":"CSAdv/1-过程抽象/#Julia中可以f,-再f(2,-3)调用","page":"过程抽象","title":"Julia中可以f=+, 再f(2, 3)调用","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"Julia 是一种支持函数作为一等公民的语言，允许您将函数分配给变量并以变量的形式进行调用。这种功能称为高阶函数（Higher-Order Functions）。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在 Julia 中，您可以使用=符号将函数赋值给变量，然后通过该变量进行函数调用。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"以下是示例，展示了在 Julia 中将函数赋值给变量并进行调用的方式：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"# 定义一个函数\nfunction add(x, y)\n    return x + y\nend\n\n# 将函数赋值给变量\nf = add\n\n# 使用变量进行函数调用\nresult = f(2, 3)  # 结果为 5","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个例子中，我们定义了一个名add的函数，它接受两个参数并返回它们的和。然后，我们将函数add赋值给变量f，使得f成为一个可调用的函数。最后，我们通过变量f进行函数调用，并将返回的结果赋给变量 result。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在 Julia 中，您可以将任何函数分配给变量，并通过变量进行函数调用。这种灵活性使您能够更好地组织和管理代码，将函数作为参数传递给其他函数，或者将函数存储在数据结构中进行后续使用。","category":"page"},{"location":"CSAdv/1-过程抽象/#Python则是定义类的**add**就相当于定义运算","page":"过程抽象","title":"Python则是定义类的add就相当于定义+运算","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在 Python 中，通过定义类的特殊方法 add()，可以为该类实现加法运算符 + 的行为。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"特殊方法（或称为魔术方法）是在类中定义的具有特殊命名和行为的方法，用于模拟类的一些内置操作。其中 __add__()方法用于定义对象之间的加法操作。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"以下是一个示例，展示了在 Python 中如何通过定义类的__add__()方法来实现加法运算：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"class Number:\n    def __init__(self, value):\n        self.value = value\n    \n    def __add__(self, other):\n        if isinstance(other, Number):\n            return Number(self.value + other.value)\n        else:\n            raise TypeError(\"Unsupported operand type.\")\n    \n    def __repr__(self):\n        return f\"Number({self.value})\"\n\n# 创建 Number 对象\nnum1 = Number(3)\nnum2 = Number(4)\n\n# 加法运算\nresult = num1 + num2\nprint(result)  # 输出：Number(7)","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个例子中，我们定义了一个名为Number的类，并在类中实现了__add__()方法。该方法接受另一个对象作为参数，并在方法内部执行加法运算。如果传递的参数是Number类型的对象，则返回一个新的Number对象，其值为两个对象值的和。否则，会抛出一个类型错误异常。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"通过定义__add__()方法，我们可以使用加法运算符+对Number对象进行加法操作。在示例中，我们创建了两个Number对象num1和num2，然后执行加法运算num1 + num2，得到了一个新的Number对象 result，其值为7。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"这种方式允许我们自定义类的加法行为，并使其与内置的加法运算符一致。类似地，还可以通过定义其他特殊方法来模拟其他运算符的行为。这种能力使得 Python 的类可以表现得像内置类型一样，并具有更强的灵活性。","category":"page"},{"location":"CSAdv/1-过程抽象/#主函数不一定是必须的。但是程序需要有个入口","page":"过程抽象","title":"主函数不一定是必须的。但是程序需要有个入口","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"甚至，主函数不一定是必须的。但是程序需要有个入口。像Julia语言，顺着jl文件走就是入口。像c也不则main是入口，像go则是main模块的main函数是入口。不同的编程语言有不同的程序入口约定。 在许多编程语言中，例如 C、C++、Java，程序的入口点是由一个特定的函数（通常是 main 函数）来定义的。这个函数被称为主函数（main function），它是程序执行的起点，定义了程序开始执行的逻辑。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"然而，并非所有的编程语言都要求必须有显式的主函数。在一些语言中，入口点可以是文件的执行顺序或模块的默认行为。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在 Julia 中，执行 Julia 脚本通常是从顶级的.jl文件开始的。当您运行一个Julia脚本时，该文件中的代码会按照顺序执行，没有显式的主函数要求。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在 Go 语言中，程序的入口是main包中的main函数。当您构建和运行一个 Go 程序时，系统会自动调用 main 包中的 main 函数作为程序的入口点。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"总而言之，不同的编程语言对于程序入口点的定义可能有所不同。有些语言要求显式地定义主函数，而有些语言则根据约定或默认行为来确定入口点。理解特定编程语言的入口规则对于编写正确的程序是很重要的。","category":"page"},{"location":"CSAdv/1-过程抽象/#同一个函数名，接受不同的参数类型，是一种进步，越来越对人友好。实际上是多重分发或者多态等设计实现的。","page":"过程抽象","title":"同一个函数名，接受不同的参数类型，是一种进步，越来越对人友好。实际上是多重分发或者多态等设计实现的。","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"函数重载（Function Overloading）是一种编程语言特性，允许在同一个函数名下定义多个具有不同参数类型或参数个数的函数。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"函数重载提供了一种方便的方式来编写多态的代码，使得函数能够根据传入的参数类型或参数个数进行不同的操作或返回不同的结果。这提高了代码的可读性和可维护性，同时也增强了代码的灵活性。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"以下是一个示例，展示了函数重载的概念：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"def add(x, y):\n    return x + y\n\ndef add(a, b, c):\n    return a + b + c\n\nresult1 = add(2, 3)  # 调用第一个 add 函数，结果为 5\nresult2 = add(1, 2, 3)  # 调用第二个 add 函数，结果为 6","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个例子中，我们定义了两个名为add的函数，它们具有不同的参数个数。当我们调用add函数时，根据传入的参数个数，解释器会自动选择匹配的函数进行调用。这样，我们可以使用相同的函数名进行不同类型或个数的参数操作，从而使代码更加灵活和易于理解。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"需要注意的是，函数重载在某些编程语言中是支持的，例如 C++、Java，但并不是所有的编程语言都直接支持函数重载。例如，Python 不直接支持函数重载，因为它是一种动态类型语言，函数的参数类型在运行时才确定。然而，通过使用可变参数、默认参数和函数内部的类型检查等技术，可以在 Python 中模拟一些函数重载的行为。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"函数重载是面向对象编程中多态性的一种实现方式，它允许不同类型的对象对同一个函数名进行不同的操作。这种灵活性使得代码更具可扩展性和可维护性，并提供了更好的代码组织和抽象能力。","category":"page"},{"location":"CSAdv/1-过程抽象/#Julia例子","page":"过程抽象","title":"Julia例子","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在 Julia 中，函数重载是通过多分派（Multiple Dispatch）的机制实现的。多分派允许函数根据参数的类型和个数来选择不同的方法进行调用。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"以下是一个示例，展示了在 Julia 中如何实现函数重载：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"# 定义一个名为 add 的函数\nfunction add(x::Int, y::Int)\n    println(\"Adding two integers:\", x + y)\nend\n\n# 重载 add 函数，处理不同类型的参数\nfunction add(x::Float64, y::Float64)\n    println(\"Adding two floats:\", x + y)\nend\n\n# 调用 add 函数\nadd(2, 3)  # 调用第一个 add 函数，输出：Adding two integers: 5\nadd(1.5, 2.5)  # 调用第二个 add 函数，输出：Adding two floats: 4.0","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个例子中，我们定义了一个名为add的函数，并使用不同的参数类型进行了两次重载。第一个add函数接受两个整数参数，并输出它们的和。第二个add函数接受两个浮点数参数，并输出它们的和。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"当我们调用add函数时，Julia 的多分派机制会根据传入的参数类型来选择最匹配的函数进行调用。在示例中，我们分别传入整数和浮点数参数来调用add函数，系统会根据参数类型选择对应的函数进行执行，并输出相应的结果。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"通过多分派的机制，我们可以方便地实现函数重载，并根据不同的参数类型提供不同的行为。这种能力使得 Julia 语言在处理不同类型数据的操作时非常灵活和高效。","category":"page"},{"location":"CSAdv/1-过程抽象/#函数的集合构成库","page":"过程抽象","title":"函数的集合构成库","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"库有一些函数是对外服务的，有一些函数是内部支持的。对外提供服务的就需要有办法描述，c语言中就是头文件 函数的集合可以构成一个库（Library），库可以包含一组相关的函数和数据结构，提供特定的功能和服务。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在许多编程语言中，为了能够正确地使用库中的函数和数据结构，通常需要提供一些描述库接口的文档或声明。在 C 语言中，常用的方式是使用头文件（Header File）来描述库的接口。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"头文件是一个包含函数原型（Function Prototype）、宏定义（Macro Definition）、类型定义（Type Definition）等信息的文本文件。它通常用于声明库中公共函数的名称、参数类型和返回类型，以便其他程序在编译和链接时能够正确地调用和使用库中的函数。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"以下是一个简化的示例，展示了一个库的头文件和库的使用方式：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"example.h（头文件）：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"#ifndef EXAMPLE_H\n#define EXAMPLE_H\n\n// 函数原型声明\nint add(int a, int b);\nvoid greet(const char* name);\n\n#endif","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"example.c（库的实现）：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"#include \"example.h\"\n\nint add(int a, int b) {\n    return a + b;\n}\n\nvoid greet(const char* name) {\n    printf(\"Hello, %s!\\n\", name);\n}","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"main.c（使用库的程序）：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"#include <stdio.h>\n#include \"example.h\"\n\nint main() {\n    int result = add(2, 3);\n    printf(\"Result: %d\\n\", result);\n\n    greet(\"Alice\");\n    return 0;\n}","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个例子中，example.h是库的头文件，其中包含了函数add()和greet()的原型声明。在example.c中实现了这两个函数。然后，在main.c中通过包含头文件example.h，以及使用add()和greet()函数来使用库的功能。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"头文件提供了对外部程序的接口定义，使得其他程序能够了解库中可用的函数和数据结构，并正确地与库进行交互。通过合适的头文件，库的使用者可以了解库中公开的函数、参数类型、返回类型等信息，从而能够正确地调用库中的函数和使用其提供的功能。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"需要注意的是，不同编程语言和开发环境可能有不同的方式来描述库的接口和提供对外服务的函数。头文件只是一种常见的方式，在其他语言中可能采用其他形式的接口定义，例如接口文件、模块文档等。","category":"page"},{"location":"CSAdv/1-过程抽象/#库，有静态链接库，有动态链接库","page":"过程抽象","title":"库，有静态链接库，有动态链接库","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"库可以分为静态链接库（Static Library）和动态链接库（Dynamic Library），它们在编译和链接时的行为和使用方式有所不同。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"静态链接库（Static Library）是在编译时将库的代码和数据直接复制到可执行程序中的一种库形式。当程序被编译链接时，静态链接库的代码会被复制到可执行文件中，成为可执行文件的一部分。这意味着程序在运行时不再需要依赖外部的库文件，因为所有需要的代码已经被包含在可执行文件中。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"优点：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"·简单易用，不需要额外的配置和依赖。 ·执行速度相对较快，因为所有代码都已经被复制到可执行文件中。 缺点：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"·静态链接库增加了可执行文件的大小。 ·如果多个可执行文件使用同一个静态链接库，会造成代码的冗余。 动态链接库（Dynamic Library），也称为共享库（Shared Library），是在程序运行时由操作系统动态加载的库。动态链接库的代码和数据被单独编译和链接为一个独立的文件，程序在运行时通过动态链接器将需要的库加载到内存中，并与程序进行链接。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"优点：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"·减小了可执行文件的大小，多个程序可以共享同一个动态链接库。 ·更新库时，不需要重新编译可执行文件，只需替换动态链接库文件即可。 缺点：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"·需要在运行时依赖相应的动态链接库文件。 ·由于动态加载和链接的过程，相对于静态链接库，会有一定的运行时性能损耗。 使用静态链接库还是动态链接库取决于具体的需求和应用场景。一般来说，静态链接库适合小型应用或者需要独立部署的应用，而动态链接库适合大型应用或者需要共享库的情况。选择哪种类型的库需要综合考虑可执行文件大小、运行时依赖、部署和维护的方便性等因素。","category":"page"},{"location":"CSAdv/1-过程抽象/#还有些语言，库就是个包，或者一个模块","page":"过程抽象","title":"还有些语言，库就是个包，或者一个模块","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在一些编程语言中，库可以被称为包（Package）或模块（Module），具有类似的功能和概念。这些术语可以根据不同的语言和上下文有不同的含义，但它们通常指代一组相关的函数、类、数据结构和其他代码组织形式的集合。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"包（Package）： 在许多现代编程语言中，包是一种用于组织和管理代码的方式。一个包可以包含多个模块、库、工具和其他资源文件。包的目的是提供一种逻辑上的组织结构，将相关的代码组织在一起，以便于复用、分发和维护。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"例如，Python 中的包是由一个或多个模块组成的目录，包含一个特殊的·init.py·文件作为包的入口点。通过使用包，可以将相关的模块组织在一起，提供命名空间管理，以及方便地导入和使用其中的函数和类。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"模块（Module）： 模块是指将相关的代码组织在一起，形成一个独立的单元。一个模块可以包含函数、类、变量和其他代码，可以通过导入（import）的方式在其他地方进行使用。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"许多编程语言都提供了模块的概念，例如 Python、JavaScript、Ruby 等。模块提供了一种代码封装和组织的机制，可以将代码分割成可管理的单元，并提供命名空间隔离，避免命名冲突。通过使用模块，可以将代码逻辑划分为模块化的部分，提高代码的可读性、可维护性和可重用性。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"需要注意的是，不同编程语言对于包和模块的具体实现和使用方式可能有所不同。有些语言可能将包和模块作为语言的一部分提供，而有些语言可能依赖第三方库或工具来支持包和模块的管理和使用。无论是包、模块还是库，它们都是为了方便代码组织、复用和管理而存在的重要概念。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在 Julia 中，包（Package）和模块（Module）是重要的概念，用于组织和管理代码。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"包（Package）： 在 Julia 中，包是一组相关功能的集合，可以包含模块、函数、数据类型、宏等。包提供了一种逻辑上的组织结构，用于封装和管理相关代码，并提供命名空间隔离和模块化的特性。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"Julia 中的包管理器（Package Manager）可以用来创建、安装、更新和管理包。用户可以通过创建自己的包或使用已经存在的包来扩展 Julia 的功能，并共享给其他用户使用。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"模块（Module）： 在 Julia 中，模块是用于组织代码的单元，它提供了一种命名空间隔离和代码封装的机制。通过定义模块，可以将相关的函数、数据类型和其他代码组织在一起，并提供对外接口。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"一个模块可以包含多个子模块、函数、常量、类型定义等。模块可以被导入到其他模块或脚本中使用，通过使用模块名和点操作符可以访问模块中的内容。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"以下是一个示例，展示了在 Julia 中如何定义和使用模块：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"# 定义一个名为 MyModule 的模块\nmodule MyModule\n\n    # 定义模块中的函数\n    function greet(name)\n        println(\"Hello, $name!\")\n    end\n\n    # 定义模块中的常量\n    const PI = 3.14159\n\nend\n\n# 使用模块中的函数和常量\nMyModule.greet(\"Alice\")  # 输出：Hello, Alice!\nprintln(MyModule.PI)  # 输出：3.14159","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个例子中，我们定义了一个名为MyModule的模块，其中包含了一个函数greet和一个常量PI。在使用模块中的函数和常量时，需要使用模块名和点操作符来访问。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"通过使用包和模块，Julia 提供了一种有效的代码组织和管理方式，可以使代码更可读、可维护，并提供了命名空间隔离和模块化的特性，方便在大型项目中进行开发和协作。","category":"page"},{"location":"CSAdv/1-过程抽象/#命名空间实际上是为了避免名字冲突","page":"过程抽象","title":"命名空间实际上是为了避免名字冲突","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"命名空间实际上是为了避免名字冲突，就像物理学不同领域可能有相同的符号代表不同的含义。命名空间的一个重要作用是避免命名冲突。在软件开发中，当不同的代码块（如模块、库、函数等）具有相同的名称时，可能会导致命名冲突，使代码的语义变得模糊或产生错误。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"命名空间通过提供一种隔离机制，使得在不同的命名空间中可以使用相同的名称来表示不同的实体，而不会产生冲突。每个命名空间都有自己的上下文环境，其中定义的名称只在该命名空间内可见。这样，即使在不同的命名空间中使用相同的名称，它们也不会相互干扰，因为它们存在于不同的命名空间中。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"类比物理学中的符号重用情况，不同的物理学领域可能会使用相同的符号来表示不同的物理量或概念。为了避免混淆，物理学家会在特定的上下文中明确定义符号的含义，确保在不同的物理学领域中使用相同的符号时不会发生歧义。这种方式类似于命名空间，通过上下文环境隔离不同的符号含义，避免混淆和冲突。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"因此，命名空间在编程中起到了类似的作用，通过提供隔离的上下文环境，确保不同代码块中的名称不会相互干扰，从而避免命名冲突，提高代码的可读性、可维护性和可重用性。","category":"page"},{"location":"CSAdv/1-过程抽象/#有些语言是通过模块实现命名空间的概念，如Julia","page":"过程抽象","title":"有些语言是通过模块实现命名空间的概念，如Julia","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"许多编程语言使用模块（Module）来实现命名空间的概念，包括 Julia。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在 Julia 中，模块是一种用于组织代码的机制，它提供了命名空间的隔离，可以将函数、变量、常量、类型等封装在模块中，避免名称冲突，并提供代码的模块化和可重用性。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"模块在 Julia 中使用module和end关键字进行定义，可以包含函数、类型定义、常量、导入其他模块等。模块可以被其他模块导入，并通过模块名和点操作符来访问其中的内容。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"下面是一个示例，展示了在 Julia 中如何定义和使用模块来实现命名空间：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"module MyModule\n\n    export my_function\n\n    # 定义模块中的函数\n    function my_function()\n        println(\"This is my function.\")\n    end\n\n    # 定义模块中的常量\n    const MY_CONSTANT = 42\n\nend\n\n# 使用模块中的函数和常量\nMyModule.my_function()  # 输出：This is my function.\nprintln(MyModule.MY_CONSTANT)  # 输出：42","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个例子中，我们定义了一个名为MyModule的模块，其中包含了一个函数my_function和一个常量 MY_CONSTANT。通过使用模块名和点操作符，我们可以在外部访问和使用模块中定义的函数和常量。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"通过模块的使用，我们可以将代码逻辑划分为模块化的部分，避免了命名冲突，提高了代码的可读性和可维护性。同时，模块也提供了一种封装和隐藏内部实现的机制，使得我们可以将一些实现细节隐藏在模块内部，只暴露需要对外使用的接口，增加了代码的安全性和灵活性。","category":"page"},{"location":"CSAdv/1-过程抽象/#函数能被跨语言调用","page":"过程抽象","title":"函数能被跨语言调用","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"函数可以通过跨语言的方式进行调用。当你使用多种编程语言开发不同的组件或模块时，有时需要在这些不同的语言之间进行函数调用，以实现功能的交互和整合。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"实现跨语言函数调用的方式取决于具体的编程语言和技术栈。以下是几种常见的跨语言函数调用方式：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"1.外部函数接口（Foreign Function Interface, FFI）：许多编程语言提供了外部函数接口，允许从一种语言调用另一种语言的函数。这通常涉及到使用特定的语法和工具，将函数的参数和返回值进行适配和传递。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"2.跨语言函数调用库：有些编程语言提供了专门的库或工具，用于简化跨语言函数调用的过程。这些库提供了一套标准的接口和机制，允许在不同的语言之间进行函数调用。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"3.远程过程调用（Remote Procedure Call, RPC）：RPC 是一种通过网络进行远程函数调用的方式。它允许不同语言的程序在网络上相互调用函数，通过序列化和反序列化的方式传递参数和结果。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"4.使用中间层或桥接器：有时可以使用中间层或桥接器来连接不同的编程语言。这可以是使用共享库、进程间通信、消息队列或其他机制，通过在中间层处理函数调用的逻辑，实现跨语言调用。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"需要注意的是，跨语言函数调用可能会涉及到数据类型、内存管理、参数传递方式等方面的兼容性问题。因此，在进行跨语言函数调用时，需要仔细考虑和处理这些问题，确保正确传递参数和处理返回值，以及保证程序的稳定性和正确性。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"总而言之，通过适当的技术手段和工具支持，函数可以在不同的编程语言之间进行跨语言调用，实现功能的整合和交互。这为跨语言开发和组件复用提供了灵活性和便利性。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"除了我之前提到的外部函数接口（FFI），RPC（Remote Procedure Call，远程过程调用）、REST（Representational State Transfer，表述性状态转移）和 Socket（套接字）也是常用的跨语言函数调用的方式。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"1.RPC（Remote Procedure Call）：RPC 是一种通过网络进行远程函数调用的机制。它允许不同语言的程序在网络上相互调用函数，通过序列化和反序列化的方式传递参数和结果。RPC 可以使用不同的协议和技术实现，如 gRPC、Thrift、XML-RPC 等。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"2.REST（Representational State Transfer）：REST 是一种基于 HTTP 协议的网络通信架构风格，它定义了一组规范和约束，用于构建分布式系统中的 Web 服务。RESTful API 提供了一组基于 URL 和 HTTP 方法的接口，通过 HTTP 请求和响应传递数据。不同的编程语言可以通过 HTTP 请求调用 RESTful API 来实现函数调用。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"3.Socket（套接字）：Socket 是一种通信机制，允许不同计算机或进程之间通过网络进行通信。它提供了一种底层的网络编程接口，通过在不同的主机之间建立连接，可以实现跨语言的函数调用。Socket 可以使用 TCP 或 UDP 协议进行通信，具体实现方式因编程语言和网络库而异。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"这些跨语言函数调用的方式在不同的场景和需求下具有不同的优势和适用性。选择合适的方式需要考虑诸多因素，包括性能要求、开发复杂度、协议支持、安全性等。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"无论使用哪种方式，跨语言函数调用都需要确保函数的参数和返回值的序列化和反序列化，协议的匹配性，以及处理错误和异常情况等。这些都是在设计和实现跨语言函数调用时需要注意的关键点。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"还有直接的，dll函数调用 直接调用动态链接库（DLL）中的函数也是一种常见的跨语言函数调用方式。这种方式适用于具有动态链接库支持的编程语言，如 C、C++、C# 等。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"动态链接库是编译好的可重用代码库，它包含一组函数和符号，可以在运行时动态加载和链接到应用程序中。通过调用动态链接库中的函数，可以实现跨语言函数调用。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在使用动态链接库进行函数调用时，通常需要以下步骤：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"1.动态链接库的加载：首先需要加载动态链接库，即将动态链接库加载到内存中，使得其中的函数和符号可用。这通常涉及到使用特定的语言或操作系统提供的函数或机制来加载动态链接库，如 LoadLibrary（Windows）、dlopen（Linux）等。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"2.函数签名和参数传递：在调用动态链接库中的函数之前，需要了解函数的签名和参数传递方式。这包括函数名称、返回类型、参数类型、参数个数等信息。确保在函数调用时传递正确的参数，以及正确处理返回值。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"3.函数调用：通过调用动态链接库中的函数，可以实现跨语言的函数调用。这通常涉及到使用特定的语言提供的机制来调用外部函数，如函数指针、DllImport（C#）、ctypes（Python）等。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"4.资源释放：在完成对动态链接库中函数的调用后，需要确保正确释放相关资源，如关闭动态链接库句柄等。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"需要注意的是，直接调用动态链接库中的函数需要对底层语言的函数调用、内存管理等有一定的了解，并且跨语言的函数调用可能涉及到类型转换、数据传递等方面的兼容性问题。因此，在进行跨语言函数调用时，建议仔细阅读相关文档和资料，并确保正确处理函数调用过程中的各种细节和问题。","category":"page"},{"location":"CSAdv/1-过程抽象/#一定意义上，执行某个程序也相当于一个函数调用。比如ls命令。在操作系统中执行某个程序实际上可以看作是一个函数调用的过程。","page":"过程抽象","title":"一定意义上，执行某个程序也相当于一个函数调用。比如ls命令。在操作系统中执行某个程序实际上可以看作是一个函数调用的过程。","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"当你在终端或命令行中输入一个命令，比如ls，操作系统会在搜索路径中查找对应的可执行文件，然后加载并执行该可执行文件。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"这个过程可以被视为操作系统内部的函数调用。操作系统会为每个可执行文件分配一个入口点，通常是一个函数，例如在 C 语言中是main函数。操作系统会调用这个入口函数，将命令行参数传递给它，并开始执行程序的逻辑。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"因此，你可以将执行某个程序看作是调用了这个程序中的入口函数，将命令行参数传递给它。这个程序的逻辑会在入口函数中执行，然后根据需要进行一系列的操作，例如输出结果、访问文件系统、执行其他函数等。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"总而言之，执行某个程序可以被看作是一个函数调用的过程，操作系统调用该程序的入口函数，并传递命令行参数，从而开始执行程序的逻辑。这样的函数调用是操作系统和编程语言运行时环境提供的基本机制，使得我们可以通过命令行或终端与计算机进行交互，并执行特定的任务和操作。 在操作系统中执行某个程序实际上可以看作是一个函数调用的过程。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"当你在终端或命令行中输入一个命令，比如 ls，操作系统会在搜索路径中查找对应的可执行文件，然后加载并执行该可执行文件。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"这个过程可以被视为操作系统内部的函数调用。操作系统会为每个可执行文件分配一个入口点，通常是一个函数，例如在 C 语言中是 main 函数。操作系统会调用这个入口函数，将命令行参数传递给它，并开始执行程序的逻辑。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"因此，你可以将执行某个程序看作是调用了这个程序中的入口函数，将命令行参数传递给它。这个程序的逻辑会在入口函数中执行，然后根据需要进行一系列的操作，例如输出结果、访问文件系统、执行其他函数等。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"总而言之，执行某个程序可以被看作是一个函数调用的过程，操作系统调用该程序的入口函数，并传递命令行参数，从而开始执行程序的逻辑。这样的函数调用是操作系统和编程语言运行时环境提供的基本机制，使得我们可以通过命令行或终端与计算机进行交互，并执行特定的任务和操作。","category":"page"},{"location":"CSAdv/1-过程抽象/#此时，函数的参数是通过命令行参数给出。","page":"过程抽象","title":"此时，函数的参数是通过命令行参数给出。","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"当执行某个程序时，可以将命令行参数作为函数调用的参数传递给程序的入口函数。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"命令行参数是在执行程序时通过命令行或终端提供的附加信息，用于向程序传递参数值。这些参数可以用来指定程序的行为、控制程序的运行方式，或者提供必要的输入数据。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在函数调用的概念中，命令行参数就相当于函数的参数。当执行程序时，操作系统会将命令行参数传递给程序的入口函数，以供程序在运行时使用。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在许多编程语言中，可以通过特定的方式获取和处理命令行参数。例如，在C语言中，可以使用main函数的参数来获取命令行参数，即int main(int argc, char *argv[])，其中argc表示参数的数量，argv是一个指针数组，每个元素指向一个命令行参数的字符串。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"类似地，在其他编程语言中也有相应的机制或库可以用于获取命令行参数，如sys.argv（Python）、args（Go）、os.Args（Go）等。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"通过命令行参数，我们可以将外部的信息传递给程序，从而在执行过程中根据不同的参数值进行不同的处理。这使得程序具有更大的灵活性和可配置性，可以根据需要进行定制和适应不同的场景。","category":"page"},{"location":"CSAdv/1-过程抽象/#以ls为例，示范一下","page":"过程抽象","title":"以ls为例，示范一下","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"当我们在命令行中执行 ls 命令时，它会列出当前目录下的文件和子目录。在这种情况下，ls 命令不需要接受额外的命令行参数。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"下面是一个简单的示例，展示如何在 Python 中获取命令行参数并模拟实现类似 ls 命令的功能：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"import os\nimport sys\n\ndef list_files(directory):\n    files = os.listdir(directory)\n    for file in files:\n        print(file)\n\n# 获取命令行参数\nargs = sys.argv\n\n# 确保至少有一个命令行参数（第一个参数是脚本本身的名称）\nif len(args) >= 2:\n    # 第二个参数是目录路径\n    directory = args[1]\n    list_files(directory)\nelse:\n    # 没有提供目录路径时，默认列出当前目录下的文件\n    list_files(os.getcwd())","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在上述示例中，我们使用os.listdir()函数获取指定目录下的文件和子目录的列表，然后使用循环逐个打印出来。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"要运行这个示例，可以保存为ls.py文件，并在命令行中执行以下命令：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"python ls.py [目录路径]","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"其中 [目录路径]是可选的，表示要列出文件的目录路径。如果不提供目录路径，默认会列出当前目录下的文件。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"请注意，这只是一个简化的示例，用于演示如何获取命令行参数并执行相应的操作。在实际的ls命令中，会有更多的选项和参数用于控制输出的格式和内容。","category":"page"},{"location":"CSAdv/1-过程抽象/#只需要执行系统本身的ls命令，给出不同的命令行参数例子即可","page":"过程抽象","title":"只需要执行系统本身的ls命令，给出不同的命令行参数例子即可","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"如果你想直接执行系统本身的ls命令，并传递不同的命令行参数，可以使用适当的方法来调用系统命令。这里给出几个示例：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在 Python 中使用subprocess模块执行系统命令：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"import subprocess\n\n# 执行 ls 命令，并列出当前目录下的所有文件和子目录\nsubprocess.call(['ls'])\n\n# 执行 ls 命令，并列出指定目录下的所有文件和子目录\nsubprocess.call(['ls', '/path/to/directory'])\n\n# 执行 ls 命令，显示文件的详细信息（长格式）\nsubprocess.call(['ls', '-l'])","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在命令行或终端中直接执行系统命令：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"# 列出当前目录下的所有文件和子目录\nls\n\n# 列出指定目录下的所有文件和子目录\nls /path/to/directory\n\n# 显示文件的详细信息长格式）\nls -l","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"上述示例中，通过subprocess.call()函数调用系统命令，并传递不同的命令行参数。在命令行或终端中直接执行命令时，可以直接输入命令和参数。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"请注意，在执行系统命令时要谨慎，确保输入的命令和参数安全可靠。避免直接从用户输入中构造命令，以免受到命令注入等安全风险。如果涉及到处理用户输入，建议使用适当的安全措施和参数验证来确保系统的安全性。","category":"page"},{"location":"CSAdv/1-过程抽象/#程序执行时的环境变量有可能也会影响函数的行为。环境变量就是当前环境的键值对表","page":"过程抽象","title":"程序执行时的环境变量有可能也会影响函数的行为。环境变量就是当前环境的键值对表","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"环境变量是当前执行环境中的键值对表，可以影响程序的行为和配置。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在操作系统中，每个进程都有自己的环境变量。环境变量包含了一些配置信息、路径设置、系统参数等，可以被程序在运行时读取和使用。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"编程语言通常提供了访问和操作环境变量的接口或函数，以便程序可以获取和修改环境变量的值。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"下面是一个示例，展示如何在 Python 中访问环境变量：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"import os\n\n# 获取单个环境变量的值\nvalue = os.environ.get('ENV_VARIABLE_NAME')\n\n# 获取所有环境变量的键值对\nenv_vars = os.environ\n\n# 遍历所有环境变量\nfor key, value in env_vars.items():\n    print(f'{key}: {value}')","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在上述示例中，我们使用 os.environ 来访问当前进程的所有环境变量。可以使用os.environ.get()方法来获取指定环境变量的值，传入环境变量的名称作为参数。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"程序可以根据环境变量的值来改变其行为，例如根据不同的环境变量配置读取不同的配置文件、设置不同的路径、启用或禁用特定的功能等。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"通过使用环境变量，可以提供一种灵活的方式来配置和定制程序的行为，而无需修改程序的源代码。这使得程序可以在不同的环境中以不同的方式运行，增强了程序的可配置性和适应性。","category":"page"},{"location":"CSAdv/1-过程抽象/#执行一个函数，就好比打游戏进入一扇门，保留现场就好比压栈，带入的技能集就好比环境","page":"过程抽象","title":"执行一个函数，就好比打游戏进入一扇门，保留现场就好比压栈，带入的技能集就好比环境","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"这是一个有趣的比喻！将执行一个函数比作打游戏进入一扇门，保留现场比作压栈，而带入的技能集比作环境，可以帮助我们更好地理解函数的执行过程。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"当我们执行一个函数时，可以将其类比为进入游戏中的一扇门。函数提供了一种进入特定逻辑或执行特定任务的方式，就像一扇门将我们引入一个新的场景或体验。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"保留现场则类似于压栈的操作，它表示在函数执行期间，程序会将当前执行的上下文和状态信息保存起来，以便在函数执行完毕后能够回到之前的执行点。这样做的好处是，可以确保函数执行后程序能够继续执行，并恢复到之前的状态。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"带入的技能集就好比环境，它可以影响函数的行为和结果。就像在游戏中，不同的技能集可以影响我们的能力和表现，环境也会对函数的执行产生影响。这可以是一些全局变量、配置参数、环境变量或其他上下文信息，它们提供了一种定制函数行为的方式。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"综合起来，这个比喻形象地描述了函数的执行过程。函数就像一扇门，通过执行函数可以进入不同的逻辑和任务；保留现场就像压栈，确保函数执行完毕后能够回到之前的执行点；而带入的技能集则像是环境，可以影响函数的行为和结果。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"这样的比喻有助于我们以一种形象的方式理解函数的概念和执行过程，并将其与我们在日常生活中的经验和场景联系起来。","category":"page"},{"location":"CSAdv/1-过程抽象/#运行时的环境，和入口，就构成一个闭包。就好比一下子穿越了。函数返回就穿越回来了。","page":"过程抽象","title":"运行时的环境，和入口，就构成一个闭包。就好比一下子穿越了。函数返回就穿越回来了。","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"闭包的概念与运行时的环境和函数的返回相关联。闭包是指函数对象以及它在定义时所处的环境的组合。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"当一个函数在定义时捕获了其周围的变量，并在之后的执行过程中保持对这些变量的引用，那么该函数就形成了一个闭包。闭包允许函数访问其定义时所在的作用域中的变量，即使在定义时的作用域已经不存在了。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"通过闭包，函数可以保持对定义时的环境的引用，这意味着函数可以捕获并操作其周围的状态和数据。这对于实现某些设计模式和编程技术非常有用，例如函数工厂、柯里化、延迟求值等。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"入口函数可以被看作是一个闭包的入口点，它提供了执行代码的起始位置。当程序开始运行时，入口函数会创建一个运行时的环境，并在该环境中执行代码。这个环境包含了各种变量、函数和其他资源，为代码的执行提供了必要的上下文。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在函数返回时，函数所处的执行环境被销毁，但如果该函数是一个闭包，它仍然保持对定义时的环境的引用。这样，当函数再次被调用时，它可以继续访问和操作定义时环境中的变量和状态，就好像穿越过去，回到了函数定义时的环境。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"闭包提供了一种强大的编程机制，使得函数能够捕获和操作其周围的环境，以及在不同的上下文中执行。这种能力可以增加代码的灵活性和可复用性，并为实现一些高级的编程模式和技术提供支持。","category":"page"},{"location":"CSAdv/1-过程抽象/#由函数可以构成服务。","page":"过程抽象","title":"由函数可以构成服务。","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"过去不让写死循环，现在daemon程序就是死循环。窗口界面程序也是死循环，基于事件做出响应。当然过去不让写死循环也是有原因的。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"函数可以构成服务，而服务通常需要以某种形式持续运行。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在过去的编程规范中，通常不鼓励使用死循环（infinite loop），因为它可能导致程序陷入无限循环中，无法正常退出或终止。死循环可能会造成资源浪费、性能下降或程序崩溃等问题。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"然而，在一些特定的应用场景下，死循环是必要的。例如，守护进程（daemon）是一种持续运行的后台程序，它通常以死循环的形式执行，以提供一些特定的服务或功能。守护进程会持续监听事件、处理请求或执行任务，并在必要时做出响应。它们通常在系统启动时启动，并在系统关闭前一直运行。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"类似地，窗口界面程序通常也会包含一个死循环，以等待用户的输入或事件发生，并在接收到输入或事件时做出相应的响应。这种基于事件的循环称为事件循环（event loop），它负责接收和分发事件，并调用相应的函数或方法来处理事件。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"现代的编程语言和框架通常提供了对事件循环的支持，使得编写基于事件的程序更加方便和灵活。事件循环可以帮助我们编写响应式的程序，实现用户交互、异步处理和并发任务等功能。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"虽然死循环在某些场景下是必要的，但在编写这样的程序时，我们仍然需要注意控制循环的条件、避免无限循环和资源泄漏，以确保程序的正确性和可靠性。","category":"page"},{"location":"CSAdv/1-过程抽象/#可以认为make也是一个函数，它的输入参数是makefile","page":"过程抽象","title":"可以认为make也是一个函数，它的输入参数是makefile","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"可以将make视为一个函数，而Makefile是作为输入参数传递给这个函数的。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"make是一个常用的构建工具，用于自动化构建软件项目。它根据项目中定义的规则（通常在一个名为Makefile 的文件中）来决定哪些文件需要重新构建，从而提高了构建过程的效率。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"Makefile文件中包含了一系列规则（rules），每个规则定义了一个目标（target）和相关的依赖项（dependencies）。规则描述了如何根据依赖关系来生成目标文件的过程。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"当运行make命令时，make工具会读取Makefile文件，并根据规则执行相应的动作。它会检查每个目标文件和对应的依赖项的时间戳，如果目标文件不存在或其依赖项的时间戳较新，那么make会执行规则中定义的命令来生成目标文件。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个过程中，我们可以将make视为一个函数，它接受Makefile作为输入参数，并根据规则来执行相应的操作。这个函数的目标是根据依赖关系生成所需的目标文件。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"通过定义规则和依赖关系，make提供了一种灵活的方式来管理和构建复杂的软件项目。它可以自动化构建过程，并根据文件的更新情况来确定需要重新构建的部分，从而提高了开发效率和代码管理的便利性。","category":"page"},{"location":"CSAdv/1-过程抽象/#cmake也是函数，它的输入是cmakelist.txt","page":"过程抽象","title":"cmake也是函数，它的输入是cmakelist.txt","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"CMake也可以被看作是一个函数，而CMakeLists.txt文件则是作为输入参数传递给这个函数的。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"CMake是一个跨平台的构建工具，用于自动生成用于不同构建系统（如Makefile、Visual Studio等）的构建脚本。它使用一种被称为 CMakeLists.txt 的脚本语言来描述项目的构建过程和依赖关系。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"CMakeLists.txt文件中包含了一系列的命令和指令，用于指导CMake如何生成构建系统所需的构建文件。这些命令可以用来定义目标、设置编译选项、指定依赖项、配置安装规则等。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"当运行CMake命令时，它会读取CMakeLists.txt文件，并根据文件中的指令和命令来生成相应的构建文件。生成的构建文件可以用于在目标平台上构建项目。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在这个过程中，我们可以将CMake视为一个函数，它接受CMakeLists.txt文件作为输入参数，并根据其中的指令和命令来生成构建文件。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"通过使用CMake，我们可以将项目的构建过程与具体的构建系统解耦，从而实现跨平台的构建。它提供了一种统一的方式来描述项目的构建需求，并自动生成适应不同平台和构建系统的构建文件。这使得项目的构建和移植变得更加简单和可维护。","category":"page"},{"location":"CSAdv/1-过程抽象/#过程抽象补充","page":"过程抽象","title":"过程抽象补充","text":"","category":"section"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"在讲解过程抽象时，已经提到了函数、参数、返回值、函数调用和函数嵌套等重要概念。这些都是过程抽象的核心内容。还可以考虑涵盖以下几个方面来完善：","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"作用域：讲解函数内部的变量作用域以及变量的可见性。解释全局作用域和局部作用域的概念，并说明在函数调用过程中如何管理变量的作用域。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"递归：介绍递归作为一种重要的过程抽象方式。解释递归的概念、递归函数的结构和执行过程，并举例说明递归在问题求解中的应用。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"高阶函数：探讨高阶函数作为一种过程抽象的进阶概念。解释高阶函数的定义和特点，以及如何使用高阶函数来操作和组合其他函数。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"匿名函数：介绍匿名函数作为一种特殊的函数定义方式。讲解匿名函数的语法和用法，并说明它们在简洁性和灵活性方面的优势。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"函数式编程：简要介绍函数式编程范式，其中函数被视为一等公民，强调纯函数、不可变性和无副作用的编程风格。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"错误处理：讲解在函数调用中如何处理异常和错误情况，包括返回特定值、抛出异常和使用错误码等方式。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"部分应用和柯里化：探讨将函数部分应用于参数，以及柯里化作为一种将多参数函数转化为一系列单参数函数的技术。","category":"page"},{"location":"CSAdv/1-过程抽象/","page":"过程抽象","title":"过程抽象","text":"过程抽象的优势：总结过程抽象的优势，包括代码重用性、模块化和抽象屏障等方面的好处。","category":"page"},{"location":"Optimization/3-能源系统工程中的优化问题/#能源系统工程中有哪些优化问题","page":"能源系统工程中有哪些优化问题","title":"能源系统工程中有哪些优化问题","text":"","category":"section"},{"location":"Optimization/3-能源系统工程中的优化问题/","page":"能源系统工程中有哪些优化问题","title":"能源系统工程中有哪些优化问题","text":"当涉及到能源系统工程时，有几个典型的例子如下：","category":"page"},{"location":"Optimization/3-能源系统工程中的优化问题/","page":"能源系统工程中有哪些优化问题","title":"能源系统工程中有哪些优化问题","text":"发电系统规划： 发电系统规划是指在特定地区或国家范围内，根据电力需求和资源可用性，确定最佳的发电技术和配置。这涉及到选择合适的发电设备（如燃煤、天然气、风能、太阳能等）、容量规模、电网互联等因素。发电系统规划旨在最大化能源利用效率、降低环境影响、确保电力供应可靠性和经济性。\n微电网设计： 微电网是指一个相对较小的能源系统，可以独立运行或与传统电网连接。微电网通常由多种能源资源（如太阳能、风能、电池储能等）和能源转换设备组成。微电网设计涉及到确定适当的能源资源组合、储能容量、运行策略和互联性，以实现可靠的供电和能源自给自足。\n能源系统优化： 能源系统优化旨在通过最优化调度和管理能源系统中的各个组件，以最大化能源利用效率、降低能源成本或减少碳排放等目标。这可能涉及到能源供应与需求的平衡、能源存储和转换设备的优化、能源网络调度等。能源系统优化可以应用于各种场景，如建筑能源管理、工业过程优化、电动车充电规划等。\n可再生能源集成： 可再生能源集成是将不同的可再生能源技术（如太阳能、风能、水能等）整合到一个系统中，以满足能源需求。这涉及到确定适当的技术组合、能源存储、电力输配等因素，以实现可再生能源的高效利用和平稳供应。","category":"page"},{"location":"Optimization/3-能源系统工程中的优化问题/","page":"能源系统工程中有哪些优化问题","title":"能源系统工程中有哪些优化问题","text":"这些是能源系统工程中的一些典型例子，每个例子都涉及到能源资源的选择、设备配置、优化目标的定义等方面。在实践中，针对具体的能源系统工程问题，需要结合具体的需求、资源可用性和技术限制，进行系统建模、优化和评估。","category":"page"},{"location":"Optimization/3-能源系统工程中的优化问题/#优化目标","page":"能源系统工程中有哪些优化问题","title":"优化目标","text":"","category":"section"},{"location":"Optimization/3-能源系统工程中的优化问题/","page":"能源系统工程中有哪些优化问题","title":"能源系统工程中有哪些优化问题","text":"在能源系统工程中，经济性目标、技术经济性目标和环境目标是三个最典型的优化目标。","category":"page"},{"location":"Optimization/3-能源系统工程中的优化问题/","page":"能源系统工程中有哪些优化问题","title":"能源系统工程中有哪些优化问题","text":"经济性目标： 经济性目标旨在最大化能源系统的经济效益。这包括降低能源成本、最大化利润或投资回报率等。在发电系统规划、能源供应链优化和能源市场设计等问题中，经济性目标是最常见和重要的优化目标之一。通过优化资源配置、能源供需平衡和市场机制等方式，以经济性为导向来实现经济效益的最大化。\n技术经济性目标： 技术经济性目标是在能源系统工程中结合技术可行性和经济性，以实现可行和经济的解决方案。这包括在选择能源技术、设备容量和工程规模时考虑成本效益、资源利用效率、系统可靠性等方面的优化。技术经济性目标的关注点是将技术可行性与经济效益相结合，找到在技术和经济约束下最优的解决方案。\n环境目标： 环境目标旨在减少能源系统对环境的负面影响，包括减少温室气体排放、降低空气污染、保护生态系统等。这涉及到优化能源系统的环境性能，例如通过增加可再生能源比例、推动能源效率改进、采用清洁能源技术等方式来减少碳足迹和环境污染。环境目标在应对气候变化和可持续发展方面具有重要意义。","category":"page"},{"location":"Optimization/3-能源系统工程中的优化问题/","page":"能源系统工程中有哪些优化问题","title":"能源系统工程中有哪些优化问题","text":"在实际能源系统工程中，这些目标通常是综合考虑的，因为它们相互关联并且存在着权衡。优化算法和决策支持工具可以帮助分析人员在不同的目标之间找到平衡点，以制定出符合实际需求的最佳解决方案。 ","category":"page"},{"location":"Optimization/3-能源系统工程中的优化问题/#约束","page":"能源系统工程中有哪些优化问题","title":"约束","text":"","category":"section"},{"location":"Optimization/3-能源系统工程中的优化问题/","page":"能源系统工程中有哪些优化问题","title":"能源系统工程中有哪些优化问题","text":"约束在能源系统工程中起着重要的作用，限制了系统的可行性和可操作性。以下是一些常见的约束类型：","category":"page"},{"location":"Optimization/3-能源系统工程中的优化问题/","page":"能源系统工程中有哪些优化问题","title":"能源系统工程中有哪些优化问题","text":"资源约束： 资源约束涉及到能源系统所需资源的可用性和限制。例如，可再生能源资源的可利用程度受到日照、风速等天气条件的限制；化石燃料资源受到供应量和价格的影响。资源约束需要在系统设计和运营中考虑，以确保能源供应的可持续性和稳定性。\n供能系统容量约束： 供能系统容量约束是指能源系统中各个组件的容量限制。例如，发电厂的最大发电容量、储能设备的储存容量、输电线路的传输能力等。这些约束需要考虑设备的技术特性、安全性和经济性等因素，以确保能源系统的可靠性和稳定性。\n运行约束： 运行约束涉及到能源系统在运行过程中的限制条件。例如，发电机的最小稳定负荷要求、储能设备的充放电速率限制、输电线路的功率平衡等。这些约束用于确保能源系统在运行中满足特定的要求，如稳定性、可靠性和安全性。\n环境约束： 环境约束涉及到能源系统对环境的影响。例如，温室气体排放的限制、污染物排放标准的遵守等。这些约束旨在保护环境和生态系统，并促进可持续发展。\n经济约束： 经济约束涉及到能源系统的成本和经济效益。例如，能源价格、设备投资成本、运维成本等。这些约束需要考虑能源系统的经济可行性和盈利能力。","category":"page"},{"location":"Optimization/3-能源系统工程中的优化问题/","page":"能源系统工程中有哪些优化问题","title":"能源系统工程中有哪些优化问题","text":"这些约束在能源系统规划、运营和管理中起着重要的作用。合理地处理约束条件可以确保能源系统的可行性、可靠性和经济性，以实现系统的可持续发展和最优性。","category":"page"},{"location":"Optimization/3-能源系统工程中的优化问题/#决策变量","page":"能源系统工程中有哪些优化问题","title":"决策变量","text":"","category":"section"},{"location":"Optimization/3-能源系统工程中的优化问题/","page":"能源系统工程中有哪些优化问题","title":"能源系统工程中有哪些优化问题","text":"在能源系统工程中，决策变量可以涉及多个方面，以下是一些常见的决策变量：","category":"page"},{"location":"Optimization/3-能源系统工程中的优化问题/","page":"能源系统工程中有哪些优化问题","title":"能源系统工程中有哪些优化问题","text":"能源资源选择和配置： 决策变量可以包括选择和配置不同类型的能源资源，如太阳能光伏电池板的安装容量、风力涡轮机的数量、燃煤发电机组的容量等。这些决策变量影响能源系统的供给结构和资源利用。\n设备容量和规模： 决策变量可以涉及各种设备的容量和规模，如发电机组的容量、储能设备的存储容量、输电线路的传输能力等。这些决策变量影响能源系统的产能和输配能力。\n运营策略和调度： 决策变量可以涉及能源系统的运营策略和调度决策，如发电机组的启停策略、储能设备的充放电策略、电力市场交易策略等。这些决策变量影响能源系统的运行方式和资源调度。\n储能和能量存储： 决策变量可以涉及能源系统中储能设备的容量、充放电速率、储能策略等。这些决策变量影响能源系统的能量存储和调度能力。\n能源供需平衡： 决策变量可以涉及能源供需平衡的调节决策，如能源进口和出口策略、能源需求管理策略等。这些决策变量影响能源系统的供需平衡和稳定性。","category":"page"},{"location":"Optimization/3-能源系统工程中的优化问题/","page":"能源系统工程中有哪些优化问题","title":"能源系统工程中有哪些优化问题","text":"这些决策变量涉及能源系统的不同方面，从能源资源选择到运营策略和供需平衡等，都对能源系统的性能和效益产生影响。通过合理地选择和优化这些决策变量，能够实现能源系统的高效、可靠和可持续运行。","category":"page"},{"location":"JuliaIntro/5-julia的环境/#julia的环境","page":"julia的环境","title":"julia的环境","text":"","category":"section"},{"location":"JuliaIntro/5-julia的环境/#julia的环境简介","page":"julia的环境","title":"julia的环境简介","text":"","category":"section"},{"location":"JuliaIntro/5-julia的环境/","page":"julia的环境","title":"julia的环境","text":"julia提供了一种类似于Python虚拟环境的机制，称为\"环境\"（Environment）。环境允许您在不同的项目或场景中创建独立的Julia环境，以便管理不同版本的包和依赖关系。以下是关于Julia环境的介绍：","category":"page"},{"location":"JuliaIntro/5-julia的环境/","page":"julia的环境","title":"julia的环境","text":"环境的创建： 您可以使用Pkg模块中的activate命令来创建一个新的环境。例如，要创建一个名为\"myenv\"的环境，可以执行以下命令：\nusing Pkg\nPkg.activate(\"myenv\")\n这将在当前工作目录下创建一个新的\"myenv\"环境，并将Julia的包管理器指向该环境。\n环境的使用： 一旦您激活了特定的环境，Julia将在该环境中安装和管理包。您可以使用Pkg模块中的各种命令来安装、更新和移除包，就像在全局环境中一样。Julia将在当前环境中记录和管理您的包依赖关系，确保在该环境中使用一致的包版本。\n环境的切换： 您可以随时切换活动环境以在不同的环境之间切换。使用activate命令，您可以激活已创建的环境。例如，要切换回全局环境，可以执行以下命令：\nusing Pkg\nPkg.activate()\n这将切换回全局环境，使您可以在全局范围内管理和安装包。\n环境的导出和导入： 您可以将环境的依赖关系导出到一个文件中，以便在其他地方导入和重现相同的环境。使用Pkg模块中的instantiate命令，可以根据导出的文件创建和还原环境。例如，要从名为\"environment.toml\"的文件创建环境，可以执行以下命令：\nusing Pkg\nPkg.instantiate(\"environment.toml\")\n这将根据导出的文件还原依赖关系，并创建相应的环境。","category":"page"},{"location":"JuliaIntro/5-julia的环境/","page":"julia的环境","title":"julia的环境","text":"Julia的环境机制使您能够轻松地创建、管理和共享独立的Julia环境，以满足不同项目或场景的需求。","category":"page"},{"location":"JuliaIntro/5-julia的环境/","page":"julia的环境","title":"julia的环境","text":"希望这次的回答对您有帮助。如果您还有其他问题，请随时提问！","category":"page"},{"location":"Frameworks/OptControl/#OptControl.jl设计理念","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"tip: Tip\nContents：OptControl：最优控制问题的解释器Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"note: Note\nOptControl地址。arXiv文章引用","category":"page"},{"location":"Frameworks/OptControl/#摘要","page":"OptControl.jl设计理念","title":"摘要","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"最优控制问题的本质是一个优化问题。OptControl.jl(OptControl)基于Julia语言，实现了最优控制的符号化建模过程，并生成相应的基于Julia生态的最优控制问题的数值优化求解代码。OptControl没有定义数据类型(struct)，而是通过处理字符生成解决方案脚本，并在内部解析并运行脚本。OptControl也提供保存脚本文件到本地的接口。同时，OptControl支持组件化建模，这让构建复杂系统的最优控制问题变得简单。OptControl的依赖包完全来自于Julia生态。","category":"page"},{"location":"Frameworks/OptControl/#Motivation","page":"OptControl.jl设计理念","title":"1 Motivation","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"最优控制问题的本质是一个优化问题，更准确的说是一个泛函求极值问题。从实现的角度，最优控制的解析解只有在特定的几种情况下才能求出，例如线性系统。而实际问题中往往需要面对非线性系统或者一些复杂的系统，这些问题的解析解一般而言难以求得。因此，能算出结果的数值解则是一个利器。虽然数值解在结果上会有一些偏差，但有偏差的结果也能带给人们一定理解问题的灵感。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"最优控制问题的数值解法一般而言可以转化为数值优化问题。数值优化问题可以使用JuMP.jl来求解。使用JuMP.jl求解一个最优控制问题，可以分为5步：","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"抽象实际问题\n获得状态方程模型\n构建数值优化模型\n生成JuMP模型\n求解","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"事实上，JuMP.jl完成了第4步，第5步的内容由具体的求解器完成。但JuMP.jl在完成第4步的基础上，提供了到第5步的接口。因此也可以认为，JuMP.jl包揽了第4步和第5步的工作。那么整个问题需要留给用户解决的，还有前3步。它们的关系由下图所示。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"(Image: 图 1)  ","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"事实上，第一步包含了从实际问题到数学表达的抽象过程，这一过程只有高级的人脑才能完成。那么，第2步和第3步能否实现自动化呢？这正是OptControl所希望完成的内容。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"OptControl的重点在于自动化，即如何自动构建最优问题，如何自动构建JuMP优化模型以及调用求解器自动求解。如何求解一个最优问题，如何构建符号化的系统等类型的问题，OptControl都不涉及。OptControl关心的是，整合已有的资源（Julia生态中的各种软件包），尽可能地自动化完成上述5个步骤。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"所以可以视OptControl是一个解释器，实现状态空间模型到最优控制问题的转化。它有三个特点：","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"接受Symbolics.jl或ModelingToolkit.jl构建的基于符号系统的状态空间模型\n自动生成以JuMP模型表达的最优化问题求解脚本，并自动运行\n提供保存脚本文件的接口，供用户自由修改","category":"page"},{"location":"Frameworks/OptControl/#OptControl框架","page":"OptControl.jl设计理念","title":"2 OptControl框架","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"OptControl的能力是逐步提高的。","category":"page"},{"location":"Frameworks/OptControl/#.1-构建优化模型","page":"OptControl.jl设计理念","title":"2.1 构建优化模型","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"首先完成的是第3步到第5步的解决方案。该解决方案的函数是","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"generateJuMPcodes——处理线性系统\ngenerateNLJuMPcodes——处理非线性系统","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"generateJuMPcodes与generateNLJuMPcodes接受以符号形式表达的状态方程。符号表达通过Symbolics.jl构建。Symbolics.jl是一个拥有高性能，并能够以用户语言进行拓展的符号代数系统。用符号表达的状态方程能够转变成Julia函数，通过该函数对问题进行离散化处理，将离散后的模型中的状态作为JuMP系统的优化变量，构建JuMP优化模型进行求解。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"(Image: 图 3)  ","category":"page"},{"location":"Frameworks/OptControl/#.2-获得状态方程模型","page":"OptControl.jl设计理念","title":"2.2 获得状态方程模型","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"更进一步，我们希望自动化实现第2步到第5步。第2步到第5步的解决方案需要使用ModelingToolkit.jl的非因果组件建模系统。该解决方案的函数是","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"generateMTKcodes——处理ODESystem系统","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"generateMTKcodes接受ODESystem系统。ODESystem中描述系统的微分方程事实上就是最优控制问题的状态方程。它们的区别是，ODESystem系统中的某些变量在最优控制问题中是状态量，而另一些是控制量。换而言之即，在最优控制中的状态方程与仿真系统中的微分方程本质上是相同的，不同的是最优控制问题赋予了某些变量特殊的含义。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"generateMTKcodes使用ModelingToolkit.jl中的generate_function函数生成Julia函数，并使用函数进行离散，将离散后的状态作为JuMP系统的优化变量，构建JuMP优化模型进行求解。2.1与2.2中解决方案的思路是相同的。它们都生成了Julia函数。2.1中的函数来自Symbolics.jl符号矩阵，2.2中的函数来自ModelingToolkit.jl中的ODESystem。OptControl利用生成的Julia函数进行状态空间的离散，并构建JuMP优化模型。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"(Image: 图 4)  ","category":"page"},{"location":"Frameworks/OptControl/#OptControl中的数学推演","page":"OptControl.jl设计理念","title":"3 OptControl中的数学推演","text":"","category":"section"},{"location":"Frameworks/OptControl/#.1-仿真或者控制？","page":"OptControl.jl设计理念","title":"3.1 仿真或者控制？","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"最优控制问题的中描述系统的方程为:","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"dotboldsymbolx(t)=boldsymbolAboldsymbolx(t)+boldsymbolBboldsymbolu(t)=fboldsymbolx(t)boldsymbolu(t)ttag1","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"其中，boldsymbolx(t)是系统的状态向量，boldsymbolu(t)是系统的控制量向量。它们都是关于自变量t的函数，也就是说它们随时间的变化而变化。事实上，在控制问题中，系数矩阵boldsymbolAboldsymbolB也是可以随时间而变化的，则变为boldsymbolA(t)boldsymbolB(t)。这根据实际需要而定。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"省去关于时间的函数表达，上述方程可以简写成：","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"dotboldsymbolx=boldsymbolAboldsymbolx+boldsymbolBboldsymbolu=f(boldsymbolxboldsymbolut)tag2","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"如果从数学的角度思考，不考虑boldsymbolxboldsymbolu的物理含义，这是一个关于时间的常微分方程问题。如果boldsymbolu的值不人为地决定，而是在系统中自我演化。那么这个就是一个微分方程求解问题。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"dotboldsymbolx=f(boldsymbolxboldsymbolpt)tag3","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"求解该微分方程的在真实世界中对应系统的动态仿真。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"所以，控制问题和动态仿真问题的本质是相同的。系统的描述方程都为关于时间的微分方程（组）。不同之处在于，问题的中的某些变量是否可以人为介入改变。也可以说，动态仿真问题是我们希望看到系统是如何演化的，而控制问题是，我们希望系统按照我们的期望去演化。正因为我们有期望，所以我们需要介入，对系统进行人为干预。而在方程中的体现是boldsymbolu，boldsymbolu是对系统干预的数学表达。所以，如果我们构造了boldsymbolu而不改变它，即它没有起到干预的作用，那这样的问题仍然是一个动态仿真问题。因为人的影响并没有通过boldsymbolu传递到系统。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"这正是为何OptControl能够用ModelingToolkit.jl构建系统的原因。ModelingToolkit.jl原本是用来构建动态仿真问题的工具，ODESystem描述的是动态系统的仿真模型，它并不存在可以人为干预系统的接口——控制变量boldsymbolu。我们可以构建ODESystem，观察系统是怎样变化的，而不能从头至尾地控制它的演化方向（事实上，偶尔的干预是可以通过Callback功能实现的，但它远没有达到“控制”的内涵）。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"但我们只要稍加改变，就能够将仿真问题转变为控制问题。只需要给ODESystem中的某些变量加上控制属性，工作就完成了。这正是OptControl使用的方法——把ODESystem中的参数boldsymbolp变为了控制量boldsymbolu。就得到到了控制问题中状态空间方程的最原始形式。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"dotboldsymbolx=f(boldsymbolxboldsymbolpt)Rightarrow dotboldsymbolx=f(boldsymbolxboldsymbolut)tag4","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"为了实现这一点，在构建ODESystem时需要做一点设计——需要把我们系统中某需要转变为控制量的变量设置成参数boldsymbolp。","category":"page"},{"location":"Frameworks/OptControl/#.2-最优控制怎样最优","page":"OptControl.jl设计理念","title":"3.2 最优控制怎样最优","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"上一节中我们探讨了boldsymbolu的内涵。那么还剩下一个问题是，如何用于数学语言描述最优。整个最优问题可以分为两个部分，控制过程中的最优以及控制终态的最优。方程5表示对最优的一个目标。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"min Phi(boldsymbolx(t_f)t_f)+int_t_0^t_f Lboldsymbolx(t)boldsymbolu(t)tdt  tag5","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"其中，Phi(boldsymbolx(t_f)t_f)表示对终端状态的一个期望，积分int_t_0^t_f Lboldsymbolx(t)boldsymbolu(t)tdt表示控制过程中的期望状态达到的最小指标。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"方程2和方程5合起来，就成为了最优控制问题控制方程的一般形式。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"beginmatrix\nminPhi(boldsymbolx(t_f)t_f)+int_t_0^t_f Lboldsymbolx(t)boldsymbolu(t)tdtst hspace10cm dotboldsymbolx =\nfboldsymbolx(t)boldsymbolu(t)t \nendmatrix tag6","category":"page"},{"location":"Frameworks/OptControl/#.3-数值优化模型","page":"OptControl.jl设计理念","title":"3.3 数值优化模型","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"方程6是连续形式，如果采用数值优化方法则需要将其离散化。离散方法采用欧拉法，则有:","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"beginmatrix\nminPhi(boldsymbolx(t_f)t_f)+sum_i=1^n L(boldsymbolx_iboldsymbolu_it_i) st hspace04cm boldsymbolx_i+1 =boldsymbolx_i+f(boldsymbolx_iboldsymbolu_it_i)*dt\nendmatrix tag6","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"如果采用后退欧拉法则有：","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"beginmatrix\nminPhi(boldsymbolx(t_f)t_f)+sum_i=1^n L(boldsymbolx_iboldsymbolu_it_i) st hspace04cm boldsymbolx_i+1 =boldsymbolx_i+f(boldsymbolx_i+1boldsymbolu_i+1t_i+1)*dt\nendmatrix tag7","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"此外，还有很多的离散方法，如梯形法，亚当斯方法等等。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"一旦获得了方程6和方程7的结果，下一步可以用JuMP.jl来构建相应的JuMP模型，以便调用相关的求解器求解。这由OptControl自动化地完成。","category":"page"},{"location":"Frameworks/OptControl/#求解实例","page":"OptControl.jl设计理念","title":"4 求解实例","text":"","category":"section"},{"location":"Frameworks/OptControl/#.1-Case1:-线性系统最优控制问题","page":"OptControl.jl设计理念","title":"4.1 Case1: 线性系统最优控制问题","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"求解以下线性最优控制问题：","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"min int_0^2 u^2dt newline st  dotboldsymbolx =beginbmatrix01 newline 00endbmatrixboldsymbolx+ beginbmatrix0 newline 1 endbmatrixu newline boldsymbolx(0) = beginbmatrix 1 newline 1 endbmatrix boldsymbolx(2)=beginbmatrix 0 newline 0 endbmatrix","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"使用OptControl求解该问题的步骤是：","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"使用ModelingToolkit.jl或者Symbolics.jl描述系统方程\n确定初态和终态等参数\n调用generateJuMPcodes求解","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"using OptControl, Statistics, ModelingToolkit\n@variables t u x[1:2]\nf = [0 1; 0 0] * x + [0, 1] * u\nL = 0.5 * u^2\nt0 = [1.0, 1.0]\ntf = [0.0, 0.0]\ntspan = (0.0, 2.0)\nN = 100\nsol = generateJuMPcodes(L, f, x, u, tspan, t0, tf; N=N)","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"该最优问题中，x_1的解析解是","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"x_1(t) = 05*t^3-175*t^2+t+1","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"比较解析解和优化数值解，可以得到它们的均方差是2.696E-6。在这个误差下的结果即使不能使用，它也是极具参考意义的，能给与人们启示。","category":"page"},{"location":"Frameworks/OptControl/#.2-Case2:-非线性系统最优控制问题","page":"OptControl.jl设计理念","title":"4.2 Case2: 非线性系统最优控制问题","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"求解以下非线性最优控制问题：","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"min int_0^2 u^2dt newline st  dotboldsymbolx =beginbmatrixexpcos newline sin1endbmatrixboldsymbolx+ beginbmatrix0 newline 1 endbmatrixu newline boldsymbolx(0) = beginbmatrix 1 newline 1 endbmatrix boldsymbolx(1)=beginbmatrix 0 newline 0 endbmatrix","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"使用ModelingToolkit.jl或者Symbolics.jl定义符号变量，给定初态和终态。调用generateNLJuMPcodes则可以得到结果。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"using OptControl, ModelingToolkit, Test\n@variables t u x[1:2]\nf = [exp(x[1]) + cos(x[2]), sin(x[1]) + x[2]] + [1, 0] * u\nL = u^2\nt0 = [1.0, 1.0]\ntf = [0.0, 0.0]\ntspan = (0.0, 2.0)\nN = 100\nsol = generateNLJuMPcodes(L, f, x, u, tspan, t0, tf; N=N)","category":"page"},{"location":"Frameworks/OptControl/#.3-Case3:-RC电路系统最优控制","page":"OptControl.jl设计理念","title":"4.3 Case3: RC电路系统最优控制","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"这是一个简单的电路系统。电源电压1V，电阻1欧姆，电容1法拉。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"(Image: 图 2)  ","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"我们构造的最优控制问题是，电压如何变化才能使得电容电压在1s内从1V变化到3V的同时，满足整个过程中电压尽可能低的目标。这在物理上是有意义的，但是可能没有应用价值。但它能充分说明问题所在。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"using OptControl, ModelingToolkit, Test\n\n# Components ......\n\n# Define and Simplify System\nR = 1.0\nC = 1.0\nV = 1.0\n@named resistor = Resistor(R=R)\n@named capacitor = Capacitor(C=C)\n@named source = ConstantVoltage(V=V)\n@named ground = Ground()\nrc_eqs = [\n    connect(source.p, resistor.p)\n    connect(resistor.n, capacitor.p)\n    connect(capacitor.n, source.n)\n    connect(capacitor.n, ground.g)\n]\n@named _rc_model = ODESystem(rc_eqs, t)\n@named rc_model = compose(_rc_model,\n    [resistor, capacitor, source, ground])\nsys = structural_simplify(rc_model)\n\n# Build Optimal Control Problem and Solve\nL = 0.5 * (source.V^2)\nt0 = [1.0]\ntf = [3.0]\ntspan = (0.0, 1.0)\nN = 100\nsol = OptControl.generateMTKcodes(L, sys, states(sys), [source.V], tspan, t0, tf;N=N)","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"上述代码的组件来自于ModelingToolkit.jl的文档。如果是一个仿真问题，当ODESystem被化简完成后应该需要调用DifferentialEquations.jl来求解。现在是一个最优控制问题，所以我们指定优化目标，以及定义相关参数，通过generateMTKcodes求解。","category":"page"},{"location":"Frameworks/OptControl/#结论","page":"OptControl.jl设计理念","title":"5 结论","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"OptControl实现了从状态方程到最优控制问题的自动化构建以及从ModelingToolkit的常微分方程系统到系统最优控制问题的自动化构建。问题的核心在于选择设计控制变量boldsymbolu。在状态空间方程离散过程中，OptControl提供了选择离散方法的接口。在未来的工作中，会发展更多离散方法。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"OptControl另外一个重要特点是，它不直接解决问题，而是生成解决方案脚本并解释运行。这意味OptControl像一个指挥者，它把问题分解，再调用Julia生态中的包解决问题。OptControl提供了获得脚本的接口，这意味当OptControl的功能不能满足你的需求时，你可以直接修改脚本。在它基础之上添加任何你需要的功能。如果你不熟悉JuMP的建模语言，那么你正好可以通过生成的脚本学习一些JuMP的高级用法。如果你还想选择一些不同的求解器，那就修改脚本吧。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"在未来，OptControl也许会提供更多的接口。但它不会改变指挥者的角色。也就是说，OptControl会一直致力于自动化生成最优控制问题的解决方法，而不是像ModelingToolkit.jl和JuMP.jl发展一种建模语言，也不会像JuMP.jl调用的求解器一样发展求解算法。OptControl的初衷是打通壁垒，整合工具，方便快捷的解决最优控制的问题。","category":"page"},{"location":"Simulation/1-微分代数方程/#微分代数方程DAE","page":"微分代数方程DAE","title":"微分代数方程DAE","text":"","category":"section"},{"location":"Simulation/1-微分代数方程/#何为微分代数方程","page":"微分代数方程DAE","title":"何为微分代数方程","text":"","category":"section"},{"location":"Simulation/1-微分代数方程/#代数方程、常微分方程、偏微分方程相互关系","page":"微分代数方程DAE","title":"代数方程、常微分方程、偏微分方程相互关系","text":"","category":"section"},{"location":"Simulation/1-微分代数方程/#微分代数方程的应用范围","page":"微分代数方程DAE","title":"微分代数方程的应用范围","text":"","category":"section"},{"location":"Simulation/1-微分代数方程/#流程模拟的序贯模块法与联立方程法","page":"微分代数方程DAE","title":"流程模拟的序贯模块法与联立方程法","text":"","category":"section"},{"location":"Simulation/1-微分代数方程/#流程仿真的软件及其构建方法","page":"微分代数方程DAE","title":"流程仿真的软件及其构建方法","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/#静态链接库和动态链接库","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"编程中函数的本质是把具有一定功能性代码整合起来，可以重复的使用。至于函数内部的实现，你可以认为就是一个黑箱。但是我得告诉你我这个黑箱中有什么功能。就像快递收发点一样，怎么运输的你不用管，但是我得有个目录告诉你有些什么选择和对应的收费标准。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"c语言中，stdio等库就是这么个情况，把很多有用的函数封装在一起，成为一个库（静态和动态我们等会儿再说），库里有什么则通过stdio.h这个文件告诉你，同时stdio.h也告诉你了要以什么样的参数方式调用。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"人们可以把一些函数封装成库，提供给用户服务。c语言就有很多这样的库，你写程序的时候，就可以调用c语言自带的这些库函数。编译的时候，你的c语言源代码会编译成.o文件，但是要做成exe文件，还需要把库里所有要用到的那些函数代码嵌入进来，这种方式就是静态的链接到了你的exe文件中。提供的这些库，就称呼为静态链接库。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"而如果某些函数使用率非常的高，或者你自己脑回路清奇，或者乐意，你也可以把那些用到的函数不嵌入进来，只是告诉你的exe程序，需要用到某个库中的某个函数，在运行的时候才加载那个库，调用库里的函数。这样的方式就是动态链接库。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在windows下，静态链接库一般是lib为后缀名，动态链接库一般是dll为后缀名。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在linux下，静态链接库一般是a为后缀名，动态链接库一般是so为后缀名。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在mac os x 下，动态链接库一般是dylib为后缀名。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"我们在julia中可以很方便的调用动态链接库里的函数。详情请见julia调用dll中的函数。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#静态链接库和动态链接库是什么","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库是什么","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"动态链接库（Dynamic Link Library，DLL）是一种在多个程序之间共享代码和数据的可执行文件格式。DLL包含一组可重用的函数、类、变量和资源，可以被不同的应用程序或进程调用和使用。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"与静态链接库（Static Link Library）不同，DLL在运行时才加载到内存中，并且可以由多个应用程序同时使用。这种共享的特性带来了一些优势：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"节省内存空间：由于多个应用程序可以共享同一个DLL，所以不同的应用程序不需要在内存中加载相同的代码和数据，从而节省了内存空间。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"代码和数据的更新和维护：如果需要更新DLL中的代码或数据，只需更新DLL本身，而不需要重新编译和链接所有使用该DLL的应用程序。这样可以简化代码的维护和更新过程。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"提供标准化的功能和接口：通过使用DLL，可以将常用的功能和接口封装在一个共享的库中，使得多个应用程序可以共享这些标准化的功能，减少了代码冗余和重复开发。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在Windows操作系统中，DLL文件具有特定的文件扩展名 \".dll\"，并且可以通过动态链接方式进行加载和调用。应用程序可以使用特定的函数调用语法来调用DLL中的函数，从而实现对DLL中功能的使用。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"需要注意的是，由于DLL是共享的，因此在使用DLL时需要注意版本兼容性和依赖关系。如果一个应用程序依赖于某个DLL的特定版本，那么必须确保该DLL的版本可用，并且正确配置应用程序的运行环境，以避免出现兼容性问题。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"总之，动态链接库是一种方便共享代码和数据的可执行文件格式，它提供了灵活性、代码重用和资源共享的好处，被广泛用于软件开发中。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#使用c语言，CMake工具，来个例子","page":"静态链接库和动态链接库","title":"使用c语言，CMake工具，来个例子","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"当使用CMake构建动态链接库或静态链接库时，您需要编写CMakeLists.txt文件来描述构建过程。下面是一个示例，展示如何使用C语言生成一个动态链接库和一个静态链接库。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"首先，创建一个名为mylib的文件夹，并在其中创建以下文件：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"CMakeLists.txt - 用于构建库的CMake文件。\nmylib.h - 库的头文件。\nmylib.c - 库的源代码文件。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"确保将这些文件放在同一个文件夹中。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"下面是CMakeLists.txt的内容：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"cmake_minimum_required(VERSION 3.10)\nproject(mylib)\n\n# 添加库的源文件\nset(SOURCES mylib.c)\n\n# 生成动态链接库\nadd_library(mylib_shared SHARED ${SOURCES})\n\n# 生成静态链接库\nadd_library(mylib_static STATIC ${SOURCES})\n\n# 设置库的输出名称\nset_target_properties(mylib_shared PROPERTIES OUTPUT_NAME \"mylib\")\nset_target_properties(mylib_static PROPERTIES OUTPUT_NAME \"mylib\")\n\n# 设置库的安装路径\ninstall(TARGETS mylib_shared mylib_static\n        LIBRARY DESTINATION lib\n        ARCHIVE DESTINATION lib)\n\n# 设置头文件的安装路径\ninstall(FILES mylib.h DESTINATION include)","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在上述示例中，我们使用add_library命令来创建动态链接库和静态链接库。set_target_properties命令用于设置库的输出名称，这里设置为\"mylib\"。install命令用于指定库的安装路径和头文件的安装路径。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"要构建库，可以按照以下步骤进行操作：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"创建一个名为build的文件夹，并进入该文件夹。\n打开终端，导航到build文件夹。\n运行以下命令以生成构建文件：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"cmake ..","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"运行以下命令以构建库：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"cmake --build .","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"完成上述步骤后，将在build文件夹中生成动态链接库（libmylib.so）和静态链接库（libmylib.a）。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"如果您希望安装库到系统路径中，可以运行以下命令（需要管理员权限）：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"sudo make install","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"这将把库文件和头文件安装到默认的系统路径（例如，/usr/local/lib和/usr/local/include）。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#对应的c语言源文件","page":"静态链接库和动态链接库","title":"对应的c语言源文件","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"这里是一个示例的C源文件mylib.c，用于生成动态链接库和静态链接库：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"#include \"mylib.h\"\n\nint add(int a, int b) {\n    return a + b;\n}\n\nint subtract(int a, int b) {\n    return a - b;\n}","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在上述示例中，我们定义了两个简单的函数：add和subtract。这些函数的实现位于mylib.c文件中，并在mylib.h文件中进行了声明。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"您可以将这个mylib.c文件放在与CMakeLists.txt相同的目录中，然后按照上述说明使用CMake来构建动态链接库和静态链接库。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#头文件呢？","page":"静态链接库和动态链接库","title":"头文件呢？","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"当生成动态链接库或静态链接库时，您需要一个头文件来声明库中的函数和数据结构。在上一个示例中，我忘记包含头文件mylib.h的内容，非常抱歉。以下是正确的mylib.h头文件内容：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"#ifndef MYLIB_H\n#define MYLIB_H\n\nint add(int a, int b);\nint subtract(int a, int b);\n\n#endif  // MYLIB_H","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"请将上述代码保存到名为mylib.h的文件中，并确保与CMakeLists.txt和mylib.c文件位于同一个目录中。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"这个头文件声明了两个函数：add和subtract，这些函数的实现位于mylib.c文件中。通过包含这个头文件，其他源文件就可以使用库中的函数。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"希望这次提供的信息对您有所帮助！如果您还有其他问题，请随时提问。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#如何调用","page":"静态链接库和动态链接库","title":"如何调用","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"当调用生成的动态链接库或静态链接库时，您需要创建一个主函数文件，并使用CMake来构建项目。下面是一个示例，展示如何编写主函数文件和CMakeLists.txt文件来调用生成的库。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"首先，创建一个名为myapp的文件夹，并在其中创建以下文件：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"CMakeLists.txt - 用于构建应用程序的CMake文件。\nmain.c - 主函数文件，用于调用库中的函数。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"确保将这些文件放在同一个文件夹中。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"下面是CMakeLists.txt的内容：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"cmake_minimum_required(VERSION 3.10)\nproject(myapp)\n\n# 添加库的源文件\nset(SOURCES main.c)\n\n# 生成可执行文件\nadd_executable(myapp ${SOURCES})\n\n# 链接动态链接库\ntarget_link_libraries(myapp PRIVATE mylib)\n\n# 设置库的搜索路径\nlink_directories(/path/to/mylib)\n\n# 设置库的头文件路径\ninclude_directories(/path/to/mylib)\n\n# 设置可执行文件的安装路径\ninstall(TARGETS myapp DESTINATION bin)","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在上述示例中，我们使用add_executable命令创建可执行文件，并使用target_link_libraries命令将生成的库（这里假设为mylib）链接到可执行文件中。通过link_directories和include_directories命令，我们设置库的搜索路径和头文件路径。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"要构建应用程序，可以按照以下步骤进行操作：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"创建一个名为build的文件夹，并进入该文件夹。\n打开终端，导航到build文件夹。\n运行以下命令以生成构建文件：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"cmake ..","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"运行以下命令以构建应用程序：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"cmake --build .","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"完成上述步骤后，将在build文件夹中生成可执行文件（myapp）。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"如果您希望安装应用程序到系统路径中，可以运行以下命令（需要管理员权限）：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"sudo make install","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"这将把可执行文件安装到默认的系统路径（例如，/usr/local/bin）。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"请注意，您需要根据实际情况修改link_directories和include_directories中的路径，以确保正确链接和包含库的头文件。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#使用clion来一个step-by-step生成动态链接库的例子","page":"静态链接库和动态链接库","title":"使用clion来一个step by step生成动态链接库的例子","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"使用CLion来生成动态链接库的步骤如下：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"步骤 1: 创建一个新的CMake项目","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"打开CLion并选择 \"Create New Project\"。\n在对话框中选择 \"C Executable\" 并点击 \"Next\"。\n为项目选择一个适当的名称和位置，并点击 \"Create\".","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"步骤 2: 创建源文件","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在项目中创建一个新的C源文件，例如 mylib.c。\n编写您的库的实现代码。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"以下是一个简单的示例 mylib.c：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"#include \"mylib.h\"\n\nint add(int a, int b) {\n    return a + b;\n}\n\nint subtract(int a, int b) {\n    return a - b;\n}","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"步骤 3: 创建头文件","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在项目中创建一个新的头文件，例如 mylib.h。\n在头文件中声明您的库的函数和数据结构。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"以下是 mylib.h 的内容：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"#ifndef MYLIB_H\n#define MYLIB_H\n\nint add(int a, int b);\nint subtract(int a, int b);\n\n#endif  // MYLIB_H","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"步骤 4: 编辑CMakeLists.txt","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在项目根目录下找到 CMakeLists.txt 文件，并编辑它。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"以下是一个基本的 CMakeLists.txt 示例：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"cmake_minimum_required(VERSION 3.10)\nproject(mylib)\n\n# 添加库的源文件\nset(SOURCES mylib.c)\n\n# 生成动态链接库\nadd_library(mylib SHARED ${SOURCES})\n\n# 设置库的安装路径\ninstall(TARGETS mylib LIBRARY DESTINATION lib)\ninstall(FILES mylib.h DESTINATION include)","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"步骤 5: 配置和构建项目","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"打开CLion中的项目。\n在CLion界面的底部工具栏，点击 \"Reload CMake Project\" 以加载新的CMake配置。\n在CLion界面的顶部工具栏，点击 \"Build\" 按钮构建项目。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"完成上述步骤后，CLion将使用CMake构建您的项目，并在构建过程中生成动态链接库。生成的动态链接库将位于 build/lib 目录中。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"如果您希望安装库到系统路径中，可以在 CMakeLists.txt 中添加以下安装规则：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"install(TARGETS mylib LIBRARY DESTINATION /usr/local/lib)\ninstall(FILES mylib.h DESTINATION /usr/local/include)","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"运行 Reload CMake Project 和 Build 命令后，库将安装到 /usr/local/lib 和 /usr/local/include 路径中。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"这样，您就可以在CLion中使用CMake逐步生成动态链接库了。如果您有任何进一步的问题，请随时提问。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#调用如何进行？","page":"静态链接库和动态链接库","title":"调用如何进行？","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"以下是在CLion中调用动态链接库的步骤：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"步骤 1: 创建一个新的CMake项目","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"打开CLion并选择 \"Create New Project\"。\n在对话框中选择 \"C Executable\" 并点击 \"Next\"。\n为项目选择一个适当的名称和位置，并点击 \"Create\".","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"步骤 2: 创建源文件","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在项目中创建一个新的C源文件，例如 main.c。\n编写您的主函数代码。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"以下是一个简单的示例 main.c：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"#include <stdio.h>\n#include \"mylib.h\"\n\nint main() {\n    int result = add(5, 3);\n    printf(\"Addition result: %d\\n\", result);\n\n    result = subtract(5, 3);\n    printf(\"Subtraction result: %d\\n\", result);\n\n    return 0;\n}","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"步骤 3: 添加动态链接库的引用","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"打开项目的 CMakeLists.txt 文件。\n在 add_executable 行之前，添加 add_library 行来引用动态链接库。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"以下是修改后的 CMakeLists.txt 示例：","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"cmake_minimum_required(VERSION 3.10)\nproject(myapp)\n\n# 引用动态链接库\nadd_library(mylib SHARED IMPORTED)\n\n# 设置动态链接库的路径\nset_target_properties(mylib PROPERTIES IMPORTED_LOCATION /path/to/mylib.so)\n\n# 添加可执行文件\nadd_executable(myapp main.c)\n\n# 链接动态链接库\ntarget_link_libraries(myapp PRIVATE mylib)","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在上述示例中，您需要将 /path/to/mylib.so 替换为实际的动态链接库文件路径。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"步骤 4: 配置和构建项目","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"打开CLion中的项目。\n在CLion界面的底部工具栏，点击 \"Reload CMake Project\" 以加载新的CMake配置。\n在CLion界面的顶部工具栏，点击 \"Build\" 按钮构建项目。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"完成上述步骤后，CLion将使用CMake构建您的项目，并在构建过程中将动态链接库引用到可执行文件中。然后，您可以在CLion中运行项目，查看调用动态链接库函数的结果。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"请注意，您需要将 /path/to/mylib.so 替换为实际的动态链接库文件路径，并确保动态链接库文件存在。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#能否简单补充一下CMake是什么？","page":"静态链接库和动态链接库","title":"能否简单补充一下CMake是什么？","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"当然可以！CMake是一个开源的跨平台构建系统，用于管理软件项目的构建过程。它使用名为CMakeLists.txt的文本文件来描述项目的构建配置，并根据此配置生成适合各种构建工具（如make、Ninja等）的构建文件。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"CMake的主要优势在于它提供了一种简化和抽象构建过程的方式，使得开发者可以更方便地管理复杂的项目结构和依赖关系。通过CMake，您可以编写平台无关的构建脚本，这意味着您可以在不同的操作系统和编译器上使用相同的CMake配置来构建项目。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"CMake使用类似于编程语言的语法，提供了丰富的命令和变量，用于定义项目的源文件、目标、库依赖关系、编译选项等。通过编写CMakeLists.txt文件，您可以描述项目的组织结构、源代码文件、库的构建方式等细节，从而使得构建过程更加灵活和可定制。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"在使用CMake构建项目时，通常的步骤是：创建CMakeLists.txt文件，定义源文件和目标，指定库的依赖关系和链接选项，然后运行CMake来生成构建文件，最后使用构建工具进行实际的构建操作。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"CMake已被广泛使用，并且许多开源项目和跨平台项目都使用CMake来管理其构建过程，使得项目在不同的平台和编译器上更容易构建和交付。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#作业","page":"静态链接库和动态链接库","title":"作业","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"请自己完成静态链接库及其调用。使用CLion，CMake。","category":"page"},{"location":"CSBase/6-静态链接库和动态链接库/#视频链接","page":"静态链接库和动态链接库","title":"视频链接","text":"","category":"section"},{"location":"CSBase/6-静态链接库和动态链接库/","page":"静态链接库和动态链接库","title":"静态链接库和动态链接库","text":"动态链接库和静态链接库","category":"page"},{"location":"Simulation/DE_heattran/#DE求解PDE（对比MTK）","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"tip: Tip\nContents：DE、PDE、手动空间离散Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"note: Note\nDE = DifferentialEquations.jlPDE = Partial Differential EquationDifferentialEquations.jl为处理时间微分的求解建模工具包。","category":"page"},{"location":"Simulation/DE_heattran/#DE求解PDE","page":"DE求解PDE（对比MTK）","title":"DE求解PDE","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"在MTK手动空间离散求解PDE中介绍了手动空间离散的思想。本篇中将通过手动PDE求解传热问题对DE与MTK进行一个小对比。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"DE构建的问题过程中，需要把问题推演至求解之前。求解之前的部分都需要手动完成。MTK手动空间离散求解PDE中提到，求解PDE的数值方法有这么几步：建立数学描述方程、对变量进行离散、迭代求解。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"把问题进一步细化，则变为：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"Step1:建立数学描述方程\nStep2:网格生成（变量离散）\nStep3:生成求解格式\nStep4:迭代求解","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"MTK完成了Step3、Step4的内容，而DE只能帮我们完成Step4的内容。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"tip: Tip\n如果我们仔细琢磨，会发现：如果是基于时间微分的组件化建模。使用MTK时，我们完成Step1的内容，剩下MTK全包了！所以这也是为什么说，MTK提供了基于时间的一条龙求解。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"我们来看看，DE是如何完成Step4的内容的。同时，也会让大家对数值求解过程有一个更加深刻的理解。","category":"page"},{"location":"Simulation/DE_heattran/#数值传热学实例","page":"DE求解PDE（对比MTK）","title":"数值传热学实例","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"考虑MTK手动空间离散求解PDE中正方形铸件的散热过程。节点的离散结果如下（不再推导）：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"内节点：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"fracpartial T_Ppartial t=A(T_W^n+T_E^n+ T_N^n+T_S^n - 4T_P^n)","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"边边界节点：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"fracpartial T_Ppartial t=A(T_W^n+T_N^n+T_S^n)-(B+3A)T_P^n+BT_f","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"角边界节点：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"fracpartial T_Ppartial t=A(T_E^n + T_N^n )-(2B+2A)T_P^n+2BT_f","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"这里，我们进一步对问题进行拓展。正方形铸件初始温度1000℃，环境温度为一个变化的值：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"T_f = 400 * (1 + sin(t))","category":"page"},{"location":"Simulation/DE_heattran/#求解实例","page":"DE求解PDE（对比MTK）","title":"求解实例","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"求解的全部代码如下：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"using ModelingToolkit, DifferentialEquations\nusing Dates\n\nprintln(\"=====DE TEST=====\")\nstarttime = now()\na = 1.27E-5\nn = 10\nL = 0.2\nδ = L / n\nλ = 50\nh = 1.0E9\nTf = 0.0\nA = a / δ^2\nB = a / (δ^2 / 2 + δ * λ / h)\np = [A, B, n]\nfunction to_index(i, j, n)\n    return (i - 1) * n + j\nend\nfunction heat!(dT, T, p, t)\n    A, B, n = p\n    n = Int(n)\n    Tf = 400.0 * (1 + sin(t))\n    # 内部节点\n    for i in 2:n-1\n        for j in 2:n-1\n            dT[to_index(i, j, n)] = A * (T[to_index(i + 1, j, n)] + T[to_index(i - 1, j, n)] + T[to_index(i, j + 1, n)] + T[to_index(i, j - 1, n)] - 4 * T[to_index(i, j, n)])\n        end\n    end\n    # 边边界\n    for i in 2:n-1\n        dT[to_index(i, 1, n)] = A * (T[to_index(i + 1, 1, n)] + T[to_index(i - 1, 1, n)] + T[to_index(i, 2, n)]) - (3B + A) * T[to_index(i, 1, n)] + B * Tf\n    end\n    for i in 2:n-1\n        dT[to_index(i, n, n)] = A * (T[to_index(i + 1, n, n)] + T[to_index(i - 1, n, n)] + T[to_index(i, n - 1, n)]) - (3B + A) * T[to_index(i, n, n)] + B * Tf\n    end\n    for i in 2:n-1\n        dT[to_index(1, i, n)] = A * (T[to_index(1, i + 1, n)] + T[to_index(1, i - 1, n)] + T[to_index(2, i, n)]) - (3B + A) * T[to_index(1, i, n)] + B * Tf\n    end\n    for i in 2:n-1\n        dT[to_index(n, i, n)] = A * (T[to_index(n, i + 1, n)] + T[to_index(n, i - 1, n)] + T[to_index(n - 1, i, n)]) - (3B + A) * T[to_index(1, i, n)] + B * Tf\n    end\n    # 角边界\n    dT[to_index(1, 1, n)] = A * (T[to_index(2, 1, n)] + T[to_index(1, 2, n)]) - (2B + 2A) * T[to_index(1, 1, n)] + 2B * Tf\n    dT[to_index(n, n, n)] = A * (T[to_index(n - 1, n, n)] + T[to_index(n, n - 1, n)]) - (2B + 2A) * T[to_index(n, n, n)] + 2B * Tf\n    dT[to_index(n, 1, n)] = A * (T[to_index(n, 2, n)] + T[to_index(n - 1, 1, n)]) - (2B + 2A) * T[to_index(n, 1, n)] + 2B * Tf\n    dT[to_index(1, n, n)] = A * (T[to_index(2, n, n)] + T[to_index(1, n - 1, n)]) - (2B + 2A) * T[to_index(1, n, n)] + 2B * Tf\nend\nu0 = [1000.0 for i in 1:n for j in 1:n]\nprob = ODEProblem(heat!, u0, (0, 100), p, saveat=1)\nsol = solve(prob, Tsit5())\nendtime = now()\nprintln(\"time use:\"*string(endtime - starttime))","category":"page"},{"location":"Simulation/DE_heattran/#可视化","page":"DE求解PDE（对比MTK）","title":"可视化","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"动画走你！","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"an_len = length(sol.u)\nusing Plots, GR\nres = rand(n, n, an_len)\nfor t in 1:an_len\n    for i in 1:n\n        for j in 1:n\n            res[i, j, t] = sol.u[t][to_index(i, j, n)]\n        end\n    end\nend\nxs = LinRange(0.0, L, n)\nys = LinRange(0.0, L, n)\nPlots.contourf(xs, ys, res[:, :, 1])\nanim = @animate for i ∈ 2:an_len\n    contourf!(xs, ys, res[:, :, i])\nend\ngif(anim, \"DE_trans.gif\", fps=24)","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"以上代码对比之前，有所改变的是：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"saveat","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"我们把时间拉长，同时saveat的时间步长变成了1s。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"","category":"page"},{"location":"Simulation/DE_heattran/#求解速度对比","page":"DE求解PDE（对比MTK）","title":"求解速度对比","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"跑相同的问题：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"MTK用时：2.407s\nDE用时：0.810s","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"可见，Step3的符号化简与DE问题生成的确需要消耗不少的资源。","category":"page"},{"location":"Simulation/DE_heattran/#关于内涵的理解","page":"DE求解PDE（对比MTK）","title":"关于内涵的理解","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"MTK与DE两种方法都能够求解PDE问题。为什么这样做能行呢？下面分享一些关于问题内涵的思考。","category":"page"},{"location":"Simulation/DE_heattran/#空间离散的物理内涵","page":"DE求解PDE（对比MTK）","title":"空间离散的物理内涵","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"动画中可以清晰感受到外围颜色的震动，这是我们设定环境温度波动的结果。若要把环境温度变化以微分方程的形式定义，同样可行。只需要再添加一个变量关于时间相关的变量即可。而这个随时间的变化的环境温度，是真正驱动系统变化的变量，它的变化是由时间决定，而不受其它网格影响。相反，其它网格受到环境温度变量的影响。可以说，环境温度变量是独立于网格离散而存在的。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"由此，我们可以聊一聊关于空间离散的内涵。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"在以上的传热实例中，系统的根本“驱动力”在于温差。也就是说，因为温差的存在，才会让系统产生变化。而我们在空间离散时，其实并没有对这种变化进行处理。我们手动空间离散的内涵是：在不同网格间，架起了让网格相互联系的桥梁。其本质描述了网格和网格之间的联系。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"从高数中微元的角度思考，只要网格足够小，那么我们就可以得到非常精确的模拟结果；从物理内涵的角度思考，不管网格如何小，任何一个网格都可以视为一个小组件，这个小组件的特性有：温度、边长、导热系数等等，并且在小组件内部，这些属性的数值视为不变。而空间离散，就是建立了这些小组件之间的关联。这种思想在数值计算领域是一种专业的离散方式——有限容积法。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"所以，以上空间离散的思想内涵就和之间组件化建模的思想内涵统一起来了。区别在于，空间离散出来的结果是微元，组件化建模的模型结果是宏观组件。 但是，不同组件（微元）之间需要建立相互联系的桥梁这一点是不变的。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"如果深入思考传热的内涵——由温差引起的热量传递。我们也能发现，以小组件的形式看待微元网格，其物理逻辑也是非常自洽的。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"把空间离散赋予物理内涵（微元组件化）后，剩下的问题也很清晰了——组件在时间域上的变化。组件之间的连接建立好之后，当外界环境（温度）随时间动态变化，组件的属性（温度）也会发生相应的变化。这不就是时间域上动态系统的求解内涵吗？只是我们不会把描述时间微分的方程离散，而是把它丢给求解器去解。","category":"page"},{"location":"Simulation/DE_heattran/#迭代格式的数学内涵","page":"DE求解PDE（对比MTK）","title":"迭代格式的数学内涵","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"迭代格式数学内涵中最关键的一环是函数to_index()","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"function to_index(i, j, n)\n    return (i - 1) * n + j\nend","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"MTK中采用T[i, j]的网格描述方式，这是从物理位置中对网格进行了一种描述。这种描述中是附加由物理含义的——空间位置。而这种附加了物理含义的变量描述，底层求解器是无法求解的。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"DE能求解的方程是什么样的呢？如下所示：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"leftbeginarrayc\ny_1^prime(x)=fleft(x y_1(x) y_2(x) ldots y_n(x) right) y_2^prime(x)=fleft(x y_1(x) y_2(x) ldots y_n(x) right)  ldots y_n^prime(x)=fleft(x y_1(x) y_2(x) ldots y_n(x) right)  y_1left(x_0right)=y_10 y_2left(x_0right)=y_20 ldots y_nleft(x_0right)=y_n 0endarrayright","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"写成统一的格式即：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"mathbfyprime=mathbff(mathbfxmathbfy)","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"note: Note\n求解微分方程的数值解法主要有：欧拉法yleft(x_i+1right)=yleft(x_iright)+hfleft(x_iy(x_i)right)+Oleft(h^2right)后退欧拉法yleft(x_i+1right)=yleft(x_iright)+hfleft(x_i+1y(x_i+1)right)+Oleft(h^2right)梯形法yleft(x_i+1right)=yleft(x_iright)+frach2leftfleft(x_iy_i right)+fleft(x_i+1y_i+1right)right+Oleft(h^3right)辛普森方法yleft(x_i+1right)=yleft(x_i-1right)+ frach3leftfleft(x_i-1y_i-1right)+4fleft(x_iy_iright)+fleft(x_i+1y_i+1right)right+Oleft(h^5right)标准龙格库塔法leftbeginarrayc\ny_i+1=y_i+frac16left(K_1+2 K_2+2 K_3+K_4right) \nK_1=h fleft(x_i y_iright) \nK_2=h fleft(x_i+frac12 h y_i+frac12 K_1right) \nK_3=h fleft(x_i+frac12 h y_i+frac12 K_2right) \nK_4=h fleft(x_i+h y_i+K_3right)\nendarrayright其中，h为求解的步长。各方法阶数为（阶数越高精度越高）：方法 阶数\n欧拉法 1阶\n后退欧拉法 1阶\n梯形法 2阶\n辛普森方法 4阶\n标准龙格库塔法 4阶","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"对于这样的数学描述方式，y可以视为微分变量的数组，f(xy)视为变量之间的联系。那么y=f(xy)的含义是：微分与其它变量之间的关联。这种关联是不包含物理内涵的。而二维数组T[i, j]包含了位置关系。所以要去位置化，就需要把二维映射到一维上。所以我们采用(i - 1) * n + j将二维索引展平为一维。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"本质是通过to_index()消除了物理位置含义。生成了DE可计算的描述方式——最原始最根本的微分方程组数学描述方式。这一步就是前面所说的Step3。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"总的来看，DE求解我们手动完成了Step2、Step3、Step4。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"tip: Tip\nMTK求解时。Step3、Step4由程序完成。","category":"page"},{"location":"Optimization/1-优化的概念/#优化的概念","page":"优化的概念","title":"优化的概念","text":"","category":"section"},{"location":"Optimization/1-优化的概念/#优化简介","page":"优化的概念","title":"优化简介","text":"","category":"section"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"优化，也称为数学规划，是数学中的一个分支领域，旨在找到最佳解决方案或最优化的决策。它涉及到在给定的约束条件下，通过最小化或最大化一个或多个目标函数来寻找最优解。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"优化问题可以在各种领域中应用，包括工程、经济学、物理学、计算机科学等。在实际应用中，我们常常面临资源有限的情况下，需要找到一种最佳分配方式。优化问题的目标是通过利用现有资源最大限度地满足需求或实现特定目标。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"数学规划可以分为线性规划、非线性规划、整数规划、动态规划等不同类型。线性规划是优化问题中最常见的类型，其中目标函数和约束条件都是线性的。非线性规划则涉及到目标函数或约束条件中包含非线性项。整数规划要求决策变量取整数值。动态规划则涉及到一系列决策问题，其中每个决策都会影响到后续决策的结果。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"为了解决优化问题，需要使用数学工具和算法来分析和计算最佳解。这些工具和算法可以根据具体问题的特征选择，例如简单的问题可以使用暴力搜索方法，复杂的问题可能需要使用高级的数值优化算法，如线性规划算法、梯度下降算法、遗传算法等。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"总之，优化是数学中研究如何在给定约束条件下找到最佳解决方案或最优化决策的领域。它在实际应用中具有广泛的应用价值，并且需要使用数学方法和算法来解决。","category":"page"},{"location":"Optimization/1-优化的概念/#一个Julia例子","page":"优化的概念","title":"一个Julia例子","text":"","category":"section"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"下面是一个使用Julia语言解决线性规划问题的简单例子：","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"using JuMP\nusing GLPK\n\n# 创建一个线性规划模型\nmodel = Model(with_optimizer(GLPK.Optimizer))\n\n# 定义决策变量\n@variable(model, x >= 0)  # 非负变量 x\n\n# 定义目标函数\n@objective(model, Max, 2x + 3)\n\n# 添加约束条件\n@constraint(model, 1x <= 4)\n@constraint(model, 2x >= 1)\n\n# 求解优化问题\noptimize!(model)\n\n# 输出结果\nprintln(\"最优解: x = \", value(x))\nprintln(\"最优目标值: \", objective_value(model))","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"在这个例子中，我们使用了JuMP包来建立优化模型，并使用GLPK包作为优化器。我们定义了一个决策变量x，它必须是非负的。然后，我们定义了目标函数2x + 3，希望最大化这个目标函数。最后，我们添加了两个约束条件：x小于等于4，2x大于等于1。通过调用optimize!函数，我们可以求解出最优解，并使用value函数获取变量的取值，objective_value函数获取最优目标值。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"这只是一个简单的例子，实际的优化问题可能会涉及更多的变量和约束条件，以及复杂的目标函数。Julia语言提供了丰富的优化工具和包，可以灵活地处理各种类型的优化问题。","category":"page"},{"location":"Optimization/1-优化的概念/#一个GAMS的例子","page":"优化的概念","title":"一个GAMS的例子","text":"","category":"section"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"下面是一个使用GAMS（General Algebraic Modeling System）解决线性规划问题的示例：","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"SET i /1*3/;\nPARAMETER c(i) '系数';\nc(i) = 2, 3, 4;\n\nVARIABLES x(i) '决策变量';\n\nEQUATIONS obj '目标函数' \n          constraint1 '约束条件1' \n          constraint2 '约束条件2';\n\nobj.. sum(i, c(i)*x(i)) =E= 0;  // 目标函数\n\nconstraint1.. sum(i, x(i)) =L= 10;  // 约束条件1\n\nconstraint2.. x('2') + x('3') =G= 5;  // 约束条件2\n\nMODEL LinearProgrammingModel /all/;\n\nSOLVE LinearProgrammingModel USING LP MAXIMIZING x;\n\nDISPLAY x.l, obj.l;","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"在这个例子中，我们使用GAMS建立了一个线性规划模型。首先，我们定义了一个集合i，其中包含了三个元素。然后，我们定义了一个参数c(i)，它包含了系数值。接下来，我们声明了一个变量x(i)，它是我们的决策变量。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"然后，我们定义了三个方程：obj（目标函数）、constraint1（约束条件1）和constraint2（约束条件2）。目标函数是求解的目标，约束条件限制了变量的取值范围。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"在GAMS中，我们使用\"E=\"表示等式约束，\"L=\"表示小于等于约束，\"G=\"表示大于等于约束。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"接下来，我们定义了一个名为LinearProgrammingModel的模型，并使用LP（线性规划）求解器进行求解。通过使用MAXIMIZING关键字，我们指定了求解最大化目标函数。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"最后，我们使用DISPLAY命令来显示变量x和目标函数的取值（x.l和obj.l）。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"这只是一个简单的示例，GAMS提供了更多高级功能和约束类型来处理各种优化问题。通过使用GAMS语言和相应的求解器，您可以更灵活地定义和求解复杂的优化模型。","category":"page"},{"location":"Optimization/1-优化的概念/#一个Pyomo的例子","page":"优化的概念","title":"一个Pyomo的例子","text":"","category":"section"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"下面是一个使用Pyomo库解决线性规划问题的示例：","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"from pyomo.environ import *\n\n# 创建一个具体模型\nmodel = ConcreteModel()\n\n# 定义决策变量\nmodel.x = Var([1, 2, 3], domain=NonNegativeReals)\n\n# 定义目标函数\nmodel.obj = Objective(expr=2 * model.x[1] + 3 * model.x[2], sense=maximize)\n\n# 添加约束条件\nmodel.constraint1 = Constraint(expr=sum(model.x[i] for i in [1, 2, 3]) <= 10)\nmodel.constraint2 = Constraint(expr=model.x[2] + model.x[3] >= 5)\n\n# 求解优化问题\nsolver = SolverFactory('glpk')\nresult = solver.solve(model)\n\n# 输出结果\nprint(\"最优解：\")\nfor i in [1, 2, 3]:\n    print(f\"x[{i}] = {model.x[i].value}\")\n\nprint(\"最优目标值：\", model.obj())","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"在这个例子中，我们使用Pyomo库创建了一个具体模型。我们定义了决策变量model.x，它是一个字典变量，包含了三个非负实数变量。然后，我们定义了目标函数model.obj，使用maximize指定了最大化的目标。接下来，我们添加了两个约束条件model.constraint1和model.constraint2。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"然后，我们选择了一个求解器（在这个例子中是GLPK）来求解优化问题。通过调用solver.solve(model)，我们可以求解出最优解。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"最后，我们使用model.x[i].value获取变量x的取值，并使用model.obj()获取最优目标值。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"Pyomo提供了丰富的建模语言和优化求解功能，可以用于解决各种优化问题。通过定义变量、目标函数和约束条件，并选择适当的求解器，您可以使用Pyomo库解决复杂的优化问题。","category":"page"},{"location":"Optimization/1-优化的概念/#决策变量、约束与目标函数","page":"优化的概念","title":"决策变量、约束与目标函数","text":"","category":"section"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"在优化问题中，决策变量、约束和目标函数是三个核心概念。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"决策变量（Decision Variables）： 决策变量是在优化问题中我们希望确定的未知量或可调节量。它们表示问题的决策或选择，我们希望找到一组合适的取值来达到优化的目标。决策变量可以是实数、整数或离散值，具体取决于问题的特性和要求。\n在优化模型中，我们通常会明确定义决策变量的名称、类型（如连续型变量、整数变量等）以及可能的取值范围。\n约束（Constraints）： 约束是对决策变量的限制条件，它们反映了问题的约束性质和限制条件。约束条件用于限制决策变量的取值范围，确保最优解满足问题的要求。\n约束可以包括等式约束（如等于某个常数）、不等式约束（如大于等于某个常数或小于等于某个常数）、范围约束（如取值在某个范围内）等。这些约束条件反映了问题的实际限制和约束条件。\n目标函数（Objective Function）： 目标函数是在优化问题中需要最小化或最大化的函数。它表示我们所追求的目标或效用，是问题的评价标准。目标函数的设计取决于具体的问题和我们希望达到的优化目标。\n在优化模型中，我们通常需要明确定义目标函数的表达式和优化方向（最小化或最大化）。目标函数可以是线性函数、非线性函数或其他复杂的函数形式。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"优化问题的目标是找到一组决策变量的取值，使得目标函数最优，并且满足所有的约束条件。优化算法通过在决策变量的可行区域内搜索，调整决策变量的取值，以逐步接近或达到最优解。决策变量的取值必须同时满足所有的约束条件，并使得目标函数达到最优值。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"因此，决策变量、约束和目标函数是构建和描述优化问题的重要组成部分，通过合理定义和约束它们，我们可以建立数学模型，并通过求解算法找到最佳解决方案。","category":"page"},{"location":"Optimization/1-优化的概念/#单目标优化与多目标优化","page":"优化的概念","title":"单目标优化与多目标优化","text":"","category":"section"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"单目标优化（Single-Objective Optimization）和多目标优化（Multi-Objective Optimization）是两种不同的优化问题类型，它们在目标函数的数量和优化目标的角度上存在差异。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"单目标优化： 单目标优化是指在优化问题中只有一个目标函数需要最小化或最大化。在单目标优化中，我们试图找到一个解决方案，使得目标函数达到最优值，同时满足约束条件。单目标优化可以用来解决各种问题，例如线性规划、非线性规划和整数规划等。\n在单目标优化中，问题的关注点集中在一个单一的目标上。优化算法通过在决策变量空间中搜索，找到使得目标函数最优的解决方案。常见的单目标优化算法包括梯度下降、遗传算法、粒子群优化等。\n多目标优化： 多目标优化是指在优化问题中存在多个冲突的目标函数需要最小化或最大化。在多目标优化中，我们试图找到一组解决方案，这些解决方案形成了一个“帕累托前沿”（Pareto Front），其中没有一个解决方案可以在所有目标上优于其他解决方案。\n多目标优化的目标是寻找一组解决方案，这些解决方案代表了不同的权衡和取舍。这些解决方案通常称为非支配解（Non-Dominated Solutions），它们在不同的目标之间形成了一种平衡。多目标优化的关键是通过搜索和评估决策变量空间中的多个解来构建帕累托前沿。\n多目标优化算法包括多目标遗传算法、多目标粒子群优化、多目标模拟退火等。这些算法旨在寻找一组尽可能好的非支配解，并提供一系列可行的解决方案供决策者选择。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"在实际问题中，我们需要根据具体情况来确定是使用单目标优化还是多目标优化。如果问题只涉及一个主要目标，那么单目标优化可能更适合。而如果问题涉及到多个相互关联的目标，并且需要权衡不同的目标之间的取舍，那么多目标优化更适合。","category":"page"},{"location":"Optimization/1-优化的概念/#一个现实的问题","page":"优化的概念","title":"一个现实的问题","text":"","category":"section"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"问题描述： 我们要制造一个圆柱形的水罐，要求它的体积固定为V（已知值），而制造成本最低。制造成本与所需钢材的面积成正比。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"解决方案： 为了解决这个问题，我们可以使用优化方法来确定水罐的尺寸，使得制造成本最低。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"决策变量：","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"R：水罐底部的半径（决策变量）\nH：水罐的高度（决策变量）","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"目标函数： 制造成本（目标函数）：由于制造成本与所需钢材的面积成正比，我们可以将制造成本定义为钢材的面积，即成本 = π * R^2 + 2 * π * R * H。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"约束条件：","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"水罐的体积（约束条件）：V = π * R^2 * H，这个约束条件确保水罐的体积固定为V。\n尺寸的非负性（约束条件）：R >= 0，H >= 0，这些约束条件确保水罐的尺寸非负。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"通过求解这个优化问题，我们可以找到最佳的水罐尺寸，使得制造成本最低。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"请注意，这个例子只是简化的示例，实际的问题可能还涉及其他约束条件和考虑更多的实际因素。例如，我们可能还需要考虑材料的可获得性、制造工艺的限制等等。","category":"page"},{"location":"Optimization/1-优化的概念/#再来一个例子","page":"优化的概念","title":"再来一个例子","text":"","category":"section"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"问题描述： 某商店有一个仓库，店主有一定的本钱，他可以购买棉花和钢材以售出以获得收益。希望通过合理购买和销售来最大化收益。然而，仓库有一定的容量限制，而棉花和钢材的购买受到店主本钱和仓库容量的限制。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"解决方案： 为了解决这个问题，我们可以使用优化方法来确定棉花和钢材的购买量，使得收益最大化。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"决策变量：","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"x1：购买的棉花质量（决策变量）\nx2：购买的钢材质量（决策变量）","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"目标函数： 收益（目标函数）：收益由售出的棉花和钢材所得，即收益 = p1o * x1 + p2o * x2，其中p1o和p2o分别为棉花和钢材的售价。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"约束条件：","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"仓库容量约束（约束条件）：v1 * x1 + v2 * x2 <= C，这个约束条件确保购买的棉花和钢材的总体积不超过仓库的容量C。其中v1和v2分别为单位质量棉花和钢材的体积。\n本钱约束（约束条件）：p1 * x1 + p2 * x2 <= B，这个约束条件确保购买棉花和钢材的成本不超过店主的本钱B。其中p1和p2分别为单位质量棉花和钢材的进价。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"通过求解这个优化问题，我们可以找到最佳的购买方案，使得收益最大化。","category":"page"},{"location":"Optimization/1-优化的概念/","page":"优化的概念","title":"优化的概念","text":"请注意，这个例子只是简化的示例，实际的问题可能还涉及其他约束条件、售价变动、销售量的考虑等等。此外，还需要考虑市场需求、供应量等因素来更全面地建模和求解这个优化问题。","category":"page"},{"location":"Optimization/1-优化的概念/#优化问题的建模平台","page":"优化的概念","title":"优化问题的建模平台","text":"","category":"section"},{"location":"Optimization/1-优化的概念/#传统决定性算法","page":"优化的概念","title":"传统决定性算法","text":"","category":"section"},{"location":"Optimization/1-优化的概念/#启发式算法","page":"优化的概念","title":"启发式算法","text":"","category":"section"},{"location":"Optimization/1-优化的概念/#黑箱优化问题","page":"优化的概念","title":"黑箱优化问题","text":"","category":"section"},{"location":"Optimization/1-优化的概念/#可用的工具","page":"优化的概念","title":"可用的工具","text":"","category":"section"},{"location":"Optimization/1-优化的概念/#参数估计及软测量","page":"优化的概念","title":"参数估计及软测量","text":"","category":"section"},{"location":"Optimization/1-优化的概念/#代理模型","page":"优化的概念","title":"代理模型","text":"","category":"section"},{"location":"Optimization/1-优化的概念/#模型辨识","page":"优化的概念","title":"模型辨识","text":"","category":"section"},{"location":"Optimization/1-优化的概念/#递归与plasmo.jl的思想","page":"优化的概念","title":"递归与plasmo.jl的思想","text":"","category":"section"},{"location":"Optimization/1-优化的概念/#modelingtoolkit与递归","page":"优化的概念","title":"modelingtoolkit与递归","text":"","category":"section"},{"location":"CSAdv/9-OpenFoam解构/#OpenFoam解构","page":"OpenFoam解构","title":"OpenFoam解构","text":"","category":"section"},{"location":"CSAdv/9-OpenFoam解构/","page":"OpenFoam解构","title":"OpenFoam解构","text":"专门来说说对OpenFoam的理解。","category":"page"},{"location":"JuliaIntro/1-julia的安装/#julia的安装","page":"julia的安装","title":"julia的安装","text":"","category":"section"},{"location":"JuliaIntro/1-julia的安装/#julia简介","page":"julia的安装","title":"julia简介","text":"","category":"section"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"Julia是一种高性能、动态的编程语言，旨在提供与传统科学计算语言（如Matlab）和通用编程语言（如Python）相媲美的性能。它是为解决科学计算和数据分析中的复杂问题而设计的。Julia的特点包括易于使用、动态类型、即时编译和可扩展性。","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"Julia的语法类似于其他科学计算语言，如Matlab和Python，但它引入了一些独特的特性。它支持向量化操作和广播，使得处理数组和矩阵等数据结构变得更加高效和简洁。Julia还具有强大的类型推导功能，可以根据代码上下文自动推断变量类型，从而提高执行速度。","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"Julia拥有丰富的科学计算和数据分析库，包括线性代数、统计学、优化、图形化等方面的工具。这些库使得使用Julia进行科学研究和数据分析变得非常方便。","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"要开始学习Julia，你可以安装Julia的最新版本并打开交互式终端。在Julia的REPL（Read-Eval-Print Loop）中，你可以直接输入和执行Julia代码。Julia的官方网站提供了大量的学习资源，包括官方文档、教程和示例代码，这些资源可以帮助你快速入门并掌握Julia的基础知识。","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"总之，Julia是一个强大而灵活的科学计算语言，它通过提供高性能和易用性的组合，为科学家、工程师和数据分析师提供了一种有效的工具来解决复杂的计算问题。","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"希望这段介绍能帮助到你！如有任何进一步的问题，我会尽力回答。","category":"page"},{"location":"JuliaIntro/1-julia的安装/#安装Julia","page":"julia的安装","title":"安装Julia","text":"","category":"section"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"Julia官方提供了免安装的绿色版本，也被称为Julia的二进制预编译版本。以下是安装Julia的步骤：","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"访问Julia官方网站：https://julialang.org/downloads/，在\"Current release\"下找到适合您操作系统的版本。点击下载按钮。\n在下载页面中，您可以选择不同的操作系统和体系结构，选择与您的系统匹配的版本。\n一旦下载完成，您将得到一个压缩文件（.tar.gz或.zip）。将其解压缩到您喜欢的位置，比如您的桌面或特定的文件夹。\n解压缩后，您将看到一个名为\"julia-x.y.z\"（x.y.z代表版本号）的文件夹。进入该文件夹，然后进入\"bin\"子目录。\n在\"bin\"目录中，您可以找到可执行文件\"julia\"（Windows上可能是\"julia.exe\"）。您可以直接运行该文件，它将启动Julia的REPL（交互式终端）。","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"现在您已经成功地安装了免安装的绿色版本的Julia，并可以开始在REPL中编写和执行Julia代码了。","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"请注意，虽然免安装的绿色版本不需要进行传统的安装过程，但它并没有集成到您的系统路径中。这意味着您需要手动指定Julia的路径，或者将其添加到系统路径中，以便在任何位置都能够访问Julia。","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"当使用免安装的绿色版本的Julia时，您可能需要手动将Julia的路径添加到系统的环境变量中，这样您就可以在任何位置使用\"julia\"命令来启动Julia。以下是添加环境变量的操作：","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"打开系统的环境变量设置。具体操作方式可能因不同的操作系统而异：\n在Windows上，右键点击\"计算机\"（或\"此电脑\"），选择\"属性\"，然后点击\"高级系统设置\"。在弹出窗口中，点击\"环境变量\"按钮。\n在Mac上，打开\"终端\"应用程序，然后输入命令\"nano ~/.bash_profile\"来编辑bash配置文件。\n在Linux上，打开终端，并编辑~/.bashrc或~/.bash_profile文件，具体命令取决于您使用的Linux发行版。\n在环境变量设置中，找到\"PATH\"变量，并进行编辑。\n在\"PATH\"变量的值中，添加Julia的路径。路径应指向Julia的\"bin\"目录，该目录中包含可执行文件\"julia\"（在Windows上可能是\"julia.exe\"）。\n例如，在Windows上，您可以将路径添加为：C:\\path\\to\\julia\\bin 在Mac和Linux上，您可以将路径添加为：/path/to/julia/bin\n请确保将上述路径替换为实际的Julia安装路径。\n保存更改并关闭编辑器或终端窗口。\n重新启动终端或命令提示符，以使环境变量的更改生效。","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"现在，您应该能够在任何位置使用\"julia\"命令来启动Julia了。","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"请注意，以上步骤可能因操作系统和个人设置而有所不同。如果您遇到任何问题，请参考您所使用的操作系统的文档或进行相关的在线搜索。","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"希望这可以帮助您成功地添加Julia到系统的环境变量中！如果您有任何其他问题，请随时向我提问。","category":"page"},{"location":"JuliaIntro/1-julia的安装/#安装vscode以及julia插件","page":"julia的安装","title":"安装vscode以及julia插件","text":"","category":"section"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"当然！以下是安装Visual Studio Code（简称VS Code）以及Julia插件的步骤：","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"访问VS Code官方网站：https://code.visualstudio.com/。\n点击网页上的\"Download\"按钮，选择适用于您的操作系统的版本，并下载安装程序。\n执行安装程序，并按照提示进行安装。在安装过程中，您可以选择是否将VS Code添加到系统的环境变量中，以便您可以从任何位置使用\"code\"命令来启动VS Code。\n安装完成后，打开VS Code。您将看到一个简洁的编辑器界面。\n在VS Code的扩展市场中，搜索并安装Julia插件。您可以通过按下Ctrl+Shift+X（Windows和Linux）或Command+Shift+X（Mac）来打开扩展视图，然后在搜索框中输入\"Julia\"进行搜索。选择\"Julia\"插件，并点击\"Install\"按钮进行安装。\n安装完成后，您将可以在VS Code中使用Julia插件。插件提供了语法高亮、代码补全、调试支持等功能，使您更方便地编写和调试Julia代码。\n要开始使用Julia插件，请打开一个Julia源代码文件（后缀为\".jl\"），然后使用VS Code的编辑器功能来编写代码。Julia插件将会根据Julia语法和上下文提供相应的功能和建议。","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"请注意，安装Julia插件之前，确保您已经成功安装了Julia，并将其路径添加到系统的环境变量中（之前提到的步骤）。这样Julia插件才能正常与Julia进行交互。","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"希望这可以帮助您安装VS Code以及Julia插件！如果您有任何进一步的问题，请随时向我提问。","category":"page"},{"location":"JuliaIntro/1-julia的安装/#vscode中Julia插件的使用","page":"julia的安装","title":"vscode中Julia插件的使用","text":"","category":"section"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"当您在Visual Studio Code（VS Code）中安装并启用了Julia插件后，以下是一些常用的操作和功能：","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"打开Julia文件：使用VS Code的文件菜单或快捷键（Ctrl+O）打开一个Julia源代码文件（后缀为\".jl\"）。\n代码编辑功能：在Julia文件中，您可以使用VS Code的丰富编辑功能，如语法高亮、自动缩进、括号匹配等。\n代码补全：在您键入代码时，Julia插件会根据上下文和库函数提供代码补全建议。您可以使用Tab键或Enter键来接受建议。\n函数签名和参数提示：当您输入函数名称时，Julia插件会显示函数的签名和参数信息。您可以按下Tab键或Enter键来接受函数的参数提示。\n文档查看：通过将光标停留在Julia函数或变量上，按下Ctrl键并单击鼠标，或使用快捷键（Ctrl+K Ctrl+I），可以查看函数或变量的文档字符串。\n调试支持：Julia插件提供了调试功能，使您能够在VS Code中调试Julia代码。您可以设置断点、逐行执行代码，并查看变量的值和堆栈信息。\nJulia REPL：Julia插件内置了一个交互式的Julia REPL终端。您可以使用快捷键（Ctrl+Shift+P）打开命令面板，然后输入\"Julia: Start REPL\"来启动Julia REPL。在REPL中，您可以输入和执行Julia代码，并查看输出结果。\n任务和构建：您可以使用VS Code的任务功能来执行Julia脚本或运行Julia项目。通过创建一个\"tasks.json\"文件并定义相应的任务，您可以方便地执行Julia代码。","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"这些是Julia插件中的一些常见操作和功能。请注意，插件的功能和操作方式可能会有所变化，因此建议查阅Julia插件的文档以获取更详细的信息。","category":"page"},{"location":"JuliaIntro/1-julia的安装/","page":"julia的安装","title":"julia的安装","text":"希望这些介绍有助于您在VS Code中使用Julia插件！如有任何进一步的问题，请随时向我提问。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/#以SAM为例实操","page":"以SAM为例实操","title":"以SAM为例实操","text":"","category":"section"},{"location":"CSBase/7-以SAM为例整体实操一下/#SAM是什么","page":"以SAM为例实操","title":"SAM是什么","text":"","category":"section"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"NREL (National Renewable Energy Laboratory) 的 SAM (System Advisor Model) 是一个广泛应用于可再生能源系统分析和评估的计算工具。SAM 可以帮助研究人员、工程师和政策制定者评估各种可再生能源项目的技术和经济可行性。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM 提供了一系列模块，涵盖了太阳能、风能、生物质能、地热能等多个可再生能源技术。使用 SAM，用户可以建立虚拟的可再生能源项目，并对其进行系统级的模拟和分析。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM 的主要功能包括：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"建模工具：SAM 提供了丰富的建模工具，可以创建和配置各种可再生能源系统。用户可以定义系统的组件、能源资源、电网连接等。\n技术性能模型：SAM 包含了各种可再生能源技术的技术性能模型，例如太阳能光伏电池板的发电模型、风力涡轮机的功率曲线等。这些模型基于广泛的实验数据和经验，并提供了高精度的技术性能预测。\n资金成本模型：SAM 还提供了成本模型，可以帮助用户估算可再生能源项目的资金成本。这些成本模型包括设备成本、建设成本、运营维护成本等。\n经济性分析：SAM 可以对可再生能源项目进行经济性分析，包括计算项目的净现值、内部收益率、年均收益等经济指标。这有助于评估项目的可行性和经济效益。\n市场分析：SAM 还提供了市场分析模块，可以评估可再生能源项目在不同市场条件下的竞争力和盈利潜力。用户可以模拟不同的电力市场、能源政策和投资条件，以了解项目在不同情景下的表现。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM的GitHub地址是：https://github.com/nrel/SAM","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"关于NREL和SAM的官方网站，您可以访问以下链接获取更多信息：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"NREL官方网站：https://www.nrel.gov/","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM官方网站：https://sam.nrel.gov/","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"总而言之，NREL 的 SAM 是一个功能强大的可再生能源系统分析工具，可以帮助用户评估和优化可再生能源项目的技术性能、经济可行性和市场前景。它在可再生能源领域的研究、工程设计和政策制定中发挥了重要作用。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/#SAM的组件构成","page":"以SAM为例实操","title":"SAM的组件构成","text":"","category":"section"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM的组件构成主要包括以下几个部分：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SSC（SAM Simulation Core）：SSC是SAM的内核，是一个用C++编写的计算引擎。它提供了可再生能源系统模拟和分析的核心功能，包括模型计算、数据处理和结果生成等。SSC负责处理技术性能模型、成本模型、经济模型等方面的计算。\nGUI（Graphical User Interface）：SAM的GUI是一个可视化界面，提供了图形化的用户界面，使用户可以通过交互方式创建、配置和分析可再生能源项目。GUI简化了输入参数的设置和结果的可视化，使用户更方便地使用SAM进行建模和分析。\nSDK（Software Development Kit）：SDK是一个开发工具包，用于扩展SAM的功能和自定义模块。SDK提供了一组API和文档，使开发人员可以根据自己的需求开发新的模型、算法或工具，并与SAM进行集成。\nDatasets：SAM还包括一系列数据集，用于提供输入参数和参考数据。这些数据集包括天气数据、设备性能数据、成本数据等，可以帮助用户进行准确的模拟和分析。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"综上所述，SAM的核心是SSC，它提供了计算引擎和模型库，支持可再生能源系统的建模和分析。GUI提供了图形化界面，使用户可以通过可视化方式操作SAM。SDK则允许开发人员进行功能扩展和定制化开发。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/#SAM的windows下的编译过程","page":"以SAM为例实操","title":"SAM的windows下的编译过程","text":"","category":"section"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"当使用SAM进行编译时，以下是SAM的编译过程的基本步骤和解释：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"源代码收集：首先，需要获取SAM的源代码。您可以从SAM的GitHub存储库中获取源代码，并将其下载到本地计算机中。\n依赖项安装：在编译之前，需要安装SAM所需的依赖项和开发工具。这些依赖项可能包括编译器、构建工具、库文件等。您可以查阅SAM的文档或README文件，了解所需的依赖项和安装说明，并确保在编译之前正确安装它们。\n配置编译环境：为了成功编译SAM，您需要配置适当的编译环境。这可能包括设置编译器选项、环境变量、路径设置等。根据您的操作系统和编译工具，您可能需要执行一些特定的设置步骤。确保按照指南进行正确的环境配置。\n构建项目：一旦环境配置完成，您可以开始构建SAM项目。这通常涉及使用构建工具（如Makefile或CMake）执行构建命令。构建过程会编译源代码文件，并将它们转换为可执行文件或库文件。构建过程可能需要一些时间，具体取决于项目的规模和计算机的性能。\n编译错误解决：在编译过程中，可能会出现错误或警告。这些错误可能是由于缺少依赖项、语法错误、库文件问题等引起的。如果出现编译错误，您需要仔细阅读错误消息，并在代码中找到并修复问题。通常，错误消息会提供有关问题所在的线索，例如错误的行号或函数名称。\n构建成功：一旦编译过程成功完成，您将获得SAM的可执行文件或库文件。这些文件可以用于在您的计算机上运行SAM，并开始使用它的功能。确保验证编译的结果，并根据需要进行必要的配置和安装。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"通过以上步骤，您可以通过SAM的编译过程理解程序编译的 step by step 流程。请注意，编译过程可能因操作系统、编译工具和项目的特定要求而有所差异。因此，建议您参考SAM的文档和指南，以获取针对SAM的具体编译说明和最佳实践。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"这里是Windows下如何编译SAM的官方说明。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"以下是其中文翻译： Windows构建说明","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"这些说明适用于在您的计算机上设置构建SAM Windows版本所需的几个开源C++代码库。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"更新于2022年7月","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"概述 构建工具 要构建SAM，您需要构建CMake、wxWidgets和Google Test：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"CMake是一套用于构建软件的工具集：https://cmake.org/。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"wxWidgets是一个用于开发用户界面的平台：https://www.wxwidgets.org。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"Google Test是一个C++测试框架：https://github.com/google/googletest。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"版本控制和协作 SAM的代码存储库存储在GitHub.com上，因此您需要使用Git进行工作的工具。这些说明假设您已经安装了Git并熟悉它。（如果您需要使用Git进行SAM的帮助，请参阅此基本教程。）","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"Git是版本控制和协作软件：https://git-scm.com/ 源代码 构建SAM所需的C++和其他代码存储在GitHub.com上的LK、WEX、SSC和SAM存储库中：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"LK是SAM的内置LK脚本语言：https://github.com/nrel/lk。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"WEX包含了对wxWidgets的自定义用户界面增强功能：https://github.com/nrel/wex。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SSC是用于SAM性能和财务模型的代码：https://github.com/nrel/ssc。（SSC API和PySAM Python软件包提供了对SSC的访问权限，供其他软件应用程序使用。）","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM是用于SAM用户界面的代码：https://github.com/nrel/SAM。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM-private存储库包含了SAM官方NREL版本的代码。只有在与NREL的SAM软件开发团队合作构建官方NREL版本的SAM时，才需要这些代码。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM-private是用于用户注册、欢迎页面、Web API密钥和其他SAM官方NREL版本的功能的代码：https://github.com/nrel/SAM-private。 开发和修补分支 每个存储库的Develop分支包含最新的代码。如果您要贡献代码，应从该分支开始工作。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"每个存储库的Patch分支在发布新版本的SAM后的几个月内处于活动状态。在此期间，如果您要贡献代码以更新当前版本，应从Patch分支开始工作。（完成和批准工作后，应将Patch分支合并到Develop分支。）","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"GitHub.com上的默认分支为Develop，除了在更新期间，此时默认分支设置为Patch。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM版本的标签 要构建特定版本的SAM，可以检出该版本的标签。请参阅此标签列表，了解SAM、SSC、WEX和LK的不同版本。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"总体构建步骤 整个设置和构建过程应该需要1到2个小时，具体取决于您选择每个步骤的选项和互联网下载速度。计算机设置完成后","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"，首次构建SAM可能需要几分钟时间。后续构建速度较快，具体取决于构建选项以及在构建之前修改的代码量。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"下载并安装Visual Studio Community 2022（10分钟，需要Microsoft账户和计算机重新启动）。\n下载并构建wxWidgets 3.2.0（10分钟）。\n下载并安装CMake 3.24或更高版本（5分钟）。\n克隆并构建Google Test（需要CMake）（5分钟）。\n克隆SAM代码存储库（根据互联网速度，可能需要10-20分钟）。\n设置环境变量（5分钟）。\n为Visual Studio生成SAM项目文件（需要CMake）（5分钟）。\n构建SAM（对于SAMOS的干净构建需要10分钟，构建所有项目需要更长时间）。\n测试构建结果。\n1.下载并安装Visual Studio Community 2022\n如果您的计算机上尚未安装Visual Studio Community 2022 (VS 2022)，请从https://visualstudio.microsoft.com/下载并安装。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"使用VS 2022需要一个免费的Microsoft账户，当您首次启动程序时，系统会提示您创建或输入账户。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"运行Visual Studio安装程序，并选择以下三个工作负载：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"C++桌面开发\nPython开发（用于SAM与Python的集成）\nC++ Linux和嵌入式开发（用于CMake）","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果您的计算机上安装了其他版本的Visual Studio，您可以与其他版本并存安装和运行VS 2022。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"启动VS 2022并登录到您的Microsoft账户或创建一个新账户。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"下载并构建wxWidgets 3.2.0","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM的用户界面使用的是wxWidgets 3.2.0，这是截至2022年7月7日的最新稳定版本。其他版本的wxWidgets可能与SAM兼容也可能不兼容。您可以从https://www.wxwidgets.org/downloads/下载不同版本的wxWidgets。在页面底部的\"Other Downloads\"下的GitHub Release Archive中，提供了以前的版本。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"从https://github.com/wxWidgets/wxWidgets/releases/tag/v3.2.0下载Windows源代码，可以选择ZIP或7Z文件。将文件解压到计算机上的一个文件夹中，例如c:/wxWidgets-3.2.0。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"启动VS 2022并打开c:/wxWidgets-3.2.0/build/msw/wx_vc17.sln解决方案文件。该目录中有适用于其他版本的Visual Studio的项目文件，因此请确保打开vc17文件。vc17解决方案适用于VS 2022。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"构建64位的Debug和Release版本：在VS 2022的工具栏中，选择Release配置和x64平台，然后按F7键或从Build菜单中选择Build Solution。构建完成后，选择Debug x64并进行构建（24个项目都要构建）。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果构建成功，您应该会看到构建了24个项目成功的消息。在c:/wxWidgets-3.2.0/build/msw中，您还应该看到vcx64-mswu和vcx64-mswud文件夹，每个文件夹中都有几个文件夹和.pch文件。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"下载并安装CMake","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM需要CMake 3.24或更高版本来为Windows、Linux和Mac生成构建文件。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"从https://cmake.org/download/下载最新版本的Windows x64安装程序。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"运行安装程序，按照提示安装CMake，并勾选“将CMake添加到系统路径中”选项，可以选择单个用户或所有用户。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"安装程序应自动将C:/Program Files/CMake/bin添加到Windows系统路径中。要验证，请在Windows开始菜单中输入\"env\"，打开\"环境变量\"窗口，双击系统变量下的Path变量。如果路径列表中没有该路径，您可以手动添加。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"4.克隆并构建Google Test SAM的代码存储库依赖于Google Test C++单元测试框架。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"从https://github.com/google/googletest.git克隆Google Test。在命令窗口中执行以下命令：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"cd path/to/my/repos\ngit clone https://github.com/google/googletest.git","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"在问题https://github.com/NREL/ssc/issues/806解决之前，切换到提交b85864c64758dec007208e56af933fc3f52044ee：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"cd path/to/googletest\ngit checkout b85864c64758dec007208e56af933fc3f52044ee","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"这样就会显示HEAD is now at b85864c6 Eliminate the legacy GTESTCOMPILEASSERT_ macro.（这个问题如果已经解决，则不需要进行上述步骤，文件会直接被完整克隆下来）","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"进入包含ci、docs、googlemock和googletest的顶级googletest文件夹，并创建一个build文件夹（也可以通过鼠标在对应位置创建文件夹）：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"mkdir path/to/googletest/build","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"进入刚创建的build文件夹（建议创建文件夹的位置与示例相同，如果不同，进行命令行操作时，注意要输入与之相对应的正确路径）：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"cd path/to/googletest/build 运行CMake生成Visual Studio项目文件：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"请注意，在CMake命令的末尾使用两个句点..，以确保命令能够找到父文件夹中的CMakeLists.txt文件。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"cmake -G \"Visual Studio 17 2022\" -DCMAKE_CONFIGURATION_TYPES=\"Release;Debug\" -Dgtest_force_shared_crt=ON ..","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果CMake成功，您应该会看到path/to/googletest/build/googletest/gtest.sln文件。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"在VS 2022中打开gtest.sln文件，并构建x64的Debug和Release配置（步骤同第二步wxWidgets的配置）。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果构建成功，您应该会在path/to/googletest/build/lib中看到包含gtest.lib等文件的Release和Debug文件夹。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"克隆SAM代码存储库","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"创建一个父文件夹来存储这些存储库，例如path/to/sam_dev：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"mkdir path/to/sam_dev","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"将每个存储库克隆到父文件夹中。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"cd path/to/sam_dev","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"git clone https://github.com/nrel/lk","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"git clone https://github.com/nrel/wex","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"git clone https://github.com/nrel/ssc","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"git clone https://github.com/nrel/sam","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果您可以访问SAM-private存储库以构建官方的NREL版本的SAM，请选择使用Web浏览器身份验证方式验证您的GitHub.com账户是否有权访问该存储库：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"git clone https://github.com/nrel/sam-private","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"设置环境变量","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM的构建工具使用Windows环境变量来确定它所需文件在计算机上的存储位置。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"关闭任何打开的命令窗口以及正在运行的VS 2022。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"打开Windows系统属性窗口，在\"高级\"选项卡上，点击\"环境变量\"，或在Windows搜索栏中输入\"env\"并点击\"编辑系统环境变量\"。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"在用户变量列表中，点击\"新建\"，并为下表中的每一项输入变量名和值。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"例如，如果您将LK存储库放在c:/samdev/lk中，您将把环境变量的名称设置为\"LKDIR\"，其值设置为\"c:/samdev/lk\"（不需要输入引号）。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"LKDIR path/to/sam_dev/lk\nWEXDIR path/to/sam_dev/wex\nSSCDIR path/to/sam_dev/ssc\nSAMNTDIR path/to/sam_dev/sam\nRAPIDJSONDIR path/to/sam_dev/ssc","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"*RAPIDJSONDIR是一个单独的环境变量，用于支持不依赖于SSC的WEX构建。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果您可以访问SAM-private存储库以构建官方的NREL版本的SAM：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"| SAMNRELDIR | path/to/sam_dev/SAM-private | | ––––– | –––––––––––––- |","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"创建以下用户变量，指向Google Test、wxWidgets和CMake的文件夹：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"GTDIR path/to/googletest\nWXMSW3 path/to/wxWidgets-3.2.0\nCMAKEBUILDDIR path/to/sam_dev/build","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"关闭系统属性窗口。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"生成 SAM Visual Studio 2022 项目文件","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"这一步是在首次构建 SAM 以及从 LK、WEX、SSC 或 SAM 存储库中添加或移除 .cpp 源文件后所需的。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"使用文本编辑器在 SAM 的父文件夹中创建一个名为 CMakeLists.txt 的 \"总体 CMake 文件\"（在我们的例子中为 path/to/sam_dev/CMakeLists.txt），其内容如下：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"cmake_minimum_required(VERSION 3.24)\n\nset(CMAKE_OSX_DEPLOYMENT_TARGET \"10.15\" CACHE STRING \"Minimum OS X deployment version\")\nif (UNIX AND NOT CMAKE_C_COMPILER)\n    set(CMAKE_C_COMPILER gcc)\n    set(CMAKE_CXX_COMPILER g++)\nendif()\n\nif(MSVC)\n    set(CMAKE_CONFIGURATION_TYPES \"Debug;Release\" CACHE STRING \"Debug and Release Builds Configured\" FORCE)\nendif()\n\nproject(system_advisor_model)\n\noption(SAMPRIVATE \"Release build of SAM\" OFF)\n\nadd_subdirectory(lk)\nadd_subdirectory(wex)\nadd_subdirectory(ssc)\nadd_subdirectory(sam)\nif (SAMPRIVATE)\n    add_subdirectory(SAM-private)\n    add_subdirectory(SAM-private/webupd)\nendif()","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"打开一个终端窗口，并在 SAM 的父文件夹中创建一个名为 build 的文件夹（path/to/sam_dev/build）。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"cd path/to/sam_dev\nmkdir build","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果这不是你第一次构建 SAM，而且你想删除旧的构建（除非你在构建过程中遇到问题或重新运行 cmake 后添加了 .cpp 文件到其中一个存储库，否则不需要删除旧的构建）：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"cd path/to/sam_dev\nrmdir /Q/S build\nmkdir build","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"现在，你应该有一个 SAM 的目录结构，它看起来像这样（对于我们的示例，这将是 path/to/sam_dev 的内容）：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"build\nlk\nsam\nssc\nwex\nCMakeLists.txt","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"进入你上面创建的 build 文件夹。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"cd path/to/sam_dev/build","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"运行 CMake 以生成 Visual Studio 解决方案和项目文件。该命令为 SAM 的开源版本构建了 Debug 和 Release 文件，这对于大多数开发任务足够了。如果要构建官方的 NREL 版本的 SAM，并/或者生成用于 PySAM 的 API 文件，请选择下面描述的适当的 CMake 选项。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"请注意，CMake 命令的末尾有两个句点 ..，以确保运行你在父文件夹中创建的 CmakeLists.txt 文件。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"cmake -G \"Visual Studio 17 2022\" -DCMAKE_CONFIGURATION_TYPES=\"Debug;Release\" -DSAM_SKIP_AUTOGEN=1 -DSAMAPI_EXPORT=0 -DSAMPRIVATE=0 -DCMAKE_SYSTEM_VERSION=10.0 ..","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"当 CMake 完成后，你应该在 path/to/samdev/build/ 文件夹中看到 systemadvisor_model.sln Visual Studio 解决方案文件以及支持文件、Debug 和 Release 文件夹，以及分别包含 SAM、","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SSC、WEX 和 LK 的文件夹等其他文件和文件夹。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果出现有关缺少文件的构建错误，请检查环境变量以确保它们被正确命名并指向正确的文件夹。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"CMake 选项:","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"请注意，每个选项在 cmake 命令中的前面都有字母 \"D\"。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"CMAKECONFIGURATIONTYPES","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"​       构建调试、发布版本或两个版本的选项。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"\"Debug\" = 为调试版本构建文件。如果你打算使用 VS 2022 的调试工具，请选择此选项。 \n\"Release\" = 为发布版本构建文件。选择此选项可在不使用 VS 2022 的调试工具的情况下运行 SAM。\n\"Debug;Release\" = 为调试和发布版本构建文件。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAMSKIPAUTOGEN","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"​       跳过从 export_config 自动生成 SAMAPI 文件。SAMAPI 文件用于 PySAM    Python 包。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"1 = 跳过 SAMAPI 文件的生成。当不需要生成 SAMAPI 文件时，使用此选项可以加快构建时间。\n0 = 重新生成文件。如果你正在向 SSC 的 Develop 或 Patch 分支提交添加、删除或修改输入或输出变量，或添加或删除计算模块的代码，请使用此选项。 ","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAMAPI_EXPORT","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"​       将 SSC 二进制文件导出到 SAMapi 文件夹。这些文件用于 PySAM Python 包。（Unix 还会编译 SAMAPI 的库文件）。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"1 = 导出二进制文件。如果你正在向 SSC 的 Develop 或 Patch 分支提交添加、删除或修改输入或输出变量，或添加或删除计算模块的代码，请使用此选项。\n0 = 不导出。当不需要构建 PySAM 文件时，使用此选项可以加快构建时间。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAMPRIVATE","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"​        为官方的 NREL 发行版本的 SAM 构建解决方案文件。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"1 = 在解决方案中包括私有 (SAM) 和开源 (SAMOS) 项目。如果你正在构建官方的 NREL 发行版本并且可以访问私有的 SAM-private 存储库，请使用此选项。\n0 = 在解决方案中只包括开源 (SAMOS) 项目。如果你正在构建 SAM 的开源版本，请使用此选项。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"CMAKESYSTEMVERSION CMake 版本号。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"（可选，但推荐）：在 path/to/sam_dev 文件夹中添加一个 .editorconfig 文件，以确保你的代码与项目标准一致的格式化。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"构建 SAM","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"启动 VS 2022，打开上一步中的 systemadvisormodel.sln 解决方案文件。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"在大多数情况下，你只需要构建 SAMOS 项目：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"在解决方案资源管理器中选择 SAMOS 项目（如果看不到解决方案资源管理器，请按 Ctrl+; 显示它）。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"从窗口顶部的工具栏中选择 Release 或 Debug。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"从“生成”菜单中选择“构建 SAMOS”（或按 Ctrl+B）。这将从 SAM、SSC、WEX 和 LK 以及其他依赖项目构建出 SAM 的可执行版本。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"构建解决方案中的所有项目比仅构建 SAMOS 需要更长时间，会创建 SDKtoool 和 TCSconsole 的可执行文件，并生成大量用于 PySAM 的 API 文件，你可能不需要。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果你有权限构建官方 NREL 版本的 SAM，并在上面的 cmake 命令中使用了 SAMPRIVATE = 1 选项，将会有两个 SAM 项目：SAMOS 是 SAM 的开源版本，而 SAM 是官方 NREL 版本的 SAM。构建 SAMOS 来测试官方版本特定的功能。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"官方版本（SAM）需要注册密钥才能运行，并包括从 SAM 用户界面下载 NSRDB 天气文件、URDB 电费数据和 Cambium 市场价格数据等功能。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"开源版本（SAMOS）可以在没有注册密钥的情况下运行。如果你想在 SAMOS 中使用下载功能，请修改 path/to/samdev/sam/src/private.h 添加有效的 API 密钥。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"默认情况下，VS 2022 的启动项目设置为 ALL_BUILD。如果你想在 VS 2022 中从“调试”菜单运行 SAM，或者按 Ctrl+F5 或 F5 键而不构建不必要的其他项目，可以将启动项目更改为 SAMOS（或 SAM，如果是官方 NREL 版本的 SAM）。要更改启动项目，请在解决方案资源管理器中右键单击项目名称（SAMOS 或 SAM），然后单击“设置为启动项目”。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果你的代码贡献涉及添加或更改输入的默认值，你应该在构建中包含 exportconfig 和 SAMapi，以更新用于 PySAM 的文件中的默认值。这需要在上面的 cmake 命令中使用 -DSAMSKIPAUTOGEN=0 和 -DSAMAPIEXPORT=1，以便这些项目在你的 Visual Studio 解决方案中可用。为了避免同时运行两个作业时的冲突，你只需要构建一个 Release 版本即可。（对于此目的来说，构建调试和发布版本是多余的，例如，没有 exportconfigd.exe。）","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"你还可以使用批量构建来选择要构建的项目：在“生成”菜单中，点击“批量生成”。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"测试构建","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"在构建解决方案后，通过启动 SAM 并运行模拟来","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"测试构建。可执行文件取决于你构建的版本：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"对于 SAM 的开源版本，请转到 path/to/sam_dev/SAM/deploy/x64 并运行 SAMOS.exe。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"对于 SAM 的官方 NREL 版本，请转到 path/to/samdev/SAM-private/buildwindows/deploy/x64 并运行 SAM.exe。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"调试版本位于相同的文件夹中，但文件名中包含 \"d\"：SAMOSd.exe 和 SAMd.exe。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"进行基本功能测试：","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"SAM 启动后，在 SAM 的欢迎页面上，点击“开始新项目”。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"选择“光伏”、“详细光伏模型”和“分布式”、“住宅业主”。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"在 SAM 窗口左下方点击“模拟”。SAM 应该运行模拟并显示结果。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"在“模拟”按钮下方点击“宏”，选择其中一个宏名称，然后点击“运行宏”或“查看代码”。你应该看到宏代码，表示 LK 构建正确。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"在“位置和资源”页面上，点击“查看数据”。一个 DView 窗口应该打开，表示 WEX 项目的 DView 构建正确。（SAM 还使用 DView 在“结果”页面上显示数据。）","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果你正在测试官方 NREL 版本，请在“位置和资源”和“电费”页面上测试下载功能。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/#小结","page":"以SAM为例实操","title":"小结","text":"","category":"section"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果不明白，请查看前面6条内容。ssc实际编译完就是ssc.dll这个动态链接库。sam额外加了gui壳，以方便用户使用。lk只是sam提供的一个脚本语言，忽略它。","category":"page"},{"location":"CSBase/7-以SAM为例整体实操一下/#写在最后","page":"以SAM为例实操","title":"写在最后","text":"","category":"section"},{"location":"CSBase/7-以SAM为例整体实操一下/","page":"以SAM为例实操","title":"以SAM为例实操","text":"如果对git不懂，请参考我们系列文档的git介绍。对cmake不懂请参考我们的make和makefile介绍。仍然不明白，请自行借助网络搜索引擎。编译完之后，把前面讲过的内容再想一想，体会一下。每一步大概都是在干啥，为什么。","category":"page"},{"location":"IotBigdataCloud/3-大数据简介/#大数据简介","page":"大数据简介","title":"大数据简介","text":"","category":"section"},{"location":"IotBigdataCloud/3-大数据简介/#大数据的框架体系","page":"大数据简介","title":"大数据的框架体系","text":"","category":"section"},{"location":"IotBigdataCloud/3-大数据简介/","page":"大数据简介","title":"大数据简介","text":"当介绍大数据时，可以覆盖以下内容：","category":"page"},{"location":"IotBigdataCloud/3-大数据简介/","page":"大数据简介","title":"大数据简介","text":"定义：解释什么是大数据。大数据是指规模庞大、复杂多样、高速生成的数据集合，无法通过传统的数据处理工具进行捕捉、管理和处理。\n特征：介绍大数据的特点。大数据通常具有四个主要特征：3V特征，即数据的体量（Volume）、速度（Velocity）、多样性（Variety），以及变化的真实性（Veracity）。\n应用领域：讨论大数据在不同领域的应用。大数据应用广泛，可以在商业、科学研究、医疗保健、金融、能源等领域发挥作用，例如市场营销分析、智能交通管理、风险评估和疾病预测等。\n数据收集与存储：介绍大数据的收集和存储方法。大数据的收集可以通过传感器、社交媒体、日志文件等多种途径进行，而存储则需要使用大数据存储技术，如分布式文件系统和数据库。\n数据处理与分析：探讨大数据的处理和分析方法。大数据处理需要使用分布式计算框架，如Apache Hadoop和Apache Spark，以及机器学习和数据挖掘算法，来从大数据中提取有价值的信息和见解。\n挑战与机遇：讨论大数据所面临的挑战和带来的机遇。挑战包括数据质量问题、隐私和安全性问题、技术复杂性等，而机遇则包括基于数据的创新、决策的优化和商业竞争力的提升等方面。\n伦理和法律问题：提及大数据伦理和法律方面的问题。大数据的使用可能涉及隐私、数据所有权、数据安全和歧视等问题，因此需要遵守相关法律法规，并确保数据使用的公平性和透明性。\n未来发展趋势：展望大数据的未来发展趋势。大数据在不断演进，包括更高级的数据分析技术、人工智能和机器学习的融合、边缘计算和云计算的结合等，将为我们带来更多的机会和挑战。","category":"page"},{"location":"IotBigdataCloud/3-大数据简介/","page":"大数据简介","title":"大数据简介","text":"通过涵盖这些内容，您可以提供一个全面的大数据介绍，并使读者对大数据的概念、应用和影响有一个初步的了解。","category":"page"},{"location":"IotBigdataCloud/3-大数据简介/","page":"大数据简介","title":"大数据简介","text":"大数据是指规模庞大、复杂多样、高速生成的数据集合，无法通过传统的数据处理工具进行捕捉、管理和处理。大数据具有以下主要特征：体量大（Volume）、速度快（Velocity）、多样性高（Variety）和变化的真实性（Veracity）。大数据的应用广泛，可以在商业、科学研究、医疗保健、金融、能源等领域发挥作用。收集大数据可以通过传感器、社交媒体、日志文件等多种途径进行，而存储则需要使用大数据存储技术，如分布式文件系统和数据库。处理大数据需要使用分布式计算框架和机器学习算法，以从大数据中提取有价值的信息和见解。大数据的使用面临一些挑战，如数据质量、隐私和安全性问题，但也带来了创新和商业机会。在未来，大数据将继续演进，包括更高级的数据分析技术、人工智能和机器学习的融合，以及边缘计算和云计算的结合，为我们带来更多机会和挑战。","category":"page"},{"location":"IotBigdataCloud/3-大数据简介/#大数据的核心技术","page":"大数据简介","title":"大数据的核心技术","text":"","category":"section"},{"location":"IotBigdataCloud/3-大数据简介/","page":"大数据简介","title":"大数据简介","text":"MapReduce是大数据处理中的核心技术之一，它是一种用于处理和分析大规模数据集的编程模型。除了MapReduce，还有其他一些核心技术在大数据领域中发挥着重要作用。以下是几个关键的大数据核心技术：","category":"page"},{"location":"IotBigdataCloud/3-大数据简介/","page":"大数据简介","title":"大数据简介","text":"分布式存储系统：大数据需要有效的存储解决方案来处理大规模数据的存储需求。分布式存储系统如Apache Hadoop的Hadoop分布式文件系统（HDFS）和云存储平台如Amazon S3等，能够可靠地存储大数据并实现数据的高可用性和容错性。\n分布式计算框架：大数据处理需要强大的计算能力来处理庞大的数据集。分布式计算框架如Apache Hadoop的MapReduce、Apache Spark和Apache Flink等，能够将任务并行分发到集群中的多个计算节点上进行并行处理，以实现高效的大数据计算。\n数据挖掘和机器学习：数据挖掘和机器学习技术用于从大数据中发现模式、提取知识和进行预测。这些技术包括聚类、分类、回归、关联规则挖掘等。流行的机器学习工具和库如Scikit-learn、TensorFlow和PyTorch等，提供了丰富的算法和工具来处理大规模数据集。\n实时流处理：大数据处理不仅限于批处理，还需要能够处理实时数据流的技术。实时流处理框架如Apache Kafka和Apache Flink的流处理功能，能够实时接收、处理和分析数据流，对于需要实时决策和响应的应用非常有用。\n数据库技术：传统的关系型数据库在处理大数据时存在限制，因此出现了一些专门用于大数据的数据库技术。例如，NoSQL数据库（如MongoDB、Cassandra）提供了高可扩展性和灵活性，适用于大规模分布式数据存储和查询。\n数据可视化和探索：大数据分析结果的可视化和交互探索对于理解和传达数据的洞察力非常重要。可视化工具和库如Tableau、Power BI和D3.js等，能够将大数据以图表、图形和仪表板的形式呈现，帮助用户发现数据中的模式和趋势。","category":"page"},{"location":"IotBigdataCloud/3-大数据简介/","page":"大数据简介","title":"大数据简介","text":"这些核心技术的综合应用可以实现大规模数据的高效存储、处理和分析，从而为企业和研究机构提供更深入的洞察力和价值。","category":"page"},{"location":"IotBigdataCloud/3-大数据简介/#更多参考信息","page":"大数据简介","title":"更多参考信息","text":"","category":"section"},{"location":"IotBigdataCloud/3-大数据简介/","page":"大数据简介","title":"大数据简介","text":"厦门大学数据库实验室的大数据课程公共服务平台。很全面啦。要想学习，自己去看吧。","category":"page"},{"location":"Optimization/systemParaEste/#MTK符号系统参数辨识","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"","category":"section"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"tip: Tip\nContents：MTK模型、优化、DiffEqParamEstimContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"note: Note\nDEPE = DiffEqParamEstim.jl(Differential Equation Parameters Estimate)DiffEqParamEstim.jl是计算微分方程参数估计的软件包。","category":"page"},{"location":"Optimization/systemParaEste/#原理","page":"MTK符号系统参数辨识","title":"原理","text":"","category":"section"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"MTK与DE在问题层面具有一致性。MTK是符号处理的软件包，问题的求解仍然推给DE。而DEPE是从DE的problem层面构建的参数优化问题，所以使用MTK进行建模后，依然可以使用DEPE进行参数估计。对于DEPE来说，不管是MTK还是DE，它接受的问题都是DE的Problem。所以，不管是使用MTK还是DE构建模型，到DEPE这一层面都是贯通的。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"下面以RC电路模型为例，进行电路中正弦电压源的电压值估计。","category":"page"},{"location":"Optimization/systemParaEste/#RC组件建模","page":"MTK符号系统参数辨识","title":"RC组件建模","text":"","category":"section"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"基于ModelingToolkit，建立RC电路模型，模型如下图所示。这是一个震荡电路 (Image: 在这里插入图片描述)","category":"page"},{"location":"Optimization/systemParaEste/#构建组件","page":"MTK符号系统参数辨识","title":"构建组件","text":"","category":"section"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"首先完成电路模型的组件编写，一共有5个组件，分别是电源、电阻、电容、电感、接地","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"using ModelingToolkit, Plots, DifferentialEquations\n\n@variables t\n@connector function Pin(; name)\n    sts = @variables v(t) = 1.0 i(t) = 1.0 [connect = Flow]\n    ODESystem(Equation[], t, sts, []; name=name)\nend\n\nfunction Ground(; name)\n    @named g = Pin()\n    eqs = [g.v ~ 0]\n    compose(ODESystem(eqs, t, [], []; name=name), g)\nend\n\nfunction OnePort(; name)\n    @named p = Pin()\n    @named n = Pin()\n    sts = @variables v(t) = 1.0 i(t) = 1.0\n    eqs = [\n        v ~ p.v - n.v\n        0 ~ p.i + n.i\n        i ~ p.i\n    ]\n    compose(ODESystem(eqs, t, sts, []; name=name), p, n)\nend\n\nfunction Resistor(; name, R=1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters R = R\n    eqs = [\n        v ~ i * R\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction Capacitor(; name, C=1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters C = C\n    D = Differential(t)\n    eqs = [\n        D(v) ~ i / C\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction ConstantVoltage(; name, V=1.0)\n    @named oneport = OnePort()\n    @unpack v = oneport\n    ps = @parameters V = V\n    eqs = [\n        V ~ v\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction Inductor(; name, L=1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters L = L\n    D = Differential(t)\n    eqs = [\n        D(i) ~ v / L\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction ChangeableVoltage(; name)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    eqs = [\n        v ~ 16 * sin(2π * t)\n    ]\n    extend(ODESystem(eqs, t, [], []; name=name), oneport)\nend","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"可以看到，系统一共定义有4个参数，分别是电阻值，电容值，电感值以及电压的最大值","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"然后，通过连接函数，组建系统","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"@named resistor = Resistor(R=3.0)\n@named capacitor = Capacitor(C=1.0/24)\n@named source = ChangeableVoltage(vol=10.0)\n@named inductor = Inductor(L=0.1)\n@named ground = Ground()\n\n\nrc_eqs = [\n          connect(source.p, capacitor.p)\n          connect(capacitor.n, inductor.p)\n          connect(inductor.n, resistor.p)\n          connect(source.n,resistor.n,ground.g)\n         ]\n\n@named _rc_model = ODESystem(rc_eqs, t)\n@named rc_model = compose(_rc_model,\n    [resistor, inductor, capacitor, source, ground])\n\nsys = structural_simplify(rc_model)\n\nusing Plots\nu0 = [\n    capacitor.v => 0.0\n    capacitor.p.i => 0.0\n    inductor.i => 0\n    inductor.v => 0\n     ]\nP=[3.0,1.0/24,0.1,10.0]  #系统的参数\nprob = ODAEProblem(sys, u0, (0, 10.0),P)\nsol = solve(prob, Tsit5())\n\np1 = plot(sol,vars=[capacitor.v capacitor.p.i],xlims = (0,10),ylim = (-10,15))\np2 = plot(sol,vars=[inductor.v inductor.i],xlims = (0,10),ylim = (-5,5))\nplot(p1,p2,layout=(2,1))\n","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"运行代码可以得到结果图： (Image: 在这里插入图片描述)","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"电容的电压电流、电感的电压电流都是震荡的。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"初值向量P分别对应4个参数的参数值，电压值为最后一个，设定为10.0","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"在不知道参数的顺序时，可以使用parameters函数查看系统参数。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"parameters(sys)","category":"page"},{"location":"Optimization/systemParaEste/#建立问题","page":"MTK符号系统参数辨识","title":"建立问题","text":"","category":"section"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"为了能够模拟参数辨识，给其中一个变量加上扰动（这里依旧采用手动生成数据的思想，可能保证模型与数据匹配）。可以使用states函数查看系统变量（在组件设计过程中定义的）。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"states(sys)","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"这里对两个变量都添加扰动。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"using RecursiveArrayTools\nt = collect(range(0,stop=10,length=1000)) # 建立时间向量\nrandomized = VectorOfArray([(sol(t[i]) + .5randn(2)) for i in 1:length(t)])\ndata = convert(Array,randomized)  ","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"对sol的结果，选取了1000个点作为样本点加入扰动。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"加入的扰动的方式是：通过生成绝对值小于0.5的随机数加入到从sol中选取出来的样本点中去，将其作为需要参数辨识的样本数据。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"看一看扰动生成的结果：","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"p1=plot(t,data[1,:],ylim=(-8,8))\np1=plot!(t,data[2,:],ylim=(-8,8))\np2=plot(sol,vars=[inductor.i,capacitor.v],ylim=(-8,8))\nplot(p1,p2,layout=(2,1))","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"产生的结果图为： (Image: 在这里插入图片描述)","category":"page"},{"location":"Optimization/systemParaEste/#辨识过程","page":"MTK符号系统参数辨识","title":"辨识过程","text":"","category":"section"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"参数辨识使用DiffEqParamEstim，","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"using DiffEqParamEstim\ncost_function = build_loss_objective(prob,Tsit5(),\nL2Loss(t,data),maxiters=10000,verbose=false)","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"通过buildlossobjective建立了辨识模型，即通过该函数可以求处理后的样本点与模型计算结果的方差和（L2Loss），当然方差和只是作为拟合的评价指标之一，可以选取不同的函数或者构建不同的指标。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"接下来，看一看不同的电压值，带来的方差和的变化。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"vals = 0:0.1:20.0\nplot(vals,[cost_function([3.0,1.0/24,0.1,i]) for i in vals],yscale=:log10,\n     xaxis = \"Parameter\", yaxis = \"Cost\", title = \"1-Parameter Cost Function\",\n     lw = 3)","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"val为从0开始，到20，步长为0.1。对这些电压值，去匹配模型，算出来的与样本值的方差和会不同。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"结果为： (Image: 在这里插入图片描述)","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"可以看到，在10.0的地方，方差和最小（因为设定的值就是10.0，扰动是在此基础之上叠加的）。说明辨识结果有效。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"以上是通过“肉眼”观察的出来的结果。科学的方法是求一组参数，使得方差和最小。这是一个最优化问题。使用Optim","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"using Optim\nresult = optimize(cost_function, [3.0,1.0/24,0.1,15])\nresult.minimizer","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"将电压的初始值设为15去寻优，得到的结果为：","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"4-element Vector{Float64}:\n 2.975801390547115\n 0.04266590691854741\n 0.09999565290932136\n 9.923607580088433","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"和真实值是非常接近的！寻优有效！","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"也可以将4个初始值都改变去寻优。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"result = optimize(cost_function, [2.0,0.1,0.5,16])\nresult.minimizer","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"得到的结果也很好","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"4-element Vector{Float64}:\n 2.972037379476059\n 0.04300492580277582\n 0.09998659716890046\n 9.911215185371102","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"note: Note\n该参数辨识仍然是优化问题的子集，选择不同的初值很可能得到不同的结果。","category":"page"},{"location":"tengfeibei/#腾飞杯","page":"腾飞杯","title":"腾飞杯","text":"","category":"section"},{"location":"tengfeibei/#**腾飞杯招募**","page":"腾飞杯","title":"腾飞杯招募","text":"","category":"section"},{"location":"tengfeibei/#腾飞杯项目简介信息","page":"腾飞杯","title":"腾飞杯项目简介信息","text":"","category":"section"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"自我介绍：能动研二杨景懿，感兴趣的研究方向是：系统的建模、仿真、优化与控制。个人主页。QQ：522432938","category":"page"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"目前已有核心开发人员3名，指导老师1名。","category":"page"},{"location":"tengfeibei/#主题","page":"腾飞杯","title":"主题","text":"","category":"section"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"云仿真平台（具体名字待定），简单理解为：网页版Simulink（或者网页版AspenPlus，网页版gproms，网页版modelica，本质都一样）","category":"page"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"暂定赛道：科技发明制作A类","category":"page"},{"location":"tengfeibei/#技术框架","page":"腾飞杯","title":"技术框架","text":"","category":"section"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"前后端分离。前端VUE3，后端Julia，通过json交互。","category":"page"},{"location":"tengfeibei/#已有进展","page":"腾飞杯","title":"已有进展","text":"","category":"section"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"所有代码、文档可在Github上自行查看。","category":"page"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"我们的Ai4Energy开源组织：https://github.com/ai4energy\n模型库Ai4EComponentLib.jl，现在已有的有可压缩组件库（空压系统），不可以压缩组件库（管道系统），电化学库（光伏、电解槽、电池等），热力循环库（各类循环等）\njson解析器：Ai4EMetaPSE.jl\nAi4ELab，Julia的web框架。但是灵活性不够高，希望用VUE3开发。\n求解器采用开源求解器。\n前端页面参考：https://github.com/yaolunmao/vue-webtopo-svgeditor","category":"page"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"总结：高可拓展性的后端框架已经完成，完整作品的上线测试运行只差前端。","category":"page"},{"location":"tengfeibei/#招募队员","page":"腾飞杯","title":"招募队员","text":"","category":"section"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"招募2-3名队员。","category":"page"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"负责内容：基于该VUE实现做开发，打造自己的作品。 要求：专业不限，年级不限。动手能力强，具有钻研精神。热爱程序设计。能投入。","category":"page"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"有兴趣的同学联系+QQ：522432938","category":"page"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"tip: Tip\n基于上述介绍，我们是踏实严肃的且有货的开发团队，不鸽不水。\n本网页是我们开放的文档库，可自行学习浏览。\n我们的目的是打造作品，只要东西能做出来，队长、队员重要程度什么的都好商量。最后，腾飞杯只是一个展示平台。比赛过后，我们的组织依旧会传承与发展，我们的目标是星辰大海~ 抛开比赛，欢迎有热情、有激情的同学加入，共同学习、成长与开发。","category":"page"},{"location":"Simulation/componementModel/#组件化建模实例","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"section"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"tip: Tip\nContents：MTK、组件化建模Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"note: Note\nMTK = ModelingToolkit.jlModelingToolkit.jl Acausal Component-Based Modeling the RC Circuit介绍了组件化建模的例子","category":"page"},{"location":"Simulation/componementModel/#MTK符号建模","page":"组件化建模实例","title":"MTK符号建模","text":"","category":"section"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"在DifferentialEquations建模方法与ModelingToolkit建模方法中介绍DE与MTK的两种建模方式。分析了使用它们建模的具体步骤与实现方法，并介绍了相应的内涵。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"这一篇中主要介绍符号建模的另一个强大功能——组件化建模。","category":"page"},{"location":"Simulation/componementModel/#RC电路建模实例","page":"组件化建模实例","title":"RC电路建模实例","text":"","category":"section"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"仿真如下图的电路系统：","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"(Image: 图 2)  ","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"@MTK版本：8.5.5","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"using ModelingToolkit, Plots, DifferentialEquations\n\n@variables t\n@connector function Pin(; name)\n    sts = @variables v(t) = 1.0 i(t) = 1.0 [connect = Flow]\n    ODESystem(Equation[], t, sts, []; name=name)\nend\n\nfunction Ground(; name)\n    @named g = Pin()\n    eqs = [g.v ~ 0]\n    compose(ODESystem(eqs, t, [], []; name=name), g)\nend\n\nfunction OnePort(; name)\n    @named p = Pin()\n    @named n = Pin()\n    sts = @variables v(t) = 1.0 i(t) = 1.0\n    eqs = [\n        v ~ p.v - n.v\n        0 ~ p.i + n.i\n        i ~ p.i\n    ]\n    compose(ODESystem(eqs, t, sts, []; name=name), p, n)\nend\n\nfunction Resistor(; name, R=1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters R = R\n    eqs = [\n        v ~ i * R\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction Capacitor(; name, C=1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters C = C\n    D = Differential(t)\n    eqs = [\n        D(v) ~ i / C\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction ConstantVoltage(; name, V=1.0)\n    @named oneport = OnePort()\n    @unpack v = oneport\n    ps = @parameters V = V\n    eqs = [\n        V ~ v\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction Inductor(; name, L=1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters L = L\n    D = Differential(t)\n    eqs = [\n        D(i) ~ v / L\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction ChangeableVoltage(; name)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    eqs = [\n        v ~ 16 * sin(2π * t)\n    ]\n    extend(ODESystem(eqs, t, [], []; name=name), oneport)\nend\n\n\n\n@named resistor = Resistor(R=3.0)\n@named capacitor = Capacitor(C=1.0 / 24)\n@named source = ChangeableVoltage()\n@named inductor = Inductor(L=0.1)\n@named ground = Ground()\n\n\nrc_eqs = [\n    connect(source.p, capacitor.p)\n    connect(capacitor.n, inductor.p)\n    connect(inductor.n, resistor.p)\n    connect(source.n, resistor.n, ground.g)\n]\n\n\n@named _rc_model = ODESystem(rc_eqs, t)\n@named rc_model = compose(_rc_model,\n    [resistor, inductor, capacitor, source, ground])\n\nsys = structural_simplify(rc_model)\n\nusing Plots\nu0 = [\n    capacitor.v => 0.0\n    capacitor.p.i => 0.0\n    inductor.i => 0\n    inductor.v => 0\n]\nprob = ODAEProblem(sys, u0, (0, 10.0))\nsol = solve(prob, Tsit5())\nsol[resistor.p.i]\np1 = plot(sol, vars=[capacitor.v capacitor.p.i], xlims=(0, 10), ylim=(-20, 20))\np2 = plot(sol, vars=[inductor.v inductor.i], xlims=(0, 10), ylim=(-5, 5))\nplot(p1, p2, layout=(2, 1))","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"结果如图所示：","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"(Image: 图 1)  ","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"主要的过程有以下几步：","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"构建组件\n定义组件实例\n连接系统\n化简\n设置初值\n构建问题并求解\n结果处理","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"构建组件过程中主要有两方面考虑，系统内部结构与系统对外接口。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"内部结构则是各个组件内部的数学特性。对于电阻有： V=R*I","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"对于电容有： fracdVdt=fracIC","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"对于电感有： fracdIdt=fracVL","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"这些关系可以在模型构建时体现。这是系统的内部变量之间的决定关系。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"外部结构是模块化的另一个关键部分。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"RC的接口体现在函数Pin()上，每一个组件都由两个Pin——输入引脚与输出引脚。这完全是抽象出来的，引脚存在的意义就是为了连接。每个引脚有自己的电压值（更准确的说是电势大小）以及电流。这些变量的引入只是为了跟好地模块化。例如，器件A的出口引脚与器件B的进口引脚相连，它们在电路模型中完全可以视为一个等价的点。为了使模块变得更加完整，分化出来各自的引脚。事实上，这些引脚变量在最后计算时，被化简消除了。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"所以，在模块化的过程中为了使个组件变得完整，会派生出很多变量，这些变量都是“锦上添花”的存在，不具备决定性意义。但它们又是使各模块间能够衔接的必要存在。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"\n@named resistor = Resistor(R=3.0)\n@named capacitor = Capacitor(C=1.0 / 24)\n@named source = ChangeableVoltage()\n@named inductor = Inductor(L=0.1)\n@named ground = Ground()\n","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"组件实例化中的@named的作用是给相应组件命名，每个组件的本质都是一个ODESystem，不同的组件不过是ODESystem中存储的方程不同。ODESystem中有一个成员为name，@named把实例的名称赋值给这个成员变量。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"例如,下面两种定义方式是等价的。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"\n@named resistor = Resistor(R=3.0)\n\nresistor = Resistor(R=3.0;name =:resistor)","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"rc_eqs = [\n    connect(source.p, capacitor.p)\n    connect(capacitor.n, inductor.p)\n    connect(inductor.n, resistor.p)\n    connect(source.n, resistor.n, ground.g)\n]","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"依据系统的拓扑结构进行连接。connect函数可以接受任意参数个（并联中多点连接的问题就解决了）。连接的本质是建立模块间的联系，连接模块内部的机理，一旦连接绑定，这些变量的使命就完成了。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"化简的过程中，会把多余的中间变量都消去。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"sys = structural_simplify(rc_model)","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"查看各组件各变量的求解结果：","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"sol[resistor.p.i]","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"值得一提的是，在求解的过程中会化简，但是依旧可以查看这些变量的求解结果。方法如示例所示。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"page"},{"location":"JuliaIntro/7-julia的类型系统/#julia的类型系统","page":"julia的类型系统","title":"julia的类型系统","text":"","category":"section"},{"location":"JuliaIntro/7-julia的类型系统/#julia的类型系统-2","page":"julia的类型系统","title":"julia的类型系统","text":"","category":"section"},{"location":"JuliaIntro/7-julia的类型系统/","page":"julia的类型系统","title":"julia的类型系统","text":"当进一步学习Julia时，了解其类型系统是很重要的。Julia拥有强大的类型系统，允许您指定和操作变量的类型，从而提高性能并增强代码的可读性。下面是关于Julia类型系统的一些基本概念：","category":"page"},{"location":"JuliaIntro/7-julia的类型系统/","page":"julia的类型系统","title":"julia的类型系统","text":"动态类型系统： Julia是一种动态类型语言，这意味着变量的类型是在运行时确定的。您可以在声明变量时指定类型，也可以在后续的操作中改变变量的类型。\n类型注解： 您可以使用类型注解来显式指定变量的类型。类型注解使用::符号，后跟要指定的类型。这有助于编译器进行类型推断，并可以提高性能。\nx::Int = 10  # 声明x为整数类型\n抽象类型： 在Julia中，抽象类型是其他类型的父类型。它们不会被直接实例化，而是作为类型层次结构的基础。例如，Number是整数和浮点数等具体类型的抽象父类型。\nabstract type Number end\n具体类型： 具体类型是实际实例化的类型。它们是类型层次结构中的叶子节点。例如，Int和Float64是具体类型。\nstruct Int <: Number end\nstruct Float64 <: Number end\n类型参数化： Julia允许您创建参数化类型，这些类型具有一个或多个类型参数。类型参数化可以使代码更灵活，可以为同一种类型的不同实例提供不同的行为。\nstruct Point{T}\n    x::T\n    y::T\nend\n类型转换和类型断言： 在Julia中，您可以使用convert函数将一个类型转换为另一个类型。如果您确定某个变量的类型，可以使用typeof函数进行类型断言。\nx = 3.14\ny = convert(Int, x)  # 将x转换为整数类型\nz = typeof(x)        # 获取x的类型\n多分派： Julia是一种多分派语言，这意味着函数可以根据参数的类型和数量选择不同的方法进行调用。这使得您可以根据不同的参数类型定义多个相同名称的函数。\nfunction add(x::Int, y::Int)\n    println(\"Adding two integers\")\n    return x + y\nend\n\nfunction add(x::Float64, y::Float64)\n    println(\"Adding two floating-point numbers\")\n    return x + y\nend","category":"page"},{"location":"JuliaIntro/7-julia的类型系统/","page":"julia的类型系统","title":"julia的类型系统","text":"Julia的类型系统是其强大和灵活性的基础，使您能","category":"page"},{"location":"JuliaIntro/7-julia的类型系统/","page":"julia的类型系统","title":"julia的类型系统","text":"够编写高性能和可维护的代码。深入了解和利用Julia的类型系统将使您能够更好地利用语言的优势。","category":"page"},{"location":"JuliaIntro/7-julia的类型系统/#多重分发","page":"julia的类型系统","title":"多重分发","text":"","category":"section"},{"location":"JuliaIntro/7-julia的类型系统/","page":"julia的类型系统","title":"julia的类型系统","text":"多重派发（Multiple Dispatch）是Julia语言的一项强大特性，它允许您根据函数参数的类型和数量来选择不同的方法进行调用。这意味着可以根据函数参数的不同组合来定义多个具有相同名称的函数，并根据实际传入的参数类型来决定使用哪个方法。","category":"page"},{"location":"JuliaIntro/7-julia的类型系统/","page":"julia的类型系统","title":"julia的类型系统","text":"多重派发有助于实现更具表达力和灵活性的代码，以及更高效的函数调用。下面是多重派发的几个关键要点：","category":"page"},{"location":"JuliaIntro/7-julia的类型系统/","page":"julia的类型系统","title":"julia的类型系统","text":"定义多个相同名称的函数： 在Julia中，您可以定义多个具有相同名称的函数，但它们的参数类型和数量不同。这些函数可以被称为方法（methods）。例如，可以定义不同类型的参数的加法方法：\nfunction add(x::Int, y::Int)\n    println(\"Adding two integers\")\n    return x + y\nend\n\nfunction add(x::Float64, y::Float64)\n    println(\"Adding two floating-point numbers\")\n    return x + y\nend\n根据参数类型和数量选择方法： 当您调用一个具有多个方法的函数时，Julia会根据实际传入的参数类型和数量来选择最匹配的方法。这种选择过程称为派发（Dispatch）。根据参数类型的匹配程度，Julia会选择执行最合适的方法。\nadd(2, 3)      # 调用第一个方法：Adding two integers\nadd(2.0, 3.0)  # 调用第二个方法：Adding two floating-point numbers\n支持多个参数的多重派发： 多重派发不仅可以基于单个参数的类型进行派发，还可以基于多个参数的类型组合进行派发。这使得可以定义更加复杂和灵活的函数行为。\nfunction foo(x::Int, y::Float64)\n    println(\"Int and Float64\")\nend\n\nfunction foo(x::Float64, y::Int)\n    println(\"Float64 and Int\")\nend\n\nfoo(2, 3.0)   # 调用第一个方法：Int and Float64\nfoo(2.0, 3)   # 调用第二个方法：Float64 and Int","category":"page"},{"location":"JuliaIntro/7-julia的类型系统/","page":"julia的类型系统","title":"julia的类型系统","text":"多重派发是Julia语言的一项强大功能，它使得函数调用可以根据参数类型和数量动态选择最适合的方法。这样可以更好地表达和处理不同类型和组合的数据，并提供更高效的函数调用。","category":"page"},{"location":"JuliaIntro/7-julia的类型系统/#julia的类型和python、java的oop对比","page":"julia的类型系统","title":"julia的类型和python、java的oop对比","text":"","category":"section"},{"location":"JuliaIntro/7-julia的类型系统/","page":"julia的类型系统","title":"julia的类型系统","text":"当涉及到类型和面向对象编程（OOP）的比较时，Julia、Python和Java有一些不同的特点。以下是它们之间的简要对比：","category":"page"},{"location":"JuliaIntro/7-julia的类型系统/","page":"julia的类型系统","title":"julia的类型系统","text":"类型系统：\nJulia：Julia具有强大的类型系统，支持动态类型和静态类型的结合。它允许您显式地定义类型和类型层次结构，并利用多重派发来实现多态。\nPython：Python是一种动态类型语言，它具有灵活的类型系统。它使用类和对象来组织代码，并支持面向对象编程的概念，如继承、多态和封装。\nJava：Java是一种静态类型语言，具有强类型检查和显式的类型声明。它使用类、接口和对象来实现面向对象编程的概念，并且支持继承、多态和封装。\n类和对象：\nJulia：Julia在语言层面上没有类和对象的概念。相反，它使用结构体（structs）和抽象类型（abstract types）来组织和管理数据。\nPython：Python是一种面向对象的语言，支持类和对象的概念。您可以定义类来创建对象，并使用继承和多态等OOP特性来组织代码。\nJava：Java是一种纯粹的面向对象编程语言，具有类和对象的概念。您可以定义类来创建对象，并使用继承、多态和封装等OOP特性来组织和管理代码。\n继承和多态：\nJulia：Julia使用多重派发来实现多态。多重派发允许根据函数参数的类型和数量选择不同的方法进行调用，从而实现灵活的函数重载。\nPython：Python支持单继承和多继承。通过继承，子类可以继承父类的属性和方法。Python还通过鸭子类型（Duck Typing）来实现多态，即根据对象的行为而不是类型进行函数调用。\nJava：Java支持单继承和接口实现。通过继承，子类可以继承父类的属性和方法。Java使用方法重写和接口实现来实现多态。\n封装：\nJulia：Julia使用模块（Modules）来实现封装，允许将相关的函数和数据组织在一起，并通过限制访问来保护模块中的私有内容。\nPython：Python使用类的访问修饰符（如公有（public）、私有（private）和受保护（protected））来实现封装。公有成员可以被任何代码访问，私有成员只能在类内部访","category":"page"},{"location":"JuliaIntro/7-julia的类型系统/","page":"julia的类型系统","title":"julia的类型系统","text":"问，受保护成员可以在类及其子类中访问。","category":"page"},{"location":"JuliaIntro/7-julia的类型系统/","page":"julia的类型系统","title":"julia的类型系统","text":"Java：Java使用类的访问修饰符（如公有（public）、私有（private）和受保护（protected））来实现封装。公有成员可以被任何代码访问，私有成员只能在类内部访问，受保护成员可以在类及其子类中访问。","category":"page"},{"location":"JuliaIntro/7-julia的类型系统/","page":"julia的类型系统","title":"julia的类型系统","text":"总的来说，Julia、Python和Java在类型和OOP方面有一些区别。Julia的类型系统非常灵活且强大，可以与面向对象编程的概念结合使用。Python是一种面向对象的语言，具有类和对象的概念，并且支持多态和封装。Java是一种纯粹的面向对象编程语言，具有严格的静态类型和类的概念，并支持继承、多态和封装。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#Ai4EComponentLib.jl设计理念","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"tip: Tip\nContents：Ai4EComponentLib：Julia组件模型库Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"note: Note\nAi4EComponentLib地址。arXiv文章","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#摘要","page":"Ai4EComponentLib.jl设计理念","title":"摘要","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"Ai4EComponentLib是基于Julia语言构建的组件化模型库。它依赖于微分方程求解器DifferentialEquations.jl与符号建模工具Modelingtoolkit.jl。面向不同的物理领域的问题，Ai4EComponentLib尝试使用组件化建模的方法去构建它们。在新一代符号建模工具的支持下，使用Ai4EComponentLib构建的模型比传统的用Modelica构建的模型更加灵活，并具有更高的可拓展性。本文将介绍Ai4EComponentLib模型库的实例与通用建模思想。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#Motivation","page":"Ai4EComponentLib.jl设计理念","title":"1 Motivation","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"在建模仿真领域，已经存在着许许多多的建模工具，例如Modelica、gProms、Simulink等等。它们在不同领域中都发挥着重要的作用，这些工具也已经成为科研工作者的必备工具。但这并不意味着，它们是完美无暇的。以开源的Modelica为例，Modelica拥有自己的编译器，能将建模语言编译成C语言。对于仿真问题来说，它形成了一个完备的解决方案链条。但它的缺陷是，不易扩展。它不能向外扩展形成优化问题的解决方案（参数辨识、最优控制问题）等等。而Julia生态中的ModelingToolkit就解决了扩展性不足的问题。在符号建模体系下，它具有高可拓展性。基于ModelingToolkit的工作，Ai4EComponentLib构建了一些模型库，期望在将来能够利用其高可拓展行的优势。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#Ai4EComponentLib设计理念","page":"Ai4EComponentLib.jl设计理念","title":"2 Ai4EComponentLib设计理念","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"Ai4EComponentLib设计系统的方法与传统的组件化建模思想是相通的。但由于ModelingToolkit的高可拓展性，我们将用更高一层的抽象来看待这个问题。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"组件建模的核心在于过程，以及过程中的物质能量流动。建模过程中的两个关键点为：内部过程与外部连接。设计一个系统，也就是设计它们的内部过程与外部连接。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"现有一个系统，系统中有3个组件A, B and C，如图所示，每个组件有各自的输入输出节点（如a1、a2等），其输入输出特性如箭头所示。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"(Image: 图 1) ","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#.1-内部过程","page":"Ai4EComponentLib.jl设计理念","title":"2.1 内部过程","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"各模块内部有自身的特性。即输入输出量之间在节点内部产生的反应与物质信息交换的过程。在组件与组件之间是各不相同的。这些机制反映了模型对现实实体的映射，是不同的数学物理现象的抽象。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"例如上图组件A的a1、a2、a3。在组件内部，它们有特定的数学关系。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"f(a1a2a3) = 0","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"在这里f(a1a2a3)是一种通用的函数形式，它可以是微分方程，也可以是代数方程。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"例如，对于电阻组件，同样的电压差加在一个不同电阻的两端，流过的电流大小不同。若电阻是随时间变化的，那么系统的电流也是随时间变化的。“不同的电阻”与“随时间变化的电阻”都是组件的特性，在设计组件时，通过不同的方程f来描述。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"这些方程就决定了“物质能量流动”流经组件时的变化。一旦系统中的组件确定了，整个系统的特性就能够通过这些组件确定下来。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#.2-外部连接","page":"Ai4EComponentLib.jl设计理念","title":"2.2 外部连接","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"在构建系统连接时，我们关注点在于连接点的物质和能量。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"例如电路系统。电路系统的a2作为组件的出口，电流与电势值是必要的属性。同时，每个组件的进出口都存在电流与电势。所以，在电路系统中，电流与电势是连接系统的“物质流”。\n例如水流管道系统（不考虑势能）。管道系统的a2作为组件的出口，水流的压力与流速是必要的属性。每个组件的进出口都存在水压与流速属性。所以，在管道系统中，水压与流速连接系统的“物质流”。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"具体的物质流动关系，我们需要根据特性系统的数学模型来构建。例如，电路系统中的基尔霍夫定律，管道流动的伯努利方程。控制方程是描述系统的基础。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"在外部的连接特性中，一般都必须遵循守恒定律——能量守恒与质量守恒：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"leftbeginarrayl\na 2=b 1  b 3=c 2 a 3=c 1\nendarrayrighttag1","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"对于状态量，如电压、水压、气体压力。一般有：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"leftbeginarrayl\na 2=b 1  b 3=c 2 a 3=c 1\nendarrayrighttag2","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"对于过程量，如电流、水流量、气体流量。一般有（规定流入为正，流出为负）：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"leftbeginarrayl\na 2+b 1=0  b 3+c 2 =0a 3+c 1=0\nendarrayrighttag3","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#系统实例","page":"Ai4EComponentLib.jl设计理念","title":"3 系统实例","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/#.1-不可压缩管道系统","page":"Ai4EComponentLib.jl设计理念","title":"3.1 不可压缩管道系统","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"当管道中液体为不可压缩流体时，系统的控制方程为伯努利方程。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"fracprho g +fracv^22g  + h=text  constant  tag4","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其中，p是压力，v是速度，h是高度。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"写成流量形式则有，","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"fracprho g +frac8q^2pi^2D^4g + h=mathrmconstant tag5","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其中，p是压力，q是流量，D是管道直径，h是高度。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"伯努利方程描述的是管道内部液体流动的能量守恒定律。组件的内部过程是能量的增加或减少。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#.1.1-管道组件","page":"Ai4EComponentLib.jl设计理念","title":"3.1.1 管道组件","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"对于一个直管道，组件内部一般有沿程阻力损失与局部阻力损失。当液体从管道一端流向另一端时，液体的总能量减小。沿程阻力损失与局部阻力损失是管道组件的内部过程。其数学方程为：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"fracp_inrho g +frac8q_in^22pi^2D^4g + z_in=\nfracp_outrho g +frac8q_out^22pi^2D^4g + z_out+h_f+h_mtag6","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其中，下标_in代表管道进口，_out代表管道出口，h_f表示沿程阻力损失，h_m表示局部阻力损失。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"沿程阻力损失方程为：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"h_f = ffracLD frac8q^2pi^2D^4gtag7","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其中，f为摩擦因数，L为管道长度，D为管道直径。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"局部阻力损失方程为：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"h_m = K frac8q^2pi^2D^4gtag8","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其中，K为局部阻力系数。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"管道的外部连接主要为压力与流量(高度也是，暂不考虑)。压力是状态量，流量是过程量。在两个组件a,b之间，有：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"p_a=p_bq_a+q_b=0","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#.1.2-离心泵组件","page":"Ai4EComponentLib.jl设计理念","title":"3.1.2 离心泵组件","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"与管道组件类型，离心泵组件的内部过程是为流体增加能量。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"fracp_inrho g +frac8q_in^22pi^2D^4g + z_in=\nfracp_outrho g +frac8q_out^22pi^2D^4g + z_out+H_ttag9","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其中，H_t表示流经离心泵增加的能量。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"H_t=frac(romega)^2g-fracomega cotbeta 2pi bgQ=c_0omega^2-c_1omega Q=a_0-a_1Qtag10","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其中，a_0a_1代表水泵特性参数，方程10实际上是水泵的理论扬程流量曲线。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#.1.3-组件与系统","page":"Ai4EComponentLib.jl设计理念","title":"3.1.3 组件与系统","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"构建系统的水泵、管道等主要组件之前，建立ModelingToolkit中的Connector（Connector中的变量在管道系统中为压力与流量）。代码仓库中有详尽的代码可以查看。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"# Component: SimplePipe(pipe with fixed friction factor `f`)\nfunction SimplePipe(; name, L=10.0, D=25E-3, f=0.01, ρ=1.0E3, zin=0.0, zout=0.0, K_inside=0.0)\n    @named in = PipeNode(z=zin)\n    @named out = PipeNode(z=zout)\n    ps = @parameters D = D L = L f = f K_inside = K_inside\n    eqs = [\n        _NodeEnergy(in, D, ρ) ~ _NodeEnergy(out, D, ρ) + _h_f(in, f, L, D) + _h_m(in, K_inside, D)\n        0 ~ in.q + out.q\n    ]\n    compose(ODESystem(eqs, t, [], ps, name=name), in, out)\nend\n\n# Component: CentrifugalPump\nfunction CentrifugalPump(; name, D=25E-3, ω=2500, c_0=4.4e-4, c_1=5.622, ρ=1.0E3)\n    @named in = PipeNode()\n    @named out = PipeNode()\n    a_0 = c_0 * abs2(ω * 2π / 60)\n    a_1 = c_1 * ω * 2π / 60\n    ps = @parameters D = D\n    eqs = [\n        _NodeEnergy(in, D, ρ) + a_0 - a_1 * abs(in.q) ~ _NodeEnergy(out, D, ρ)\n        0 ~ in.q + out.q\n    ]\n    compose(ODESystem(eqs, t, [], ps, name=name), in, out)\nend\n\n# Component: Sink_P\nfunction Sink_P(; name, p=101325)\n    @named port = PipeNode(z=0.0)\n    eqs = [\n        port.p ~ p\n    ]\n    compose(ODESystem(eqs, t, [], [], name=name), port)\nend\n","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"由以上组件构建如下系统则变得简单快捷。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"(Image: )","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"@named Pump = CentrifugalPump(ω=5000)\n@named A = Sink_P()\n@named B = Sink_P()\n\nsystem = [A, B, Pump]\n\n@named Pipe1 = SimplePipe(L=2.0);\npush!(system, Pipe1);\n@named Pipe2 = SimplePipe(L=3.0);\npush!(system, Pipe2);\n@named Pipe3 = SimplePipe(L=7.0);\npush!(system, Pipe3);\n@named Pipe4 = SimplePipe(L=9.0);\npush!(system, Pipe4);\n@named Pipe5 = SimplePipe(L=5.0);\npush!(system, Pipe5);\n@named Pipe6 = SimplePipe(L=4.0);\npush!(system, Pipe6);\n@named Pipe7 = SimplePipe(L=5.0);\npush!(system, Pipe7);\n@named Pipe8 = SimplePipe(L=1.0);\npush!(system, Pipe8);\n@named Pipe9 = SimplePipe(L=10.0);\npush!(system, Pipe9);\n@named Pipe10 = SimplePipe(L=2.0);\npush!(system, Pipe10);\n@named Pipe11 = SimplePipe(L=2.0);\npush!(system, Pipe11);\n@named Pipe12 = SimplePipe(L=3.0);\npush!(system, Pipe12);\n@named Pipe13 = SimplePipe(L=12.0);\npush!(system, Pipe13);\n@named Pipe14 = SimplePipe(L=1.0);\npush!(system, Pipe14);\n@named Pipe15 = SimplePipe(L=2.0);\npush!(system, Pipe15);\n@named Pipe16 = SimplePipe(L=3.0);\npush!(system, Pipe16);\n@named Pipe17 = SimplePipe(L=6.0);\npush!(system, Pipe17);\n@named Pipe18 = SimplePipe(L=6.0);\npush!(system, Pipe18);\n@named Pipe19 = SimplePipe(L=6.0);\npush!(system, Pipe19);\n@named Pipe20 = SimplePipe(L=1.0);\npush!(system, Pipe20);\n@named Pipe21 = SimplePipe(L=1.0);\npush!(system, Pipe21);\n@named Pipe22 = SimplePipe(L=7.0);\npush!(system, Pipe22);\n@named Pipe23 = SimplePipe(L=3.0);\npush!(system, Pipe23);\n@named Pipe24 = SimplePipe(L=3.0);\npush!(system, Pipe24);\n@named Pipe25 = SimplePipe(L=2.0);\npush!(system, Pipe25);\n\neqs = [\n  connect(A.port, Pump.in)\n  connect(Pump.out, Pipe1.in)\n  connect(Pipe1.out, Pipe2.in, Pipe5.in)\n  connect(Pipe2.out, Pipe3.in, Pipe6.in)\n  connect(Pipe3.out, Pipe4.in, Pipe7.in)\n  connect(Pipe4.out, Pipe10.out, Pipe14.in)\n  connect(Pipe5.out, Pipe11.in, Pipe12.in)\n  connect(Pipe6.out, Pipe8.in, Pipe9.in)\n  connect(Pipe7.out, Pipe9.out, Pipe10.in)\n  connect(Pipe12.out, Pipe8.out, Pipe13.in)\n  connect(Pipe13.out, Pipe14.out, Pipe15.in)\n  connect(Pipe11.out, Pipe19.in, Pipe16.in)\n  connect(Pipe16.out, Pipe17.in, Pipe20.in)\n  connect(Pipe17.out, Pipe18.in, Pipe21.in)\n  connect(Pipe18.out, Pipe15.out, Pipe22.in)\n  connect(Pipe19.out, Pipe20.out, Pipe23.in)\n  connect(Pipe21.out, Pipe22.out, Pipe24.in)\n  connect(Pipe23.out, Pipe24.out, Pipe25.in)\n  connect(B.port, Pipe25.out)\n]\n","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#.2-热力循环系统","page":"Ai4EComponentLib.jl设计理念","title":"3.2 热力循环系统","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/#.1.1-数学内涵","page":"Ai4EComponentLib.jl设计理念","title":"3.1.1 数学内涵","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"热力循环系统中，有几个典型的内部过程。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"等温过程：fracTP = constant\n等压过程：fracTv = constant\n等熵过程：pv^k = constant\n等容过程：pv = constant","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"这些过程中能量变化的体现，最终体现在流体的压力、密度、焓值、熵值、温度上。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"在热力循环中，外部连接正包含这5个状态量。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"在构建热力系统时，尽管可以使用不同内部过程的控制方程，但理论方程和实际始终会有些出入。所以在构建热力系统时，可以利用ModelingToolkit的可拓展性特点——调用外部的物性库。调用物性库可以减小某些理论计算的误差。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"以等温过程为例，过程起点的状态已知。其内部过程的控制方程为：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"T_1=T_2tag11","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"再确定过程终点的另一个状态量，则终点的其他状态可由2个已知状态得到。那么有以下4种组合：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"beginmatrix\n T_2p_2 Rightarrow  s_2D_2h_2\n T_2s_2 Rightarrow  p_2D_2h_2\n T_2D_2 Rightarrow  s_2p_2h_2\n T_2h_2 Rightarrow  s_2p_2D_2\nendmatrixtag12","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"使用CoolProp物性库，输入等式左边的两个参数，就能得到等式右边的任意一个参数。由此，可以外部CoolProp库替换内部方程，完成组件构建。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#.1.2-组件与系统","page":"Ai4EComponentLib.jl设计理念","title":"3.1.2 组件与系统","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"以等焓过程为例，等焓过程中，内部方程为：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"h_1=h_2","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"假如给定一个参数p，则函数chose_equations会自动生成通过ph调用CoolProp得到其他参数数值的代码","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"\nfunction IsoenthalpyProcess(; name, inter_state=\"Q_0\", fluid=\"Water\")\n    @assert inter_state != \"H\" \"IsoenthalpyProcess can't accept H. Please chose another state.\"\n    @named oneport = StreamPort()\n    @unpack Δh, out = oneport\n    eqs = [\n        Δh ~ 0\n    ]\n    push!(eqs, chose_equations(out, inter_state, \"H\", fluid)...)\n    return extend(ODESystem(eqs, t, [], []; name=name), oneport)\nend","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"考虑图3-2描述的再热循环：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"(Image: 图 1)  ","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其代码如下。更加详细的代码请查看代码仓库以及文档。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"@named pump = IsentropicProcess(inter_state=\"P\")\n@named pump_P = DThermalStates(state=\"P\", value=-1.0E5, u0=18.0E6)\n\n@named boiler = IsobaricProcess(inter_state=\"T\")\n@named boiler_T = ThermalStates(state=\"T\", value=550+ 273.15)\n\n@named turbine = IsentropicProcess(inter_state=\"P\")\n@named turbine_P = ThermalStates(state=\"P\", value=3.0e6)\n\n@named reboiler = IsobaricProcess(inter_state=\"T\")\n@named reboiler_T = ThermalStates(state=\"T\", value=450 + 273.15)\n\n@named returbine = IsentropicProcess(inter_state=\"P\")\n@named returbine_P = ThermalStates(state=\"P\", value=4.0e3)\n\n@named condenser = IsothermalProcess(inter_state=\"Q_0\")\n\neqs = [\n  connect(pump.out, boiler.in, pump_P.node)\n  connect(boiler.out, turbine.in, boiler_T.node)\n  connect(turbine.out, reboiler.in, turbine_P.node)\n  connect(reboiler.out, returbine.in, reboiler_T.node)\n  connect(returbine.out, condenser.in, returbine_P.node)\n  connect(condenser.out, pump.in)\n]\n","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#组件化模型的优势","page":"Ai4EComponentLib.jl设计理念","title":"4 组件化模型的优势","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"现在可以做一个小结，组件本质上就是描述变量与变量之间关系的方程。组件内部的控制方程才是最重要的部分，对系统的变化具有决定性意义。外部连接通过补充一个连接方程，描述了组件与组件之间的关系。连接方程对于真正的系统反应不具备决定性，只是辅助系统构建。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"模块化的组件在设计时会把大系统拆解成一个个小组件。这样做的好处是方便用户构建系统，坏处是这些连接变量在系统构建后的系统化简时还要消耗计算资源将它们化简。但事实上，组件化模型带来的收益远超过消耗一点计算资源付出的代价。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"例如，由模块ABC组成的系统视为一个整体X，则ABC成为了X的内部结构，其数学形式也为微分代数方程，与模块ABC的数学形式并没有本质上的区别。唯一的区别在于方程数量的多少。系统X同样拥有对外的三个接口：输入接口x1、x2与输出接口x3。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"(Image: 图 2)  ","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"此时系统与子系统有了完备的闭包概念。假若此时ABC并不是一个最小系统，在ABC的基础之上可进一步细分出更小的模块。那么，可以称ABC为系统X的子系统，系统ABC同样拥有自己的子系统。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"假如ABC一共只有几个方程，那么不需要ABC作为X的子系统来构建。我们直接把X内部的方程手动展平，只包含x1、x2、x3即可。但假如ABC一共有成千上万个方程，假若系统ABC同样拥有自己的子系统。这个时候手动展平还是一种好方法吗？","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"所以，分为内外结构的组件，在组成一个巨型系统时具有重要意义。一旦内部最关键的特性决定了，在今后复杂系统的任何层次节点上，人们的精力都能够集中在系统最关键的问题上——系统（子系统）之间的构建连接关系。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"剩下的化简，就交给计算机吧！若是让人不断的去展平方程，从零构建系统，不也是人力资源的浪费吗？人思维的价值应该体现系统的设计上，而不是展平方程上，虽然浪费一些计算资源，但不也是生产力的提升吗？","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#结论","page":"Ai4EComponentLib.jl设计理念","title":"结论","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"组件化模型在构建时具有它本身的优势。依托于ModelingToolkit符号体系构建的组件化模型则有更加广阔的应用前景。ModelingToolkit自动的回调时间相应、DifferentialEquations的求解器分析可以更加灵活地处理仿真问题，基于ModelingToolkit的OptControl.jl可以将组件模型系统转变利用JuMP求解的最优控制问题。此外还有SciML的参数辨识工具包等等。在Julia社区的强力支撑下，组件化模型不仅仅是用于仿真的方程，它也可以是控制问题中的状态方程模型，优化问题中的约束。组件的本质——方程可以用最基本Julia要素描述——函数。","category":"page"},{"location":"Optimization/JumpMILP/#JuMP混合整数线性优化实例","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"","category":"section"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"tip: Tip\nContents：优化Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Optimization/JumpMILP/#问题简介","page":"JuMP混合整数线性优化实例","title":"问题简介","text":"","category":"section"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"Advent Of Code中有一个很有意思的问题，可用JuMP来求解。同时也是能源系统优化的一个缩影。","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"问题如下：","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"为了收获粘土，你需要专用的粘土收集机器人。要制造任何类型的机器人，你都需要矿石。收集矿石需要带大钻头的矿石收集机器人。幸运的是，你的背包中正好有一个矿石收集机器人，你可以使用它启动整个操作。","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"每个机器人每分钟可以收集1个其资源类型。机器人工厂（也在你的背包中）构建任何类型的机器人也需要一分钟，尽管它在构建开始时会消耗必要的可用资源，同时每分钟最多建造1个机器人。","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"机器人工厂有很多蓝图（问题的输入）你可以选择，但一旦你用蓝图配置好了，你就不能改变它。","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"蓝图1：\n    制造一个矿石机器人（ore robot）消耗4矿石（ore）。\n    制造一个粘土机器人（clay robot）消耗2矿石（ore）。\n    制造一个黑曜石机器人（obsidian robot）消耗3块矿石（ore）和14块粘土（clay）。\n    制造一个紫晶机器人（geode robot）消耗2个矿石（ore）和7个黑曜石（obsidian）。\n\n蓝图2：\n    制造一个矿石机器人消耗2矿石。\n    制造一个粘土机器人消耗3矿石。\n    制造一个黑曜石机器人消耗3块矿石和8块粘土。\n    制造一个紫晶机器人消耗3个矿石和12个黑曜石。","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"优化问题为：如何分配资源去建造机器人，在24分钟后获得最多的紫晶。","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"蓝图1的最优方案为最多获得9个紫晶，具体操作过程为：","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"==第1分钟==\n1台矿石收集机器人收集1个矿石；你现在有1个矿石。\n\n==第2分钟==\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n\n==第3分钟==\n花2矿石开始建造一个粘土收集机器人。\n1台矿石收集机器人收集1个矿石；你现在有1个矿石。\n\n新的粘土收集机器人准备就绪；你现在有一个了。\n\n==第4分钟==\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n1个粘土收集机器人收集1个粘土；你现在有1个粘土。\n\n==第5分钟==\n\n花2矿石开始建造一个粘土收集机器人。\n1台矿石收集机器人收集1个矿石；你现在有1个矿石。\n1个粘土收集机器人收集1个粘土；你现在有2个粘土。\n\n新的粘土收集机器人准备就绪；你现在有两个了。\n\n==第6分钟==\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n2个粘土收集机器人收集2个粘土；你现在有4块粘土。\n\n==第7分钟==\n花2矿石开始建造一个粘土收集机器人。\n1台矿石收集机器人收集1个矿石；你现在有1个矿石。\n2个粘土收集机器人收集2个粘土；你现在有6块粘土。\n\n新的粘土收集机器人准备就绪；你现在有3个了。\n\n==第8分钟==\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n3个粘土收集机器人收集3个粘土；你现在有9块粘土。\n\n==第9分钟==\n1台矿石收集机器人收集1个矿石；你现在有3个矿石。\n3个粘土收集机器人收集3个粘土；你现在有12块粘土。\n\n==第10分钟==\n1台矿石收集机器人收集1个矿石；你现在有4个矿石。\n3个粘土收集机器人收集3个粘土；你现在有15块粘土。\n\n==分钟11==\n花3块矿石和14块粘土开始建造一个黑曜石收集机器人。\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n3个粘土收集机器人收集3个粘土；你现在有4块粘土。\n\n新的黑曜石收集机器人准备就绪；你现在有一个了。\n\n==第12分钟==\n花2矿石开始建造一个粘土收集机器人。\n1台矿石收集机器人收集1个矿石；你现在有1个矿石。\n3个粘土收集机器人收集3个粘土；你现在有7块粘土。\n1个黑曜石收集机器人收集1颗黑曜岩；你现在有1个黑曜石。\n\n新的粘土收集机器人准备就绪；你现在有4个。\n\n==第13分钟==\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n4个粘土收集机器人收集4个粘土；你现在有11块粘土。\n1个黑曜石收集机器人收集1颗黑曜岩；你现在有2颗黑曜石。\n\n==第14分钟==\n1台矿石收集机器人收集1个矿石；你现在有3个矿石。\n4个粘土收集机器人收集4个粘土；你现在有15块粘土。\n1个黑曜石收集机器人收集1颗黑曜岩；你现在有3个黑曜石。\n\n==第15分钟==\n花3块矿石和14块粘土开始建造一个黑曜石收集机器人。\n1台矿石收集机器人收集1个矿石；你现在有1个矿石。\n4个粘土收集机器人收集4个粘土；你现在有5块粘土。\n1个黑曜石收集机器人收集1颗黑曜岩；你现在有4颗黑曜石。\n\n新的黑曜石收集机器人准备就绪；你现在有两个了。\n\n==第16分钟==\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n4个粘土收集机器人收集4个粘土；你现在有9块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有6颗黑曜石。\n\n==第17分钟==\n1台矿石收集机器人收集1个矿石；你现在有3个矿石。\n4个粘土收集机器人收集4个粘土；你现在有13块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有8颗黑曜石。\n\n==第18分钟==\n花2颗矿石和7颗黑曜石开始建造一个紫晶机器人。\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n4个粘土收集机器人收集4个粘土；你现在有17块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有3个黑曜石。\n\n新的紫晶机器人准备就绪；你现在有一个了。\n\n==第19分钟==\n1台矿石收集机器人收集1个矿石；你现在有3个矿石。\n4个粘土收集机器人收集4个粘土；你现在有21块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有5颗黑曜石。\n\n1个紫晶机器人收集1个紫晶；你现在有一个紫晶。\n\n==第20分钟==\n1台矿石收集机器人收集1个矿石；你现在有4个矿石。\n4个粘土收集机器人收集4个粘土；你现在有25块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有7颗黑曜石。\n\n1个紫晶机器人收集1个紫晶；你现在有2个紫晶。\n\n==第21分钟==\n花2颗矿石和7颗黑曜石开始建造一个紫晶机器人。\n1台矿石收集机器人收集1个矿石；你现在有3个矿石。\n4个粘土收集机器人收集4个粘土；你现在有29块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有2颗黑曜石。\n1个紫晶开裂机器人开裂1个大地洞；你现在有3个紫晶。\n\n新的紫晶机器人准备就绪；你现在有两个了。\n\n==第22分钟==\n1台矿石收集机器人收集1个矿石；你现在有4个矿石。\n4个粘土收集机器人收集4个粘土；你现在有33块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有4颗黑曜石。\n2个紫晶机器人收集2个紫晶；你现在有5个紫晶。\n\n==第23分钟==\n1台矿石收集机器人收集1个矿石；你现在有5个矿石。\n4个粘土收集机器人收集4个粘土；你现在有37块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有6颗黑曜石。\n2个紫晶机器人收集2个紫晶；你现在有7个紫晶。\n\n==第24分钟==\n1台矿石收集机器人收集1个矿石；你现在有6个矿石。\n4个粘土收集机器人收集4个粘土；你现在有41块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有8颗黑曜石。\n2个紫晶机器人收集2个紫晶；你现在有9个紫晶。","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"蓝图2最多获得12个紫晶。","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"对于以下蓝图，分别能获得的最多紫晶是多少？","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"Blueprint 1: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 17 clay. Each geode robot costs 4 ore and 20 obsidian.\nBlueprint 2: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 3 ore and 17 clay. Each geode robot costs 3 ore and 8 obsidian.\nBlueprint 3: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 7 clay. Each geode robot costs 4 ore and 13 obsidian.\nBlueprint 4: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 10 clay. Each geode robot costs 3 ore and 14 obsidian.\nBlueprint 5: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 17 clay. Each geode robot costs 3 ore and 16 obsidian.\nBlueprint 6: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 16 clay. Each geode robot costs 2 ore and 15 obsidian.\nBlueprint 7: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 15 clay. Each geode robot costs 2 ore and 15 obsidian.\nBlueprint 8: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 19 clay. Each geode robot costs 2 ore and 18 obsidian.\nBlueprint 9: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 7 clay. Each geode robot costs 2 ore and 19 obsidian.\nBlueprint 10: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 6 clay. Each geode robot costs 3 ore and 16 obsidian.\nBlueprint 11: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 8 clay. Each geode robot costs 3 ore and 19 obsidian.\nBlueprint 12: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 19 clay. Each geode robot costs 2 ore and 12 obsidian.\nBlueprint 13: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 14 clay. Each geode robot costs 4 ore and 17 obsidian.\nBlueprint 14: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 2 ore and 14 obsidian.\nBlueprint 15: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 10 clay. Each geode robot costs 2 ore and 11 obsidian.\nBlueprint 16: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 13 clay. Each geode robot costs 3 ore and 11 obsidian.\nBlueprint 17: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 19 clay. Each geode robot costs 3 ore and 10 obsidian.\nBlueprint 18: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 2 ore and 17 obsidian.\nBlueprint 19: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 11 clay. Each geode robot costs 4 ore and 12 obsidian.\nBlueprint 20: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 7 clay. Each geode robot costs 3 ore and 10 obsidian.\nBlueprint 21: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 13 clay. Each geode robot costs 3 ore and 7 obsidian.\nBlueprint 22: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 15 clay. Each geode robot costs 2 ore and 7 obsidian.\nBlueprint 23: Each ore robot costs 3 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 3 ore and 18 obsidian.\nBlueprint 24: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 18 clay. Each geode robot costs 4 ore and 8 obsidian.\nBlueprint 25: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 3 ore and 14 clay. Each geode robot costs 4 ore and 15 obsidian.\nBlueprint 26: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 3 ore and 9 obsidian.\nBlueprint 27: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 5 clay. Each geode robot costs 3 ore and 7 obsidian.\nBlueprint 28: Each ore robot costs 3 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 11 clay. Each geode robot costs 2 ore and 8 obsidian.\nBlueprint 29: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 12 clay. Each geode robot costs 3 ore and 15 obsidian.\nBlueprint 30: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 10 clay. Each geode robot costs 3 ore and 10 obsidian.","category":"page"},{"location":"Optimization/JumpMILP/#优化问题的数学表达","page":"JuMP混合整数线性优化实例","title":"优化问题的数学表达","text":"","category":"section"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"因为涉及到时间域上的状态改变（本质就是离散），所以需要在求解时间域上的每个时间点上设置一个变量。同时，每个不同种类的矿石也需要设置变量。","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"变量设置：","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"每个种类每个时间点矿石数量，整数\n每个种类每个时间点机器人数量，整数\n每个种类每个时间点是否建造，0或1","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"所以有：","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"\nrobots_ij  in N\nisBuild_ij in 01\nobtains_ij in N\ni in ore clay obsidian geode\nj in 1232324\n","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"优化目标为第24分钟，紫晶最多：","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"\nmax obtains_geode24 \n","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"约束：","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"矿石量等于上一周期的矿石量加上本周期的产出减去本周期的消耗。","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"note: Note\ncosts的每一行是建造不同种机器人消耗的材料个数。costs =  beginbmatrix4 3 2 3  0 0 17 0  0 0 0 16  0 0 0 0endbmatrix例如，第一行为建造4中不同的机器人，分别要消耗4，3，2，3个ore；第二行为建造4中不同的机器人,分别要消耗0，0，17，0个clay：","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"obtains_ij = obtains_ij-1+robots_ij - sum_k^ costs_ik * isBulid_kj","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"上一个周期结束，矿石足够才能在本周期建造机器人","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"obtains_ij-1 geqslant sum_k^ costs_ik * isBulid_kj","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"建造机器人，数量增加","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"robots_ij =  robots_ij-1  + isBulid_ij-1","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"一次只能建造一个机器人","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"sum_k^ isBulid_kj leqslant 1","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"初值条件，没有材料且只有一台矿石机器人：","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"isBulid_i1 = 0 i in ore clay obsidian geode\nobtain_i1 = 0 i in  clay obsidian geode\nrobots_i1 = 0 i in  clay obsidian geode\nobtain_ore1 = 1 \nrobots_ore1 = 1 ","category":"page"},{"location":"Optimization/JumpMILP/#JuMP求解代码","page":"JuMP混合整数线性优化实例","title":"JuMP求解代码","text":"","category":"section"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"using JuMP\nimport HiGHS\n\ninputs = \"\"\"Blueprint 1: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 17 clay. Each geode robot costs 4 ore and 20 obsidian.\nBlueprint 2: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 3 ore and 17 clay. Each geode robot costs 3 ore and 8 obsidian.\nBlueprint 3: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 7 clay. Each geode robot costs 4 ore and 13 obsidian.\nBlueprint 4: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 10 clay. Each geode robot costs 3 ore and 14 obsidian.\nBlueprint 5: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 17 clay. Each geode robot costs 3 ore and 16 obsidian.\nBlueprint 6: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 16 clay. Each geode robot costs 2 ore and 15 obsidian.\nBlueprint 7: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 15 clay. Each geode robot costs 2 ore and 15 obsidian.\nBlueprint 8: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 19 clay. Each geode robot costs 2 ore and 18 obsidian.\nBlueprint 9: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 7 clay. Each geode robot costs 2 ore and 19 obsidian.\nBlueprint 10: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 6 clay. Each geode robot costs 3 ore and 16 obsidian.\nBlueprint 11: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 8 clay. Each geode robot costs 3 ore and 19 obsidian.\nBlueprint 12: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 19 clay. Each geode robot costs 2 ore and 12 obsidian.\nBlueprint 13: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 14 clay. Each geode robot costs 4 ore and 17 obsidian.\nBlueprint 14: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 2 ore and 14 obsidian.\nBlueprint 15: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 10 clay. Each geode robot costs 2 ore and 11 obsidian.\nBlueprint 16: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 13 clay. Each geode robot costs 3 ore and 11 obsidian.\nBlueprint 17: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 19 clay. Each geode robot costs 3 ore and 10 obsidian.\nBlueprint 18: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 2 ore and 17 obsidian.\nBlueprint 19: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 11 clay. Each geode robot costs 4 ore and 12 obsidian.\nBlueprint 20: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 7 clay. Each geode robot costs 3 ore and 10 obsidian.\nBlueprint 21: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 13 clay. Each geode robot costs 3 ore and 7 obsidian.\nBlueprint 22: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 15 clay. Each geode robot costs 2 ore and 7 obsidian.\nBlueprint 23: Each ore robot costs 3 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 3 ore and 18 obsidian.\nBlueprint 24: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 18 clay. Each geode robot costs 4 ore and 8 obsidian.\nBlueprint 25: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 3 ore and 14 clay. Each geode robot costs 4 ore and 15 obsidian.\nBlueprint 26: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 3 ore and 9 obsidian.\nBlueprint 27: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 5 clay. Each geode robot costs 3 ore and 7 obsidian.\nBlueprint 28: Each ore robot costs 3 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 11 clay. Each geode robot costs 2 ore and 8 obsidian.\nBlueprint 29: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 12 clay. Each geode robot costs 3 ore and 15 obsidian.\nBlueprint 30: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 10 clay. Each geode robot costs 3 ore and 10 obsidian.\n\"\"\"\n\ninputs = IOBuffer(inputs)\n\nfunction readData(path=inputs)\n    rawData = readlines(path)\n    rawData = split.(rawData, c -> c == '.' || c == ':')\n    regs = [\n        r\"Blueprint (\\d+)\",\n        r\"costs (\\d+) ore\",\n        r\"costs (\\d+) ore\",\n        r\"costs (\\d+) ore and (\\d+) clay\",\n        r\"costs (\\d+) ore and (\\d+) obsidian\",\n    ]\n    d = Dict{Int,Vector{Vector{Int64}}}()\n    for line in rawData |> eachindex\n        c = map(x -> zeros(Int64, 4), 1:4)\n        r = Vector{Int64}[]\n        for i in 1:5\n            m = match(regs[i], rawData[line][i]).captures\n            m = map(x -> parse(Int64, x), m)\n            push!(r, m)\n        end\n        c[1][1] = r[2][1]\n        c[1][2] = r[3][1]\n        c[1][3] = r[4][1]\n        c[1][4] = r[5][1]\n        c[2][3] = r[4][2]\n        c[3][4] = r[5][2]\n        d[r[1][1]] = c\n    end\n    return d\nend\n\n\nfunction solve_1(costs, periods)\n    model = Model(HiGHS.Optimizer)\n    set_silent(model)\n    names = [\"ore\", \"clay\", \"obsidian\", \"geode\"]\n    # robots为每个机器人的数量，obtains为每个机器人每个周期的产出，isBuild为每个机器人每个周期是否建造\n    @variable(model, robots[names, periods], Int)\n    @variable(model, obtains[names, periods], Int)\n    @variable(model, isBuild[names, periods], Bin)\n    # 矿石量等于上一周期的矿石量加上本周期的产出减去本周期的消耗\n    for (p1, p2) ∈ zip(periods[1:end-1], periods[2:end])\n        @constraint(model, [ind = 1:4], obtains[names[ind], p2] == obtains[names[ind], p1] + robots[names[ind], p2] - sum(costs[ind] .* isBuild[:, p2]))\n    end\n    # 矿石足够才能建造机器人\n    for (p1, p2) ∈ zip(periods[1:end-1], periods[2:end])\n        @constraint(model, [ind = 1:4], obtains[names[ind], p1] >= sum(costs[ind] .* isBuild[:, p2]))\n    end\n    # 建造机器人\n    for (p1, p2) ∈ zip(periods[1:end-1], periods[2:end])\n        @constraint(model, [ind = 1:4], robots[names[ind], p2] == robots[names[ind], p1] + isBuild[names[ind], p1])\n    end\n    # 一次只能建造一个机器人\n    @constraint(model, [i = periods], sum(isBuild[:, i]) <= 1)\n    # 初始条件\n    @constraint(model, [ind = 2:4], robots[names[ind], 1] == 0)\n    @constraint(model, [ind = 1:1], robots[names[ind], 1] == 1)\n    @constraint(model, [ind = 2:4], obtains[names[ind], 1] == 0)\n    @constraint(model, [ind = 1:1], obtains[names[ind], 1] == 1)\n    @constraint(model, [ind = 1:4], isBuild[names[ind], 1] == 0)\n    # 目标函数\n    @objective(model, Max, obtains[\"geode\", lastindex(periods)])\n    optimize!(model)\n    return objective_value(model) |> Int\nend\n\nfunction solve_P1()\n    d = readData()\n    s = String[]\n    for (i, c) in d\n        res = solve_1(c, 1:24)\n        push!(s,\"第$(i)个结果:\"*string(res))\n    end\n    return s\nend\n\nsolve_P1()","category":"page"},{"location":"Optimization/JumpMILP/#小结","page":"JuMP混合整数线性优化实例","title":"小结","text":"","category":"section"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"这个问题重要的特点为：","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"存在时域上的状态转移（能源系统中负荷的变化等等），以及如何用变量之间的关联体现状态转移的关系\n包含整数与布尔变量（设备启停、满足最小需求的设备数量等等）","category":"page"},{"location":"Modeling/neural_network/#数学视角下的神经网络","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"tip: Tip\nContents：Flux，神经网络Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"note: Note\nFlux.jl Julia机器学习包\n著作\nPattern Recognition and Machine Learning - Christopher M. Bishop\n机器学习 - 周志华\nDive into Deep Learning - 阿斯顿·张，李沐\n博文\nApacheCN 人工智能知识树\n机器学习原理\n视频\n吴恩达 deeplearning.ai\n李宏毅 Course-Machine Learning\n前言\npapers with code","category":"page"},{"location":"Modeling/neural_network/#神经网络的数学内涵","page":"数学视角下的神经网络","title":"1 神经网络的数学内涵","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 2)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"对于这样一个简单的神经网络，其中间神经元的激活函数为tanh，输入x与输出y之间的数学表达式为：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"y=w_21tanhleft(w_11x+b_11right)+w_22tanhleft(w_12x+b_12right)+b_2","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"训练的目标为：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"minsum_i=0^n left(y_reali-y_trainiright)^2 tag1-1","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"其中y_reali为实际数据，y_traini为通过模型计算出来的数据。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"如果y也是一个激活函数tanh，经过激活函数后输出，那么数学模型则变为：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"y=tanh(w_21tanhleft(w_11x+b_11right)+w_22tanhleft(w_12x+b_12right)+b_2)+b","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"神经网络的参数训练，则是为了要找到使训练目标最小的一组参数：w_ijb_ij。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"由此可以归纳：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"神经网络的本质是一个关于激活函数的复合函数\n训练的内涵是寻优的过程，内涵是优化问题（回归问题）\n神经网络处理问题的内涵是用复合函数去拟合数据集","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"所以从数学内涵上来说，作为人工智能代表之一的神经网络并没有那么神秘。事实上，它也并没有那么强大！根据其内涵，可以总结出其优缺点。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"优点：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"普适性的优化框架，如BP算法\n模型任意搭建，成熟的工具（Tensorflow等）","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"缺点：包含了拟合的缺点。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"其模型的内涵（机理）不明确，只是从数学的角度逼近真实数据\n容易过拟合","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"下面通过一些实验来说明。","category":"page"},{"location":"Modeling/neural_network/#神经网络的学习特性探究","page":"数学视角下的神经网络","title":"2 神经网络的学习特性探究","text":"","category":"section"},{"location":"Modeling/neural_network/#.1-一维曲线学习","page":"数学视角下的神经网络","title":"2.1 一维曲线学习","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"考虑简单的函数学习问题，用神经网络（1隐藏层2节点，如上图所示，中间层激活函数采用双曲正弦函数）来学习一个一元函数，即单输入单输出网络，一共有7（2*2+2+1）个参数。在数据集中生成中，严格按照二次曲线规律生成，不添加任何扰动。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"采用下面的程序计算，训练10000次，训练结果的均方差为5.52E-5。为了验证学习的效果。在区间010内取一些原函数（y= x^2）上的点，作为测试集。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"using Flux\nusing Flux: train!\nusing Plots\n\nW1 = rand(2,1)\nb1 = rand(2)\nlayer1(x) = W1 * x .+ b1\n\nW2 = rand(1,2)\nb2 = rand(1)\nlayer2(x) = W2 * x .+ b2\n\ng(x) = x^2\n\nmodel(x) = layer2(g.(layer1(x)))[1]\n\nx_train = collect(0:.1:1)\ny_train = x_train.^2\nscatter(x_train,y_train,legend=false)\n\nmodel.(x_train)\nloss(x,y) = Flux.Losses.mse(model.(x),y)\nparameters = [W1,b1,W2,b2]\ndata = [(x_train,y_train)]\nopt = Descent(0.1)\nfor i in 1:5000\n    train!(loss, parameters, data, opt)\nend\nprintln(loss(x_train,y_train))\nbegin\n    scatter(x_train,y_train,legend=false,title=\"x^2\",color=\"red\")\n    plot!(x_train,model.(x_train),color=\"blue\")\nend\n\nbegin\n    x_learned = collect(0.07:0.07:1)\n    scatter!(x_learned,x_learned.^2,legend=false,color=\"green\")\nend","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 3)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"学习的结果如上图，红色点为训练集，以绿色点为测试集。可以认为，学习机很好地找到了在区间010原有数据的“机理”，因为学习结果几乎和原函数一致。这是一个非常漂亮的学习过程！","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"上述学习训练过程的核心特点为：训练集的学习域覆盖了测试集的测试域，它们都在之内010。自然而然地想到，没有学习过的区域呢？比如1020left-1000right这些区间表现会表现得怎么样？","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"begin\n    x_pred = collect(1:.1:2)\n    scatter!(x_pred, x_pred.^2,legend=false,color=\"green\")\n    plot!(x_pred,model.(x_pred),color=\"blue\")\nend\n\nbegin\n    x_pred = collect(-1.0:.1:0)\n    scatter!(x_pred, x_pred.^2,legend=false,color=\"green\")\n    plot!(x_pred,model.(x_pred),color=\"blue\")\nend","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 5)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"在1020left-1000right区间上，结果如图所示。表现为没有“学会”。因为实际值和测试值偏离了。","category":"page"},{"location":"Modeling/neural_network/#.2-内涵探讨","page":"数学视角下的神经网络","title":"2.2 内涵探讨","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"事实上，这个结果应该是意料之中的。上面说过，神经网络学习的本质上是用复合函数逼近。用一个构造的数学函数y去代替数据点二次曲线的实际内涵。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"Tanh的泰勒展开为：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"tanh=x-fracx^35+frac2x^515+o(x^7)","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"在式（1-1）中，学习机除去偏移量b_2还有6个参数，简单认为逼近的精度为tanh泰勒展开的前6项，误差为项为o(x^13)。在数据训练集区间内，o(x^13)可以保证在训练域误差可以很小，但一旦扩展到全实数域，这部分误差是无法避免的。因为其本质的“机理”并不相同。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"上面的问题中，神经网络通过参数优化，逼近了0 10区间内关于x^2的数据特性，可以使得学习机在0 10 完美替代x^2$。在这个区间外，它还是它自己，即tanh。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"所以，神经网络的数学内涵是逼近，其预测世界规律的方法是激活函数。采用统一的方法去逼近任意区间内的数据。所以，从数学的角度，激活函数与神经元个数都体现神经网络结构的逼近能力。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"下图分表表示了激活函数为exp与x^2训练与预测情况。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 6)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 7)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"在0 10内，可以认为神经网络可以代表x^2。而在0 10外，函数走势都是它们“本来的样子”。","category":"page"},{"location":"Modeling/neural_network/#.3-二维曲线学习","page":"数学视角下的神经网络","title":"2.3 二维曲线学习","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"拓展到二维平面拥有相同的规律。采用10节点2隐藏层全连接网络逼近二元函数函数:","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"gleft(xyright)=sinleft(xright)ast c o sleft(yright)   xyinleft(01right)","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"神经网络图与训练结果如下图：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 8)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 9)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"散点代表真实值。平面代表预测平面。可以看到散点图几乎都在平面上，训练效果较好。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 10)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"学习机在xyinleft(02right)的表现如上图所示。红点为训练数据集，黄点为训练集域内的测试集，绿点为训练集外的测试集。可以看到随着预测范围往外扩展，绿点作为测试集与预测平面已经“分道扬镳”。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"这与前面的分析一致，不同之处在于学习机逼近二元函数，逼近的对象是面而不是曲线。再拓展到更高维度的超平面上，神经网络逼近的特性仍然成立。这是由它的数学内涵决定的。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"代码如下。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"using Flux\nusing Flux: train!\nusing Plots\n\nW1 = rand(10,2)\nb1 = rand(10)\nlayer1(x) = W1 * x .+ b1\n\nW2 = rand(10,10)\nb2 = rand(10)\nlayer2(x) = W2 * x .+ b2\n\nW3 = rand(1,10)\nb3 = rand(1)\nlayer3(x) = W3 * x .+ b3\n\nmodel(x) = layer3(tanh.(layer2(tanh.(layer1(x)))))[1]\n\nxs = collect(0:0.1:1.0)\nx_grid = [x for x = xs for y = xs]\na_grid = [y for x = xs for y = xs]\nz_train = cos.(x_grid) .* sin.(a_grid)\nxy = [[x,y] for x in xs for y in xs]\nmodel.(z_train)\n\nloss(x,y) = Flux.Losses.mse(model.(x),y)\nparameters = [W1,b1,W2,b2,W3,b3]\ndata = [(xy,z_train)]\nopt = Descent(0.1)\n\nfor i in 1:1000\n    train!(loss, parameters, data, opt)\nend\nprintln(loss(xy,z_train))\n\n\n\nxs = collect(0:0.1:2.0)\nx_grid = [x for x = xs for y = xs]\na_grid = [y for x = xs for y = xs]\nxy = [[x,y] for x in xs for y in xs]\nz_predic = model.(xy)\nplot(x_grid,a_grid,z_predic, st = :surface)\nscatter!(x_grid,a_grid,cos.(x_grid) .* sin.(a_grid))\n\n\nxs = collect(0:0.1:2.0)\nx_grid = [x for x = xs for y = xs]\na_grid = [y for x = xs for y = xs]\nxy = [[x,y] for x in xs for y in xs]\nz_predic = model.(xy)\nplot(x_grid,a_grid,z_predic, st = :surface)\nxs = collect(0.05:0.1:1.0)\nx_grid = [x for x = xs for y = xs]\na_grid = [y for x = xs for y = xs]\nscatter!(x_grid,a_grid,cos.(x_grid) .* sin.(a_grid),color=\"yellow\",legend=false)\nxs = collect(0:0.1:1.0)\nx_grid = [x for x = xs for y = xs]\na_grid = [y for x = xs for y = xs]\nscatter!(x_grid,a_grid,cos.(x_grid) .* sin.(a_grid),color=\"red\")\nxs = collect(0:0.1:2.0)\nx_grid = [x for x = xs for y = xs if x>=1.0||y>=1.0]\na_grid = [y for x = xs for y = xs if x>=1.0||y>=1.0]\nscatter!(x_grid,a_grid,cos.(x_grid) .* sin.(a_grid),color=\"green\")","category":"page"},{"location":"Modeling/neural_network/#.4-正则化对逼近的影响","page":"数学视角下的神经网络","title":"2.4 正则化对逼近的影响","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"那么正则化的引入有没有改变这一内涵呢？答案是否定的。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"在前面的讨论中，数据集都严格符合函数规律，没有任何误差。在实际的数据集中，不可能由如此理想的情况。而正则项就是对这测量值误差的一种折中处理，神经网络的设计者可以通过正则项来指引网络的优化方向，从人的智能角度规避纯数据带来的“误导”。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"首先，基于y=x^2在0010范围内生成一些点，并且加上随机扰动作为训练集。如下图所示。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 11)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"从散点图依稀可以看出二次函数的影子。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"下面尝试不同的正则化。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"情况1，无正则化：Loss=sum_i=1^Nleft(y_i-fleft(x_iright)right)^2","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 13)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"情况2，正则化大权值逼近y=05：Loss=sum_i=1^Nleft(y_i-fleft(x_iright)right)^2+100ast(fleft(x_iright)-05)^2","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 14)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"情况2，正则化大权值逼近y=x^2：Loss=sum_i=1^Nleft(y_i-fleft(x_iright)right)^2+100ast(fleft(x_iright)-x_i^2)^2","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 16)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"学习机是否克服了“逼近”带来的缺点呢？答案依旧是否定的。在未知域，学习机并没有带来惊喜。如图下图所示，在1020的预测范围内，预测能力也没有得到显著的提升。Loss方程的改变，只是规避了数据观测误差带来的影响，防止神经网络因某些异常点陷入过拟合状态。其并没有改变神经网络架构逼近的数学内涵，所以其仍然不具备学习域外的预测能力，因为其“探索世界的根本方法论”依旧是——tanh。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"但正则项所带来的泛化能力是毋庸置疑的，在遇到特定问题时也许不容易知道数据的“机理”，但是从方法论的进程上来说，正则化已经向“探索未知”迈出了重要的一步。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 17)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"using Flux\nusing Flux: train!\nusing Plots\nusing Statistics\n\nN = 10\nW1 = rand(N,1)\nb1 = rand(N)\nlayer1(x) = W1 * x .+ b1\n\nW2 = rand(1,N)\nb2 = rand(1)\nlayer2(x) = W2 * x .+ b2\n\nmodel(x) = layer2(tanh.(layer1(x)))[1]\n\nx_train = collect(0:.1:1)\ny_train = x_train.^2 .+ rand(length(x_train))*0.2\n\nmodel.(x_train)\nloss(x,y) = 0.1*Flux.Losses.mse(model.(x),y) + mean((model.(x).-x.^2).^2)\nparameters = [W1,b1,W2,b2]\ndata = [(x_train,y_train)]\nopt = Descent(0.1)\nbegin\n    for i in 1:2000\n        train!(loss, parameters, data, opt)\n    end\n    println(loss(x_train,y_train))\nend\n\nbegin\n    scatter(x_train,y_train,legend=false)\n    plot!(x_train,model.(x_train))\nend\n\nbegin\n    x_pred = collect(1:0.1:2)\n    y_pred = model.(x_pred)\n    scatter!(x_pred,x_pred.^2,color=\"green\")\n    plot!(x_pred,y_pred,color=\"green\")\nend\n","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"神经网络的数学内涵是用函数去逼近某个区间内的数据集，其本质的特征是激活函数。这一点决定了在未学习过的未知域，神经网络的预测作用有限。 在纷杂又充满噪声的数据中，正则化是探索数据内涵重要的利器！正则项代表人的智能对学习机学习的一种指导，在已知域内正则化可以剔除噪声发现已知域的本质。这是从完全的数据挖掘以至于陷入过拟合发展状态的重大突破。虽然如此，但正则项没有改变根本的拟合逼近问题。","category":"page"},{"location":"Modeling/neural_network/#启发与讨论","page":"数学视角下的神经网络","title":"3 启发与讨论","text":"","category":"section"},{"location":"Modeling/neural_network/#神经网络应用的启示","page":"数学视角下的神经网络","title":"神经网络应用的启示","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"从上面的分析中，我们可以划分定义两个概念：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"训练域：训练集涉及到的变量区间\n未知域：训练集未涉及到的变量区间","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"可以把测试集分成两类。一类是在训练域中的，一类是在未知域中的。由上面的实验可以推知，在训练域中训练集的临域通过学习机“逼近”了，那么在临域内的测试集就能有很高预测精度。而在未知域中的测试集，那么就只能听天由命。因为训练域之外，学习机就呈现了激活函数本来的面貌。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"对其应用而言，又要引入两个概念：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"结构化问题：传统的机理明确（能用完备的数学方程描述，如欧姆定律：U=I*R）的问题\n非结构化问题：机理不明确的问题（只知变量之间有关联但无明确的机理量化关系，如喝牛奶频率和身高的关系）","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"从以上分析，可以知道。在结构化问题中，神经网络无优势。其优势在于非结构化问题的预测，因为非结构化问题本就机理不明，不明就“暴力拟合”试试呗 :)！虽然上述过程中讨论的都是结构化问题，但是对于非结构化问题也有一定的参考。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"例如，人脸识别。这可以从某种程度上解释人脸学习时为何需要一组端端正正的人脸。图像可以视作高维函数（自变量为RGB值）。一组端正的人脸保证了不管是训练集还是测试集，他们作为“数”的特性的坐标都比较相近，即保证了用来测试的人脸一定是在训练时“见过的”，或者“和见过的非常相近”。类比至上述实验的解释是，采用端正的0 10区间的“人脸”作为训练集，当测试集的人脸也很端正，也在0 10区间内，或者在其“附近”，那么学习机就能准确识别，因为已经学过了。但是，出现了一张“奇怪”的人脸，假设它是在25 30区间内。这没有学过，那就不会！","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"那么，机器学习的应用中可以获得一些启示。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"对于分类问题判别问题，应该用训练集包含更加广泛的训练域，如果训练域涵盖了测试集，那么精度会非常高。类似与高维的图像识别在数据量少的如何做到这一点呢？就需要在特征提取与降维方面下功夫。简单来说是，训练时让学习机见识过了所有的情况，那么测试时再见到，它一定可以处理得很好。如果见识太少，那就只能靠猜。人的经验不就是这样的道理吗？但问题是，在一维0 10区间，我们很容易界定训练域与未知域。在实际问题中，这是很难定义的。例如，怎么量化定义人脸的训练域？仅通过RGB颜色值？似乎不好说。所以，这还有待长远的探索。\n关于预测，若是对于训练域之外的测试集要想准确预测，要么改变tanh能够让激活函数体现出数据发展趋势的“道”；要么提取被学习对象的精髓让激活函数能够成为它的“道”。但预测本来就有巨大的不确定性。在实际问题的非结构性问题中，神经网络拟合的这个“机理”究竟是否是“真实的机理”呢？没人说得清，依旧要靠其它测试集来实践检验！或者，面对一些复杂的问题，通过一系列“猛如虎的操作”（例如池化卷积等等），本质上没有提升神经网络的预测能力，而是通过调参把训练集与测试集的尽可能缩到了处理后的变量训练域内。这样，逼近就有效果了，但这内涵难道不更像是插值处理？所以预测在某些些问题上，本就是一个伪命题。要真正实现预测，一定是机理得以明确，找到了事物最本质的规律之后的“对未知的预测”，而不是基于统计原理的“带插值含义的预测”。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"所以，对于神经网络，我们不需要过于神话。其本质可以看作一个强有力的拟合工具，尤其是在计算机技术飞速发展的今天，神经网络有它巨大的使用价值。但作为工具来说，科学的发展并不依赖于工具。工具只是手段，有些时候我们也应该“不忘初心”，回到对问题本质的结构化性质探索的方向上去。从另一个角度来说，神经网络可以成为结构化性质探索道路上的得力帮手，但是其大概率不能成为决定性因素。若是我们心中对它已经有了一种依赖，或者陷入了某种网络调参的狂热。那么我们是不是应该反思，我们是否陷入了对机器学习的路径依赖，是否忘了探索的真谛——研究问题本身？","category":"page"},{"location":"Modeling/neural_network/#.2-学习的本质","page":"数学视角下的神经网络","title":"3.2 学习的本质","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"人类探索真理的过程，本质上是一个演绎推理、实验验证的过程。对应机器学习，一次训练对应演绎推理，测试集测试对应实验验证。对于人类的科学发展而言，这一探索是螺旋式上升的。从实践到理论，再用理论指导实践，实践结果修正理论，这是马克思科学原理的哲学观。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"在探索与发展的过程中，没有什么是绝对成立的，没有绝对的真理。就像牛顿定律不适用于量子领域，正是在“大误差”中，科学得以修正发展，本质上是一个理论与实践的Loss方程数值不断缩小的过程。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"类比科学发展的本质，在有限的数据集下，机器学习的学习方法或者学习范式还不够具有发展性。机器学习的学习方式更加接近于“一锤子买卖”。学习训练然后测试，没有测试结果指导理论的过程，或者说这一过程是由人来完成的。人根据测试结果的准确性来判断模型是否需要修改提升。目前阶段学习机没有自我驱动的迭代能力，即根据学习的效果来修正学习模型。人类智能的巨大潜力，正是体现在驱动实践理论再实践这一个过程当中。从这哲学的角度，这样一种实践理论再实践的学习范式是面对“未知的虚无”最强有力的手段，也是最强大的学习方法。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"学习的本质，在机器学习中更加接近元学习的思想。即在学习模型中提供根据结果修正模型参数的接口，让学习机能够在Loss方程的指引下，自我迭代。目前可能是调整超参数，未来可能就能发展成为自我修正网络结构、激活函数等学习模型的框架结构。从计算的本质来说，这一过程对应Code Generation。目前普遍的学习方法是修改模型参数，元学习的学习方法是学习机能够修改模型代码。对应的实现方式为元编程——用代码写代码。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"目前来说元编程的技术实现完全没有问题，Julia语言中就有成熟高效的元编程方式。元学习的技术实现不是问题。但从它的学习过程可以轻易推断，元学习的难点在于Loss方程的量化指标。由损失到参数，是在数的领域。而由损失到网络结构，这不是一个可以直接跨越的鸿沟。在它们中间，需要架起一座由数到结构的桥梁，也就是变成一个可计算的问题。要实现这一点，还需要长时间的探索。","category":"page"},{"location":"Optimization/DE_Estim/#微分方程参数辨识实例","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"section"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"tip: Tip\nContents：微分方程参数辨识、优化、DiffEqParamEstimContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"note: Note\nDEPE = DiffEqParamEstim.jl(Differential Equation Parameters Estimate)DiffEqParamEstim.jl是计算微分方程参数估计的软件包。","category":"page"},{"location":"Optimization/DE_Estim/#微分方程参数辨识问题","page":"微分方程参数辨识实例","title":"微分方程参数辨识问题","text":"","category":"section"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"在JuMP非线性参数辨识实例与MTK非线性参数辨识实例中介绍了参数辨识问题的形式与求解工具。求解的问题的数学形式为一般方程：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"y = ax^2+sin(bx)a=15b=08","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"DEPE则是针对另外一种数学形式进行参数辨识求解的工具包——微分方程形式。例如，如下问题：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"fracdydt = at^2+sin(bt)a=15b=08","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"对于这样一个微分问题。假设我们并不知道参数ab的值是多少。同样只能过实验和测量获得对应时间点上y的观测值。参数辨识需要解决的问题是：根据t，y观测值。反推出ab的值。与前面解决的问题不同的是，它是微分方程形式。相同的是，它们的核心逻辑是“优化”。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"要求解这样一个含有微分方程的参数辨识问题，可以很自然地想到：将微分方程的原函数求出来，再进行常规方程的参数辨识，问题就解决了。但是这有一个前提——能够求出原函数。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"DEPE的解决方式是，直接将微分方程离散，通过离散后的节点直接构造优化问题，进行求解。这样就避免了求解原函数问题。","category":"page"},{"location":"Optimization/DE_Estim/#离散的概念","page":"微分方程参数辨识实例","title":"离散的概念","text":"","category":"section"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"离散是微分方程数值解法中的一个概念。例如，求解：fracdydt = ytin(01)","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"具体的方法是在tin(01)选特定步长的点，假如选定步长为0.1，那么有：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"t_0=0t_1=01t_2=02t_10=10","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"同时，对于函数y，有","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"y_n-y_n-1 = y_n-1 * 01nin01210","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"所以，对于微分方程问题，就转为了求y_0至y_10的值，也就是求出具体时间点上的函数值。问题就由一个连续的方程变成了有限个点上的函数值，这个过程就成为离散。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"数值求解算法的精度与离散的方法有紧密关系。上面的离散方式可以换成：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"y_n-y_n-1 = y_n * 01nin01210","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"区别不过不过是等式右端取y_n-1还是y_n的区别。但却是两种不同的方法——向前与向后差分，求解的精度也不一样。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"此外，求解的精度还与步长等因素相关。更多理论，可以查阅《数值分析》一书。","category":"page"},{"location":"Optimization/DE_Estim/#微分参数辨识的优化表达","page":"微分方程参数辨识实例","title":"微分参数辨识的优化表达","text":"","category":"section"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"回到问题fracdydt = at^2+sin(bt)，已知系列观测值：y_real那么优化问题的数学表达为：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"undersetabminsum_i=0^n(y_reali-y_i)^2sthspace5mmy_i+1-y_i=at_i^2+sin(bt_i)","category":"page"},{"location":"Optimization/DE_Estim/#加热器实例","page":"微分方程参数辨识实例","title":"加热器实例","text":"","category":"section"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"现有一个加热系统，由加热器、温度传感器、散热器构成。那么其控制方程为：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"mcfracdTdt=(-Sh(T-T_out)+Q)*u(t-t_0)","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"可以简单理解为：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"温度变化=加热-散热*延迟函数","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"经过化简之后：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"beginarrayc\nfracd Td t=left(-fracTa+fracbaright) * u(t-c) \nu(t-c)=f(x)=leftbeginarrayll\n0  x0 1  x geq 0endarrayrightendarray","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"参数辨识的目标是辨识出a，b，c。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"数据（数据在文档最后，以CSV文件格式保存到julia程序文件夹即可）的第二列中为加热功率，在方程模型中我们做了简化。由于功率只有0和100，在方程中我们简化为开关延时函数。所以第二列的原始数据后面并没有使用。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"首先，实际的曲线如下：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"using CSV,DataFrames,Plots\ndata = CSV.read(\"./codetest/data.csv\",DataFrame)\n########根据第一列与第三列数据画出图像#########\nplot(data[:,1],data[:,3]) ","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"(Image: 图 1)  ","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"使用DE作为建模基础建立方程：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"using DifferentialEquations\nfunction fun(a)\n    if a>=0\n        1\n    else\n        0\n    end\nend\nfunction ff(u,p,t)\n    -u * fun( t- p[3])/p[1] + p[2] * fun( t- p[3])/p[1]\nend","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"这里采用了简写方式，省略了du，只包含微分方程右边的部分，因为只有一个微分变量所以可以简写。\nFun表示函数u的作用，其本质是单位阶跃函数。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"定义参数等要素：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"u0=3.6\ntspan = (0.0,3000.0)\np = [1.0,1.0,1.0]\nprob = ODEProblem(ff,u0,tspan,p)","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"需要留意p的值，这里p为选定的初始值。p的最终值是需要通过优化才能得到。优化目标为找到一组p，使得Loss方程的数值最小。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"如果按照初值p = [1.0,1.0,1.0]求解，则可以得到如下结果：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"sol = solve(prob, Tsit5())\nplot(sol)","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"(Image: 图 2)  ","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"可以看到，相去甚远！说明这个初值与真实值相差很远。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"通过DiffEqParamEstim构建优化模型：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"using DiffEqParamEstim\nrealdata = data[:,3]\nt= data[:,1]\ncost_function = build_loss_objective(prob, Tsit5(), L2Loss(t, realdata),\n    maxiters=10000, verbose=false)","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"其中，","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"realdata是实际过程中的温度值向量\nt是实际采样过程中的温度点\nbuildlossobjective 直接构建了Loss方程，其方法是L2Loss，即差的平方和。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"求解优化问题：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"using Optim\nresult_bfgs = Optim.optimize(cost_function, [1.0, 1.0, 1.0])\nprint(result_bfgs.minimizer)\n","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"Optim.optimize就是求解器，能求cost_function的最小值。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"得到结果：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"(Image: 图 3)  ","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"画图测试优化结果：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"u0=3.6\ntspan = (0.0,3000.0)\np = [779.0,49.0,-652.0]\nprob = ODEProblem(ff,u0,tspan,p)\nsol = solve(prob, Tsit5())\nplot(sol)","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"(Image: 图 4)  ","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"似乎结果差得有点远！","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"再次优化：这是因为初值对优化问题造成的影响。由于初值与目标相去甚远，所以结果有些出入。p[3]应该是正数。把优化初值的第三项改为正数。再次优化","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"result_bfgs = Optim.optimize(cost_function, [773.0,49.0,652.0])\nprint(result_bfgs.minimizer)","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"(Image: 图 5)  ","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"在这个结果下，画出来的图像如图：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"(Image: 图 6)  ","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"这是一个让人满意的结果！","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"note: Note\n多次优化是优化中一种常见的策略。某些问题的优化结果可能是一个局部最优解，这并不代表结果是错误的。所以，当优化结果不满意时，可以选择不同的初值进行优化求解。当初值离最优值越近，结果越准确。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"全部代码：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"using CSV, DataFrames, Plots\ndata = CSV.read(\"./codetest/data.csv\", DataFrame)\ndata[!, 3]\nplot(data[:, 1], data[:, 3]) #画出图像\n\nusing DifferentialEquations\nfunction fun(a)\n    if a >= 0\n        1\n    else\n        0\n    end\nend\nfunction ff(u, p, t)\n    -u * fun(t - p[3]) / p[1] + p[2] * fun(t - p[3]) / p[1]\nend\n\nu0 = 3.6\ntspan = (0.0, 3000.0)\np = [1.0, 1.0, 1.0]\nprob = ODEProblem(ff, u0, tspan, p)\n\nsol = solve(prob, Tsit5())\nplot(sol)\n\nusing DiffEqParamEstim\nrealdata = data[:, 3]\nt = data[:, 1]\ncost_function = build_loss_objective(prob, Tsit5(), L2Loss(t, realdata),\n    maxiters=10000, verbose=false)\n\nusing Optim\nresult_bfgs = Optim.optimize(cost_function, [1.0, 1.0, 1.0])\nprint(result_bfgs.minimizer)\n\nresult_bfgs = Optim.optimize(cost_function, [773.0,49.0,652.0])\nprint(result_bfgs.minimizer)\n\n\nu0=3.6\ntspan = (0.0,3000.0)\np = [267.0,45.0,343.0]\nprob = ODEProblem(ff,u0,tspan,p)\nsol = solve(prob, Tsit5())\nplot(sol)","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"原始数据：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"Time (min),Valve Position (% open),Temperature (degC)\n0,0,3.6\n5,0,3.7\n10,0,3.6\n15,0,3.7\n20,0,3.6\n25,0,3.7\n30,0,3.7\n35,0,3.6\n40,0,3.6\n45,0,3.6\n50,0,3.6\n55,0,3.7\n60,0,3.7\n65,0,3.7\n70,0,3.7\n75,0,3.5\n80,0,3.6\n85,0,3.7\n90,0,3.5\n95,0,3.6\n100,0,3.5\n105,0,3.7\n110,0,3.6\n115,0,3.7\n120,0,3.6\n125,0,3.7\n130,0,3.7\n135,0,3.7\n140,0,3.7\n145,0,3.7\n150,0,3.7\n155,0,3.5\n160,0,3.6\n165,0,3.6\n170,0,3.6\n175,0,3.7\n180,0,3.6\n185,0,3.6\n190,0,3.7\n195,0,3.6\n200,0,3.5\n205,0,3.6\n210,0,3.5\n215,0,3.7\n220,0,3.6\n225,0,3.5\n230,0,3.7\n235,0,3.7\n240,0,3.6\n245,0,3.7\n250,0,3.5\n255,0,3.7\n260,0,3.7\n265,0,3.6\n270,0,3.6\n275,0,3.7\n280,0,3.7\n285,0,3.7\n290,0,3.5\n295,0,3.7\n300,0,3.5\n305,0,3.5\n310,0,3.7\n315,0,3.6\n320,0,3.7\n325,0,3.6\n330,0,3.7\n335,0,3.5\n340,0,3.5\n345,0,3.5\n350,0,3.7\n355,0,3.7\n360,0,3.6\n365,0,3.6\n370,0,3.7\n375,0,3.5\n380,0,3.7\n385,0,3.5\n390,0,3.7\n395,0,3.6\n400,100,3.7\n405,100,14.9\n410,100,18.2\n415,100,19.2\n420,100,19.9\n425,100,20.1\n430,100,20.8\n435,100,21.0\n440,100,21.3\n445,100,21.4\n450,100,21.5\n455,100,22.0\n460,100,21.8\n465,100,21.8\n470,100,21.9\n475,100,21.5\n480,100,21.7\n485,100,21.2\n490,100,20.7\n495,100,20.3\n500,100,20.3\n505,100,20.1\n510,100,21.2\n515,100,22.8\n520,100,23.9\n525,100,24.2\n530,100,24.9\n535,100,25.7\n540,100,26.4\n545,100,26.5\n550,100,26.7\n555,100,27.3\n560,100,27.6\n565,100,27.5\n570,100,27.5\n575,100,27.7\n580,100,27.8\n585,100,27.8\n590,100,27.9\n595,100,27.9\n600,100,28.0\n605,100,28.2\n610,100,28.2\n615,100,28.5\n620,100,28.7\n625,100,28.9\n630,100,29.0\n635,100,29.2\n640,100,29.7\n645,100,29.8\n650,100,30.1\n655,100,30.4\n660,100,30.5\n665,100,30.9\n670,100,31.6\n675,100,31.8\n680,100,32.2\n685,100,32.7\n690,100,32.8\n695,100,33.0\n700,100,33.4\n705,100,33.8\n710,100,34.0\n715,100,34.6\n720,100,34.8\n725,100,35.2\n730,100,35.4\n735,100,35.7\n740,100,36.0\n745,100,36.6\n750,100,36.8\n755,100,36.9\n760,100,37.3\n765,100,37.5\n770,100,37.7\n775,100,37.9\n780,100,37.9\n785,100,38.3\n790,100,38.2\n795,100,38.4\n800,100,38.7\n805,100,38.8\n810,100,39.1\n815,100,39.2\n820,100,39.2\n825,100,39.4\n830,100,39.4\n835,100,39.3\n840,100,39.5\n845,100,39.5\n850,100,39.7\n855,100,39.7\n860,100,39.8\n865,100,40.1\n870,100,39.9\n875,100,40.1\n880,100,40.0\n885,100,40.2\n890,100,40.1\n895,100,40.3\n900,100,40.3\n905,100,40.2\n910,100,40.1\n915,100,40.1\n920,100,40.1\n925,100,40.2\n930,100,40.3\n935,100,40.4\n940,100,40.4\n945,100,40.8\n950,100,40.8\n955,100,40.8\n960,100,40.7\n965,100,40.9\n970,100,41.0\n975,100,41.2\n980,100,41.3\n985,100,41.3\n990,100,41.3\n995,100,41.3\n1000,100,41.4\n1005,100,41.7\n1010,100,41.7\n1015,100,41.6\n1020,100,41.8\n1025,100,41.6\n1030,100,41.7\n1035,100,41.8\n1040,100,41.9\n1045,100,42.0\n1050,100,42.1\n1055,100,42.0\n1060,100,42.2\n1065,100,42.1\n1070,100,42.4\n1075,100,42.4\n1080,100,42.6\n1085,100,42.7\n1090,100,42.7\n1095,100,42.9\n1100,100,43.0\n1105,100,43.0\n1110,100,43.1\n1115,100,43.2\n1120,100,43.4\n1125,100,43.4\n1130,100,43.5\n1135,100,43.4\n1140,100,43.5\n1145,100,43.8\n1150,100,43.8\n1155,100,43.8\n1160,100,44.0\n1165,100,44.0\n1170,100,44.0\n1175,100,44.1\n1180,100,44.1\n1185,100,44.2\n1190,100,44.3\n1195,100,44.2\n1200,100,44.4\n1205,100,44.4\n1210,100,44.3\n1215,100,44.4\n1220,100,44.2\n1225,100,44.2\n1230,100,44.0\n1235,100,44.1\n1240,100,43.9\n1245,100,43.9\n1250,100,43.8\n1255,100,44.0\n1260,100,44.0\n1265,100,43.8\n1270,100,43.9\n1275,100,43.9\n1280,100,44.0\n1285,100,44.0\n1290,100,44.1\n1295,100,44.1\n1300,100,44.2\n1305,100,43.9\n1310,100,43.9\n1315,100,44.0\n1320,100,43.8\n1325,100,43.9\n1330,100,43.8\n1335,100,43.9\n1340,100,43.8\n1345,100,43.6\n1350,100,43.7\n1355,100,43.7\n1360,100,43.8\n1365,100,43.7\n1370,100,43.6\n1375,100,43.8\n1380,100,43.6\n1385,100,43.7\n1390,100,43.4\n1395,100,43.4\n1400,100,43.5\n1405,100,43.4\n1410,100,43.4\n1415,100,43.6\n1420,100,43.7\n1425,100,43.6\n1430,100,43.6\n1435,100,43.5\n1440,100,43.5\n1445,100,43.6\n1450,100,43.6\n1455,100,43.5\n1460,100,43.4\n1465,100,43.6\n1470,100,43.6\n1475,100,43.6\n1480,100,43.6\n1485,100,43.7\n1490,100,43.7\n1495,100,43.7\n1500,100,43.7\n1505,100,43.6\n1510,100,43.6\n1515,100,43.7\n1520,100,43.7\n1525,100,43.5\n1530,100,43.5\n1535,100,43.7\n1540,100,43.8\n1545,100,43.7\n1550,100,43.8\n1555,100,43.8\n1560,100,43.8\n1565,100,43.8\n1570,100,43.9\n1575,100,44.0\n1580,100,43.8\n1585,100,43.9\n1590,100,44.0\n1595,100,44.1\n1600,100,44.1\n1605,100,44.1\n1610,100,44.2\n1615,100,44.0\n1620,100,44.1\n1625,100,44.0\n1630,100,44.0\n1635,100,44.1\n1640,100,44.1\n1645,100,44.2\n1650,100,44.2\n1655,100,44.2\n1660,100,44.2\n1665,100,44.1\n1670,100,44.3\n1675,100,44.3\n1680,100,44.3\n1685,100,44.5\n1690,100,44.5\n1695,100,44.5\n1700,100,44.5\n1705,100,44.5\n1710,100,44.6\n1715,100,44.7\n1720,100,44.5\n1725,100,44.7\n1730,100,44.7\n1735,100,44.9\n1740,100,44.8\n1745,100,45.0\n1750,100,44.8\n1755,100,44.9\n1760,100,44.9\n1765,100,45.0\n1770,100,45.1\n1775,100,45.1\n1780,100,45.1\n1785,100,45.2\n1790,100,45.1\n1795,100,45.2\n1800,100,45.2\n1805,100,45.3\n1810,100,45.3\n1815,100,45.2\n1820,100,45.3\n1825,100,45.2\n1830,100,45.2\n1835,100,45.3\n1840,100,45.3\n1845,100,45.2\n1850,100,45.3\n1855,100,45.2\n1860,100,45.4\n1865,100,45.4\n1870,100,45.2\n1875,100,45.4\n1880,100,45.3\n1885,100,45.4\n1890,100,45.4\n1895,100,45.2\n1900,100,45.1\n1905,100,45.2\n1910,100,45.1\n1915,100,45.3\n1920,100,45.1\n1925,100,45.2\n1930,100,45.2\n1935,100,45.0\n1940,100,45.0\n1945,100,45.1\n1950,100,45.2\n1955,100,45.0\n1960,100,45.2\n1965,100,45.3\n1970,100,45.2\n1975,100,45.3\n1980,100,45.1\n1985,100,45.2\n1990,100,45.3\n1995,100,45.3\n2000,100,45.3\n2005,100,45.3\n2010,100,45.2\n2015,100,45.3\n2020,100,45.1\n2025,100,45.3\n2030,100,45.2\n2035,100,45.2\n2040,100,45.4\n2045,100,45.2\n2050,100,45.3\n2055,100,45.4\n2060,100,45.5\n2065,100,45.4\n2070,100,45.4\n2075,100,45.3\n2080,100,45.4\n2085,100,45.3\n2090,100,45.5\n2095,100,45.4\n2100,100,45.5\n2105,100,45.3\n2110,100,45.5\n2115,100,45.5\n2120,100,45.5\n2125,100,45.3\n2130,100,45.4\n2135,100,45.4\n2140,100,45.4\n2145,100,45.5\n2150,100,45.3\n2155,100,45.5\n2160,100,45.4\n2165,100,45.5\n2170,100,45.3\n2175,100,45.5\n2180,100,45.5\n2185,100,45.5\n2190,100,45.5\n2195,100,45.4\n2200,100,45.5\n2205,100,45.3\n2210,100,45.4\n2215,100,45.4\n2220,100,45.5\n2225,100,45.3\n2230,100,45.3\n2235,100,45.4\n2240,100,45.5\n2245,100,45.5\n2250,100,45.5\n2255,100,45.5\n2260,100,45.5\n2265,100,45.5\n2270,100,45.5\n2275,100,45.6\n2280,100,45.5\n2285,100,45.6\n2290,100,45.5\n2295,100,45.5\n2300,100,45.5\n2305,100,45.5\n2310,100,45.6\n2315,100,45.6\n2320,100,45.7\n2325,100,45.5\n2330,100,45.6\n2335,100,45.6\n2340,100,45.7\n2345,100,45.8\n2350,100,45.7\n2355,100,45.7\n2360,100,45.6\n2365,100,45.8\n2370,100,45.7\n2375,100,45.9\n2380,100,45.8\n2385,100,45.8\n2390,100,45.7\n2395,100,45.6\n2400,100,45.9\n2405,100,45.7\n2410,100,45.7\n2415,100,45.7\n2420,100,45.7\n2425,100,45.8\n2430,100,45.9\n2435,100,45.8\n2440,100,45.7\n2445,100,45.9\n2450,100,45.8\n2455,100,45.7\n2460,100,45.9\n2465,100,45.9\n2470,100,45.9\n2475,100,45.9\n2480,100,45.7\n2485,100,45.8\n2490,100,45.7\n2495,100,45.7\n2500,100,45.9\n2505,100,45.8\n2510,100,45.9\n2515,100,45.8\n2520,100,45.7\n2525,100,45.7\n2530,100,45.9\n2535,100,45.8\n2540,100,45.9\n2545,100,45.9\n2550,100,45.9\n2555,100,45.7\n2560,100,46.0\n2565,100,45.8\n2570,100,45.8\n2575,100,45.9\n2580,100,46.0\n2585,100,45.8\n2590,100,46.0\n2595,100,45.8\n2600,100,45.8\n2605,100,45.9\n2610,100,46.0\n2615,100,46.0\n2620,100,45.9\n2625,100,46.0\n2630,100,46.1\n2635,100,45.9\n2640,100,46.0\n2645,100,46.0\n2650,100,45.9\n2655,100,46.0\n2660,100,46.0\n2665,100,46.0\n2670,100,46.0\n2675,100,46.1\n2680,100,46.0\n2685,100,46.1\n2690,100,46.1\n2695,100,46.0\n2700,100,45.9\n2705,100,46.1\n2710,100,45.9\n2715,100,46.1\n2720,100,46.0\n2725,100,46.0\n2730,100,46.1\n2735,100,46.0\n2740,100,46.0\n2745,100,46.0\n2750,100,46.0\n2755,100,46.0\n2760,100,46.0\n2765,100,45.8\n2770,100,46.0\n2775,100,46.0\n2780,100,45.8\n2785,100,45.9\n2790,100,45.9\n2795,100,45.9\n2800,100,45.9\n2805,100,46.0\n2810,100,46.0\n2815,100,46.0\n2820,100,46.0\n2825,100,46.0\n2830,100,45.9\n2835,100,45.9\n2840,100,45.9\n2845,100,45.9\n2850,100,45.9\n2855,100,46.0\n2860,100,46.0\n2865,100,45.9\n2870,100,45.8\n2875,100,45.8\n2880,100,46.1\n2885,100,46.0\n2890,100,46.1\n2895,100,45.9\n2900,100,46.1\n2905,100,45.9\n2910,100,46.1\n2915,100,45.9\n2920,100,46.0\n2925,100,45.9\n2930,100,46.1\n2935,100,46.0\n2940,100,46.0\n2945,100,46.1\n2950,100,46.0\n2955,100,46.0\n2960,100,46.1\n2965,100,46.1\n2970,100,46.0\n2975,100,45.9\n2980,100,46.0\n2985,100,46.1\n2990,100,46.0\n2995,100,46.1\n3000,100,46.0","category":"page"},{"location":"JuliaIntro/4-julia的包管理/#julia的包管理","page":"julia的包管理","title":"julia的包管理","text":"","category":"section"},{"location":"JuliaIntro/4-julia的包管理/#julia包管理概述","page":"julia的包管理","title":"julia包管理概述","text":"","category":"section"},{"location":"JuliaIntro/4-julia的包管理/","page":"julia的包管理","title":"julia的包管理","text":"当您使用Julia进行开发时，包管理是一个重要的方面。Julia提供了内置的包管理器，用于管理和安装各种扩展包。以下是关于Julia的包管理的一些重要信息和常用命令：","category":"page"},{"location":"JuliaIntro/4-julia的包管理/","page":"julia的包管理","title":"julia的包管理","text":"包的安装：要安装一个Julia包，您可以在Julia REPL中进入包管理模式（输入\"]\"并按下回车键），然后使用add命令后跟要安装的包的名称。例如，要安装名为\"Example\"的包，您可以执行以下命令：\n(@v1.6) pkg> add Example\n这将从官方的Julia软件包注册表中下载并安装指定的包。\n包的升级：要升级已安装的包到最新版本，您可以在包管理模式下使用update命令。例如，要升级名为\"Example\"的包，您可以执行以下命令：\n(@v1.6) pkg> update Example\n这将检查已安装包的最新版本并进行升级。\n包的移除：如果您想要移除已安装的包，可以在包管理模式下使用rm命令。例如，要移除名为\"Example\"的包，您可以执行以下命令：\n(@v1.6) pkg> rm Example\n这将从系统中移除指定的包。\n包的激活和使用：一旦您安装了一个包，您可以在Julia的代码中使用它。要在代码中使用已安装的包，只需在您的代码中使用using语句并指定包的名称。例如，要使用名为\"Example\"的包，您可以在代码中添加以下行：\nusing Example\n这将使您可以访问并使用该包中定义的函数、类型和其他功能。\n自定义包环境：Julia的包管理器还支持创建和管理自定义的包环境，以便在不同的项目中使用不同的包版本。您可以在包管理模式下使用activate命令来激活或创建一个新的包环境。例如，要激活名为\"myenv\"的包环境，您可以执行以下命令：\n(@v1.6) pkg> activate myenv\n这将切换到名为\"myenv\"的包环境，使您可以在该环境中管理和安装包。","category":"page"},{"location":"JuliaIntro/4-julia的包管理/","page":"julia的包管理","title":"julia的包管理","text":"这些是Julia的包管理器的一些常用命令和操作。包管理器使您能够轻松地安装、升级和移除Julia包，并为您的项目创建独立的包环境。","category":"page"},{"location":"JuliaIntro/4-julia的包管理/","page":"julia的包管理","title":"julia的包管理","text":"希望这些介绍有助于您了解Julia的包管理！如果您有任何进一步的问题，请随时向我提问。","category":"page"},{"location":"Optimization/systemParaEste_batter/#MTK部分参数辨识实例","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"","category":"section"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"tip: Tip\nContents：MTK模型、优化、DiffEqParamEstimContributor: HYEmail:1171006975@qq.com如有错误，请批评指正。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"note: Note\nDEPE = DiffEqParamEstim.jl(Differential Equation Parameters Estimate)DiffEqParamEstim.jl是计算微分方程参数估计的软件包。","category":"page"},{"location":"Optimization/systemParaEste_batter/#原理","page":"MTK部分参数辨识实例","title":"原理","text":"","category":"section"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"在进行参数辨识的时候，我们往往会遇到一个问题——实验只能测一到两个关键数据，例如温度、电压电流等。但在咱们的ODEsystem中，状态量states往往不止一两个（甚至有几十个），而在DiffEqParamEstim.jl包中，构建损失函数时要求我们导入所有states的实验数据，显然咱们是办不到的。这个时候，咱们有两种解决方案：1.自己重构损失函数，这个方法显然是最高级的，是真正的治标又治本的方法，但是重构损失函数对初学者可能不够友好（比如说我）。因此，在这里给大家介绍第2种解决方案：引入加权值weight，无法通过实验测得的数据，我们可以将其的weight设为0，其他能测得的states设为1。这样，我们相当于重构了损失函数，程序只会根据我们“指定”的那些数据进行参数辨识，效果跟方案1是一样的。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"下面以三星18650锂电池为例，对锂电池的模型参数进行辨识。","category":"page"},{"location":"Optimization/systemParaEste_batter/#等效电路建模","page":"MTK部分参数辨识实例","title":"等效电路建模","text":"","category":"section"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"基于ModelingToolkit，建立Thevenin二阶RC等效电路模型，如下图所示。 该等效电路模型是由开路电压Uoc，欧姆内阻R0和两个RC网络结构组成，U1、U2分别为R1、R2的端电压，UT表示电池的端电压。 (Image: 图1)","category":"page"},{"location":"Optimization/systemParaEste_batter/#构建组件","page":"MTK部分参数辨识实例","title":"构建组件","text":"","category":"section"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"组件总共有两个，一个是锂电池组件，用来模拟锂电池的伏安特性，另一个是充放电控制器组件，用来模拟锂电池的恒流充放电。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"using DiffEqParamEstim, DifferentialEquations, Random, ModelingToolkit, PlotlyJS\nusing OptimizationOptimJL\nusing IfElse: ifelse\nimport RecursiveArrayTools.VectorOfArray\n@variables t\n∂ = Differential(t)\n@connector function Pin(; name)\n    sts = @variables v(t) = 1.0 i(t) = 1.0 [connect = Flow]\n    ODESystem(Equation[], t, sts, []; name=name)\nend\nfunction OnePort(; name)\n    @named p = Pin()\n    @named n = Pin()\n    sts = @variables v(t) = 1.0 i(t) = 1.0\n    eqs = [\n        v ~ p.v - n.v\n        0 ~ p.i + n.i\n        i ~ p.i\n    ]\n    compose(ODESystem(eqs, t, sts, []; name=name), p, n)\nend\nfunction OnePort_key(; name, v_start = 1.0, i_start = 0.0)\n    @named p = Pin()\n    @named n = Pin()\n    sts = @variables v(t) = v_start [irreducible=true] i(t) = i_start [irreducible=true]\n    eqs = [\n        v ~ p.v - n.v\n        0 ~ p.i + n.i\n        i ~ p.i\n    ]\n    compose(ODESystem(eqs, t, sts, []; name=name), p, n)\nend\nfunction Ground(; name)\n    @named g = Pin()\n    eqs = [g.v ~ 0]\n    compose(ODESystem(eqs, t, [], []; name=name), g)\nend\nfunction Lithium_ion_batteries(; name, OCV=3.9998, R0=0.029031, R1=0.00994, R2=0.01408, C1=147.462, C2=902.911)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    sts = @variables v_c1(t) = 0.001 v_c2(t) = 0.001 v_b(t) = 1.0 i_b(t) = 0.0\n    ps = @parameters(\n        R0 = R0,\n        R1 = R1,\n        R2 = R2,\n        C1 = C1,\n        C2 = C2,\n        OCV = OCV,\n    )\n    eqs = [\n        OCV ~ i_b * R0 + v_c1 + v_c2 + v_b\n        i_b ~ C1 * ∂(v_c1) + v_c1 / R1\n        i_b ~ C2 * ∂(v_c2) + v_c2 / R2\n        v ~ v_b\n        i ~ -i_b\n    ]\n    return extend(ODESystem(eqs, t, sts, ps; name=name), oneport)\nend\nfunction charge_controller(; name)\n    @named oneport = OnePort_key()\n    @unpack v, i = oneport\n    equa = ifelse(t <= 10.0,16.0,ifelse(t <= 40.0,0.0,ifelse(t <= 50.0,-16.0,0.0)))\n    eqs = [i ~ equa]\n    return extend(ODESystem(eqs, t, [], []; name=name), oneport)\nend","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"不难发现，系统一共定义有6个参数，分别是欧姆内阻R0,两个RC支路所对应的R1,R2,C1,C2以及开路电压OCV。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"然后，通过连接函数，组建系统","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"@named ground = Ground()\n@named cg = charge_controller()\n@named batter = Lithium_ion_batteries()\neqs = [\n    connect(batter.p, cg.p)\n    connect(batter.n, cg.n, ground.g)\n]\n\n@named OdeFun = ODESystem(eqs, t)\n@named model = compose(OdeFun, [batter, cg, ground])\nsys = structural_simplify(model)\nu0 = [\n    batter.v_c1 => 0.024058864\n    batter.v_c2 => 0.002594792\n    cg.v => 3.928902637\n    cg.i => 0\n    batter.R0 => 0.037517357\n    batter.R1 => 0.020913201\n    batter.R2 => 0.006915906\n    batter.C1 => 4636.08469\n    batter.C2 => 1292.103841\n    batter.OCV => 3.955556293\n]\nprob = ODEProblem(sys, u0, (40.0, 60.0))","category":"page"},{"location":"Optimization/systemParaEste_batter/#导入实验数据","page":"MTK部分参数辨识实例","title":"导入实验数据","text":"","category":"section"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"导入实验数据，并对数据的格式进行一定的处理。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"time = [\n    40.98797751\n    42.00601125\n    42.99980609\n    43.99360093\n    45.01163467\n    46.00542951\n    46.99922436\n    47.9930192\n    50.99864262\n    53.0104712\n    55.99185573]\nreal_data = [\n    4.511920324\n    4.536819172\n    4.551011516\n    4.570183629\n    4.57665733\n    4.5881108\n    4.593588547\n    4.598817305\n    3.985060691\n    3.94746343\n    3.910364146]\n\nrandomized = VectorOfArray([[0, 0, real_data[i], 0] for i in 1:length(time)])\ndata = convert(Array, randomized)\n\nweight = VectorOfArray([[0.0, 0.0, 1.0, 0.0] for i in 1:length(time)])\ndata_weight = convert(Array, weight)","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"本实例的数据通过getdata软件从文献中扣取。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"系统变量有四个，分别为batter.v_c1,batter.v_c2,cg.v,cg.i。其中cg.v的数据通过实验获得，其权重值weight设为1，其他的变量权重值设为0。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"系统参数有六个，分别为batter.R0,batter.R1,batter.R2,batter.C1,batter.C2,batter.OCV。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"最终生成了data和data_weight矩阵，分别代表实验数据和相应权重值。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"(Image: 图2)","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"在不知道参数的顺序时，可以使用parameters和states函数查看系统参数。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"parameters(sys)\nstates(sys)","category":"page"},{"location":"Optimization/systemParaEste_batter/#构建损失函数并求解","page":"MTK部分参数辨识实例","title":"构建损失函数并求解","text":"","category":"section"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"obj = build_loss_objective(prob, Rosenbrock23(), L2Loss(time, data, data_weight=data_weight), maxiters=100000)\n\nresult = OptimizationOptimJL.optimize(obj,[0.037517357, 0.020913201, 0.006915906, 4636.08469, 1292.103841, 3.955556293])\nresult.minimizer","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"参数辨识结果为：","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"(Image: 图3)","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"至此，锂电池充电阶段的参数辨识完毕。同理可辨识放电阶段的参数。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"放电阶段实验数据：","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"time = [\n    1.502811712\t\n    3.005623424\n    4.508435137\t\n    6.011246849\t\n    7.489819663\t\n    11.9982548\t\n    13.50106651\t\n    15.00387822\t\n    16.50668994\t\n    18.00950165\t\n    19.48807446\t\n    20.99088617\t\n    22.49369789\t\n    23.9965096\t\n    25.49932131\t\n    27.00213302\t\n    28.50494474\n    30.00775645\t\n    31.51056816\t\n    32.98914097\n    34.49195269\n    35.9947644]\nreal_data = [\n    3.335698724\n    3.31503268\n    3.295860566\n    3.277933396\n    3.266977902\n    3.864799253\n    3.878244631\n    3.880734516\n    3.888702148\n    3.897167756\n    3.898910675\n    3.902645503\n    3.908372238\n    3.911858077\n    3.915094927\n    3.918082789\n    3.91957672\n    3.926797386\n    3.923311547\n    3.92107065\n    3.92107065\n    3.926299409]","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"放电阶段参数辨识结果为：","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"(Image: 图4)","category":"page"},{"location":"Optimization/systemParaEste_batter/#模型验证","page":"MTK部分参数辨识实例","title":"模型验证","text":"","category":"section"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"当放电阶段和充电阶段的模型参数全部辨识出来了以后，我们再将模型参数重新带回ODEsystem中，验证一下辨识结果是否有效。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"continuous_events = [\n    [t ~ 40.0] => [batter.R0 ~ 0.037203619\n        batter.R1 ~ 0.062205413\n        batter.R2 ~ 0.007078411\n        batter.C1 ~ 6373.89753\n        batter.C2 ~ 407.3465496\n        batter.OCV ~ 3.902760964]\n]\n\n@named OdeFun = ODESystem(eqs,t,continuous_events=continuous_events)\n@named model = compose(OdeFun, [batter, cg, ground])\nsys = structural_simplify(model)\nu0 = [\n    batter.v_c1 => 0.0\n    batter.v_c2 => 0.0\n    cg.v => 0.0\n    cg.i => 0.0\n    batter.R0 => 0.037517357\n    batter.R1 => 0.020913201\n    batter.R2 => 0.006915906\n    batter.C1 => 4636.08469\n    batter.C2 => 1292.103841\n    batter.OCV => 3.955556293\n]\nprob = ODEProblem(sys, u0, (0.0, 60.0))\nsol = solve(prob)","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"对比锂电池的实验数据和仿真数据，可以得到锂电池模型的端电压响应拟合曲线与实际端电压响应曲线的误差，如下图所示。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"(Image: 图5)","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"(Image: 图6)","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"可以看到，各点的拟合电压曲线误差范围均在约±0.006 V以内，即0.19%。电压最大误差为0.0059 V，平均误差为0.0021 V。电压误差大小远远较锂电池平台电压的变化范围小。因此从精度上看，模型误差尚在可接受的范围之内。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"note: Note\n该参数辨识仍然是优化问题的子集，选择不同的初值很可能得到不同的结果。 完整代码可以在/src目录下查看","category":"page"},{"location":"Control/KalmanFiltering/#卡尔曼滤波理论与应用","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"","category":"section"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"tip: Tip\nContents：卡尔曼滤波(Kalman Filtering)Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"note: Note\n一篇卡尔曼滤波的英文博客，兼具理论与感性认识。上述博客的中文翻译版本","category":"page"},{"location":"Control/KalmanFiltering/#卡尔曼滤波介绍","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波介绍","text":"","category":"section"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"一句简单的话概括卡尔曼滤波：综合考虑模型计算值与实际测量值，估计动态系统中状态的真实值。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"对这句概括的话，提出2个问题：","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"为什么要综合考虑模型计算值和实际测量值？\n如何综合考虑？","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"对于问题1，有2个事实：","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"模型不是准确的。例如，欧姆定律中，电阻值真的是一个常数吗？基础模型尚且如此，更不用说复杂系统的模型了。所以，描述系统的模型，一定是有偏差的。\n测量值不代表真实值。通过各种仪表读数时，读出来的数不能代表真实值，读数时会有各种随机误差。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"所以，Kalman觉得可以结合模型计算值与观测值，对状态的真实值进行估计。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"对于问题2：","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"综合考虑的方式为：先通过状态空间方程的计算出结果，再对结合误差对结果进行修正。由此可见，卡尔曼滤波是控制学与统计学的交叉学科方法。","category":"page"},{"location":"Control/KalmanFiltering/#卡尔曼滤波的数学表达","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波的数学表达","text":"","category":"section"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"只给结论，不推导。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"leftbeginarrayl\nx_k=F_k-1 x_k-1+Gamma_k-1 w_k-1 \nz_k=H_k x_k+v_k\nendarrayright","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"其中：","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"下表k代表k时刻\n系统状态向量——x_k（行向量）\n系统状态转移矩阵——F_k，如果在时间域上不变则为——F\n模型噪声——w_k\n模型噪声矩阵（描述噪声对变量的影响）——Gamma_k（行向量）\n系统量的测向量——z_k\n量测矩阵——H_k（行向量）\n模型噪声——v_k","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"同时，噪声满足正态分布：","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"w_k sim N(0Q_k)  v_k sim N(0R_k)","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"下面为卡尔曼滤波的滤波过程:","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"Step1 模型计算:","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"x_k=F_k-1 x_k-1\nP_k=F_k-1 P_k-1 F_k-1^T+Gamma_k-1 Q_k-1 Gamma_k-1^T","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"Step2 滤波:","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"G_k=P_k  H_k^TleftH_k P_k H_k^T+R_kright^-1\nhatx_k=x_k+G_k(tildez_k - H_kx_k)\nhatP_k = (I-G_kH_k)P_k","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"其中：","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"系统的量测的协方差矩阵——P\n滤波后的系统状态向量——hatx_k\n滤波后的系统状态向量——hatx_k\n模型噪声的方差——Q_k，如果在时间域上不变则为——Q\n测量噪声的方差——R_k，如果在时间域上不变则为——R\n滤波后的系统的量测的协方差矩阵——hatP_k\n测量值向量——tildez_k\n模型噪声——v_k","category":"page"},{"location":"Control/KalmanFiltering/#卡尔曼滤波实例","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波实例","text":"","category":"section"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"考虑加热器：fracdTdt = -(T-20) + 10 即散热系数为1，加热功率为10，环境温度为20。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"使用DifferentialEquations.jl获得仿真数据并加上扰动。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"using DifferentialEquations\nusing Statistics, Plots\n\nf(u, t, p) = -(u - 20) + 10\n\nprob = ODEProblem(f, 20.0, (0, 5))\n\nsol = solve(prob, saveat=0.1)\nnoise = rand(-0.5:0.0001:0.5, length(sol.u))\ncov(noise)\n\nmeasureT = noise + sol.u\nt = collect(0:0.1:5)\nplot(t, measureT, label=\"measure\", legend_position=:topleft)\nplot!(t, sol.u, label=\"real\", legend_position=:topleft)","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"获得的measureT将作为未来每个时间点上的温度测量数据（实际为精确解加随机误差生成的数据）。真实值与测量值如下图。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"(Image: 图 1)  ","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"若取dt=01，使用欧拉法离散，则上述微分则转变为状态空间方程：T_k+1 = 09T_k+3","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"若采用上述状态空间方程，则可以称之为“完美模型”。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"为了验证卡尔曼滤波的有效性，我们设计一个十分错误的模型：T_k+1 = T_k","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"即，我们认为这是一个温度不变的系统（错得不能再错的模型）。同时，给一个比较大的Q_w，说明模型扰动的方差比较大。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"begin\n    F = 1\n    Γ = 0.1\n    H = 1\n    Qv = 0.8\n    Qw = 10\n\n    P = 10\n    x = 20.0\n\n    x_res = zeros(1, length(measureT))\n    p_res = zeros(1, length(measureT))\n\n    p_res[:, 1] = [P]\n    x_res[:, 1] = [x]\n\n    for i in 1:length(measureT)-1\n        _P = F * p_res[1, i] * F' .+ Γ' * Qw * Γ\n        _G = _P * H * inv(H * _P * H + Qv)\n        _x = F * x_res[1, i]\n        global x_res[1, i+1] = _x + _G * (measureT[i+1] - H' * _x)\n        global p_res[1, i+1] = (1 - _G' * H) * _P\n    end\n\n    plot!(t, x_res[1, :], label=\"Wrong Model\", legend_position=:topleft)\nend","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"(Image: 图 2) ","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"结果显示，居然和真实值差不多。如果令Q_w=1，给得比较小。则变成了：","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"(Image: 图 3)  ","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"没那么好，但也不差（比直线好太多了）。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"如果把模型设置成原本的模型则:","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"begin\n    F = 0.9\n    Γ = 0.1\n    H = 1\n    Qv = 0.8\n    Qw = 10\n\n    P = 10\n    x = 20.0\n\n    x_res = zeros(1, length(measureT))\n    p_res = zeros(1, length(measureT))\n\n    p_res[:, 1] = [P]\n    x_res[:, 1] = [x]\n\n    for i in 1:length(measureT)-1\n        _P = F * p_res[1, i] * F' .+ Γ' * Qw * Γ\n        _G = _P * H * inv(H * _P * H + Qv)\n        _x = F * x_res[1, i] + 3\n        global x_res[1, i+1] = _x + _G * (measureT[i+1] - H' * _x)\n        global p_res[1, i+1] = (1 - _G' * H) * _P\n    end\n\n    plot!(t, x_res[1, :], label=\"Right Model\", legend_position=:topleft)\nend","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"(Image: 图 4)  ","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"基本就一致了。","category":"page"},{"location":"Control/KalmanFiltering/#小结","page":"卡尔曼滤波理论与应用","title":"小结","text":"","category":"section"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"卡尔曼滤波的重要意义是利用了测量值带来的信息。模型不准确的时候，利用滤波带来的效果，可以对模型进行一个矫正。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"但它的缺点在于，对预测没有帮助。对未来的多点预测只能是通过模型。既然是预测，说明事情还没有发生，那测量值无法获得，也就无法通过测量值进行矫正。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"其特点是，对已经发生的事情做一个优化，而不能提升预测未来的能力。","category":"page"},{"location":"WorkFlow/julia的安装/#Julia安装","page":"Julia安装","title":"Julia安装","text":"","category":"section"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"tip: Tip\nContents：julia安装Contributor: 孙蓓蓓、张启Email:如有错误，请批评指正。","category":"page"},{"location":"WorkFlow/julia的安装/#下载网址","page":"Julia安装","title":"下载网址","text":"","category":"section"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"搜索清华大学开源软件镜像站。   (Image: )","category":"page"},{"location":"WorkFlow/julia的安装/#下载julia-xxx-win64.zip安装包","page":"Julia安装","title":"下载julia-xxx-win64.zip安装包","text":"","category":"section"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"note: Note\nv1.7.2(Feb 6,2022)为julia当前稳定版本。新安装时，下载最新版。","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"首先，在搜索框中搜索julia，点击julia-releases： (Image: ) 其次，点击bin/： (Image: ) 找到winnt/： (Image: ) 选择x64/： (Image: ) 然后，找到最新版本系列： (Image: ) 最后，下拉找到julia-xxx-win64.zip安装包，点击下载。 (Image: )","category":"page"},{"location":"WorkFlow/julia的安装/#解压安装","page":"Julia安装","title":"解压安装","text":"","category":"section"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"找到下载好的安装包，右键解压。解压后，生成一个julia-1.7.2文件夹。可执行文件julia.exe就在julia-1.7.2文件夹的bin文件夹下。 (Image: )","category":"page"},{"location":"WorkFlow/julia的安装/#将路径加到环境变量中","page":"Julia安装","title":"将路径加到环境变量中","text":"","category":"section"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"在任务栏搜索框中找到“编辑系统环境变量”： (Image: ) 打开环境变量；在用户变量中选择变量Path，点击编辑；新建，将julia.exe文件所在路径复制进去，然后点击确定。 (Image: )","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"tip: Tip\n也可使直接“(Image: ) + r”打开运行▱，输入 rundll32 sysdm.cpl,EditEnvironmentVariables 直接打开环境变量设置界面，注意，此时无法编辑系统环境变量（实际上也并不建议直接编辑系统环境变量），编辑用户环境变量即可。","category":"page"},{"location":"WorkFlow/julia的安装/#执行julia","page":"Julia安装","title":"执行julia","text":"","category":"section"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"在任务栏搜索框输入cmd，打开命令提示符，输入julia，进入Julie REPL，此时julia就可以执行了。 (Image: ) 直接输入exit()，即可退出。","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"另外，Windows下推荐使用Windows Terminal作为交互终端（直接的Cmd或Powershell终端中，均不支持类似","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"20px\" height=\"20px\" viewBox=\"220 280 180 120\" xml:space=\"preserve\">\n    <g>\n        <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" fill=\"currentColor\" d=\"M259.618,401.811l1.231,0.268l-4.314,13.678h-39.031v-1.371h1.903\n  c2.132,0,3.654-0.699,4.568-2.082c0.521-0.799,0.774-2.639,0.774-5.506v-32.534c0-3.147-0.343-5.114-1.041-5.9\n  c-0.964-1.091-2.398-1.637-4.301-1.637h-1.903v-1.383h22.827v1.383c-2.677-0.025-4.556,0.216-5.634,0.736\n  c-1.078,0.52-1.814,1.18-2.208,1.979c-0.394,0.787-0.596,2.69-0.596,5.685v31.671c0,2.057,0.203,3.465,0.596,4.238\n  c0.292,0.52,0.749,0.9,1.37,1.154c0.622,0.242,2.551,0.367,5.799,0.367h3.68c3.87,0,6.586-0.279,8.146-0.85\n  c1.561-0.57,2.982-1.586,4.276-3.031C257.042,407.229,258.336,404.932,259.618,401.811L259.618,401.811L259.618,401.811z\" />\n        <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" fill=\"currentColor\" d=\"M265.631,392.346h-15.192l-2.657,6.193c-0.662,1.521-0.988,2.658-0.988,3.418\n  c0,0.594,0.287,1.117,0.85,1.57c0.573,0.455,1.797,0.752,3.694,0.889v1.068H238.98v-1.068c1.64-0.295,2.697-0.672,3.181-1.135\n  c0.988-0.92,2.074-2.805,3.27-5.641l13.809-32.292h1.008l13.661,32.637c1.097,2.627,2.094,4.326,2.993,5.107\n  c0.899,0.779,2.153,1.225,3.753,1.322v1.068h-15.489v-1.068c1.561-0.078,2.618-0.346,3.171-0.789\n  c0.553-0.436,0.83-0.979,0.83-1.621c0-0.848-0.396-2.182-1.166-4.02L265.631,392.346L265.631,392.346L265.631,392.346z\n   M264.821,390.202l-6.658-15.854l-6.826,15.854H264.821L264.821,390.202L264.821,390.202z\" />\n        <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" fill=\"currentColor\" d=\"M313.479,365.008l0.563,11.921h-1.432c-0.27-2.098-0.64-3.594-1.126-4.502\n  c-0.768-1.445-1.804-2.507-3.083-3.197c-1.292-0.691-2.98-1.036-5.077-1.036h-7.163v38.833c0,3.121,0.345,5.064,1.011,5.844\n  c0.946,1.051,2.417,1.574,4.387,1.574h1.766v1.381h-21.552v-1.381h1.803c2.149,0,3.671-0.652,4.566-1.957\n  c0.55-0.793,0.832-2.621,0.832-5.461v-38.833h-6.114c-2.367,0-4.055,0.179-5.053,0.524c-1.305,0.473-2.417,1.394-3.338,2.737\n  c-0.92,1.356-1.471,3.172-1.65,5.475h-1.42l0.602-11.921H313.479L313.479,365.008L313.479,365.008z\" />\n        <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" fill=\"currentColor\" d=\"M319.647,381.675v19.259h10.708c2.785,0,4.637-0.418,5.569-1.252\n  c1.251-1.104,1.938-3.042,2.085-5.826h1.325v16.965h-1.325c-0.331-2.367-0.674-3.889-1.006-4.564\n  c-0.429-0.834-1.141-1.496-2.122-1.975c-0.981-0.477-2.49-0.723-4.526-0.723h-10.708v16.068c0,2.158,0.098,3.471,0.281,3.938\n  c0.197,0.467,0.528,0.834,1.006,1.117c0.479,0.27,1.398,0.404,2.736,0.404h8.267c2.748,0,4.76-0.184,5.999-0.576\n  c1.251-0.381,2.44-1.129,3.594-2.258c1.484-1.484,3.006-3.729,4.563-6.723h1.435l-4.194,12.219h-37.56v-1.326h1.73\n  c1.141,0,2.232-0.281,3.263-0.834c0.772-0.379,1.288-0.957,1.569-1.717c0.271-0.773,0.405-2.344,0.405-4.709v-31.661\n  c0-3.091-0.307-4.992-0.933-5.716c-0.858-0.957-2.294-1.435-4.305-1.435h-1.73v-1.337h37.56l0.539,10.672h-1.41\n  c-0.503-2.563-1.055-4.318-1.668-5.274c-0.613-0.957-1.509-1.693-2.711-2.196c-0.957-0.355-2.65-0.54-5.066-0.54H319.647\n  L319.647,381.675L319.647,381.675z\" />\n        <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" fill=\"currentColor\" d=\"M370.217,387.709l10.832,16.14c2.997,4.469,5.219,7.289,6.679,8.469\n  c1.448,1.182,3.29,1.83,5.524,1.957v1.371h-21.651v-1.371c1.435-0.025,2.502-0.18,3.2-0.457c0.521-0.217,0.939-0.561,1.282-1.016\n  c0.331-0.459,0.496-0.928,0.496-1.398c0-0.57-0.114-1.143-0.331-1.713c-0.178-0.42-0.862-1.512-2.044-3.277l-8.559-12.94\n  l-10.565,13.538c-1.117,1.447-1.791,2.4-2.006,2.883c-0.229,0.482-0.344,0.99-0.344,1.51c0,0.801,0.344,1.447,1.004,1.969\n  c0.672,0.521,1.955,0.826,3.835,0.902v1.371h-17.893v-1.371c1.27-0.127,2.349-0.395,3.276-0.789\n  c1.536-0.646,2.996-1.51,4.381-2.602c1.396-1.092,2.984-2.77,4.762-5.029l11.911-15.022l-9.93-14.552\n  c-2.705-3.937-5.004-6.527-6.883-7.747c-1.893-1.232-4.063-1.879-6.515-1.956v-1.384h23.327v1.384\n  c-1.98,0.076-3.34,0.394-4.076,0.965c-0.724,0.571-1.092,1.207-1.092,1.893c0,0.927,0.597,2.26,1.778,4.025l7.745,11.568\n  l8.966-11.353c1.041-1.333,1.676-2.248,1.917-2.743c0.229-0.508,0.355-1.016,0.355-1.537s-0.152-0.978-0.457-1.372\n  c-0.368-0.521-0.838-0.889-1.409-1.092c-0.571-0.216-1.752-0.331-3.53-0.356v-1.384h17.893v1.384\n  c-1.41,0.076-2.565,0.292-3.467,0.661c-1.333,0.571-2.565,1.346-3.683,2.311c-1.117,0.965-2.692,2.755-4.724,5.358L370.217,387.709\n  L370.217,387.709L370.217,387.709z\" />\n    </g>\n</svg>","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"的用法输入UTF-8字符）。","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"直接在Microsoft Store上下载Windows Terminal，打开软件后进入设置界面： (Image: 打开Windows Teminal设置)","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"可以直接在界面中运行julia命令，或者将Julia添加到终端中。","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"左侧导航栏划至最下，新建配置文件，这里这就复制Windows Powershell的（有兴趣可以复制Cmd的试试）。 (Image: Winwdos Termianl 新建设置文件)","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"在新建的配置文件里面编辑设计即可，详细如图： (Image: Julia终端设置)","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"注：终端界面的图标自己找一个，如果懒着找，就接着使用Powershell的也行。","category":"page"},{"location":"Tools/3-ssh-git实操/#SSH、Git与Git图形化软件","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"tip: Tip\nContents：SSH、Git与Git的图形化软件Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"本文介绍ssh、git与git的图形化软件。他们之间的关系为：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git基于ssh通讯操作\ngit图形化软件是操作git的图形化软件","category":"page"},{"location":"Tools/3-ssh-git实操/#SSH使用","page":"SSH、Git与Git图形化软件","title":"SSH使用","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/#SSH是什么","page":"SSH、Git与Git图形化软件","title":"SSH是什么","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"SSH是一种网络协议，用于计算机之间的加密登录。一个用户从本地计算机，使用SSH协议登录另一台远程计算机，就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。","category":"page"},{"location":"Tools/3-ssh-git实操/#SSH密钥登录原理","page":"SSH、Git与Git图形化软件","title":"SSH密钥登录原理","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"客户端发出认证请求；\n服务器端使用客户端发送的公钥对一个随机的256位的字符串进行加密，并发送给 客户端；\n客户端使用私钥对字符串进行解密，并生成一个MD5值发送给服务器端；\n服务器端根据原始随机字符串生成MD5值进行匹配, 确认客户端身份；\n至此, 双方互相确认对方身份并建立加密信道, 可以正式进行安全通信。","category":"page"},{"location":"Tools/3-ssh-git实操/#SSH的两种认证方式","page":"SSH、Git与Git图形化软件","title":"SSH的两种认证方式","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"1.基于口令的安全认证 ：提供正确的用户口令后可以登录远程服务器。","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"操作方式：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"(默认端口为22)","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"ssh user@host\n\nexample：\nssh root@127.0.0.1\nssh yjy@152.20.45.154","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"然后输入登录密码进行登录 使用p参数，可以修改端口","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"ssh -p 端口号 user@host\n\nexample：\nssh -p 8080 yjy@152.20.45.154 ","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"上面这个例子是以8080端口登录","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"2.基于密钥的安全认证 ：使用公钥和私钥对的方式对用户进行认证。","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"密钥登录首先需要产生公钥和私钥。","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"公钥放在服务端，私钥放在需要远程登录服务端的客户端","category":"page"},{"location":"Tools/3-ssh-git实操/#产生公钥和私钥","page":"SSH、Git与Git图形化软件","title":"产生公钥和私钥","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"ssh-keygen -t rsa","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"在~/.ssh文件夹（~为用户目录，windows和linux目录下都会有）下会出现idrsa与idrsa.pub两个文件。","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"idrsa是私钥，idrsa.pub是公钥。","category":"page"},{"location":"Tools/3-ssh-git实操/#修改配置文件","page":"SSH、Git与Git图形化软件","title":"修改配置文件","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"之后，在远程主机的ssh配置文件(/etc/ssh/sshd_config)中做如下修改，开启权限。这几项有些是新加上的，有些原来是no：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"RSAAuthentication yes\nPubkeyAuthentication yes\nAuthorizedKeysFile .ssh/authorized_keys","category":"page"},{"location":"Tools/3-ssh-git实操/#在服务端存放公钥","page":"SSH、Git与Git图形化软件","title":"在服务端存放公钥","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"方法一：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"将公钥中的一大串字符添加到服务端~/.ssh/authorized_keys文件中去，如果已经存在，那么在后面再添上一条。不建议覆盖，因为这样其它客户端远程登录的公钥就会被覆盖！","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"方法二：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"也可以用一段代码自动加过去","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"ssh root@111.20.45.124 \"mkdir -p .ssh && cat >> .ssh/authorized_keys\" < ~/.ssh/id_rsa.pub","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"这条命令由多个语句组成，依次分解开来看：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"（1）\"$ ssh user@host\"，表示登录远程主机；\n（2）双引号中的mkdir .ssh && cat >> .ssh/authorized_keys，表示登录后在远程shell上执行的命令：\n（3）\"$ mkdir -p .ssh\"的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；\n（4）'cat >> .ssh/authorizedkeys' < ~/.ssh/idrsa.pub的作用是，将本地的公钥文件~/.ssh/idrsa.pub，重定向追加到远程文件authorizedkeys的末尾。","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"写入authorized_keys文件后，公钥登录的设置就完成了。","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"现在就可以远程免密登录了！","category":"page"},{"location":"Tools/3-ssh-git实操/#可能出现的问题","page":"SSH、Git与Git图形化软件","title":"可能出现的问题","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"基本都是文件权限的问题，比如报错too open。Linux和Windows都会出现这样的情况，相关的解决方案很多，可以直接查找。","category":"page"},{"location":"Tools/3-ssh-git实操/#登录github或者码云","page":"SSH、Git与Git图形化软件","title":"登录github或者码云","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"用ssh怎么操作呢？","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"做一个转换，github相当于就是服务端，只需要把公钥放在服务端就可以了。在github上更加方便，因为它都是图形化软件操作。进入设置软件，选择ssh就可以进行调试了（码云同理）。","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"配置好了之后，可以进行如下测试：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"ssh -T git@github.com\n（ssh -T git@gitee.com）","category":"page"},{"location":"Tools/3-ssh-git实操/#git的使用","page":"SSH、Git与Git图形化软件","title":"git的使用","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/#git和ssh的关联","page":"SSH、Git与Git图形化软件","title":"git和ssh的关联","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"之前讲了那么多ssh的知识，有什么作用呢？ 会了ssh，git基本就会了一半了！","category":"page"},{"location":"Tools/3-ssh-git实操/#git的关键要素","page":"SSH、Git与Git图形化软件","title":"git的关键要素","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"本地工作区（自己电脑的文件夹）\n远程仓库（远端服务器上的文件夹）","category":"page"},{"location":"Tools/3-ssh-git实操/#git基本操作","page":"SSH、Git与Git图形化软件","title":"git基本操作","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"初始化本地仓库\n从远端拉取\n在本地编写文件\n文件暂存\n提交修改\n提交到远程","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"1.初始化本地仓库","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"通过git bash或者cmd进入仓库文件夹 输入：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git init","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"简单配置(相关教程也很多，不赘述)：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git config user.name \"Your Name\"\ngit config user.email \"email@example.com\"","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"链接到仓库的地址，相当于后面的操作就不需要输入地址了： （origin相当于变量，储存远端的地址）","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git remote add origin \"仓库的ssh地址\"","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"2.从远端拉取","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"拉取origin的master分支","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git pull origin master","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"3.本地编写文件 编写hello.txt","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"4.提交暂存","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git add .\n##或者\ngit add hello.txt","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"5.提交修改","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git commit -m \"文件说明\"","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"6.推送到远端","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git push origin master","category":"page"},{"location":"Tools/3-ssh-git实操/#git进阶操作","page":"SSH、Git与Git图形化软件","title":"git进阶操作","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"提交多个版本的文件\n回退","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"1. 提交多个版本的文件 hello.txt 版本1：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"i love you","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"提交暂存并修改","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git add hello.txt\ngit commit -m \"first\"","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"hello.txt 版本2：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"i love you\nI love you","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"提交暂存并修改","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git add hello.txt\ngit commit -m \"second\"","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"hello.txt 版本3：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"i love you\nI love you\nI love you too much","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"提交暂存并修改","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git add hello.txt\ngit commit -m \"third\"","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"接下来查看日志：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git log","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"如图： (Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"可以看到，HEAD 指向的是最新版本（head可以理解为当前版本，也就说如果要推到远程就是推这个版本）","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"2.回退 接下来回退到上一个版本：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git reset --hard HEAD^ ##回退到上上个就是：HEAD^^","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"那么可以看到head确实变了","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"又不想回退了，还是要回到第三次改变的最新版本","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git reset --hard 3ed54(commid的id，只能这样操作)","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"其实回退了之后就看不到id了，如果想要回到最新版本，就要记下id，所以说善变是有代价的！","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"可以方便查看id与修改信息：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git log --pretty=oneline","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"3.Push 在善变之后，找到了真爱，不管是谁吧，反正证还是要领的。最后就是把文件推送到远端了。","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git push origin master","category":"page"},{"location":"Tools/3-ssh-git实操/#git图形化软件","page":"SSH、Git与Git图形化软件","title":"git图形化软件","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git图形化软件的好处就是，把以上对git的操作图形化。","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"常用且免费的有：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"sourcetree\nvscode中内嵌的git操作页面\ngitkraken（团队版付费，个人免费）","category":"page"},{"location":"Tools/3-ssh-git实操/#sourcetree示例","page":"SSH、Git与Git图形化软件","title":"sourcetree示例","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"软件如下：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"比如说clone：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"某一个链接仓库的工作软件：","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/3-ssh-git实操/#vscode示例","page":"SSH、Git与Git图形化软件","title":"vscode示例","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"(Image: 图 4)  ","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"更多操作见vscode中使用git","category":"page"},{"location":"Tools/3-ssh-git实操/#gitkraken示例","page":"SSH、Git与Git图形化软件","title":"gitkraken示例","text":"","category":"section"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"gitkraken网址","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"(Image: 图 5)  ","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"不管什么软件，拉取、提交、暂存等等都是相同的！","category":"page"},{"location":"Tools/3-ssh-git实操/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"如果你明白git的操作原理了，那么这个无师自通，因为本质上sourcetree就是提供一个图形化的操作软件。再没有其它新鲜玩意了！","category":"page"}]
}
