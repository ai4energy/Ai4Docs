var documenterSearchIndex = {"docs":
[{"location":"Simulation/DE_heattran/#DE求解PDE（对比MTK）","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"tip: Tip\nContents：DE、PDE、手动空间离散Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"note: Note\nDE = DifferentialEquations.jlPDE = Partial Differential EquationDifferentialEquations.jl为处理时间微分的求解建模工具包。","category":"page"},{"location":"Simulation/DE_heattran/#DE求解PDE","page":"DE求解PDE（对比MTK）","title":"DE求解PDE","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"在MTK手动空间离散求解PDE中介绍了手动空间离散的思想。本篇中将通过手动PDE求解传热问题对DE与MTK进行一个小对比。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"DE构建的问题过程中，需要把问题推演至求解之前。求解之前的部分都需要手动完成。MTK手动空间离散求解PDE中提到，求解PDE的数值方法有这么几步：建立数学描述方程、对变量进行离散、迭代求解。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"把问题进一步细化，则变为：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"Step1:建立数学描述方程\nStep2:网格生成（变量离散）\nStep3:生成求解格式\nStep4:迭代求解","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"MTK完成了Step3、Step4的内容，而DE只能帮我们完成Step4的内容。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"tip: Tip\n如果我们仔细琢磨，会发现：如果是基于时间微分的组件化建模。使用MTK时，我们完成Step1的内容，剩下MTK全包了！所以这也是为什么说，MTK提供了基于时间的一条龙求解。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"我们来看看，DE是如何完成Step4的内容的。同时，也会让大家对数值求解过程有一个更加深刻的理解。","category":"page"},{"location":"Simulation/DE_heattran/#数值传热学实例","page":"DE求解PDE（对比MTK）","title":"数值传热学实例","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"考虑MTK手动空间离散求解PDE中正方形铸件的散热过程。节点的离散结果如下（不再推导）：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"内节点：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"fracpartial T_Ppartial t=A(T_W^n+T_E^n+ T_N^n+T_S^n - 4T_P^n)","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"边边界节点：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"fracpartial T_Ppartial t=A(T_W^n+T_N^n+T_S^n)-(B+3A)T_P^n+BT_f","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"角边界节点：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"fracpartial T_Ppartial t=A(T_E^n + T_N^n )-(2B+2A)T_P^n+2BT_f","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"这里，我们进一步对问题进行拓展。正方形铸件初始温度1000℃，环境温度为一个变化的值：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"T_f = 400 * (1 + sin(t))","category":"page"},{"location":"Simulation/DE_heattran/#求解实例","page":"DE求解PDE（对比MTK）","title":"求解实例","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"求解的全部代码如下：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"using ModelingToolkit, DifferentialEquations\nusing Dates\n\nprintln(\"=====DE TEST=====\")\nstarttime = now()\na = 1.27E-5\nn = 10\nL = 0.2\nδ = L / n\nλ = 50\nh = 1.0E9\nTf = 0.0\nA = a / δ^2\nB = a / (δ^2 / 2 + δ * λ / h)\np = [A, B, n]\nfunction to_index(i, j, n)\n    return (i - 1) * n + j\nend\nfunction heat!(dT, T, p, t)\n    A, B, n = p\n    n = Int(n)\n    Tf = 400.0 * (1 + sin(t))\n    # 内部节点\n    for i in 2:n-1\n        for j in 2:n-1\n            dT[to_index(i, j, n)] = A * (T[to_index(i + 1, j, n)] + T[to_index(i - 1, j, n)] + T[to_index(i, j + 1, n)] + T[to_index(i, j - 1, n)] - 4 * T[to_index(i, j, n)])\n        end\n    end\n    # 边边界\n    for i in 2:n-1\n        dT[to_index(i, 1, n)] = A * (T[to_index(i + 1, 1, n)] + T[to_index(i - 1, 1, n)] + T[to_index(i, 2, n)]) - (3B + A) * T[to_index(i, 1, n)] + B * Tf\n    end\n    for i in 2:n-1\n        dT[to_index(i, n, n)] = A * (T[to_index(i + 1, n, n)] + T[to_index(i - 1, n, n)] + T[to_index(i, n - 1, n)]) - (3B + A) * T[to_index(i, n, n)] + B * Tf\n    end\n    for i in 2:n-1\n        dT[to_index(1, i, n)] = A * (T[to_index(1, i + 1, n)] + T[to_index(1, i - 1, n)] + T[to_index(2, i, n)]) - (3B + A) * T[to_index(1, i, n)] + B * Tf\n    end\n    for i in 2:n-1\n        dT[to_index(n, i, n)] = A * (T[to_index(n, i + 1, n)] + T[to_index(n, i - 1, n)] + T[to_index(n - 1, i, n)]) - (3B + A) * T[to_index(1, i, n)] + B * Tf\n    end\n    # 角边界\n    dT[to_index(1, 1, n)] = A * (T[to_index(2, 1, n)] + T[to_index(1, 2, n)]) - (2B + 2A) * T[to_index(1, 1, n)] + 2B * Tf\n    dT[to_index(n, n, n)] = A * (T[to_index(n - 1, n, n)] + T[to_index(n, n - 1, n)]) - (2B + 2A) * T[to_index(n, n, n)] + 2B * Tf\n    dT[to_index(n, 1, n)] = A * (T[to_index(n, 2, n)] + T[to_index(n - 1, 1, n)]) - (2B + 2A) * T[to_index(n, 1, n)] + 2B * Tf\n    dT[to_index(1, n, n)] = A * (T[to_index(2, n, n)] + T[to_index(1, n - 1, n)]) - (2B + 2A) * T[to_index(1, n, n)] + 2B * Tf\nend\nu0 = [1000.0 for i in 1:n for j in 1:n]\nprob = ODEProblem(heat!, u0, (0, 100), p, saveat=1)\nsol = solve(prob, Tsit5())\nendtime = now()\nprintln(\"time use:\"*string(endtime - starttime))","category":"page"},{"location":"Simulation/DE_heattran/#可视化","page":"DE求解PDE（对比MTK）","title":"可视化","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"动画走你！","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"an_len = length(sol.u)\nusing Plots, GR\nres = rand(n, n, an_len)\nfor t in 1:an_len\n    for i in 1:n\n        for j in 1:n\n            res[i, j, t] = sol.u[t][to_index(i, j, n)]\n        end\n    end\nend\nxs = LinRange(0.0, L, n)\nys = LinRange(0.0, L, n)\nPlots.contourf(xs, ys, res[:, :, 1])\nanim = @animate for i ∈ 2:an_len\n    contourf!(xs, ys, res[:, :, i])\nend\ngif(anim, \"DE_trans.gif\", fps=24)","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"以上代码对比之前，有所改变的是：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"saveat","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"我们把时间拉长，同时saveat的时间步长变成了1s。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"","category":"page"},{"location":"Simulation/DE_heattran/#求解速度对比","page":"DE求解PDE（对比MTK）","title":"求解速度对比","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"跑相同的问题：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"MTK用时：2.407s\nDE用时：0.810s","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"可见，Step3的符号化简与DE问题生成的确需要消耗不少的资源。","category":"page"},{"location":"Simulation/DE_heattran/#关于内涵的理解","page":"DE求解PDE（对比MTK）","title":"关于内涵的理解","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"MTK与DE两种方法都能够求解PDE问题。为什么这样做能行呢？下面分享一些关于问题内涵的思考。","category":"page"},{"location":"Simulation/DE_heattran/#空间离散的物理内涵","page":"DE求解PDE（对比MTK）","title":"空间离散的物理内涵","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"动画中可以清晰感受到外围颜色的震动，这是我们设定环境温度波动的结果。若要把环境温度变化以微分方程的形式定义，同样可行。只需要再添加一个变量关于时间相关的变量即可。而这个随时间的变化的环境温度，是真正驱动系统变化的变量，它的变化是由时间决定，而不受其它网格影响。相反，其它网格受到环境温度变量的影响。可以说，环境温度变量是独立于网格离散而存在的。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"由此，我们可以聊一聊关于空间离散的内涵。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"在以上的传热实例中，系统的根本“驱动力”在于温差。也就是说，因为温差的存在，才会让系统产生变化。而我们在空间离散时，其实并没有对这种变化进行处理。我们手动空间离散的内涵是：在不同网格间，架起了让网格相互联系的桥梁。其本质描述了网格和网格之间的联系。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"从高数中微元的角度思考，只要网格足够小，那么我们就可以得到非常精确的模拟结果；从物理内涵的角度思考，不管网格如何小，任何一个网格都可以视为一个小组件，这个小组件的特性有：温度、边长、导热系数等等，并且在小组件内部，这些属性的数值视为不变。而空间离散，就是建立了这些小组件之间的关联。这种思想在数值计算领域是一种专业的离散方式——有限容积法。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"所以，以上空间离散的思想内涵就和之间组件化建模的思想内涵统一起来了。区别在于，空间离散出来的结果是微元，组件化建模的模型结果是宏观组件。 但是，不同组件（微元）之间需要建立相互联系的桥梁这一点是不变的。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"如果深入思考传热的内涵——由温差引起的热量传递。我们也能发现，以小组件的形式看待微元网格，其物理逻辑也是非常自洽的。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"把空间离散赋予物理内涵（微元组件化）后，剩下的问题也很清晰了——组件在时间域上的变化。组件之间的连接建立好之后，当外界环境（温度）随时间动态变化，组件的属性（温度）也会发生相应的变化。这不就是时间域上动态系统的求解内涵吗？只是我们不会把描述时间微分的方程离散，而是把它丢给求解器去解。","category":"page"},{"location":"Simulation/DE_heattran/#迭代格式的数学内涵","page":"DE求解PDE（对比MTK）","title":"迭代格式的数学内涵","text":"","category":"section"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"迭代格式数学内涵中最关键的一环是函数to_index()","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"function to_index(i, j, n)\n    return (i - 1) * n + j\nend","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"MTK中采用T[i, j]的网格描述方式，这是从物理位置中对网格进行了一种描述。这种描述中是附加由物理含义的——空间位置。而这种附加了物理含义的变量描述，底层求解器是无法求解的。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"DE能求解的方程是什么样的呢？如下所示：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"leftbeginarrayc\ny_1^prime(x)=fleft(x y_1(x) y_2(x) ldots y_n(x) right) y_2^prime(x)=fleft(x y_1(x) y_2(x) ldots y_n(x) right)  ldots y_n^prime(x)=fleft(x y_1(x) y_2(x) ldots y_n(x) right)  y_1left(x_0right)=y_10 y_2left(x_0right)=y_20 ldots y_nleft(x_0right)=y_n 0endarrayright","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"写成统一的格式即：","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"mathbfyprime=mathbff(mathbfxmathbfy)","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"note: Note\n求解微分方程的数值解法主要有：欧拉法yleft(x_i+1right)=yleft(x_iright)+hfleft(x_iy(x_i)right)+Oleft(h^2right)后退欧拉法yleft(x_i+1right)=yleft(x_iright)+hfleft(x_i+1y(x_i+1)right)+Oleft(h^2right)梯形法yleft(x_i+1right)=yleft(x_iright)+frach2leftfleft(x_iy_i right)+fleft(x_i+1y_i+1right)right+Oleft(h^3right)辛普森方法yleft(x_i+1right)=yleft(x_i-1right)+ frach3leftfleft(x_i-1y_i-1right)+4fleft(x_iy_iright)+fleft(x_i+1y_i+1right)right+Oleft(h^5right)标准龙格库塔法leftbeginarrayc\ny_i+1=y_i+frac16left(K_1+2 K_2+2 K_3+K_4right) \nK_1=h fleft(x_i y_iright) \nK_2=h fleft(x_i+frac12 h y_i+frac12 K_1right) \nK_3=h fleft(x_i+frac12 h y_i+frac12 K_2right) \nK_4=h fleft(x_i+h y_i+K_3right)\nendarrayright其中，h为求解的步长。各方法阶数为（阶数越高精度越高）：方法 阶数\n欧拉法 1阶\n后退欧拉法 1阶\n梯形法 2阶\n辛普森方法 4阶\n标准龙格库塔法 4阶","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"对于这样的数学描述方式，y可以视为微分变量的数组，f(xy)视为变量之间的联系。那么y=f(xy)的含义是：微分与其它变量之间的关联。这种关联是不包含物理内涵的。而二维数组T[i, j]包含了位置关系。所以要去位置化，就需要把二维映射到一维上。所以我们采用(i - 1) * n + j将二维索引展平为一维。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"本质是通过to_index()消除了物理位置含义。生成了DE可计算的描述方式——最原始最根本的微分方程组数学描述方式。这一步就是前面所说的Step3。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"总的来看，DE求解我们手动完成了Step2、Step3、Step4。","category":"page"},{"location":"Simulation/DE_heattran/","page":"DE求解PDE（对比MTK）","title":"DE求解PDE（对比MTK）","text":"tip: Tip\nMTK求解时。Step3、Step4由程序完成。","category":"page"},{"location":"Tools/CSV_jl_use/#CSV.jl使用简介","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"tip: Tip\nContents：CSV文本读入Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"note: Note\nCSV.jl是一个快速灵活的纯 Julia包，用于处理带分隔符的文本文件。","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"在建立模型与模型计算的过程中，可以很好的解决数据导入问题，它能自动辨识文本数据类型，并将数据分隔。","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"它的应用场景是：使用数据之前的输入导入。","category":"page"},{"location":"Tools/CSV_jl_use/#基本实现","page":"CSV.jl使用简介","title":"基本实现","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"文件内容：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"col1,col2,col3,col4,col5,col6,col7,col8\n,1,1.0,1,one,2019-01-01,2019-01-01T00:00:00,true\n,2,2.0,2,two,2019-01-02,2019-01-02T00:00:00,false\n,3,3.0,3.14,three,2019-01-03,2019-01-03T00:00:00,true","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"使用以下代码导入文件","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\") #file为文件名，如\"data.csv\"、\"data.txt\"","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"默认情况下，CSV.File会自动检测这个文件的分隔符','，以及每列的类型。默认情况下，它将“空字段”视为missing（本示例中的整个第一列）。它还自动处理提升类型，例如第 4 列，其中前两个值为Int，但第 3 行具有Float64值 ( 3.14)。","category":"page"},{"location":"Tools/CSV_jl_use/#自定义分隔符","page":"CSV.jl使用简介","title":"自定义分隔符","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"文件内容：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"col1::col2\n1::2\n3::4","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"使用以下代码导入文件","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; delim=\"::\")","category":"page"},{"location":"Tools/CSV_jl_use/#无标题情况","page":"CSV.jl使用简介","title":"无标题情况","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"文件内容：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"1,2,3\n4,5,6\n7,8,9","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"在没有标题的情况下，会默认把第一行当作标题，可以给定参数取消，使用以下代码导入文件","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; header=false) #取消标题","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"或者也可以手动给定标题","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; header=[\"col1\", \"col2\", \"col3\"]) #手动给定标题","category":"page"},{"location":"Tools/CSV_jl_use/#指定数据行数","page":"CSV.jl使用简介","title":"指定数据行数","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"文件内容：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"col1,col2,col3\nmetadata1,metadata2,metadata3\nextra1,extra2,extra3\n1,2,3\n4,5,6\n7,8,9","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"假如我们期望的内容是从第四行开始，可以使用以下代码","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; skipto=4) #从第四行开始","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"或者","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; datarow=4)","category":"page"},{"location":"Tools/CSV_jl_use/#读取数据段","page":"CSV.jl使用简介","title":"读取数据段","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"文件内容：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"col1,col2,col3\n1,2,3\n4,5,6\n7,8,9\n10,11,12\n13,14,15\n16,17,18\n19,20,21","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"只需要读入某一段数据段","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; skipto=4，limit=1) #从第四行开始,读取1行","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"或者","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; skipto=4，footerskip=1) #从第四行开始,除去最后一行","category":"page"},{"location":"Tools/CSV_jl_use/#转置","page":"CSV.jl使用简介","title":"转置","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"文件内容：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"col1,1,2,3\ncol2,4,5,6\ncol3,7,8,9","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"用如下代码导入","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"CSV.File(\"data.txt\"; transpose=true) #从第四行开始,读取1行","category":"page"},{"location":"Tools/CSV_jl_use/#数据操作","page":"CSV.jl使用简介","title":"数据操作","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"我们以一下文件输入为例：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"col1,col2,col3\n1,2,3\n4,5,6\n7,8,9\n10,11,12\n13,14,15\n16,17,18\n19,20,21","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"用如下代码导入","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"data = CSV.File(\"data.txt\") ","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"现在相当于把数据储存到变量data中了，data是CSV.File类型的数据，可以通过typeof函数来查看一下：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"typeof(data)","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"现在调用某一列的数字：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"println(data.col1) #显示第一列\nprintln(data.col2) #显示第二列\nprintln(data.col3) #显示第三列","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"它的结果是：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"[1, 4, 7, 10, 13, 16, 19]","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"[2, 5, 8, 11, 14, 17, 20]","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"[3, 6, 9, 12, 15, 18, 21]","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"查看一列的数据类型","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"typeof(data.col1)","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"它的结果是：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"Vector{Int64}","category":"page"},{"location":"Tools/CSV_jl_use/#小结","page":"CSV.jl使用简介","title":"小结","text":"","category":"section"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"可以发现，data是CSV.File类型，但是通过data调用的每一列数据是vector类型","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"说明可以把每一列当作平常的vector来处理，相关的方法都能够匹配。","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"比如：","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"sum(data.col1)\na = data.col1 .* data.col2","category":"page"},{"location":"Tools/CSV_jl_use/","page":"CSV.jl使用简介","title":"CSV.jl使用简介","text":"tip: Tip\n推荐一个好用的数据展示包DataFrames，它一般与CSV.jl结合起来使用在julia的包模式下安装：add DataFrames将data漂亮的输出，只需要：using DataFrames\ndisplay(DataFrame(data))","category":"page"},{"location":"Optimization/systemParaEste/#MTK符号系统参数辨识","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"","category":"section"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"tip: Tip\nContents：MTK模型、优化、DiffEqParamEstimContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"note: Note\nDEPE = DiffEqParamEstim.jl(Differential Equation Parameters Estimate)DiffEqParamEstim.jl是计算微分方程参数估计的软件包。","category":"page"},{"location":"Optimization/systemParaEste/#原理","page":"MTK符号系统参数辨识","title":"原理","text":"","category":"section"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"MTK与DE在问题层面具有一致性。MTK是符号处理的软件包，问题的求解仍然推给DE。而DEPE是从DE的problem层面构建的参数优化问题，所以使用MTK进行建模后，依然可以使用DEPE进行参数估计。对于DEPE来说，不管是MTK还是DE，它接受的问题都是DE的Problem。所以，不管是使用MTK还是DE构建模型，到DEPE这一层面都是贯通的。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"下面以RC电路模型为例，进行电路中正弦电压源的电压值估计。","category":"page"},{"location":"Optimization/systemParaEste/#RC组件建模","page":"MTK符号系统参数辨识","title":"RC组件建模","text":"","category":"section"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"基于ModelingToolkit，建立RC电路模型，模型如下图所示。这是一个震荡电路 (Image: 在这里插入图片描述)","category":"page"},{"location":"Optimization/systemParaEste/#构建组件","page":"MTK符号系统参数辨识","title":"构建组件","text":"","category":"section"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"首先完成电路模型的组件编写，一共有5个组件，分别是电源、电阻、电容、电感、接地","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"using ModelingToolkit, Plots, DifferentialEquations\n\n@variables t\n@connector function Pin(; name)\n    sts = @variables v(t) = 1.0 i(t) = 1.0 [connect = Flow]\n    ODESystem(Equation[], t, sts, []; name=name)\nend\n\nfunction Ground(; name)\n    @named g = Pin()\n    eqs = [g.v ~ 0]\n    compose(ODESystem(eqs, t, [], []; name=name), g)\nend\n\nfunction OnePort(; name)\n    @named p = Pin()\n    @named n = Pin()\n    sts = @variables v(t) = 1.0 i(t) = 1.0\n    eqs = [\n        v ~ p.v - n.v\n        0 ~ p.i + n.i\n        i ~ p.i\n    ]\n    compose(ODESystem(eqs, t, sts, []; name=name), p, n)\nend\n\nfunction Resistor(; name, R=1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters R = R\n    eqs = [\n        v ~ i * R\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction Capacitor(; name, C=1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters C = C\n    D = Differential(t)\n    eqs = [\n        D(v) ~ i / C\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction ConstantVoltage(; name, V=1.0)\n    @named oneport = OnePort()\n    @unpack v = oneport\n    ps = @parameters V = V\n    eqs = [\n        V ~ v\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction Inductor(; name, L=1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters L = L\n    D = Differential(t)\n    eqs = [\n        D(i) ~ v / L\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction ChangeableVoltage(; name)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    eqs = [\n        v ~ 16 * sin(2π * t)\n    ]\n    extend(ODESystem(eqs, t, [], []; name=name), oneport)\nend","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"可以看到，系统一共定义有4个参数，分别是电阻值，电容值，电感值以及电压的最大值","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"然后，通过连接函数，组建系统","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"@named resistor = Resistor(R=3.0)\n@named capacitor = Capacitor(C=1.0/24)\n@named source = ChangeableVoltage(vol=10.0)\n@named inductor = Inductor(L=0.1)\n@named ground = Ground()\n\n\nrc_eqs = [\n          connect(source.p, capacitor.p)\n          connect(capacitor.n, inductor.p)\n          connect(inductor.n, resistor.p)\n          connect(source.n,resistor.n,ground.g)\n         ]\n\n@named _rc_model = ODESystem(rc_eqs, t)\n@named rc_model = compose(_rc_model,\n    [resistor, inductor, capacitor, source, ground])\n\nsys = structural_simplify(rc_model)\n\nusing Plots\nu0 = [\n    capacitor.v => 0.0\n    capacitor.p.i => 0.0\n    inductor.i => 0\n    inductor.v => 0\n     ]\nP=[3.0,1.0/24,0.1,10.0]  #系统的参数\nprob = ODAEProblem(sys, u0, (0, 10.0),P)\nsol = solve(prob, Tsit5())\n\np1 = plot(sol,vars=[capacitor.v capacitor.p.i],xlims = (0,10),ylim = (-10,15))\np2 = plot(sol,vars=[inductor.v inductor.i],xlims = (0,10),ylim = (-5,5))\nplot(p1,p2,layout=(2,1))\n","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"运行代码可以得到结果图： (Image: 在这里插入图片描述)","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"电容的电压电流、电感的电压电流都是震荡的。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"初值向量P分别对应4个参数的参数值，电压值为最后一个，设定为10.0","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"在不知道参数的顺序时，可以使用parameters函数查看系统参数。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"parameters(sys)","category":"page"},{"location":"Optimization/systemParaEste/#建立问题","page":"MTK符号系统参数辨识","title":"建立问题","text":"","category":"section"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"为了能够模拟参数辨识，给其中一个变量加上扰动（这里依旧采用手动生成数据的思想，可能保证模型与数据匹配）。可以使用states函数查看系统变量（在组件设计过程中定义的）。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"states(sys)","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"这里对两个变量都添加扰动。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"using RecursiveArrayTools\nt = collect(range(0,stop=10,length=1000)) # 建立时间向量\nrandomized = VectorOfArray([(sol(t[i]) + .5randn(2)) for i in 1:length(t)])\ndata = convert(Array,randomized)  ","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"对sol的结果，选取了1000个点作为样本点加入扰动。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"加入的扰动的方式是：通过生成绝对值小于0.5的随机数加入到从sol中选取出来的样本点中去，将其作为需要参数辨识的样本数据。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"看一看扰动生成的结果：","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"p1=plot(t,data[1,:],ylim=(-8,8))\np1=plot!(t,data[2,:],ylim=(-8,8))\np2=plot(sol,vars=[inductor.i,capacitor.v],ylim=(-8,8))\nplot(p1,p2,layout=(2,1))","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"产生的结果图为： (Image: 在这里插入图片描述)","category":"page"},{"location":"Optimization/systemParaEste/#辨识过程","page":"MTK符号系统参数辨识","title":"辨识过程","text":"","category":"section"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"参数辨识使用DiffEqParamEstim，","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"using DiffEqParamEstim\ncost_function = build_loss_objective(prob,Tsit5(),\nL2Loss(t,data),maxiters=10000,verbose=false)","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"通过buildlossobjective建立了辨识模型，即通过该函数可以求处理后的样本点与模型计算结果的方差和（L2Loss），当然方差和只是作为拟合的评价指标之一，可以选取不同的函数或者构建不同的指标。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"接下来，看一看不同的电压值，带来的方差和的变化。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"vals = 0:0.1:20.0\nplot(vals,[cost_function([3.0,1.0/24,0.1,i]) for i in vals],yscale=:log10,\n     xaxis = \"Parameter\", yaxis = \"Cost\", title = \"1-Parameter Cost Function\",\n     lw = 3)","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"val为从0开始，到20，步长为0.1。对这些电压值，去匹配模型，算出来的与样本值的方差和会不同。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"结果为： (Image: 在这里插入图片描述)","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"可以看到，在10.0的地方，方差和最小（因为设定的值就是10.0，扰动是在此基础之上叠加的）。说明辨识结果有效。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"以上是通过“肉眼”观察的出来的结果。科学的方法是求一组参数，使得方差和最小。这是一个最优化问题。使用Optim","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"using Optim\nresult = optimize(cost_function, [3.0,1.0/24,0.1,15])\nresult.minimizer","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"将电压的初始值设为15去寻优，得到的结果为：","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"4-element Vector{Float64}:\n 2.975801390547115\n 0.04266590691854741\n 0.09999565290932136\n 9.923607580088433","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"和真实值是非常接近的！寻优有效！","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"也可以将4个初始值都改变去寻优。","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"result = optimize(cost_function, [2.0,0.1,0.5,16])\nresult.minimizer","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"得到的结果也很好","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"4-element Vector{Float64}:\n 2.972037379476059\n 0.04300492580277582\n 0.09998659716890046\n 9.911215185371102","category":"page"},{"location":"Optimization/systemParaEste/","page":"MTK符号系统参数辨识","title":"MTK符号系统参数辨识","text":"note: Note\n该参数辨识仍然是优化问题的子集，选择不同的初值很可能得到不同的结果。","category":"page"},{"location":"WorkFlow/gitworkflow/#Ai4E组织合作开发流程","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"tip: Tip\nContents：基于Gitkraken的合作开发流程Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"note: Note\nGitkraken为Git图形化软件。预计实践时间：60min - 120min","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"Pages = [\"gitworkflow.md\"]","category":"page"},{"location":"WorkFlow/gitworkflow/#开发流程简介","page":"Ai4E组织合作开发流程","title":"开发流程简介","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"Github是一个非常流行的代码托管平台，上面有许许多多的前辈与“他们的牛逼代码”。为了充分与国际接轨，我们（Ai4Energy）组织也选择Github。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"Ai4Energy组织可以视为一个大的代码仓库，每个人都可以向组织中贡献代码。Github基于Git，有完善且高效的多人协作的开发流程（所谓开发流程其实就是如何向Ai4Energy组织中提交代码做贡献）。","category":"page"},{"location":"WorkFlow/gitworkflow/#准备工作","page":"Ai4E组织合作开发流程","title":"准备工作","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"Github注册账户\n下载Gitkraken\n用Github账户登录Gitkraken（重要），然后建立Gitkraken的profile（个人形象，不重要）\n建立SSH登录验证方式（点击下面的绿色按钮，Gitkraken自动生成并且上传），如下图。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"(Image: 图 3)  ","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"tip: Tip\n稳定连接Github，推荐一个免费加速器Watt Toolkit，在微软应用商店。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"接下来是开发的逻辑介绍。","category":"page"},{"location":"WorkFlow/gitworkflow/#开发逻辑","page":"Ai4E组织合作开发流程","title":"开发逻辑","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"应用场景是这样的：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"在某师兄云盘里有一份报告，师兄给2个师弟说你们合作把这份报告改一改（假设两位师弟一个在美国一个在日本，且不认识，只有云盘的地址）。小师弟先改第一版，大师弟改第二版。他们需要干以下的操作：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"小师弟把文件先添加到自己的云盘资源里\n假设云盘没有在线编辑功能，小师弟修改文件只有一种选择：把文件下载到本地修改。\n小师弟修改报告\n小师弟把修改完成的报告上传至自己的云盘。\n修改完成之后，小师弟就可以对师兄说：我改完了，文件在我自己的云盘里，如果可以的话，我就把你的那一份原来的报告覆盖了。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"接下来的选择就有两种：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"师兄说：改的不错，覆盖吧。然后大师弟重复1-5步骤\n师兄说：改的不行，重改吧。然后小师弟重复2-5步骤","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"以上，就是我们工作流程的实际内涵：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"1: 这个行为叫Fork。Fork的意思是在自己的个人账号下建立一个一样的别人的仓库，而且会显示你这个仓库是fork别人的。 (Image: 图 1)","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"2: 这个行为叫Pull。一般而言，第一次在本地建仓时，会自动Pull。本地仓库建好了，若云端仓库文件有更新，这个时候本地文件要更新的话，就有相应的Pull操作。 (Image: 图 2)","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"3: 这个行为叫开发🤣。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"4: 这个行为叫Push。 (Image: 图 3)","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"5: 这个行为叫Pull Request（合并到主分支）。为要先推送到自己仓库的副本而不是直接覆盖别人的那个仓库呢？🤣","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"整体的逻辑图如下：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"(Image: 图 2)  ","category":"page"},{"location":"WorkFlow/gitworkflow/#操作步骤与方法","page":"Ai4E组织合作开发流程","title":"操作步骤与方法","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"方法对应以上5个步骤。","category":"page"},{"location":"WorkFlow/gitworkflow/#Step1:-Fork","page":"Ai4E组织合作开发流程","title":"Step1: Fork","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"(Image: 图 4)  ","category":"page"},{"location":"WorkFlow/gitworkflow/#Step2:-Pull","page":"Ai4E组织合作开发流程","title":"Step2: Pull","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"首先是本地建仓：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"(Image: 图 2)","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"拉取之后点击Open Now，我们就能看到操作页面。同时在左侧需要点击Add。GitKraken自动检测到我们Fork了一个包，它会认为你可能需要通过修改别人的代码然后上传到你自己的库里，所以它给了一个添加自己Fork的库的一个选项（如果点上，也可以手动添加远程仓库）。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"(Image: 图 5)","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"note: Note\n在Step2中，如果是从自己Fork的仓库地址建立本地仓库，也可以，只不过要手动添加Ai4的远程地址了。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"中间的蓝色绿色圈是啥呢？是文件修改的记录。","category":"page"},{"location":"WorkFlow/gitworkflow/#Step3:-本地进行内容编辑——开发","page":"Ai4E组织合作开发流程","title":"Step3: 本地进行内容编辑——开发","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/#Step4:-Push","page":"Ai4E组织合作开发流程","title":"Step4: Push","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"编辑完成之后（任何改动都会被检测到）有几个关键步骤：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"给本次修改命名，表示干了什么（例如：add a file）\n右边上方暂存修改\n右边底下提交更改\n在修改的圈那里右键，点击UpStream，修改推送地点。一定要选择自己的库，组织的库没有权限推送上去。\n最后点击Push","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"(Image: 图 6)","category":"page"},{"location":"WorkFlow/gitworkflow/#Step5:-Pull-Request（合并到主分支）","page":"Ai4E组织合作开发流程","title":"Step5: Pull Request（合并到主分支）","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"Gitkraken有图形化的方式创建Pull Request。如下：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"(Image: 图 7)","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"Pull Request就是申请将你做的修改合并到Ai4的某个仓库（任何别人的仓库）。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"tip: Tip\n为什么能合并呢？因为首先把别人的库给拉取过来了，只是做了一些修改（增加或删减内容），仓库的“根”是一致的所以能合并。就类似，小师弟把师兄的文件复制过来了，在它的基础上改，改完之后把自己的内容复制，在师兄的文件中覆盖粘贴，这是没有问题的。 所以，如果选择两个不同“根”的仓库去Pull Request，那是行不通的。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"完成之后，就等“师兄审核”吧！","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"这是一套基于Gitkraken的简版Git合作开发流程，如果有兴趣，可以去了解原汁原味的Git。相关的资料很多！","category":"page"},{"location":"WorkFlow/gitworkflow/#实践","page":"Ai4E组织合作开发流程","title":"实践","text":"","category":"section"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"Ai4Energy中有一个test.jl。完成以下内容：","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"完成一次上述开发过程，形成具象认知。\n开发内容：在test.jl库中的src文件夹中，添加编辑一个xxx.jl的文件，（xxx为自己的名字，中文，便于\"师兄审核\"）\n文件内容任意。期望针对文档给出改进建议，也可以是一段Julia代码。","category":"page"},{"location":"WorkFlow/gitworkflow/","page":"Ai4E组织合作开发流程","title":"Ai4E组织合作开发流程","text":"以上是一个简单的流程，对于Git或Gitkraken来说只是冰山一角。遇到任何疑问与问题，积极思考原因，可以自行查阅相关资料，也可以积极的和Ai4组的同学交流。","category":"page"},{"location":"Modeling/MTK_tips/#MTK常见问题","page":"MTK常见问题","title":"MTK常见问题","text":"","category":"section"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"tip: Tip\nContents：建模、MTK、外部函数Contributor: YYBEmail: 812987139@qq.com如有错误，请批评指正。","category":"page"},{"location":"Modeling/MTK_tips/#UndefVarError","page":"MTK常见问题","title":"UndefVarError","text":"","category":"section"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"目前官方在此方面可能有bug，可以关注模型边界条件尝试避开问题","category":"page"},{"location":"Modeling/MTK_tips/#key-not-found","page":"MTK常见问题","title":"key not found","text":"","category":"section"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"在structural_simplify后，有些等式条件会自动微分，导致变量数没变，但是方程增加，进而导致模型不平衡","category":"page"},{"location":"Modeling/MTK_tips/#xxx-are-missing-from-variables-map","page":"MTK常见问题","title":"xxx are missing from variables map","text":"","category":"section"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"可能是初值没有设置。建议所有模型均设置初值，动态模型初值直接输入至defaults参数。","category":"page"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"@connector function flowPortNode(; name)\n    #通流元件节点，在热力学节点上包装了体积、质量流量 \n    #如果同时需要标记connect类型，还要赋值，那么一定要括起来\n    #initialValue写作Dict或者数组都可以\n    sts = @variables begin\n        p(t)\n        T(t)\n        (qm(t), [connect = Flow])\n        (rho(t), [connect = Stream])\n        (mu(t), [connect = Stream])\n        (qv(t), [connect = Stream])\n    end\n    initialValue = [\n        p => 1.013e5\n        T => 300\n        qm => 0\n        rho => 1.2\n        mu => 1.819e-5\n        qv => 0\n    ]\n    eqs = [\n        0 ~ stateEquation(p, rho, T)\n        mu ~ 1.819e-5\n        #qm ~ rho * qv\n        qv ~ qm / rho\n    ]\n    ODESystem(eqs, t, sts, []; name=name, defaults=initialValue)\nend","category":"page"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"在生成问题前再统一传入初值。","category":"page"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"u01 = [\n    d_temp => 0\n]\n\na = ModelingToolkit.defaults(sys1)\nfor i in keys(a)\n    global u01\n    u01 = [u01; i => a[i]]\nend","category":"page"},{"location":"Modeling/MTK_tips/","page":"MTK常见问题","title":"MTK常见问题","text":"该问题的产生原因与DAE问题的求解算法有关。将DAE问题降指数为ODE问题后，模型可能需要更多的初始条件作为输入。","category":"page"},{"location":"Control/OptimControl/#最优控制理论与应用","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"tip: Tip\nContents：JuMP、Control、EquationsSolverContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"note: Note\nJuMP是计算优化问题的Julia软件包。Symbolics.jl为符号计算包EquationsSolver自制的小型方程（组）求解器。","category":"page"},{"location":"Control/OptimControl/#问题描述","page":"最优控制理论与应用","title":"1 问题描述","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"本篇通过一个机器人的控制问题，介绍最优控制的相关理论与求解方式。问题如下：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 1)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"题目信息总结如下：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"这是一个含有三个关节的机器人。\n机器人身体的三部分与垂直方向的夹角分别为theta=theta_1theta_2theta_3。\n机器人的三个关节能够提供使机器人运动的扭矩：Q=Q_1Q_2Q_3。\n机器人关节的扭矩与夹角之间的关系（控制方程）为：Jmathbfddottheta=Ktheta+BQ。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"扭矩对夹角的控制方程的推导方法，我们并不关心。知晓它是通过动力学学分析得出即可。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"它最重要的信息是揭示了Q与theta之间的控制关系。通过该方程，我们可以知道，如果控制量Q发生了改变，被控量theta会发生何种变化。控制方程的物理含义是，夹角变化的角加速度与夹角的位置以及关节扭矩相关。具体的系数值见上图所示。","category":"page"},{"location":"Control/OptimControl/#.1-（最优）控制内涵","page":"最优控制理论与应用","title":"1.1 （最优）控制内涵","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"从这个问题中，我们可以抽象出“控制”一般性内涵：通过改变控制量来操作被控量。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"那么什么是最优控制的内涵呢？","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"假如，机器人初始状态是斜站着（theta=fracpi4fracpi4fracpi4，弧度制单位），现在要让机器人站直（theta=000）。我们可以改变关节扭矩Q。那么问题来了，Q应该：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"是否是一个随时间不变的常数？\n如果是常数，取何值？\n是否是一个随时间变化的函数？\n如果是函数，怎样变化？","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"我们从方程中可以发现，假若对Q不加限制。只是要机器人站直，那么我可以通过改变Q，让机器人可以慢慢的站、快快的站、先蹲后站，先躺后站，先俯卧撑再站，先整几个深蹲再站 :)。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"最优的含义则体现在这些“限制”里。一般而言，若对控制的效果加以限制，使控制的某种指标最大（最小），则是最优控制。例如，让机器人最快的站直，最省力的站直。在这些“最”的限制下，Q就不是任意的了（要最快的站直就不能先做个俯卧撑再站，那样就慢了 :) ），而是仅有一组最符合要求的。在数学上，最符合要求的Q则是这个最优化问题的解。这就是最优化控制的内涵。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"综上，其关键的要素有两点：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"控制方程\n控制过程中的最优化目标","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"在以上2点关键要素之下，最优控制问题的本质是优化问题：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"优化目标：控制最优化\n优化约束：控制方程代表的变量约束以及起点终点约束等。","category":"page"},{"location":"Control/OptimControl/#状态方程","page":"最优控制理论与应用","title":"2 状态方程","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"状态空间方程是控制学中非常重要的一个概念。控制学中，把变量视为状态。其本质还是将数学上的变量赋予了物理含义。状态方程的矩阵形式为：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"dotmathbfx=mathbfA(t)mathbfx+mathbfB(t)mathbfu","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"其特征如下：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"上述mathbfx为状态向量\n上述mathbfu为系统的输入向量（控制量向量）\n上述mathbfAB为系统系数矩阵，描述内部量之间的联系。\n统一以一阶导数的形式描述。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"若把机器人的控制方程写成状态方程，则有：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"leftbeginmatrixdotmathbfx_1=mathbfx_2dotmathbfx_2=mathbfJ^-1Kmathbfx_1+mathbfJ^-1BmathbfuendmatrixrightRightarrow dotmathbfx=beginbmatrix01mathbfJ^-1K0endbmatrixmathbfx+beginbmatrix0mathbfJ^-1Bendbmatrixmathbfu","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"其中，","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"mathbfA=beginbmatrix01mathbfJ^-1K0endbmatrixmathbfB=beginbmatrix0mathbfJ^-1Bendbmatrix","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"上述mathbfx_1代表角速度向量，有三个角速度分量。\n上述mathbfx_2代表角加速度向量，有三个角加速度分量。\n上述mathbfu代表扭矩向量，有三个扭矩分量。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"如此则统一了控制问题的方程描述。状态方程也好，控制方程也好，其本质是描述系统的方程。它们只是形式上的区别，在数学本质上是一致的。统一为状态方程的好处是，能够对控制问题进行普适性的推导与计算，使得状态方程下的数学推论具有普遍意义。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"note: Note\n状态方程的定义为:描述系统状态变量与输入变量之间关系的一阶微分方程组，称为系统的状态方程。状态方程表征了系统由输入量引起的内部状态变量的变化情况。","category":"page"},{"location":"Control/OptimControl/#最优控制问题解析解","page":"最优控制理论与应用","title":"3 最优控制问题解析解","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"首先，介绍系统一般性数学描述：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"系统状态方程","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"dotx(t)=Ax(t)+Bu(t)=fx(t)u(t)t","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"由于状态量都是关于时间的因变量，所以都写成关于时间的函数。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"系统始端与终端","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"x(t_0)=x_0x(t_f)=x_f ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"系统性能指标","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"J=int_t_o^t_fLx(t)u(t)tdt","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"其次，把它写优化问题的数学形式则为：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"beginmatrix\n min int_t_o^t_fLx(t)u(t)tdtsthspace6cmdotx(t)=fx(t)u(t)tx(t_0)=x_0x(t_f)=x_f \nendmatrix","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"一般的优化问题的解是数。不同于一般的优化问题，该优化的问题的解是函数。这就涉及到数学中的变分概念。这里不过多介绍，只给结论。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"tip: Tip\n一般最优化问题中，是找到相应的数值使得优化目标最小。最优化控制问题中，是找到相应的控制函数，使得优化目标最小。一个是找数值，一个是找函数。相当于自变量变为了函数。这是泛函分析解决的问题。","category":"page"},{"location":"Control/OptimControl/#.1-端点固定问题的解法","page":"最优控制理论与应用","title":"3.1 端点固定问题的解法","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"端点固定问题即t_f的数值确定。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"求解析解的方法是拉格朗日乘子法在泛函分析中的体现。首先令，","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"H = Lx(t)u(t)t + lambda(t)^Tfx(t)u(t)t","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"上式中，H称为哈密尔顿函数，lambda(t)为伴随方程。最优控制函数存在的必要条件为：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"beginmatrix\n dotlambda = -fracpartial Hpartial x\nfracpartial Hpartial u=0\nendmatrix","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"再结合控制方程与边界方程，则可以解得分析解。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"tip: Tip\n最优控制问题中有多种边界条件。端点固定问题只是其中一种。它们分别为：终端时刻t_f固定，终端向量x(t_f)自由\n终端时刻t_f固定，终端向量x(t_f)约束\n终端时刻t_f自由，终端向量x(t_f)约束在约束中，数值确定是也是约束的一种。不同的边界条件，添加不同的边界方程，在此不过多介绍，有兴趣可以翻看《最优控制理论》。","category":"page"},{"location":"Control/OptimControl/#机器人控制问题求解实例","page":"最优控制理论与应用","title":"4 机器人控制问题求解实例","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"机器人问题的状态方程为：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"beginmatrix\n dotmathbfx=mathbfAmathbfx+mathbfBmathbfu  \nmathbfA=beginbmatrix01mathbfJ^-1K0endbmatrixmathbfB=beginbmatrix0mathbfJ^-1Bendbmatrix\nendmatrix","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"设优化目标如下，可以理解为最省力的站直方式。因为其物理含义是时间域上的扭矩平方和最小。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"J=int_t_o^t_fu^2dt","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"可以得到哈密尔顿方程为：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"H=u^2+Alambda_2x_1+lambda_1x_2+lambda_2Bu","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"代入解析解存在的必要条件：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"beginmatrix\n dotlambda_1 = -fracpartial Hpartial x_1=-lambda_2x_2 dotlambda_2 = -fracpartial Hpartial x_2=-lambda_1fracpartial Hpartial u=2u+lambda_2B=0\nendmatrix","category":"page"},{"location":"Control/OptimControl/#.1-SymPy求状态方程解析解","page":"最优控制理论与应用","title":"4.1 SymPy求状态方程解析解","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"化简伴随方程，结合控制方程，可以得到：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"beginmatrix\n ddotlambda_2 - Alambda_2= 0 u=-05*lambda_2Bddotx_1=Ax_1+Bu\nendmatrix","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"为了求得上述问题的解析解，采用SymPy。SymPy是基于python的符号计算包，其开发了julia的调用接口。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"using SymPy\n@syms t A B λ() x() #定义函数及符号变量\ndiffeq = Eq(λ(t).diff(t, 2), A * λ(t)) # 定义需要求解的方程\nλt = dsolve(diffeq, λ(t)).__pyobject__.rhs # 求解得到λ\nut = -1//2 * B * λt # 计算得到u\ndiffeq2 = Eq(x(t).diff(t, t), A * x(t) + B * ut)# 定义关于x(t)的微分方程\ndsolve(diffeq2, x(t))  # 求解","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"warning: Warning\n在上述代码中，0.5需要用1//2，这样x(t)才能求得解析解，否则会报错。因为0.5是浮点数。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"得到结果如下：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 2)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"即：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"x_1(t)=(C_3+C_1fracB^2t4sqrtA)exp^-sqrtAt+(C_4-C_2fracB^2t4sqrtA)exp^sqrtAt","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"同时，对x_1(t)进行求导，得到x_2(t)。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"dsolve(diffeq2, x(t)).__pyobject__.rhs.diff(t)","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 1)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"即：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"x_2(t)=-(sqrtAC_3+C_1fracB^2t4)exp^-sqrtAt+(sqrtAC_4-C_2fracB^2t4)exp^sqrtAt+C_1fracB^2t4sqrtAexp^-sqrtAt-C_2fracB^2t4sqrtAexp^sqrtAt","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"这里一共有4个未知数:C_1C_2C_3C_4，通过4个边界调节确定：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"beginmatrix\nx_1(0)=fracpi4fracpi4fracpi4x_1(1)=000x_2(0)=000x_2(1)=000\nendmatrix","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"4个边界方程则可解出4个未知数C_1C_2C_3C_4。实际上C_1C_2C_3C_4是4个向量，每个向量分别对应机器人三部分的参数。在求解时，实际上是12个变量。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"note: Note\n也可以通过SymPy直接求解微分方程组。能获得同样的结果。using SymPy  \n@syms t A B λ1() x1() λ2() x2()\neqs = [\nEq(λ1(t).diff(t), -A * λ2(t)),\nEq(λ2(t).diff(t), -λ1(t)),\nEq(x1(t).diff(t), x2(t)),\nEq(x2(t).diff(t), A * x1(t) - B^2 / 2 * λ2(t))\n]\ndsolve(eqs)","category":"page"},{"location":"Control/OptimControl/#.2-参数矩阵求解","page":"最优控制理论与应用","title":"4.2 参数矩阵求解","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"下面介绍如何在Julia生态高效计算4个未知数。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"需要运用符号处理包——Symbolics.jl。该包在MTK的\"前世今生\"已经介绍过。本篇中也会用到。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"using Symbolics, EquationsSolver, LinearAlgebra\n# ==========================functions==================== #\nfunction initPara()\n    J1 = 1.0 / 12 * collect(I(3))\n    C1 = 0.5 * [1 2 2; 0 1 2; 0 0 2]\n    D1 = 0.5 * [1 0 0; 2 1 0; 4 2 1]\n    J = J1 + C1 * D1\n    K = 0.5 * [5 0 0; 0 3 0; 0 0 1]\n    B = [1 -1 0; 0 1 -1; 0 0 1]\n    A = inv(J) * K\n    B = inv(J) * B\n    return A, B\nend\n\nfunction x1(A, B, t, C1, C2, M1, M2)\n    A = sqrt(A)\n    B = inv(A) * B * B / 4\n    s = -(B * t) .* exp.(A * t) .* C1\n    s = s .+ exp.(A * t) .* M1\n    s = s .+ (B * t) .* exp.(-A * t) .* C2\n    s = s .+ exp.(-A * t) .* M2\n    return s\nend\n\nfunction x2(A, B, t, C1, C2, M1, M2)\n    A = sqrt(A)\n    B = B * B / 4\n    s = (-B * t .* C1 .+ A * M1 .- inv(A) * B * C1) .* exp.(A * t)\n    s = s .+ (-B * t .* C2 .- A * M2 .+ inv(A) * B * C2) .* exp.(-A * t)\n    return s\nend\n\nfunction SolvePro(eqs, init, vars)\n    pro = NLProblem(eqs, init)\n    res = solve(pro)\n    return [reshape([res[var[i]] for i in 1:3], (3, 1)) for var in vars]\nend\n\nfunction condition(θfields, A, B, tfields, C1, C2, M1, M2)\n    res = x1(A, B, tfields[1], C1, C2, M1, M2)\n    eqs = [res[i] ~ θfields[1][i] for i in 1:3]\n    res = x1(A, B, tfields[2], C1, C2, M1, M2)\n    append!(eqs, [res[i] ~ θfields[2][i] for i in 1:3])\n    res = x2(A, B, tfields[1], C1, C2, M1, M2)\n    append!(eqs, [res[i] ~ θfields[3][i] for i in 1:3])\n    res = x2(A, B, tfields[2], C1, C2, M1, M2)\n    append!(eqs, [res[i] ~ θfields[4][i] for i in 1:3])\n    return eqs\nend\n\nfunction Problem(A, B, θfields, tfields)\n    vars = @variables C1[1:3] C2[1:3] M1[1:3] M2[1:3]\n    C1, C2, M1, M2 = [reshape(collect(var), 3, 1) for var in vars]\n    eqs = condition(θfields, A, B, tfields, C1, C2, M1, M2)\n    init = Dict(var[i] => 0.0 for var in vars for i in 1:3)\n    return SolvePro(eqs, init, vars)\nend\n\n\n# ==========================main==================== #\nA, B = initPara()\n# 分别为x1(0) x1(t) x2(0) x2(t)的边界值\nθfields = [[π / 3, -π / 4, π / 2], [0, 0, 0], [0, 0, 0], [0, 0, 0]]\ntfields = (fill(0.0, 3, 1), fill(1.0, 3, 1))\nN = 100\nC1, C2, M1, M2 = Problem(A, B, θfields, tfields)\nt = (0, 1)\n\ndegrees = [x1(A, B, fill(i, 3, 1), C1, C2, M1, M2) for i in range(t[1], t[2], length=N)]\nvelocity = [x2(A, B, fill(i, 3, 1), C1, C2, M1, M2) for i in range(t[1], t[2], length=N)]","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"warning: Warning\nSolvePro()中，fracB^2t4sqrtA等含有除以矩阵A的式子，在编写时都要写为左乘A的逆矩阵。这是由数学含义决定的，否则结果错误。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"上述代码的核心思想为：将符号计算与数字计算在形式上统一。核心为函数x1()与x2()。其便捷性在于，若把符号矩阵作为传递给x1()，则x1()计算结果为符号矩阵，若传递数值，则计算结果为数值解。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"符号计算解参数：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"function SolvePro(eqs, init, vars)\n    pro = NLProblem(eqs, init)\n    res = solve(pro)\n    return [reshape([res[var[i]] for i in 1:3], (3, 1)) for var in vars]\nend\nfunction condition(θfields, A, B, tfields, C1, C2, M1, M2)\n    res = x1(A, B, tfields[1], C1, C2, M1, M2)\n    eqs = [res[i] ~ θfields[1][i] for i in 1:3]\n    res = x1(A, B, tfields[2], C1, C2, M1, M2)\n    append!(eqs, [res[i] ~ θfields[2][i] for i in 1:3])\n    res = x2(A, B, tfields[1], C1, C2, M1, M2)\n    append!(eqs, [res[i] ~ θfields[3][i] for i in 1:3])\n    res = x2(A, B, tfields[2], C1, C2, M1, M2)\n    append!(eqs, [res[i] ~ θfields[4][i] for i in 1:3])\n    return eqs\nend\nfunction Problem(A, B, θfields, tfields)\n    vars = @variables C1[1:3] C2[1:3] M1[1:3] M2[1:3]\n    C1, C2, M1, M2 = [reshape(collect(var), 3, 1) for var in vars]\n    eqs = condition(θfields, A, B, tfields, C1, C2, M1, M2)\n    init = Dict(var[i] => 0.0 for var in vars for i in 1:3)\n    return SolvePro(eqs, init, vars)\nend","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"在Problem()函数中，定义了12个未知数。\n将符号作为参数传递给condition()并通过其构建待求解方程。如果兴趣可以在函数中Print待求解方程结果。\n通过SolvePro()调用EquationsSolver方程求解器求解。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"最终可得到12个参数的结果","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"数字计算算结果：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"在计算出4个参数向量后，SolvePro()经过结果处理返回参数向量值，再调用x1()与x2()时，则能够得到各时间点的数值。具体的操作方式如下：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"t = (0, 1)\ndegrees = [x1(A, B, fill(i, 3, 1), C1, C2, M1, M2) for i in range(t[1], t[2], length=N)]\nvelocity = [x2(A, B, fill(i, 3, 1), C1, C2, M1, M2) for i in range(t[1], t[2], length=N)]","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"在调用x1()与x2()时，不过是传递了不同的参数，就能得到不同结果的类型。传递符号就计算符号，传递数值就计算数值。符号与数值本在数学形式上是一致的，在Julia中则完美地实现了这一点！","category":"page"},{"location":"Control/OptimControl/#.3-解析解可视化","page":"最优控制理论与应用","title":"4.3 解析解可视化","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"degrees = real.(degrees)\nvelocity = real.(velocity)\nusing Plots\nfilename = \"./a.gif\"\nlen = 1\nanim = @animate for i in 1:N\n    strings = \"t=$(i/N*(t[2]-t[1])+t[1])  \"\n    strings *= \"v₁=\" * string(round.(velocity[i][1], digits=2))\n    strings *= \" v₂=\" * string(round.(velocity[i][2], digits=2))\n    strings *= \" v₃=\" * string(round.(velocity[i][3], digits=2))\n    l = collect(0:0.01:len)\n    xs1 = l .* sin(degrees[i][1])\n    ys1 = l .* cos(degrees[i][1])\n    xs2 = l .* sin(degrees[i][2]) .+ xs1[end]\n    ys2 = l .* cos(degrees[i][2]) .+ ys1[end]\n    xs3 = l .* sin(degrees[i][3]) .+ xs2[end]\n    ys3 = l .* cos(degrees[i][3]) .+ ys2[end]\n    plot([xs1, xs2, xs3], [ys1, ys2, ys3],\n        ylims=(0, 4), xlims=(-3, 3), w=3,\n        grid=false, showaxis=false, legend=false,\n        title=strings)\nend\ngif(anim, filename, fps=24)","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"上面的实例计算的是机器人初态为theta=fracpi3-fracpi4fracpi2的情况。动图如下：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 2)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"机器人初态为theta=fracpi3fracpi4fracpi5的情况：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 3)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"机器人初态为theta=fracpi18fracpi6fracpi4的情况：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 4)  ","category":"page"},{"location":"Control/OptimControl/#数值解","page":"最优控制理论与应用","title":"5 数值解","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"该问题使用数值解则很好解决，优化问题使用JuMP则迎刃而解。","category":"page"},{"location":"Control/OptimControl/#.1-求解方法","page":"最优控制理论与应用","title":"5.1 求解方法","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"首先看一个示例：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"using JuMP, LinearAlgebra, Ipopt, Statistics\n\nθ = [π / 3, -π / 4, π / 2]\nθ = [π / 18, π / 6, π / 4]\nθ = [π / 3, π / 4, π / 5]\nN = 100\ntf = 4.0\n\n#---------------------------------------------#\nfunction initPara()\n    J1 = 1.0 / 12 * collect(I(3))\n    C1 = 0.5 * [1 2 2; 0 1 2; 0 0 2]\n    D1 = 0.5 * [1 0 0; 2 1 0; 4 2 1]\n    J = J1 + C1 * D1\n    K = 0.5 * [5 0 0; 0 3 0; 0 0 1]\n    B = [1 -1 0; 0 1 -1; 0 0 1]\n    A = inv(J) * K\n    B = inv(J) * B\n    return A, B\nend\nA, B = initPara()\nmodel = Model(Ipopt.Optimizer)\n@variables(model, begin\n    -π / 2 <= x1[1:N, 1:3] <= π / 2\n    x2[1:N, 1:3]\n    -10 <= u[1:N, 1:3] <= 10\nend)\ninitzeros = zeros(3)\nfor j in 1:3\n    @NLconstraint(model, x1[1, j] == θ[j])\n    @NLconstraint(model, x2[1, j] == initzeros[j])\n    @NLconstraint(model, x1[N, j] == initzeros[j])\n    @NLconstraint(model, x2[N, j] == initzeros[j])\nend\nfor i in 1:N-1\n    a1 = x1[i, :] + (x2[i+1, :] + x2[i, :]) * 0.5 * tf / N\n    a2 = x2[i, :] + (A * (x1[i+1, :] + x1[i, :]) + B * (u[i+1, :] + u[i, :])) * 0.5tf / N\n    for j in 1:3\n        @NLconstraint(model, x1[i+1, j] == a1[j])\n        @NLconstraint(model, x2[i+1, j] == a2[j])\n    end\nend\n@NLobjective(model, Min, sum(20 / π * x1[i, j]^2 + u[i, j]^2 for i in 1:N-1 for j in 1:3))\nJuMP.optimize!(model)\ndegrees = JuMP.value.(x1)\nvelocity = JuMP.value.(x2)\n\n\nusing Plots\nfilename = \"./u_x_a4.gif\"\nlen = 1\nanim = @animate for i in 1:N\n    strings = \"Numerical t=$(i/N*tf)  \"\n    strings *= \"v₁=\" * string(round(velocity[i, 1], digits=2))\n    strings *= \" v₂=\" * string(round(velocity[i, 2], digits=2))\n    strings *= \" v₃=\" * string(round(velocity[i, 3], digits=2))\n    l = collect(0:0.01:len)\n    xs1 = l .* sin(degrees[i, 1])\n    ys1 = l .* cos(degrees[i, 1])\n    xs2 = l .* sin(degrees[i, 2]) .+ xs1[end]\n    ys2 = l .* cos(degrees[i, 2]) .+ ys1[end]\n    xs3 = l .* sin(degrees[i, 3]) .+ xs2[end]\n    ys3 = l .* cos(degrees[i, 3]) .+ ys2[end]\n    plot([xs1, xs2, xs3], [ys1, ys2, ys3],\n        ylims=(0, 4), xlims=(-3, 3), w=3,\n        grid=false, showaxis=false, legend=false,\n        title=strings)\nend\ngif(anim, filename, fps=24)","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"该示例包含了求解与可视化，有如下特征:","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"时间采样数（离散数）为：N = 100；\n调节时间为：tf = 4；\n优化变量（扭矩、角度）有范围限制；\n终端对速度也有约束；\n状态方程作为优化问题的约束，约束不同时刻的状态量之间的关联（不同时间的角度值为不同优化变量。角度状态，角速度状态，扭矩状态各有3N个）。状态方程变为离散结构，因为一旦涉及到数值解，必定是离散化的。离散的方式是二阶的梯形法；\n优化目标为sum_j=1^3sum_i=1^Nfrac20pix_1(ij)^2+u_(ij)^2","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"tip: Tip\n离散的概念有两种理解，一种为问题性质上的理解，即问题本身具有离散性质。另外一种是方法上的理解，即求解问题的过程中对于连续问题采用了离散化的方式。问题性质的离散，是变量本身的一种状态或特性，如开关状态的0与1是独立的状态，本身具有不连续的特性。而离散化是对于连续问题的求解方式。问题本身是连续的，但是为了使用数值计算方法求得数值解，需要取“连续”中的一些相互间隔的“离散”点来代表“连续”。例如，微分方程的数值解法欧拉法的步长则是具有“连续”性质的离散。微分方程的数值解法，一定是离散化的方法——在时间域上选取一定步长间隔的点求解。这两者都可以认为是离散问题，而离散化的方法决定了数值计算的精度以及求解的计算量。从方法的层面说，数值计算本身就是离散问题，对于使用计算机进行数值求解来说，不存在连续求解方法。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"对于以上6点，先不做说明，可以先看一些结果。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况一","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"优化目标：sum_j=1^3sum_i=1^Nu_(ij)^2；\n参数：N = 100，tf = 1；\n末速度限制为0；变量无约束。\n初态为theta=fracpi3-fracpi4fracpi2","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 5)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况二 ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"优化目标：sum_j=1^3sum_i=1^Nu_(ij)^2；\n参数：N = 100，tf = 1；\n末速度无限制；变量无约束。\n初态为theta=fracpi3-fracpi4fracpi2","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 6)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况三 ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"优化目标：sum_j=1^3sum_i=1^Nx_1(ij)^2；\n参数：N = 100，tf = 1；\n末速度限制为0；变量无约束。\n初态为theta=fracpi3-fracpi4fracpi2","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 8)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况四","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"优化目标：sum_j=1^3sum_i=1^Nx_1(ij)^2；\n参数：N = 100，tf = 2；\n末速度限制为0；变量范围限制：-10=u=10。\n初态为theta=fracpi3-fracpi4fracpi2","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 9)  ","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况五","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"优化目标：sum_j=1^3sum_i=1^Nx_1(ij)^2+u_(ij)^2；\n参数：N = 100，tf = 4；\n末速度限制为0；变量范围限制：-10=u=10。\n初态为theta=fracpi3-fracpi4fracpi2","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 10)  ","category":"page"},{"location":"Control/OptimControl/#.2-对比分析","page":"最优控制理论与应用","title":"5.2 对比分析","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况一（站直且速度为零）与情况二（站直速度任意）为不同边界约束的结果。情况一确实不如情况二“迅猛”，情况一的机器人有些拘束，情况二的动作则一气呵成，因为约束少了。同时，情况一的解析解与数值解结果，机器人动作非常神似。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况一（最省力）、情况三（距离最短）与情况五（省力也要距离短）为不同优化条件的结果。可以看出来情况五综合了情况一个和情况二的优点。同时，情况五x_1前面的系数目的是为了平衡优化的效果——将角度值与速度值置于同一量级，即加大省距离的权重。这类似于机器学习的正则化。其实他们在内涵上有相通之处，通过权重规定了对不同优化目标的“重视程度”！","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"情况三与情况四的不同之处在于控制量的范围约束与调节时间限制。在数学上来说，不管给定何种始终条件，若控制量u不限制，则一定能完成控制任务（优化问题有解）。所以在条件4的控制量约束下，若是设tf=1，则在求解时找不到最优解，唯有把时间放款才能在控制量约束下找到解。这非常符合实际，控制量不能无限大，控制过程也需要时间。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"事实上，也可以通过解析解来验证这些结论，但解析解的代码量太大，不如数值解来得方便 :) 。例如，同时考虑x与u的解析解结果为 :)：","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"(Image: 图 11)  ","category":"page"},{"location":"Control/OptimControl/#总结","page":"最优控制理论与应用","title":"总结","text":"","category":"section"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"由机器人的最优控制问题，介绍最优问题的解析解与数值解。从两方面基本上已经诠释了最优控制的内涵。即，为了某种目标去找到一组最合适的控制量。事实上，这只是控制的第一步，计算结果都是静态的。接下来还需要根据实际的系统反馈进行时间域上的滚动优化，滚动起来后，就能够利用系统的反馈，实现了真正意义上的控制——对反馈的处理与计算。","category":"page"},{"location":"Control/OptimControl/","page":"最优控制理论与应用","title":"最优控制理论与应用","text":"另外，从整个机器人问题求解的过程也可以看出Julia生态的强大之处。当问题清楚之后，灵活使用Julia生态的各种软件包，能方便快捷地计算出结果。事实上，最优控制问题的底层数学形式为两种——求解类问题（解析解）与优化类问题（数值解）。同时，符号计算使得编写代码方便快捷。这三者恰恰是Julia计算的长处。所以Julia处理最优控制问题，可以用两个词来形容——丝滑、顺畅。","category":"page"},{"location":"Control/MTKMPC/#MTK求解MPC问题","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"","category":"section"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"tip: Tip\nContents：MTK、ControlContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"note: Note\nMPC = Model Predict ControlMTK = ModelingToolkit.jlOptimizationSystem为MTK中的系统类型之一","category":"page"},{"location":"Control/MTKMPC/#MTK中的ControlSystem","page":"MTK求解MPC问题","title":"MTK中的ControlSystem","text":"","category":"section"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"在ModellingToolkit的Optimal Control中，有关于ControlSystem的描述。但经过实验测试，ControlSystem并不能很好地求解“过程控制量”的值。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"因为MTK使用rungekuttadiscretize（龙格库塔离散）函数将问题离散。问题离散后，传入OptimizationSystem，而OptimizationSystem目前有一个缺陷——不能接受问题的约束。所以，即使用龙格库塔离散离散出控制过程中的多个状态量，在变量没有约束时，优化结果没有意义。（离散的概念在微分方程参数辨识中有提及） 在实例过后，这一点会有清晰的体现。","category":"page"},{"location":"Control/MTKMPC/#MTK中的OptimizationSystem","page":"MTK求解MPC问题","title":"MTK中的OptimizationSystem","text":"","category":"section"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"为了简单起见，手动构建一个MPC优化问题，通过OptimizationSystem来求解。通过构建优化目标方程，调用不同优化器求解该优化问题。那么从控制问题到优化问题这一过程可以看成是手动离散。相当于自己实现了rungekuttadiscretize。构建完优化问题，就可以直接把它推给OptimizationProblem求解，这是可以做到的。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"上述过程的核心就是把控制中的状态量手写出来。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"可行的做法是，通过MTK符号建模体系建立优化变量，同时构建Loss方程关于优化变量的符号表达。通过OptimizationSystem生成用符号体系构建的优化问题，把构建的OptimizationSystem推给OptimizationProblem，最后选择合适的求解器求解。","category":"page"},{"location":"Control/MTKMPC/#实例：加热器问题","page":"MTK求解MPC问题","title":"实例：加热器问题","text":"","category":"section"},{"location":"Control/MTKMPC/#问题描述","page":"MTK求解MPC问题","title":"问题描述","text":"","category":"section"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"现在有一个物体加热，它的温度由加热项和散热项决定。α是散热系数，β是加热系数，环境温度为T_out。那么控制方程: ","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"T = α*(T_out - T) + β*Q(t)","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"现在可以改变加热功率，那么我们构建一个优化问题：调节加热功率，使得物体的温度从T_0开始，迅速上升并且稳定在某一个温度（比如说58℃）。问题的数学表达为，通过优化控制变量Q(t) 使得损失函数最小:","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"Loss = sum_i 580-T(t_i)","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"而Q(t_i)就是未来一段时间域内，不同时间点上的控制量（控制科学中称为状态量）。通过改变这些值，能够控制温度的走势，这是控制的内涵。若使温度达到一个让人满意的状态（这里是维持在58℃，也可以是使温度线性上升等等），这是最优控制的内涵。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"所以，最优控制或者模型预测控制最根本的数学内涵是优化——多变量优化。这也是为什么能用OptimizationProblem来处理控制问题。","category":"page"},{"location":"Control/MTKMPC/#构建问题","page":"MTK求解MPC问题","title":"构建问题","text":"","category":"section"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"首先明确问题。现在假设以一个恒定功率（p=80）加热物体，环境温度18℃，初始温度20℃,散热系数α = 0.2,加热系数β = 0.1。先求解该问题。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"using Plots,DifferentialEquations\nTout = 18.0\nα = 0.2\nβ = 0.1\nf(x,p,t) = α*(Tout - x) + β*p\ntspan=(0.0,40.0)\nu0 = 20.0\np = 80.0\npr = ODEProblem(f,u0,tspan,p)\nsol = solve(pr)\nplot(sol,ylimit=(10,60))","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"得到的结果是： (Image: 图 1)  ","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"很清晰可以看到，温度缓慢上升最后稳定在58℃。那么作为我们拍脑袋的控制策略来说，这个控制问题很简单。我们可以先让功率在前期比较大（比如说150），等温度到了58℃附近，再把功率调回80，就可以实现“温度迅速上升并最后稳定在58度”。","category":"page"},{"location":"Control/MTKMPC/#优化求解","page":"MTK求解MPC问题","title":"优化求解","text":"","category":"section"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"using Symbolics,ModelingToolkit,GalacticOptim,Optim\nN = 20\nTout = 18.0\nT0 = 20.0\ndt = 4/N\nLoss = 0.0\nT = T0\nα = 0.2\nβ = 0.1\n@variables u[1:N]\nfor i = 1:N\n    global T = T + (α*(Tout - T) + β*u[i])*dt\n    global Loss += (T - 58.0)^2\nend","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"u是符号量，离散的个数为N，上面选择离散为20个变量。通过一个for循环，就可以迭代求解20个点上的温度值并且构建Loss方程。这里的20个变量，就是控制的核心，通过改变这20个不同时间点上的控制量（加热功率）的值，使得被控量（温度）接近“更好、更快”地接近目标——58℃。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"可以看到Loss方程的结果：","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"(Image: 图 2)  ","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"有些许复杂，但在情理之中。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"@named sys = OptimizationSystem(Loss,[u[i] for i in 1:N],[],inequality_constraints=inequ)\nu0 = [u[i] => 1.0 for i in 1:N]\nlb = [0.0 for i in 1:N]\nub = [200.0 for i in 1:N]\nprob = OptimizationProblem(sys,u0,[],lb = lb,ub = ub,grad=true,hess=true)\ns = solve(prob,Optim.LBFGS())","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"然后构建System和OptimizationProblem，给定上下限。这里功率上限设为200，最后求解！","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"结果为：","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"u: 20-element Vector{Float64}:\n 199.99999999999997\n 199.99999999999997\n 199.99999999999997\n 199.99999999999997\n 199.99999999999997\n 199.99999999999997\n 199.99999999999997\n 199.99999999999994\n 199.99999999999991\n 199.9999999999999\n 199.99999999999957\n 199.99999999996504\n  82.18673442597857\n  79.99995550035416\n  80.0000502201614\n  79.99991729083732\n  80.00001272875645\n  80.00004827285969\n  79.99999940246633\n  79.99997217751334","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"(Image: 图 3)  ","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"应该说是非常理想的。和我们设想的一样。先以最大功率加热到58℃附近，然后迅速将到稳态维持58℃的功率80，这样2s就完成了控制过程，而之前以恒定功率80加热，耗费了20s!","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"从图中可以很容易看出局限性，加热功率先猛加，以最高限度200直接加热到58，然后功率在恒定在80维持恒温58摄氏度。这种直上直下的调节，很显然不那么让人满意。可以想象，假如不给变量设置上下限，那么优化的结果一定是：第一个离散的变量加热功率上万，相当于在一瞬间使用超大且精准的功率把温度加到58摄氏度。第二个往后的状态量为80——维持恒温58摄氏度的加热功率。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"这在数学上是合理的，在实际中却没有意义。所以在控制中一般需要加一些约束，比如加热功率上下限、加热功率变化幅度。","category":"page"},{"location":"Control/MTKMPC/","page":"MTK求解MPC问题","title":"MTK求解MPC问题","text":"所以，为了处理约束，可以使用JuMP来做MPC。","category":"page"},{"location":"WorkFlow/DocStructure/#文档（docs）编写方法","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"","category":"section"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"tip: Tip\nContents：文档编写方法介绍Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"WorkFlow/DocStructure/#文档结构","page":"文档（docs）编写方法","title":"文档结构","text":"","category":"section"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"在包的根目录下，都有一个/docs文件夹，里面就是文档的所有内容。","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"/docs结构如下：","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"docs/\n├── src/\n│   ├── index.md\n│   ├── components/   \n│   │   ├──MTKMPC.md\n│   │   └──...\n│   └── MyApp.jl\n├── build/\n│   ├── index.html\n│   └── ...\n├── .gitignore\n├── Project.toml\n└── make.jl","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"/src里包含了文档的内容，即很多markdown文件。对应关系如下：","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"(Image: 图 1)  ","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":".gitignore里的内容是在git提交时忽略的内容。例如/build的内容就会全部忽略。","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"Project.toml是julia的环境文件，说明了docs环境中需要用到的包。","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"make.jl是生成的html页面的主文件。运行make.jl，则生成/build文件夹，在默认浏览器中打开/build/index.html就能看到文档，和网页版的一模一样。本质上也是一样的，Github部署也是部署的它。这是本地版，github提交时，会自动运行make.jl生成然后部署。所以/build不用上传。","category":"page"},{"location":"WorkFlow/DocStructure/#编写方法","page":"文档（docs）编写方法","title":"编写方法","text":"","category":"section"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"新添加文档只需要两步操作：","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"创建新的文档(.md文件)\n在make.jl中链接文档路径","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"make.jl中的page链接了全部文档。 (Image: 图 2)  ","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"图中的\"Modeling\"是子目录，在/src里可看到对应文件夹。","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"如果没有在make.jl中链接，就不会在html中显示。没链接等于没写🤣🤣🤣。","category":"page"},{"location":"WorkFlow/DocStructure/","page":"文档（docs）编写方法","title":"文档（docs）编写方法","text":"note: Note\n某些库会设计自动链接，如果自动链接了就不需要手动添加了。","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/#Julia换源(更换国内镜像站)","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"","category":"section"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"tip: Tip\nContents：JuliaPkgContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"打开julia的安装路径，找到文件夹 julia-1.x.x(如1.6.1) 如图","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"进入该文件夹找到etc","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"进入etc 再进入一个文件夹，有一个startup.jl","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"这个startup.jl就很方便了，在启动julia的时候，会首先自动运行里面的内容。","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"所以，打开它，在里面输入一行","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"ENV[\"JULIA_PKG_SERVER\"]=\"https://mirrors.pku.edu.cn/julia/\"","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"就像这样 (Image: 在这里插入图片描述) 保存就完事了。","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"ENV是julia的全局环境变量，能够直接在repl中修改环境变量，但不是永久的。所以放在startup.jl里。这样等价于永久改变了，因为每次启动都会repl自动执行它。","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"在repl中输入ENV如下： (Image: 在这里插入图片描述)","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"还有一些其它的比如LOADPATH 和DEPOTPATH等等，这些都是环境变量。更多可以看中文文档 (Image: 在这里插入图片描述)","category":"page"},{"location":"WorkFlow/julia_change_pkgserve/","page":"Julia换源(更换国内镜像站)","title":"Julia换源(更换国内镜像站)","text":"PS: 不换也行，最新版的julia好像能自动选取一个最快的源。","category":"page"},{"location":"Optimization/JuMP参数辨识/#JuMP非线性参数辨识实例","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"","category":"section"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"tip: Tip\nContents：参数辨识、优化、JuMPContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"note: Note\nJuMP = JuMP.jlNLP = NonlinearnProblem，非线性问题JuMP是计算优化问题的Julia软件包。","category":"page"},{"location":"Optimization/JuMP参数辨识/#JuMP介绍","page":"JuMP非线性参数辨识实例","title":"JuMP介绍","text":"","category":"section"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"JuMP是一种特定领域的建模语言，用于嵌入Julia中的数学优化。可以用于解决各类优化问题。JuMP的指南中列出了可用的求解器，以及能够求解问题的类型。","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"JuMP建模的思路主要分为3步：","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"定义求解器\n明确问题\n求解","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"使用MTK非线性参数辨识实例中的参数优化问题作为求解实例展开介绍","category":"page"},{"location":"Optimization/JuMP参数辨识/#求解实例","page":"JuMP非线性参数辨识实例","title":"求解实例","text":"","category":"section"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"为了优化下面模型中的参数ab：","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"y = ax^2+sin(bx)a=15b=08","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"人为生成数据，","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"##### 生成真实数据 #####\nx = collect(-1:0.01:1)\nN = length(x)\n# 产生随机误差，范围在-0.1~0.1之间\nrands = rand(-0.1:0.01:0.1, N)\na1 = 1.5\na2 = 0.8\n# 计算y值\ny = @. a1 * x^2 + sin(a2 * x) + rands","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"JuMP优化：","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"首先，定义求解器：","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"###### 定义求解器 #######\nmodel = Model(Ipopt.Optimizer)","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"随后，定义优化变量，在参数辨识问题中，被优化的参数为ab：","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"###### 定义变量 #######\n@variable(model, para[1:2])","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"其次，构建优化问题的数学表达，需要用@NLexpression生成非线性优化中的中间表达Loss。使用@NLobjective，从Loss中构建最小化优化问题。参数优化问题没有变量约束，也可以说是全局优化问题。","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"tip: Tip\n@NLobjective、@NLexpression与非线性优化问题有关，在线性优化问题中，使用@expression。不同问题类型使用不同的宏，是JuMP问题构建的特点。","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"###### 构建问题 #######\n@NLexpression(model, Loss,\n    sum((para[1] * x[i]^2 + sin(para[2] * x[i]) - y[i])^2 for i in 1:N))\n@NLobjective(model, Min, Loss)","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"最后求解","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"###### 赋初值 #######\nfor i in 1:2\n    set_start_value(para[i], 0.3)\nend\n###### 求解 #######\nJuMP.optimize!(model)\nJuMP.value.(para)","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"结果：","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"2-element Vector{Float64}:\n 1.4989653389675912\n 0.8133014851045581","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"warning: Warning\n优化的求解器不是万能的，当一个参数辨识问题无法求解时有很多原因，例如：用来描述系统的数学模型不精确上述例子中，优化数据集本身就来自于模型，所以可以肯定数据的本质一定是我们选定的模型。在实际中，面对大量的数据，数学模型准不准确往往是未知的。优化问题较为复杂多变量的复合函数，以及多优化目标的优化问题。在数学上可能有多个局部最优解。有些结果往往不太理想，典型的表现上是不同的初值获得不同的结果。或表现为初值敏感，当初值有微小改变，也能引起结果的巨大不同。面对这些数学上的难点，需要采取一些其它的策略。优化模型或者采取更加强大的求解器......","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"全部代码：","category":"page"},{"location":"Optimization/JuMP参数辨识/","page":"JuMP非线性参数辨识实例","title":"JuMP非线性参数辨识实例","text":"using JuMP, Ipopt\n\n##### 生成真实数据 ####\nx = collect(-1:0.01:1)\nN = length(x)\n# 产生随机误差，范围在-0.1~0.1之间\nrands = rand(-0.1:0.01:0.1, N)\na1 = 1.5\na2 = 0.8\n# 计算y值\ny = @. a1 * x^2 + sin(a2 * x) + rands\n\nmodel = Model(Ipopt.Optimizer)\n@variable(model, para[1:2])\n@NLexpression(model, Loss,\n    sum((para[1] * x[i]^2 + sin(para[2] * x[i]) - y[i])^2 for i in 1:N))\n@NLobjective(model, Min, Loss)\nfor i in 1:2\n    set_start_value(para[i], 0.3)\nend\n\nJuMP.optimize!(model)\nJuMP.value.(para)","category":"page"},{"location":"WorkFlow/vscodePlugin/#VScode开发环境配置","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"","category":"section"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"tip: Tip\nContents：VScode插件介绍Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"WorkFlow/vscodePlugin/#插件位置","page":"VScode开发环境配置","title":"插件位置","text":"","category":"section"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"打开插件面板，并搜索。","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 13)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/#Julia","page":"VScode开发环境配置","title":"Julia","text":"","category":"section"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"Julia官方出的Julia插件","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 1) ","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"Shift+Enter可以运行单行代码","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"Tab键补全代码","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"如：","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: )","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"体验和jupyter类似。","category":"page"},{"location":"WorkFlow/vscodePlugin/#Mardown","page":"VScode开发环境配置","title":"Mardown","text":"","category":"section"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"轻量级标记语言，文档编写必备，教程官方。","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"推荐这个3个插件，都装。","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 2)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 11)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 3)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"点击预览打开markdown预览。","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 4)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"右键 可导出PDF文件，很方便。","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 6)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/#markdown辅助贴图插件","page":"VScode开发环境配置","title":"markdown辅助贴图插件","text":"","category":"section"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 7)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"设置该扩展的图片粘贴位置，如果是Ai4E的相关开发，文档中图片的路径一般为：/docs/src/assets","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 10)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"随后右键，选择粘贴图片，自动生成markdown的图片插入语法。很方便！","category":"page"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 9)  ","category":"page"},{"location":"WorkFlow/vscodePlugin/#语言插件","page":"VScode开发环境配置","title":"语言插件","text":"","category":"section"},{"location":"WorkFlow/vscodePlugin/","page":"VScode开发环境配置","title":"VScode开发环境配置","text":"(Image: 图 12)  ","category":"page"},{"location":"Control/JuMPMPC/#JuMP求解MPC问题","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"","category":"section"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"tip: Tip\nContents：JuMP、ControlContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"note: Note\nJuMP是计算优化问题的Julia软件包。","category":"page"},{"location":"Control/JuMPMPC/#MTK中的OptimizationSystem、ControlSystem","page":"JuMP求解MPC问题","title":"MTK中的OptimizationSystem、ControlSystem","text":"","category":"section"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"通过MTK中的OptimizationSystem、ControlSystem构建MPC问题都是可行的，但是其一个致命的问题是，System会忽略约束！换一句话说，System只接受Loss方程。这是MTK优化体系不完善的地方。那么，Julia中较为成熟的优化包是JuMP、Optim和NLopt。JuMP的集成度比较好，在JuMP中可以根据不同的优化问题使用不同的求解器。所以尝试用JuMP解决。","category":"page"},{"location":"Control/JuMPMPC/#实例：加热器问题","page":"JuMP求解MPC问题","title":"实例：加热器问题","text":"","category":"section"},{"location":"Control/JuMPMPC/#问题描述","page":"JuMP求解MPC问题","title":"问题描述","text":"","category":"section"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"现在有一个物体加热，它的温度由加热项和散热项决定。α是散热系数，β是加热系数，环境温度为T_out。那么控制方程: ","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"T = α*(T_out - T) + β*Q(t)","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"现在可以改变加热功率，那么我们构建一个优化问题：调节加热功率，使得物体的温度从T_0开始，迅速上升并且稳定在某一个温度（比如说58℃）。问题的数学表达为，通过优化控制变量Q(t) 使得损失函数最小:","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"Loss = sum_i 580-T(t_i)","category":"page"},{"location":"Control/JuMPMPC/#构建问题","page":"JuMP求解MPC问题","title":"构建问题","text":"","category":"section"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"首先明确问题。现在假设以一个恒定功率（p=80）加热物体，环境温度18℃，初始温度20℃,散热系数α = 0.2,加热系数β = 0.1。先求解该问题。","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"using Plots,DifferentialEquations\nTout = 18.0\nα = 0.2\nβ = 0.1\nf(x,p,t) = α*(Tout - x) + β*p\ntspan=(0.0,40.0)\nu0 = 20.0\np = 80.0\npr = ODEProblem(f,u0,tspan,p)\nsol = solve(pr)\nplot(sol,ylimit=(10,60))","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"得到的结果是： (Image: 图 1)  ","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"很清晰可以看到，温度缓慢上升最后稳定在58℃。那么作为我们拍脑袋的控制策略来说，这个控制问题很简单。我们可以先让功率在前期比较大（比如说150），等温度到了58℃附近，再把功率调回80，就可以实现“温度迅速上升并最后稳定在58度”。","category":"page"},{"location":"Control/JuMPMPC/#优化求解","page":"JuMP求解MPC问题","title":"优化求解","text":"","category":"section"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"using JuMP,Ipopt\nN = 40\nTout = 18.0\nT0 = 20.0\ndt = 8/N\nLoss = 0.0\nT = T0\nα = 0.2\nβ = 0.1\nmodel = Model(Ipopt.Optimizer)\n@variable(model, 0 <= u[1:N] <= 200)\nfor i in 1:N\n    global T = @expression(model,T + (α*(Tout - T) + β*u[i])*dt)\n    global Loss += @expression(model,(T - 58.0)^2)\nend\nfor i = 1:N-1\n    @constraint(model,-5 <= u[i]-u[i+1] <= 5)\nend\n@objective(model, Min, Loss)\noptimize!(model)\nJuMP.value.(u)","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"u是符号量，离散的个数为N，上面选择离散为40个变量。通过一个for循环，就可以迭代求解40个点上的温度值并且构建Loss方程。同时添加约束，约束的物理含义是控制加热器功率的改变幅度不能太大，这里设置为（-5，5）。","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"PS：这里的离散方法，对微分方程求解来说实际上是最简单的欧拉法，精度有待提高，后退欧拉法，亚当斯方法，龙格库塔方法等等方法都可以用来构建Loss方程，只不过方程表达式会很复杂。","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"最后我们可以看到整个定义的问题。","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"print(model)","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"表达式非常复杂，就不放图了。","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"加热功率的变化为：","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"plot([(i -1)*dt for i in 1:N],value.(u))","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"(Image: 图 2)  ","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"温度的变化为：","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"(Image: 图 3)  ","category":"page"},{"location":"Control/JuMPMPC/#调节约束","page":"JuMP求解MPC问题","title":"调节约束","text":"","category":"section"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"结果有些许波动，调一下功率变化的幅度限制，把约束范围调成（-10，10）","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"加热功率的变化为：","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"plot([(i -1)*dt for i in 1:N],value.(u))","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"(Image: 图 1)  ","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"温度的变化为：","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"(Image: 图 4)  ","category":"page"},{"location":"Control/JuMPMPC/","page":"JuMP求解MPC问题","title":"JuMP求解MPC问题","text":"比刚刚好多了！","category":"page"},{"location":"Modeling/ModelingTutorial/#组织方程的艺术——组件化（入门）","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"tip: Tip\nContents：建模思想Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Modeling/ModelingTutorial/#前言","page":"组织方程的艺术——组件化（入门）","title":"前言","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"Ai4Energy开发者总是张口闭口组件化建模，那么组件化建模的内涵到底是什么？为什么要组件化建模？这篇我们从头至尾介绍做一个组件化思想的入门介绍。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"建模用ModelingToolkit.jl；求解用DifferentialEquations.jl。","category":"page"},{"location":"Modeling/ModelingTutorial/#电路问题","page":"组织方程的艺术——组件化（入门）","title":"电路问题","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"以电路系统切入，深入探讨组件化建模的内涵是最合适不过的了。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"首先准备2个电路元件的方程。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"欧姆定律：电阻两端的电压与流过电阻电流成正比。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"U=IR","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电容器：电容两端电压的变化率与电流成正比。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"fracdVdt = fracIC","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"tip: Tip\nC是电容量，单位为法拉（F）。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"我们再准备一个电路系统，如下图:","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"(Image: 图 5)  ","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"需要求解的问题是：电容初始电压为0，当开关闭合后，电容电压电流的变化情况是？","category":"page"},{"location":"Modeling/ModelingTutorial/#手搓求解","page":"组织方程的艺术——组件化（入门）","title":"手搓求解","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"手搓的意思是电路中学的传统解法。开关闭合后，视为导线。采用节点电压法求解。标记三个节点1，2，3。节点电压分别为V_1V_2V_3，如下图。整个电路只有一条主路，所以电流为I。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"(Image: 图 6)  ","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"所以电路的方程为：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"V_1-V_3=1 (V) \nV_1-V_2=1 (Omega) * I\nfracd(V_2-V_3)dt = fracI1 (F) = I\nV_3 = 0 tag1","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"手动化简之后可以得到2种情况：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"保留I，化简掉V_1V_3V_2。开关刚闭合，有电容视为导线，则0时刻，I=1","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"frac1-Idt = -fracdIdt= I\nI_0 = 1(A) tag2","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"保留V_2，化简掉V_1V_3I","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"fracdV_2dt = 1-V_2\nV_20=0(V) tag3","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"以上微分方程式2或3，求解任何一个，把结果代回方程组1，整个电路系统的情况就可以得到了。这个问题就解决了。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"下面看一看组件化怎么做！","category":"page"},{"location":"Modeling/ModelingTutorial/#组件化求解","page":"组织方程的艺术——组件化（入门）","title":"组件化求解","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"在之前的基础之上，我们只做一件事情——引入额外的变量。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"为每个器件添加两个端口变量（地只加一个端口）。正极叫p，负极叫n。同时为器件取名，电源叫做source，电阻叫做resistor，电容叫做capacitor，地叫做ground。同时规定，器件索引其子要素的方式为“.”。例如，电阻正极电压的变量全名为resistorpV。如下图所示。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"(Image: 图 2)  ","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"那么我们新引入了14个变量：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电源的4个","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"sourcenV\nsourceni\nsourcepV\nsourcepi","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电阻的4个","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"resistornV\nresistorni\nresistorpV\nresistorpi","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电容的4个","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"capacitornV\ncapacitorni\ncapacitorpV\ncapacitorpi","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"地的两个","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"groundportV\ngroundporti","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"再研究一下变量关系，我们可以发现。所有端口电流（地端口除外）的数值都等于I，端口电压值都等于对应的电压节点的电压。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"这，貌似就是给V_1V_3V_2I这几个变量加了很多别名？一顿操作猛如虎，细想发现全白干，形式主义我最行？","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"下面才是主菜！","category":"page"},{"location":"Modeling/ModelingTutorial/#Step1:-把V_1,V_3,V_2,I**全踢掉**，如下图。","page":"组织方程的艺术——组件化（入门）","title":"Step1: 把V_1V_3V_2I全踢掉，如下图。","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"(Image: 图 3)   ","category":"page"},{"location":"Modeling/ModelingTutorial/#Step2.-分别写组件的方程，规定电流入流为正，流出为负：","page":"组织方程的艺术——组件化（入门）","title":"Step2. 分别写组件的方程，规定电流入流为正，流出为负：","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电源：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"sourcepV - sourcenV = 1 (V)\nsourcepI + sourcenI = 0","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电阻：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"resistorpV - resistornV = resistorpI * 1 (Omega)\nresistorpI + resistornI = 0","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电容：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"fracd(capacitorpV - capacitornV)dt = fraccapacitorpI1 (F) \ncapacitorpI + capacitornI = 0","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"地（规定电势为0的点，电流不做要求）：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"groundportV = 0\ngroundportI = 0","category":"page"},{"location":"Modeling/ModelingTutorial/#Step3:-构建连接关系","page":"组织方程的艺术——组件化（入门）","title":"Step3: 构建连接关系","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电源和电阻连（等价于节点1，节点电压相等、电流净流量为0）","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"sourcenV = resistorpV\nsourcenI + resistorpI = 0","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电阻和电容连（等价于节点2，节点电压相等、电流净流量为0）","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"resistornV = capacitorpV\nresistornI + capacitorpI = 0","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"电容、电源和地连（等价于节点3，节点电压相等、电流净流量为0）","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"capacitornV = sourcpV = groundportV\ncapacitornI + sourcpI + groundportI= 0\n","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"稍微思考一下可以发现，上述10多个方程组成的方程大组，其数学本质与方程小组1完全等价！唯一的区别是前者多引入了很多变量，并且这些变量完全可以消去！","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"但是，前者完成了组件化的封装，由此连接关系与组件内部之间成了相互独立的关系。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"什么意思呢？以V_1为例。V_1既是电压源的出口电压又是电阻的正极电压。同时V_1作为节点电压，已经消去了电流的概念。这就意味每节点是不同的。而组件化的内涵就是把这一点拆解成了两部分：连接与组件内部。以电阻的正负极端口为例，对内建立组件内部的方程：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"resistorpV - resistornV = resistorpI * 1","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"其本质就是U=IR；对外建立与其他组件连接：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"sourcepV = resistorpV\nsourcenI + resistorpI = 0\nresistornV = capacitorpV\nresistornI + capacitorpI = 0","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"其本质就是节点电压1和2.","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"这么多方程很复杂但逻辑清晰。其实它很简单，因为化简计算机会去做。","category":"page"},{"location":"Modeling/ModelingTutorial/#求对比解","page":"组织方程的艺术——组件化（入门）","title":"求对比解","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/#手搓版","page":"组织方程的艺术——组件化（入门）","title":"手搓版","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"把节点电压法的分析过程，写成ModelingToolkit的代码。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"tip: Tip\n在VScode中，输入入V_3就能输入V₃(Image: 图 1)  在VScode中，按下Ctrl+Enter可以执行光标所在行的一行代码。以下的代码可以一行一行执行，看中间结果。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"using ModelingToolkit, DifferentialEquations\n\n# 定义变量\n@variables t\n@variables V₁(t) V₂(t) V₃(t) I(t)\n\n# 定义微分\nD = Differential(t)\n\n# 设置参数\nR = 1.0\nC = 1.0\nV = 1.0\n\n# 输入方程\nrc_eqs = [\n    V₁ - V₃ ~ V\n    V₁ - V₂ ~ I * R\n    D(V₂) ~ I / C\n    V₃ ~ 0\n]\n\n# 构建系统\n@named rc_model = ODESystem(rc_eqs, t)\n\n# 系统化简\nsys = structural_simplify(rc_model)\n\n# 设置初值\nu0 = [\n    V₂ => 0.0\n]\n# 求解时间范围\ntspan = (0.0, 10.0)\n\n# 构建问题并求解\nprob = ODAEProblem(sys, u0, tspan)\nsol = solve(prob, Tsit5())\n\n# 分别查看 V₁, V₂, V₃ 的变化\nsol[V₂]\nsol[V₁]\nsol[V₃]\n","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"再查看一下化简前的方程：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"equations(rc_model)","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"再查看一下化简后的方程：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"equations(sys)","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"方程中V_1=1，和推导的结果是一致的。","category":"page"},{"location":"Modeling/ModelingTutorial/#组件版","page":"组织方程的艺术——组件化（入门）","title":"组件版","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"把组件化的过程，写成代码。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"using ModelingToolkit, DifferentialEquations\n\n# 定义独立时间变量\n@variables t\n\n# 器件端口作为连接点\n@connector function Pin(; name)\n    sts = @variables v(t) = 1.0 i(t) = 1.0 [connect = Flow]\n    return ODESystem(Equation[], t, sts, []; name=name)\nend\n\n# 地，地的端口名字改为g，不是port\nfunction Ground(; name)\n    @named g = Pin()\n    eqs = [g.v ~ 0; g.i ~ 0]\n    return compose(ODESystem(eqs, t, [], []; name=name), g)\nend\n# 电阻元件\nfunction Resistor(; name, R=1.0)\n    @named p = Pin()\n    @named n = Pin()\n    ps = @parameters R = R\n    eqs = [\n        p.v - n.v ~ p.i * R\n        0 ~ p.i + n.i\n    ]\n    return compose(ODESystem(eqs, t, [], ps; name=name), p, n)\nend\n# 电容元件，因为不能对表达式进行微分，所以再引入一个电容的电压差变量v\nfunction Capacitor(; name, C=1.0)\n    @named p = Pin()\n    @named n = Pin()\n    ps = @parameters C = C\n    sts = @variables v(t) = 1.0\n    D = Differential(t)\n    eqs = [\n        v ~ p.v - n.v\n        D(v) ~ p.i / C\n        0 ~ p.i + n.i\n    ]\n    return compose(ODESystem(eqs, t, sts, ps; name=name), p, n)\nend\n# 电压源\nfunction ConstantVoltage(; name, V=1.0)\n    @named p = Pin()\n    @named n = Pin()\n    ps = @parameters V = V\n    eqs = [\n        V ~ p.v - n.v\n        0 ~ p.i + n.i\n    ]\n    return compose(ODESystem(eqs, t, [], ps; name=name), p, n)\nend\n\n# 定义组件\nR = 1.0\nC = 1.0\nV = 1.0\n@named resistor = Resistor(R=R) # @name可以视为给定义的组件起了个名字，Resistor(R=R)返回的组件名字就叫resistor\n@named capacitor = Capacitor(C=C)\n@named source = ConstantVoltage(V=V)\n@named ground = Ground()\n\n# 构建连接关系\nrc_eqs = [\n    connect(source.p, resistor.p)\n    connect(resistor.n, capacitor.p)\n    connect(capacitor.n, source.n, ground.g)\n]\n@named _rc_model = ODESystem(rc_eqs, t) #连接关系也需要放到ODESystem中。\n\n# 组件与组件连接关系一起构建系统\n@named rc_model = compose(_rc_model,[resistor, capacitor, source, ground])\nequations(rc_model) # 查看方程\n\n# 系统化简\nsys = structural_simplify(rc_model)\nequations(sys) # 查看方程\n\n# 定义初值\nu0 = [\n    capacitor.v => 0.0\n]\n\n# 求解\nprob = ODAEProblem(sys, u0, (0, 10.0))\nsol = solve(prob, Tsit5())\n\n# 查看\nsol[capacitor.v]\nsol[resistor.n.v]\nsol[capacitor.p.v]","category":"page"},{"location":"Modeling/ModelingTutorial/#小结","page":"组织方程的艺术——组件化（入门）","title":"小结","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"引入的组件端口变量作为内部方程与外部连接关系的桥梁，使得组件完整又独立，可以与任意外部组件相连接。连接就去干连接的活，组件内部就管组件内部的方程。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"从另一个角度说，节点电压法需要针对每一个系统做比较复杂的系统分析，因为其包含了某种化简的内涵；而组件化模式则是批量定义组件和批量处理连接关系，最后统一化简。后者更加易于理解与设计计算算法。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"组件化的意义就在于高效复用以提高系统构建效率。因为组件都是由开发者写好的，用户只需要构建连接关系，系统即可搭建好。这也是为什么说组件化是关于方程组织的艺术了，本质还是那个本质，只是换一种变量与方程的组织模式。电路系统的组件化是组件化思想的体现之一。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"组件化建模实例简要介绍了组件化建模思想。\nAi4EComponentLib.jl中系统的设计方法，都体现了组件化思想。\nAi4EComponentLib.jl设计理念介绍了更高层次的抽象组件内涵。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"最后，思考如何用节点电压法解下图的电路，以及如何用组件搭建。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"(Image: 图 2) ","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"其实思考之后就会发现组件化构建的优点：","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"高复用性：节点电压法构建需要自己写组件的特性方程；组件化不需要，不管它内部是什么牛鬼蛇神，组件写好了就能拿来用。之后就一个事——连接。定义组件的过程就是对组件内部方程的重用。\n高易用性：一旦组件设计好了，构建连接关系不需要再动脑子了，照着系统图哪里有节点连哪里不就完事了？剩下精髓，是如何去设计一个系统，不再需要考虑组件底层。","category":"page"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"tip: Tip\n提问：我们上面手敲代码定义组件和构建连接的过程，与在Simulink中通过图形化界面拖一个组件连一个线的过程，有本质的区别吗？如果你觉得没有区别，恭喜，你已经大致掌握流程模拟仿真软件底层架构的逻辑了。","category":"page"},{"location":"Modeling/ModelingTutorial/#练习","page":"组织方程的艺术——组件化（入门）","title":"练习","text":"","category":"section"},{"location":"Modeling/ModelingTutorial/","page":"组织方程的艺术——组件化（入门）","title":"组织方程的艺术——组件化（入门）","text":"尝试用上面写好的组件构建上图系统并求解。同样的，都假设电容电压初值为0。","category":"page"},{"location":"tengfeibei/#腾飞杯","page":"腾飞杯","title":"腾飞杯","text":"","category":"section"},{"location":"tengfeibei/#**腾飞杯招募**","page":"腾飞杯","title":"腾飞杯招募","text":"","category":"section"},{"location":"tengfeibei/#腾飞杯项目简介信息","page":"腾飞杯","title":"腾飞杯项目简介信息","text":"","category":"section"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"自我介绍：能动研二杨景懿，感兴趣的研究方向是：系统的建模、仿真、优化与控制。个人主页。QQ：522432938","category":"page"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"目前已有核心开发人员3名，指导老师1名。","category":"page"},{"location":"tengfeibei/#主题","page":"腾飞杯","title":"主题","text":"","category":"section"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"云仿真平台（具体名字待定），简单理解为：网页版Simulink（或者网页版AspenPlus，网页版gproms，网页版modelica，本质都一样）","category":"page"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"暂定赛道：科技发明制作A类","category":"page"},{"location":"tengfeibei/#技术框架","page":"腾飞杯","title":"技术框架","text":"","category":"section"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"前后端分离。前端VUE3，后端Julia，通过json交互。","category":"page"},{"location":"tengfeibei/#已有进展","page":"腾飞杯","title":"已有进展","text":"","category":"section"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"所有代码、文档可在Github上自行查看。","category":"page"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"我们的Ai4Energy开源组织：https://github.com/ai4energy\n模型库Ai4EComponentLib.jl，现在已有的有可压缩组件库（空压系统），不可以压缩组件库（管道系统），电化学库（光伏、电解槽、电池等），热力循环库（各类循环等）\njson解析器：Ai4EMetaPSE.jl\nAi4ELab，Julia的web框架。但是灵活性不够高，希望用VUE3开发。\n求解器采用开源求解器。\n前端页面参考：https://github.com/yaolunmao/vue-webtopo-svgeditor","category":"page"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"总结：高可拓展性的后端框架已经完成，完整作品的上线测试运行只差前端。","category":"page"},{"location":"tengfeibei/#招募队员","page":"腾飞杯","title":"招募队员","text":"","category":"section"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"招募2-3名队员。","category":"page"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"负责内容：基于该VUE实现做开发，打造自己的作品。 要求：专业不限，年级不限。动手能力强，具有钻研精神。热爱程序设计。能投入。","category":"page"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"有兴趣的同学联系+QQ：522432938","category":"page"},{"location":"tengfeibei/","page":"腾飞杯","title":"腾飞杯","text":"tip: Tip\n基于上述介绍，我们是踏实严肃的且有货的开发团队，不鸽不水。\n本网页是我们开放的文档库，可自行学习浏览。\n我们的目的是打造作品，只要东西能做出来，队长、队员重要程度什么的都好商量。最后，腾飞杯只是一个展示平台。比赛过后，我们的组织依旧会传承与发展，我们的目标是星辰大海~ 抛开比赛，欢迎有热情、有激情的同学加入，共同学习、成长与开发。","category":"page"},{"location":"Tools/vscode_git/#VScode中使用Git","page":"VScode中使用Git","title":"VScode中使用Git","text":"","category":"section"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"tip: Tip\nContents：VScode,GitContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"本篇介绍在vscode中使用git的方法(以码云为例，githup是同样的操作)","category":"page"},{"location":"Tools/vscode_git/#初始化仓库","page":"VScode中使用Git","title":"初始化仓库","text":"","category":"section"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"如图所示，等价于git init","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/#生成公钥","page":"VScode中使用Git","title":"生成公钥","text":"","category":"section"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"ssh-keygen -t rsa -C \"xxxxxx@qq.com\"","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"一路回车，有y/n则y。在红框中的文件夹中去找公钥文件。","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"idrsa是私钥，idrsa.pub是公钥","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"使用公钥私钥匹配就可以免去登录验证","category":"page"},{"location":"Tools/vscode_git/#配置公钥","page":"VScode中使用Git","title":"配置公钥","text":"","category":"section"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"githup与gitee是同样的方式，将id_rsa.pub的乱码复制到下图的地方。","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/#VScode中添加远程仓库","page":"VScode中使用Git","title":"VScode中添加远程仓库","text":"","category":"section"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"首先复制地址，选ssh","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"添加远程仓库","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"在框中输入复制过来的ssh地址，点击从URL添加远程仓库","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"输入仓库名字，指的是在vscode的仓库名字，随意填 (Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/#提交与推送","page":"VScode中使用Git","title":"提交与推送","text":"","category":"section"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"先暂存更改","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"在...中可以进行一系列操作，本质上就是有一个图形化的git操作界面，","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"一般选择拉取自，或推送到","category":"page"},{"location":"Tools/vscode_git/","page":"VScode中使用Git","title":"VScode中使用Git","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"Modeling/MTK_register/#ModelingToolkit调用外部函数","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"","category":"section"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"tip: Tip\nContents：建模、MTK、外部函数Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"note: Note\nMTK = ModelingToolkit.jlModelingToolkit.jl为基于符号系统的建模工具包。MTK-Version:8.5 及以上","category":"page"},{"location":"Modeling/MTK_register/#提出问题","page":"ModelingToolkit调用外部函数","title":"提出问题","text":"","category":"section"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"在前面的ModelingToolkit建模方法中提到，符号系统是MTK的基石。那么，如果想加入一个外部函数，应该怎么解决？例如方程：","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"f(xy) + x + y = 1","category":"page"},{"location":"Modeling/MTK_register/#解决方案","page":"ModelingToolkit调用外部函数","title":"解决方案","text":"","category":"section"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"把函数的调用符号化——@register_symbolic，一切问题就解决了！","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"也就是说，把函数名称放入符号系统中去。和定义符号变量类型，对相关函数进行声明，声明该函数纳入符号系统，即可完成操作。","category":"page"},{"location":"Modeling/MTK_register/#实例","page":"ModelingToolkit调用外部函数","title":"实例","text":"","category":"section"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"考虑一个简单系统：","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"fracdydt  = u(y)  u(y)= leftbeginaligned\n10  y10 \n-10  y geq 100\nendalignedright ","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"这里函数u在编程时，需要用ifelse函数来定义， 也可以用@register_symbolic来注册一个符号函数。","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"通过MTK构建：","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"using ModelingToolkit,DifferentialEquations\n@variables t y(t)\nD = Differential(t)\nu(y) = ifelse(y>100.0, -10.0, 10.0)\n\n# u(y) = y>100.0 ? -10.0 : 10.0\n# @register_symbolic u(y)\n\neqs = [\n    D(y) ~ u(y)\n]\n@named sys = ODESystem(eqs)","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"可以看到得到的方程中，u被视为函数，它的参数为y(t)。","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"求解问题：","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"sys = structural_simplify(sys)\nu0=[y => 50.0]\ntspan = (0.0,20.0)\nprob = ODEProblem(sys,u0,tspan,[])\nsol = solve(prob)\nusing Plots\nplot(sol)","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"可以看到成功求解，并且y在100附近波动。这是我们期望的结果。","category":"page"},{"location":"Modeling/MTK_register/#实例——CoolProp","page":"ModelingToolkit调用外部函数","title":"实例——CoolProp","text":"","category":"section"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"CoolProp一个开源的调用物性包，通过几行代码就可以很容易的调用流体的物性。如何在符号系统中使用Coolprop函数调用物性呢？同样，也是使用外部函数，在外部函数中封装物性查询，将函数符号化即可。","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"测试问题：在1MPa下，求温度从300K-400K的水蒸气焓值累加和。（虽然这样做很没有意义，但是这是一种测试外部函数的有效并且简单的方法）","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"using ModelingToolkit,CoolProp,DifferentialEquations\n@variables t T(t)\nD = Differential(t)\nfunction u(t)\n    PropsSI(\"H\",\"P\",1.0E6,\"T\",t,\"Water\")\nend\n@register_symbolic u(t)\neqs = [\n    D(T) ~ u(t+300.0)\n]\n@named sys = ODESystem(eqs)\nsys = structural_simplify(sys)\nu0=[\n    T => 0.0\n]\ntspan = (0.0,100.0)\nprob = ODEProblem(sys,u0,tspan,[])\nsol = solve(prob)\nusing Plots\nplot(sol)","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"程序可以运行并且得到了结果，","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"MTK符号运算系统加上外部调用函数符号化，基本上可以解决各类仿真问题。","category":"page"},{"location":"Modeling/MTK_register/","page":"ModelingToolkit调用外部函数","title":"ModelingToolkit调用外部函数","text":"note: Note\n个人观点：从仿真层面来说，MTK具有了作为一个仿真引擎的所有功能。从程序开发层面来说，MTK具备搭建一个巨型系统的潜力。","category":"page"},{"location":"Modeling/DE_intro/#DifferentialEquations建模方法","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"section"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"tip: Tip\nContents：建模、DEContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"note: Note\nDE = DifferentialEquations.jlDifferentialEquations.jl为处理时间微分的求解建模工具包。","category":"page"},{"location":"Modeling/DE_intro/#浅谈建模内涵","page":"DifferentialEquations建模方法","title":"浅谈建模内涵","text":"","category":"section"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"在研究各类系统时（上至电力、能源系统、交通系统，下至RC电路、水利管网系统），当我们需要对系统进行处理时，我们都会一件相同的事情——把系统抽象成我们能够处理的对象！","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"从发现问题到获得计算结果，在现代计算科学中一般分为两步：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"把问题抽象可量化、可处理的数学问题\n把数学问题设计成可用计算机处理与计算的可计算问题","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"在这个过程中，大脑在这个过程充当了“解释器”的角色。把实际的问题层层抽象，最后让问题变得可计算。不得不感叹，人类“编译”能力之强大。也许人类在计算速度上远远不及计算机。但在深度与广度层面，远远超过计算机。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"从前牛顿等巨人的时代开始，科学家研究的主体内容，主要是是第一步的内容。近40年，计算机科学技术呈爆炸式增长。依托于计算机，社会生产的智能化日益提高。于是基于第2步的问题也发展出许多学科分支，作为科研领域重要的方向之一。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"这是一件很奇妙的事情，巨量1与0的加减运算产生了无穷的能力！就好像神经元虽然简单，只要数量够，也能组合成产生无数想法的大脑！","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"言归正传，在第一步中，描述对象的数学形式有微分方程（组）、代数方程（组）、图等等。针对对象进行计算的数学形式有求解方程问题、寻优问题、计算图等等。DifferentialEquations.jl就是处理基于时间微分的微分方程（组）求解软件包！","category":"page"},{"location":"Modeling/DE_intro/#DE使用实例","page":"DifferentialEquations建模方法","title":"DE使用实例","text":"","category":"section"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"现有洛伦兹方程为例：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"fracdxdt  = sigma(y-x)  fracdydt  = x(rho-z)-y  fracdzdt = xy - beta z","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"微分方程在DifferentialEquations.jl中含有5个要素：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"方程描述\n求解时间域\n初值（边界条件）\n方程参数\n问题类型","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"在方程定义中，有4个参数：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"function lorenz!(du,u,p,t)\n    du[1] = p[1]*(u[2]-u[1])\n    du[2] = u[1]*(p[2]-u[3]) - u[2]\n    du[3] = u[1]*u[2] - p[3]*u[3]\nend","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"其中，","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"du为微分变量向量\nu为变量向量\np为参数\nt为时间变量","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"剩下要素的定义：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"p = [10.0,28.0,8/3]\nu0 = [1.0;0.0;0.0]\ntspan = (0.0,100.0)\nprob = ODEProblem(lorenz!,u0,tspan,p)","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"其中，","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"p为参数\nu0变量的初始值\ntspan为求解时间域\nprob为通过方法ODEProblem()定义的ODE问题","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"tip: Tip\nODEProblem = Ordinary Differential Equations Problem(常微分方程)beginarrayl\nfracd xd t=sigma(y-x) \nfracd yd t=x(rho-z)-y \nfracd zd t=x y-beta z\nendarray除此之外，还有：DAEProblem = Differential Algebraic Equations Problem（微分代数方程）beginalignedfracd y_1d t =-004 y_1+10^4 y_2 y_3 fracd y_2d t =004 y_1-10^4 y_2 y_3-3 * 10^7 y_2^2 1 =y_1+y_2+y_3endalignedDDEProblem = Delay Differential Equations Problem（随机微分）beginaligned\nd x_0 =fracv_01+beta_0left(x_2(t-tau)right)^2left(p_0-q_0right) x_0(t)-d_0 x_0(t) d x_1 =fracv_01+beta_0left(x_2(t-tau)right)^2left(1-p_0+q_0right) x_0(t) +fracv_11+beta_1left(x_2(t-tau)right)^2left(p_1-q_1right) x_1(t)-d_1 x_1(t) d x_2 =fracv_11+beta_1left(x_2(t-tau)right)^2left(1-p_1+q_1right) x_1(t)-d_2 x_2(t)endaligned更多方程种类可查官方文档。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"求解并画图","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"sol = solve(prob, Tsit5())\nplot(sol,vars=(1,2,3))","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"(Image: 图 4)  ","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"全部代码：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"using DifferentialEquations,Plots\nfunction lorenz!(du,u,p,t)\n        du[1] = p[1]*(u[2]-u[1])\n        du[2] = u[1]*(p[2]-u[3]) - u[2]\n        du[3] = u[1]*u[2] - p[3]*u[3]\nend\np = [10.0,28.0,8/3]\nu0 = [1.0;0.0;0.0]\ntspan = (0.0,100.0)\nprob = ODEProblem(lorenz!,u0,tspan,p)\nsol = solve(prob, Tsit5())\nplot(sol,vars=(1,2,3))","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/#DE的Callback特性","page":"DifferentialEquations建模方法","title":"DE的Callback特性","text":"","category":"section"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"Callback的含义为，当系统运行到某个状态时，人为介入改变系统参量的值，随后继续求解。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"下面以弹球系统为例，介绍Callback的用法。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"弹球系统的特点是，当弹球碰到地面时，需要弹起。所以在模拟弹球系统时，需要考虑求解过程中速度的方法变化，这时候就用到callback。碰地的数学的描述为，弹球速度变量变为它的相反数。也就是说当弹球高度x变为0时，速度u需要变成-u。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"其数学表达为：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"x = v  v = -g","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"DE问题构建：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"function f(du,u,p,t)\n    du[1] = u[2]\n    du[2] = -p\nend","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"其中，","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"u1为x，即弹球高度\nu2为v，即弹球速度","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"建立Callback函数：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"function condition(u,t,integrator) # Event when event_f(u,t) == 0\n    u[1]\nend\nfunction affect!(integrator)\nintegrator.u[2] = -integrator.u[2]\nend\ncb = ContinuousCallback(condition,affect!)","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"condition为系统调用callback时应该满足的条件，默认为函数返回值为0（false）时的情况。即u[1]=0。 affect!为系统调用callback时的处理动作，这里为将速度变负。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"定义剩余要素并求解，在solve中需要传递callback。","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"u0 = [50.0,0.0]\ntspan = (0.0,15.0)\np = 9.8\nprob = ODEProblem(f,u0,tspan,p)\nsol = solve(prob,Tsit5(),callback=cb)\nplot(sol)","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"可以得到如下结果：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"(Image: 图 5)","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"如果考虑反弹损失（每次反弹速度损失20%）：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"function affect!(integrator)\nintegrator.u[2] = -integrator.u[2]*0.8\nend","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"(Image: 图 6)  ","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"也能够得到相应的结果，妙啊！！！","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"全部代码：","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"using DifferentialEquations,Plots\nfunction f(du, u, p, t)\n    du[1] = u[2]\n    du[2] = -p\nend\nfunction condition(u, t, integrator) # Event when event_f(u,t) == 0\n    u[1]\nend\nfunction affect!(integrator)\n    integrator.u[2] = -integrator.u[2]\nend\ncb = ContinuousCallback(condition, affect!)\nu0 = [50.0, 0.0]\ntspan = (0.0, 15.0)\np = 9.8\nprob = ODEProblem(f, u0, tspan, p)\nsol = solve(prob, Tsit5(), callback=cb)\nplot(sol)","category":"page"},{"location":"Modeling/DE_intro/","page":"DifferentialEquations建模方法","title":"DifferentialEquations建模方法","text":"tip: Tip\nDE中有许多特性，例如求解结果的处理（Solution Handle）、回调函数（Callback）等等。更多特性可以在官方文档中查看。","category":"page"},{"location":"Modeling/WathMTKdo/#MTK的\"前世今生\"","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"","category":"section"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"tip: Tip\nContents：建模、MTK、SymbolicsContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"note: Note\nMTK = ModelingToolkit.jlSymbolics.jl为MTK依赖的符号计算包ModelingToolkit.jl为基于符号系统的建模工具包。DifferentialEquations.jl为处理时间微分的求解建模工具包。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"MTK似乎很强大，本篇介绍MTK在建模中承担的角色。","category":"page"},{"location":"Modeling/WathMTKdo/#模块化思想","page":"MTK的\"前世今生\"","title":"模块化思想","text":"","category":"section"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"首先，我们聊一聊程序设计中的模块化思想。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"个人认为，模块化其实不单单是一种软件设计的思想。毫不夸张地说，模块化也是一种组织与架构的哲学。模块化的含义可以用一个词语概括——各司其职。若是在软件开发中，需要加上一个限定词——精细化。即，精细化的各司其职。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"模块化解决问题的核心在于，把问题分成若干个部分，每个部分由特定的对象完成。当每个对象的任务都完成之后，问题也就解决了。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"从软件开发到社会的组织架构，都由模块化的影子。课程的小组合作，每个人负责一个小部分；上市公司分为市场部、研发部、财务部...。那么在程序中，这些模块的“对象”就是函数。每个函数完成各的任务，当全部执行完成之后，问题解决了。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"例如，有一个变量var。问题是：计算10 * var + var * var + 1的结果。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"对于这样一个问题，我们习惯于直接把表达式输入得到结果：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"result = 10 * var + var * var + 1","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"但采用模块化的思想，不会这么做。模块化会把这个活分给三个函数去做——乘法函数、平方函数、求和函数。当这个三个函数完成了各自的事情之后，问题解决了。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"function mult(a,b)\n    return a * b\nend\nfunction square(a)\n    return a * a\nend\nfunction sum(a...)\n    s = 0\n    for i in 1:length(a)\n        s += a[i]\n    end\n    return s\nend\nresult = sum(mult(10,var),square(var),1) ","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"当然，对于这样一个问题非要用模块化思想那是闲的。若是针对一个复杂的系统，没有人能完成所有细节的解决方案，那么模块化思想就会变得尤为重要。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"主要有两个方面的好处：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"从自上而下的角度。作为上层的调用者，不需要关心底层函数怎样解决问题。只需要知道，传递什么数据能获得什么结果。这对于复杂问题的解决非常重要。大问题分为几个小问题，小问题再分为更小的问题。作为架构师只需要关心核心部分的拆解即可。这是高效的“各司其职”。\n从自下而上的角度。把问题细分到不能再分，那么其会具有解决任何问题的潜力。什么意思呢？如果把一个表达式作为一个整体求解，这是完全没有问题的。但如果把一个表达式拆解成四则运算分别求解，就如上面的例子。由该问题设计的四则运算函数，对它们进行合理组合能够解决任何一个求解表达式问题。孰高孰低，立见高下。也可以说，模块化后的解决方案具有普适性，解决了复杂问题中的基本共性问题（足够细分的情况下）。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"所以在软件设计领域，有这样一种说法——每一个函数编写时只需要解决一个很小的问题。","category":"page"},{"location":"Modeling/WathMTKdo/#MTK在建模仿真中的角色","page":"MTK的\"前世今生\"","title":"MTK在建模仿真中的角色","text":"","category":"section"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"在DifferentialEquations建模方法从发现问题到获得计算结果，在现代计算科学中一般分为两步：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"把问题抽象可量化、可处理的数学问题\n把数学问题设计成可用计算机处理与计算的可计算问题","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"进一步细分有：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"抽象问题\n符号建模\n模型化简\n生成迭代格式\n迭代求解","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"毫无疑问，第一步由人来完成。剩下的步骤可以由MTK完成。那么新的问题在于，从2-5是否全由MTK从零开始构建呢？答案是否定的！","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"实际上，在建模仿真这样的大问题中，仍然是模块化的思想。具体的分工如下：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"Symbolics.jl：负责符号运算\nModelingToolkit.jl：负责模型化简，生成迭代格式\nDifferentialEquations.jl：负责求解","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"ModelingToolkit的核心在于各种System，System作为一种数据结构，本质是存储的是变量以及由变量构成的方程。而变量的定义与方程的定义由Symbolics完成。所以说，Symbolics是符号计算的基石，MTK在Symbolics的基础之上进一步处理方程与变量，处理成DE能够求解的形式，传递给DE计算。最终得到结果。它们三者的关系如图：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"(Image: 图 6)  ","category":"page"},{"location":"Modeling/WathMTKdo/#Symbolics实例","page":"MTK的\"前世今生\"","title":"Symbolics实例","text":"","category":"section"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"符号定义：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"@variables t α σ(..) β[1:2]\n@variables w(..) x(t) y z(t, α, x)\n@variables A[1:5, 1:3] b[1:3]","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"方程定义：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"using Symbolics\n\n@variables x y;\n@variables A[1:3, 1:3] B[1:3, 1:3];\nx ~ y\nx - y ~ 0\nA ~ B\nA .~ 3x","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"微分运算：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"@variables t\nD = Differential(t)\nz = t + t^2\nD(z)\nexpand_derivatives(D(z)) ","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"化简与符号赋值：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"B = simplify.([t + t^2 + t + t^2  2t + 4t\n               x + y + y + 2t     x^2 - x^2 + y^2])\nsimplify.(substitute.(B, (Dict(x => y^2),)))","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"还有计算雅可比矩阵、函数符号化等等符号计算的内容可查看官方文档。","category":"page"},{"location":"Modeling/WathMTKdo/#小结与启示","page":"MTK的\"前世今生\"","title":"小结与启示","text":"","category":"section"},{"location":"Modeling/WathMTKdo/#启示：文档查询","page":"MTK的\"前世今生\"","title":"启示：文档查询","text":"","category":"section"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"从模块化的角度看待MTK，我们就能知道。MTK能做什么与不能做什么。又或者说，遇到了问题，应该找谁。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"问题类型一：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"符号数组应该如何使用与计算？\nRegister如何使用？\n如何批量处理符号？","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"这样的问题应该去看Symbolics.jl的文档。因为MTK就是在它的基础上构建的。它不支持的，MTK也没办法使用。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"问题类型二：","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"求解的结果如何处理？\n如何确定精度？\nCallback如何使用？","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"这样的问题应该去看DifferentialEquations.jl的文档。因为真正的求解工作是DE完成的。solution的结果也从DE中来（MTK会提供关于符号与solution的接口，但DE中solution handling能用的功能，MTK中也一定能用）。","category":"page"},{"location":"Modeling/WathMTKdo/#启示：函数使用","page":"MTK的\"前世今生\"","title":"启示：函数使用","text":"","category":"section"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"在MTK文档没有写上的功能，但DE与Symbolics的文档中有。一般而言都能使用。例如，符号数组的矩阵运算，MTK中一定能用（某些特殊功能不一定）。DE中关于Problem类型的一些参数调用，MTK也可以使用。","category":"page"},{"location":"Modeling/WathMTKdo/","page":"MTK的\"前世今生\"","title":"MTK的\"前世今生\"","text":"每个包有每个包的特性，包与包之间的依赖关系不是功能的交集，而是功能的并集。底层依赖包的功能在上层调用包一般都能使用。只要有了这一点认识。就能够将SCIML生态的功能充分利用起来。这是贯通的其生态的关键。","category":"page"},{"location":"CS Base/Creat and Call dll/#动态链接库(DLL)的生成与调用","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"","category":"section"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"tip: Tip\nContents：Julia调用DllContributor: 杨月宝Email:812987139@qq.com如有错误，请批评指正。","category":"page"},{"location":"CS Base/Creat and Call dll/#问题的产生与解决过程概述","page":"动态链接库(DLL)的生成与调用","title":"问题的产生与解决过程概述","text":"","category":"section"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"热流问题数值计算课程的代码是2003年重新整理的Fortran代码。","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"通过Julia调用教学代码中的函数完成课程大作业。","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"Step1:生成Fortran dll，尝试用C语言调用dll。","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"Step2:通过C++调用dll，尝试用Julia调用dll。","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"Step3:配置VS2013，生成64位dll，使用Julia(64bit)调用dll。","category":"page"},{"location":"CS Base/Creat and Call dll/#工作环境","page":"动态链接库(DLL)的生成与调用","title":"工作环境","text":"","category":"section"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"Julia 1.7.0-beta2","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"VS2013 Fortran编译器：Intel.Visual.Fortran.Composer.XE.2013-SP1","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"VSCode","category":"page"},{"location":"CS Base/Creat and Call dll/#内容说明","page":"动态链接库(DLL)的生成与调用","title":"内容说明","text":"","category":"section"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"1.使用Fortran生成dll","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"2.使用VS2013开发人员命令提示查看dll位数","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"3.使用C++调用dll","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"4.使用Julia调用dll","category":"page"},{"location":"CS Base/Creat and Call dll/#.使用Fortran生成dll","page":"动态链接库(DLL)的生成与调用","title":"1.使用Fortran生成dll","text":"","category":"section"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"新建一个Fortran动态链接库项目","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"(Image: 1)","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"在Resource Files中添加一个f90文件，并输入如下内容","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"SUBROUTINE OUTPUT(a, b, sum)\n    !MS$ ATTRIBUTES DLLEXPORT::OUTPUT\n    !声明本函数为输出函数\n    IMPLICIT NONE\n    INTEGER a, b, sum\n    sum = a + b\nEND SUBROUTINE OUTPUT","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"Fortran通过下句表示dll输出函数","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"!MS$ ATTRIBUTES DLLEXPORT::OUTPUT","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"配置编译器属性，选择64位的编译器来生成64位的dll","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"(Image: 1) (Image: 1) (Image: 1) (Image: 1)","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"编译文件后生成项目，就可以在.\\x64\\Debug文件夹下找到生成的dll文件","category":"page"},{"location":"CS Base/Creat and Call dll/#使用VS2013开发人员命令提示查看dll位数","page":"动态链接库(DLL)的生成与调用","title":"使用VS2013开发人员命令提示查看dll位数","text":"","category":"section"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"VS2013的工具路径在安装目录下","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":".\\Microsoft Visual Studio 12.0\\Common7\\Tools\\Shortcuts","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"选择VS2013开发人员命令提示，可以使用dumpbit命令获得dll信息","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"dumpbin /headers 路径","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"读取上段生成dll，部分结果：","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"(Image: 1)","category":"page"},{"location":"CS Base/Creat and Call dll/#.使用C调用dll","page":"动态链接库(DLL)的生成与调用","title":"3.使用C++调用dll","text":"","category":"section"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"这里采用动态调用方法，根据网上找到的资料和Fortran程序设计课程讲义，我重新整理了C++代码。","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"这部分代码把那几个冒号去了就是C的代码。","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"调试或启动exe文件前，请将dll文件放于EXE文件所在的Debug文件夹内。我的是在E:\\Programs\\program VS2013\\HF_first\\ForDllCreat\\x64\\Debug","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"我的解决方案名和Fortran生成dll的方案同名了，请不要混淆。","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"#include <stdio.h>\n#include <windows.h> // 调用 WINDOWS API 函数所需的头文件\n\ntypedef void(*Func)(int *, int *, int *);//定义一个函数指针类型，这个指针类型与被调用函数的输入类型要一一对应\n\nint main()\n{\n int a = 1, b = 2, sum;\n\n //宏定义函数指针类型\n HMODULE hLibrary = ::LoadLibrary(L\"ForDLLCreat.dll\"); //加载动态库文件，dll名前不加L会报错\n if (hLibrary == NULL)\n {\n  printf(\"No DLL file exist!\\n\");\n  return -1;\n }\n Func dllPro = (Func)::GetProcAddress(hLibrary, \"OUTPUT\");\n //获得 Fortran 导出函数的地址\n if (dllPro == NULL)\n {\n  printf(\"Can not fine the address of the function!\\n\");\n  return -2;\n }\n dllPro(&a, &b, &sum);\n printf(\"%d + %d = %d\\n\", a, b, sum);\n FreeLibrary(hLibrary); //卸载动态库文件\n return 0;\n}","category":"page"},{"location":"CS Base/Creat and Call dll/#.使用Julia调用dll","page":"动态链接库(DLL)的生成与调用","title":"4.使用Julia调用dll","text":"","category":"section"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"Julia官方文档地址：Calling C and Fortran Code","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"在开始前，请务必确认Julia的位数与所用dll位数相同，否则会报错dll不是一个可用的Win32应用。","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"ForDllCreate.dll与ForDllCreate.64.dll内部包含和前文相同的函数，区别是前者是32位，后者是64位。 在64位REPL上载入32位dll会报错。","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"ERROR: LoadError: could not load library \"e:\\yyb\\HF_first\\ForDllCreat.dll\"\n%1 is not a valid Win32 application.\nStacktrace:\n [1] top-level scope\n   @ e:\\yyb\\HF_first\\test.jl:15\nin expression starting at e:\\yyb\\HF_first\\test.jl:15","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"先贴上示例。","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"#error\na=[1]\nb=[2]\nc=[0]\nccall((:OUTPUT, \".\\\\ForDllCreat.dll\"),Cvoid,(Ptr{Cint},Ptr{Cint},Ptr{Cint}),pointer_(a),pointer(b),pointer(c))\nprint(c)\n\n#work\na=[1]\nb=[2]\nc=[0]\nccall((:OUTPUT, \".\\\\ForDllCreat64.dll\"),Cvoid,(Ptr{Cint},Ptr{Cint},Ptr{Cint}),pointer_from_objref(a)+0x40,pointer_from_objref(b)+0x40,pointer_from_objref(c)+0x40)\nprint(c)","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"Julia可用通过ccall函数调用C和Fortran编译的dll文件，输入格式为","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"  ccall((function_name, library), returntype, (argtype1, ...), argvalue1, ...)\n  ccall(function_name, returntype, (argtype1, ...), argvalue1, ...)  \n  ccall(function_pointer, returntype, (argtype1, ...), argvalue1, ...)","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"这里通过第一种调用方法来调用我们编译的ForDllCreat64.dll，","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"function_name是调用的函数名称。引用时即可以用:OUTPUT表示，也可以用\"OUTPUT\"表示。","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"C语言与Fortran输出dll时函数名不变，C++输出函数有命名粉碎，自制dll尽量采用C输出，一定要确定被调用函数的名字才能成功引用。可看此视频","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"library是被调用dll的路径，用字符串表示。调用C标准库中的函数时，library可以略去。","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"#调用C标准库函数，不用写引用\nt = ccall(:clock, Int32, ())","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"returntype是被调函数的返回类型。Fortran的subroutine返回类型是空，即void，在Julia中表示为Cvoid。数据类型对应的表格可以参考下文表格，也可以查看官方文档。","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"(argtype1, ...)是一个tuple，与被调函数的输入变量类型要一一对应，类似在C++中定义一个与被调函数输入变量类型一一对应的函数原型。","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"argvalue1, ...  这部分是输入变量，类型要与(argtype1, ...)一一对应，并与被调函数对应。输入变量不用tuple表示。","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"不同语言间调用dll，最重要的就是数据类型的匹配。下表是从Julia官方文档中复制的数据类型对应表。更多细节请查看官方文档。","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"(Image: 图 1)  ","category":"page"},{"location":"CS Base/Creat and Call dll/#Julia中指针的用法","page":"动态链接库(DLL)的生成与调用","title":"Julia中指针的用法","text":"","category":"section"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"此处有不明点，请实践时小心处理。","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"数组类型基本上通过指针传递。","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"Julia中，指针有两种，Ptr{T}与Ref{T}","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"Ptr表示的是从变量获得的地址，这类地址是否被销毁不由Julia管理，一般是“危险的”（unsafe)。","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"Ref是由Julia分配的地址，这类地址的任何更改都由Julia进行，因此是“安全的”。","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"但是Ref能用的方法似乎不多，目前为止我没学明白这个怎么用。","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"Julia中获得变量地址的函数有pointer和pointerformobjref，他们获得的指针都是Ptr型的 pointer获得的地址被标明了数据类型，并且总比pointerformobjref的返回值多出一个数据类型的bit数；pointerformobjref获得的地址是无数据类型的。 在官方文档中，pointerfromobjref是对C提供接口的方法(C_Interface)","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"a=\"大家好\"\nb=pointer(a)\nc=pointer_from_objref(a)\nprintln(b)\nprintln(c)\nprintln(b-c)\n\nprintln(\"a[1]的字节数是\",sizeof(typeof(a[1])))#UInt8的字节数是1,但是Char类型的字节数是4","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"由地址获得值的方法是unsafepointerto_objref，这个函数也是官方文档中C接口的函数。","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"对一个Ptr指针，用pointer获得的指针要减去一个数据类型的bit数才能获得指针内的值。","category":"page"},{"location":"CS Base/Creat and Call dll/","page":"动态链接库(DLL)的生成与调用","title":"动态链接库(DLL)的生成与调用","text":"a=[1.23]\n\nb=pointer(a)\nc=pointer_from_objref(a)\n\nd=unsafe_pointer_to_objref(b-0x40)\ne=unsafe_pointer_to_objref(c)\n\nprintln(\"d=\",d)\nprintln(\"e=\",e)","category":"page"},{"location":"Simulation/componementModel/#组件化建模实例","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"section"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"tip: Tip\nContents：MTK、组件化建模Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"note: Note\nMTK = ModelingToolkit.jlModelingToolkit.jl Acausal Component-Based Modeling the RC Circuit介绍了组件化建模的例子","category":"page"},{"location":"Simulation/componementModel/#MTK符号建模","page":"组件化建模实例","title":"MTK符号建模","text":"","category":"section"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"在DifferentialEquations建模方法与ModelingToolkit建模方法中介绍DE与MTK的两种建模方式。分析了使用它们建模的具体步骤与实现方法，并介绍了相应的内涵。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"这一篇中主要介绍符号建模的另一个强大功能——组件化建模。","category":"page"},{"location":"Simulation/componementModel/#RC电路建模实例","page":"组件化建模实例","title":"RC电路建模实例","text":"","category":"section"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"仿真如下图的电路系统：","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"(Image: 图 2)  ","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"@MTK版本：8.5.5","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"using ModelingToolkit, Plots, DifferentialEquations\n\n@variables t\n@connector function Pin(; name)\n    sts = @variables v(t) = 1.0 i(t) = 1.0 [connect = Flow]\n    ODESystem(Equation[], t, sts, []; name=name)\nend\n\nfunction Ground(; name)\n    @named g = Pin()\n    eqs = [g.v ~ 0]\n    compose(ODESystem(eqs, t, [], []; name=name), g)\nend\n\nfunction OnePort(; name)\n    @named p = Pin()\n    @named n = Pin()\n    sts = @variables v(t) = 1.0 i(t) = 1.0\n    eqs = [\n        v ~ p.v - n.v\n        0 ~ p.i + n.i\n        i ~ p.i\n    ]\n    compose(ODESystem(eqs, t, sts, []; name=name), p, n)\nend\n\nfunction Resistor(; name, R=1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters R = R\n    eqs = [\n        v ~ i * R\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction Capacitor(; name, C=1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters C = C\n    D = Differential(t)\n    eqs = [\n        D(v) ~ i / C\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction ConstantVoltage(; name, V=1.0)\n    @named oneport = OnePort()\n    @unpack v = oneport\n    ps = @parameters V = V\n    eqs = [\n        V ~ v\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction Inductor(; name, L=1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters L = L\n    D = Differential(t)\n    eqs = [\n        D(i) ~ v / L\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction ChangeableVoltage(; name)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    eqs = [\n        v ~ 16 * sin(2π * t)\n    ]\n    extend(ODESystem(eqs, t, [], []; name=name), oneport)\nend\n\n\n\n@named resistor = Resistor(R=3.0)\n@named capacitor = Capacitor(C=1.0 / 24)\n@named source = ChangeableVoltage()\n@named inductor = Inductor(L=0.1)\n@named ground = Ground()\n\n\nrc_eqs = [\n    connect(source.p, capacitor.p)\n    connect(capacitor.n, inductor.p)\n    connect(inductor.n, resistor.p)\n    connect(source.n, resistor.n, ground.g)\n]\n\n\n@named _rc_model = ODESystem(rc_eqs, t)\n@named rc_model = compose(_rc_model,\n    [resistor, inductor, capacitor, source, ground])\n\nsys = structural_simplify(rc_model)\n\nusing Plots\nu0 = [\n    capacitor.v => 0.0\n    capacitor.p.i => 0.0\n    inductor.i => 0\n    inductor.v => 0\n]\nprob = ODAEProblem(sys, u0, (0, 10.0))\nsol = solve(prob, Tsit5())\nsol[resistor.p.i]\np1 = plot(sol, vars=[capacitor.v capacitor.p.i], xlims=(0, 10), ylim=(-20, 20))\np2 = plot(sol, vars=[inductor.v inductor.i], xlims=(0, 10), ylim=(-5, 5))\nplot(p1, p2, layout=(2, 1))","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"结果如图所示：","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"(Image: 图 1)  ","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"主要的过程有以下几步：","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"构建组件\n定义组件实例\n连接系统\n化简\n设置初值\n构建问题并求解\n结果处理","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"构建组件过程中主要有两方面考虑，系统内部结构与系统对外接口。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"内部结构则是各个组件内部的数学特性。对于电阻有： V=R*I","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"对于电容有： fracdVdt=fracIC","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"对于电感有： fracdIdt=fracVL","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"这些关系可以在模型构建时体现。这是系统的内部变量之间的决定关系。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"外部结构是模块化的另一个关键部分。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"RC的接口体现在函数Pin()上，每一个组件都由两个Pin——输入引脚与输出引脚。这完全是抽象出来的，引脚存在的意义就是为了连接。每个引脚有自己的电压值（更准确的说是电势大小）以及电流。这些变量的引入只是为了跟好地模块化。例如，器件A的出口引脚与器件B的进口引脚相连，它们在电路模型中完全可以视为一个等价的点。为了使模块变得更加完整，分化出来各自的引脚。事实上，这些引脚变量在最后计算时，被化简消除了。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"所以，在模块化的过程中为了使个组件变得完整，会派生出很多变量，这些变量都是“锦上添花”的存在，不具备决定性意义。但它们又是使各模块间能够衔接的必要存在。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"\n@named resistor = Resistor(R=3.0)\n@named capacitor = Capacitor(C=1.0 / 24)\n@named source = ChangeableVoltage()\n@named inductor = Inductor(L=0.1)\n@named ground = Ground()\n","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"组件实例化中的@named的作用是给相应组件命名，每个组件的本质都是一个ODESystem，不同的组件不过是ODESystem中存储的方程不同。ODESystem中有一个成员为name，@named把实例的名称赋值给这个成员变量。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"例如,下面两种定义方式是等价的。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"\n@named resistor = Resistor(R=3.0)\n\nresistor = Resistor(R=3.0;name =:resistor)","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"rc_eqs = [\n    connect(source.p, capacitor.p)\n    connect(capacitor.n, inductor.p)\n    connect(inductor.n, resistor.p)\n    connect(source.n, resistor.n, ground.g)\n]","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"依据系统的拓扑结构进行连接。connect函数可以接受任意参数个（并联中多点连接的问题就解决了）。连接的本质是建立模块间的联系，连接模块内部的机理，一旦连接绑定，这些变量的使命就完成了。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"化简的过程中，会把多余的中间变量都消去。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"sys = structural_simplify(rc_model)","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"查看各组件各变量的求解结果：","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"sol[resistor.p.i]","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"值得一提的是，在求解的过程中会化简，但是依旧可以查看这些变量的求解结果。方法如示例所示。","category":"page"},{"location":"Simulation/componementModel/","page":"组件化建模实例","title":"组件化建模实例","text":"","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#Ai4EComponentLib.jl设计理念","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"tip: Tip\nContents：Ai4EComponentLib：Julia组件模型库Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"note: Note\nAi4EComponentLib地址。arXiv文章","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#摘要","page":"Ai4EComponentLib.jl设计理念","title":"摘要","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"Ai4EComponentLib是基于Julia语言构建的组件化模型库。它依赖于微分方程求解器DifferentialEquations.jl与符号建模工具Modelingtoolkit.jl。面向不同的物理领域的问题，Ai4EComponentLib尝试使用组件化建模的方法去构建它们。在新一代符号建模工具的支持下，使用Ai4EComponentLib构建的模型比传统的用Modelica构建的模型更加灵活，并具有更高的可拓展性。本文将介绍Ai4EComponentLib模型库的实例与通用建模思想。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#Motivation","page":"Ai4EComponentLib.jl设计理念","title":"1 Motivation","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"在建模仿真领域，已经存在着许许多多的建模工具，例如Modelica、gProms、Simulink等等。它们在不同领域中都发挥着重要的作用，这些工具也已经成为科研工作者的必备工具。但这并不意味着，它们是完美无暇的。以开源的Modelica为例，Modelica拥有自己的编译器，能将建模语言编译成C语言。对于仿真问题来说，它形成了一个完备的解决方案链条。但它的缺陷是，不易扩展。它不能向外扩展形成优化问题的解决方案（参数辨识、最优控制问题）等等。而Julia生态中的ModelingToolkit就解决了扩展性不足的问题。在符号建模体系下，它具有高可拓展性。基于ModelingToolkit的工作，Ai4EComponentLib构建了一些模型库，期望在将来能够利用其高可拓展行的优势。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#Ai4EComponentLib设计理念","page":"Ai4EComponentLib.jl设计理念","title":"2 Ai4EComponentLib设计理念","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"Ai4EComponentLib设计系统的方法与传统的组件化建模思想是相通的。但由于ModelingToolkit的高可拓展性，我们将用更高一层的抽象来看待这个问题。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"组件建模的核心在于过程，以及过程中的物质能量流动。建模过程中的两个关键点为：内部过程与外部连接。设计一个系统，也就是设计它们的内部过程与外部连接。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"现有一个系统，系统中有3个组件A, B and C，如图所示，每个组件有各自的输入输出节点（如a1、a2等），其输入输出特性如箭头所示。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"(Image: 图 1) ","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#.1-内部过程","page":"Ai4EComponentLib.jl设计理念","title":"2.1 内部过程","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"各模块内部有自身的特性。即输入输出量之间在节点内部产生的反应与物质信息交换的过程。在组件与组件之间是各不相同的。这些机制反映了模型对现实实体的映射，是不同的数学物理现象的抽象。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"例如上图组件A的a1、a2、a3。在组件内部，它们有特定的数学关系。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"f(a1a2a3) = 0","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"在这里f(a1a2a3)是一种通用的函数形式，它可以是微分方程，也可以是代数方程。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"例如，对于电阻组件，同样的电压差加在一个不同电阻的两端，流过的电流大小不同。若电阻是随时间变化的，那么系统的电流也是随时间变化的。“不同的电阻”与“随时间变化的电阻”都是组件的特性，在设计组件时，通过不同的方程f来描述。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"这些方程就决定了“物质能量流动”流经组件时的变化。一旦系统中的组件确定了，整个系统的特性就能够通过这些组件确定下来。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#.2-外部连接","page":"Ai4EComponentLib.jl设计理念","title":"2.2 外部连接","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"在构建系统连接时，我们关注点在于连接点的物质和能量。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"例如电路系统。电路系统的a2作为组件的出口，电流与电势值是必要的属性。同时，每个组件的进出口都存在电流与电势。所以，在电路系统中，电流与电势是连接系统的“物质流”。\n例如水流管道系统（不考虑势能）。管道系统的a2作为组件的出口，水流的压力与流速是必要的属性。每个组件的进出口都存在水压与流速属性。所以，在管道系统中，水压与流速连接系统的“物质流”。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"具体的物质流动关系，我们需要根据特性系统的数学模型来构建。例如，电路系统中的基尔霍夫定律，管道流动的伯努利方程。控制方程是描述系统的基础。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"在外部的连接特性中，一般都必须遵循守恒定律——能量守恒与质量守恒：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"leftbeginarrayl\na 2=b 1  b 3=c 2 a 3=c 1\nendarrayrighttag1","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"对于状态量，如电压、水压、气体压力。一般有：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"leftbeginarrayl\na 2=b 1  b 3=c 2 a 3=c 1\nendarrayrighttag2","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"对于过程量，如电流、水流量、气体流量。一般有（规定流入为正，流出为负）：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"leftbeginarrayl\na 2+b 1=0  b 3+c 2 =0a 3+c 1=0\nendarrayrighttag3","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#系统实例","page":"Ai4EComponentLib.jl设计理念","title":"3 系统实例","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/#.1-不可压缩管道系统","page":"Ai4EComponentLib.jl设计理念","title":"3.1 不可压缩管道系统","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"当管道中液体为不可压缩流体时，系统的控制方程为伯努利方程。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"fracprho g +fracv^22g  + h=text  constant  tag4","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其中，p是压力，v是速度，h是高度。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"写成流量形式则有，","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"fracprho g +frac8q^2pi^2D^4g + h=mathrmconstant tag5","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其中，p是压力，q是流量，D是管道直径，h是高度。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"伯努利方程描述的是管道内部液体流动的能量守恒定律。组件的内部过程是能量的增加或减少。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#.1.1-管道组件","page":"Ai4EComponentLib.jl设计理念","title":"3.1.1 管道组件","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"对于一个直管道，组件内部一般有沿程阻力损失与局部阻力损失。当液体从管道一端流向另一端时，液体的总能量减小。沿程阻力损失与局部阻力损失是管道组件的内部过程。其数学方程为：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"fracp_inrho g +frac8q_in^22pi^2D^4g + z_in=\nfracp_outrho g +frac8q_out^22pi^2D^4g + z_out+h_f+h_mtag6","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其中，下标_in代表管道进口，_out代表管道出口，h_f表示沿程阻力损失，h_m表示局部阻力损失。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"沿程阻力损失方程为：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"h_f = ffracLD frac8q^2pi^2D^4gtag7","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其中，f为摩擦因数，L为管道长度，D为管道直径。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"局部阻力损失方程为：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"h_m = K frac8q^2pi^2D^4gtag8","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其中，K为局部阻力系数。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"管道的外部连接主要为压力与流量(高度也是，暂不考虑)。压力是状态量，流量是过程量。在两个组件a,b之间，有：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"p_a=p_bq_a+q_b=0","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#.1.2-离心泵组件","page":"Ai4EComponentLib.jl设计理念","title":"3.1.2 离心泵组件","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"与管道组件类型，离心泵组件的内部过程是为流体增加能量。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"fracp_inrho g +frac8q_in^22pi^2D^4g + z_in=\nfracp_outrho g +frac8q_out^22pi^2D^4g + z_out+H_ttag9","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其中，H_t表示流经离心泵增加的能量。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"H_t=frac(romega)^2g-fracomega cotbeta 2pi bgQ=c_0omega^2-c_1omega Q=a_0-a_1Qtag10","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其中，a_0a_1代表水泵特性参数，方程10实际上是水泵的理论扬程流量曲线。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#.1.3-组件与系统","page":"Ai4EComponentLib.jl设计理念","title":"3.1.3 组件与系统","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"构建系统的水泵、管道等主要组件之前，建立ModelingToolkit中的Connector（Connector中的变量在管道系统中为压力与流量）。代码仓库中有详尽的代码可以查看。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"# Component: SimplePipe(pipe with fixed friction factor `f`)\nfunction SimplePipe(; name, L=10.0, D=25E-3, f=0.01, ρ=1.0E3, zin=0.0, zout=0.0, K_inside=0.0)\n    @named in = PipeNode(z=zin)\n    @named out = PipeNode(z=zout)\n    ps = @parameters D = D L = L f = f K_inside = K_inside\n    eqs = [\n        _NodeEnergy(in, D, ρ) ~ _NodeEnergy(out, D, ρ) + _h_f(in, f, L, D) + _h_m(in, K_inside, D)\n        0 ~ in.q + out.q\n    ]\n    compose(ODESystem(eqs, t, [], ps, name=name), in, out)\nend\n\n# Component: CentrifugalPump\nfunction CentrifugalPump(; name, D=25E-3, ω=2500, c_0=4.4e-4, c_1=5.622, ρ=1.0E3)\n    @named in = PipeNode()\n    @named out = PipeNode()\n    a_0 = c_0 * abs2(ω * 2π / 60)\n    a_1 = c_1 * ω * 2π / 60\n    ps = @parameters D = D\n    eqs = [\n        _NodeEnergy(in, D, ρ) + a_0 - a_1 * abs(in.q) ~ _NodeEnergy(out, D, ρ)\n        0 ~ in.q + out.q\n    ]\n    compose(ODESystem(eqs, t, [], ps, name=name), in, out)\nend\n\n# Component: Sink_P\nfunction Sink_P(; name, p=101325)\n    @named port = PipeNode(z=0.0)\n    eqs = [\n        port.p ~ p\n    ]\n    compose(ODESystem(eqs, t, [], [], name=name), port)\nend\n","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"由以上组件构建如下系统则变得简单快捷。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"(Image: )","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"@named Pump = CentrifugalPump(ω=5000)\n@named A = Sink_P()\n@named B = Sink_P()\n\nsystem = [A, B, Pump]\n\n@named Pipe1 = SimplePipe(L=2.0);\npush!(system, Pipe1);\n@named Pipe2 = SimplePipe(L=3.0);\npush!(system, Pipe2);\n@named Pipe3 = SimplePipe(L=7.0);\npush!(system, Pipe3);\n@named Pipe4 = SimplePipe(L=9.0);\npush!(system, Pipe4);\n@named Pipe5 = SimplePipe(L=5.0);\npush!(system, Pipe5);\n@named Pipe6 = SimplePipe(L=4.0);\npush!(system, Pipe6);\n@named Pipe7 = SimplePipe(L=5.0);\npush!(system, Pipe7);\n@named Pipe8 = SimplePipe(L=1.0);\npush!(system, Pipe8);\n@named Pipe9 = SimplePipe(L=10.0);\npush!(system, Pipe9);\n@named Pipe10 = SimplePipe(L=2.0);\npush!(system, Pipe10);\n@named Pipe11 = SimplePipe(L=2.0);\npush!(system, Pipe11);\n@named Pipe12 = SimplePipe(L=3.0);\npush!(system, Pipe12);\n@named Pipe13 = SimplePipe(L=12.0);\npush!(system, Pipe13);\n@named Pipe14 = SimplePipe(L=1.0);\npush!(system, Pipe14);\n@named Pipe15 = SimplePipe(L=2.0);\npush!(system, Pipe15);\n@named Pipe16 = SimplePipe(L=3.0);\npush!(system, Pipe16);\n@named Pipe17 = SimplePipe(L=6.0);\npush!(system, Pipe17);\n@named Pipe18 = SimplePipe(L=6.0);\npush!(system, Pipe18);\n@named Pipe19 = SimplePipe(L=6.0);\npush!(system, Pipe19);\n@named Pipe20 = SimplePipe(L=1.0);\npush!(system, Pipe20);\n@named Pipe21 = SimplePipe(L=1.0);\npush!(system, Pipe21);\n@named Pipe22 = SimplePipe(L=7.0);\npush!(system, Pipe22);\n@named Pipe23 = SimplePipe(L=3.0);\npush!(system, Pipe23);\n@named Pipe24 = SimplePipe(L=3.0);\npush!(system, Pipe24);\n@named Pipe25 = SimplePipe(L=2.0);\npush!(system, Pipe25);\n\neqs = [\n  connect(A.port, Pump.in)\n  connect(Pump.out, Pipe1.in)\n  connect(Pipe1.out, Pipe2.in, Pipe5.in)\n  connect(Pipe2.out, Pipe3.in, Pipe6.in)\n  connect(Pipe3.out, Pipe4.in, Pipe7.in)\n  connect(Pipe4.out, Pipe10.out, Pipe14.in)\n  connect(Pipe5.out, Pipe11.in, Pipe12.in)\n  connect(Pipe6.out, Pipe8.in, Pipe9.in)\n  connect(Pipe7.out, Pipe9.out, Pipe10.in)\n  connect(Pipe12.out, Pipe8.out, Pipe13.in)\n  connect(Pipe13.out, Pipe14.out, Pipe15.in)\n  connect(Pipe11.out, Pipe19.in, Pipe16.in)\n  connect(Pipe16.out, Pipe17.in, Pipe20.in)\n  connect(Pipe17.out, Pipe18.in, Pipe21.in)\n  connect(Pipe18.out, Pipe15.out, Pipe22.in)\n  connect(Pipe19.out, Pipe20.out, Pipe23.in)\n  connect(Pipe21.out, Pipe22.out, Pipe24.in)\n  connect(Pipe23.out, Pipe24.out, Pipe25.in)\n  connect(B.port, Pipe25.out)\n]\n","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#.2-热力循环系统","page":"Ai4EComponentLib.jl设计理念","title":"3.2 热力循环系统","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/#.1.1-数学内涵","page":"Ai4EComponentLib.jl设计理念","title":"3.1.1 数学内涵","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"热力循环系统中，有几个典型的内部过程。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"等温过程：fracTP = constant\n等压过程：fracTv = constant\n等熵过程：pv^k = constant\n等容过程：pv = constant","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"这些过程中能量变化的体现，最终体现在流体的压力、密度、焓值、熵值、温度上。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"在热力循环中，外部连接正包含这5个状态量。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"在构建热力系统时，尽管可以使用不同内部过程的控制方程，但理论方程和实际始终会有些出入。所以在构建热力系统时，可以利用ModelingToolkit的可拓展性特点——调用外部的物性库。调用物性库可以减小某些理论计算的误差。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"以等温过程为例，过程起点的状态已知。其内部过程的控制方程为：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"T_1=T_2tag11","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"再确定过程终点的另一个状态量，则终点的其他状态可由2个已知状态得到。那么有以下4种组合：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"beginmatrix\n T_2p_2 Rightarrow  s_2D_2h_2\n T_2s_2 Rightarrow  p_2D_2h_2\n T_2D_2 Rightarrow  s_2p_2h_2\n T_2h_2 Rightarrow  s_2p_2D_2\nendmatrixtag12","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"使用CoolProp物性库，输入等式左边的两个参数，就能得到等式右边的任意一个参数。由此，可以外部CoolProp库替换内部方程，完成组件构建。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#.1.2-组件与系统","page":"Ai4EComponentLib.jl设计理念","title":"3.1.2 组件与系统","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"以等焓过程为例，等焓过程中，内部方程为：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"h_1=h_2","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"假如给定一个参数p，则函数chose_equations会自动生成通过ph调用CoolProp得到其他参数数值的代码","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"\nfunction IsoenthalpyProcess(; name, inter_state=\"Q_0\", fluid=\"Water\")\n    @assert inter_state != \"H\" \"IsoenthalpyProcess can't accept H. Please chose another state.\"\n    @named oneport = StreamPort()\n    @unpack Δh, out = oneport\n    eqs = [\n        Δh ~ 0\n    ]\n    push!(eqs, chose_equations(out, inter_state, \"H\", fluid)...)\n    return extend(ODESystem(eqs, t, [], []; name=name), oneport)\nend","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"考虑图3-2描述的再热循环：","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"(Image: 图 1)  ","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"其代码如下。更加详细的代码请查看代码仓库以及文档。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"@named pump = IsentropicProcess(inter_state=\"P\")\n@named pump_P = DThermalStates(state=\"P\", value=-1.0E5, u0=18.0E6)\n\n@named boiler = IsobaricProcess(inter_state=\"T\")\n@named boiler_T = ThermalStates(state=\"T\", value=550+ 273.15)\n\n@named turbine = IsentropicProcess(inter_state=\"P\")\n@named turbine_P = ThermalStates(state=\"P\", value=3.0e6)\n\n@named reboiler = IsobaricProcess(inter_state=\"T\")\n@named reboiler_T = ThermalStates(state=\"T\", value=450 + 273.15)\n\n@named returbine = IsentropicProcess(inter_state=\"P\")\n@named returbine_P = ThermalStates(state=\"P\", value=4.0e3)\n\n@named condenser = IsothermalProcess(inter_state=\"Q_0\")\n\neqs = [\n  connect(pump.out, boiler.in, pump_P.node)\n  connect(boiler.out, turbine.in, boiler_T.node)\n  connect(turbine.out, reboiler.in, turbine_P.node)\n  connect(reboiler.out, returbine.in, reboiler_T.node)\n  connect(returbine.out, condenser.in, returbine_P.node)\n  connect(condenser.out, pump.in)\n]\n","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#组件化模型的优势","page":"Ai4EComponentLib.jl设计理念","title":"4 组件化模型的优势","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"现在可以做一个小结，组件本质上就是描述变量与变量之间关系的方程。组件内部的控制方程才是最重要的部分，对系统的变化具有决定性意义。外部连接通过补充一个连接方程，描述了组件与组件之间的关系。连接方程对于真正的系统反应不具备决定性，只是辅助系统构建。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"模块化的组件在设计时会把大系统拆解成一个个小组件。这样做的好处是方便用户构建系统，坏处是这些连接变量在系统构建后的系统化简时还要消耗计算资源将它们化简。但事实上，组件化模型带来的收益远超过消耗一点计算资源付出的代价。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"例如，由模块ABC组成的系统视为一个整体X，则ABC成为了X的内部结构，其数学形式也为微分代数方程，与模块ABC的数学形式并没有本质上的区别。唯一的区别在于方程数量的多少。系统X同样拥有对外的三个接口：输入接口x1、x2与输出接口x3。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"(Image: 图 2)  ","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"此时系统与子系统有了完备的闭包概念。假若此时ABC并不是一个最小系统，在ABC的基础之上可进一步细分出更小的模块。那么，可以称ABC为系统X的子系统，系统ABC同样拥有自己的子系统。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"假如ABC一共只有几个方程，那么不需要ABC作为X的子系统来构建。我们直接把X内部的方程手动展平，只包含x1、x2、x3即可。但假如ABC一共有成千上万个方程，假若系统ABC同样拥有自己的子系统。这个时候手动展平还是一种好方法吗？","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"所以，分为内外结构的组件，在组成一个巨型系统时具有重要意义。一旦内部最关键的特性决定了，在今后复杂系统的任何层次节点上，人们的精力都能够集中在系统最关键的问题上——系统（子系统）之间的构建连接关系。","category":"page"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"剩下的化简，就交给计算机吧！若是让人不断的去展平方程，从零构建系统，不也是人力资源的浪费吗？人思维的价值应该体现系统的设计上，而不是展平方程上，虽然浪费一些计算资源，但不也是生产力的提升吗？","category":"page"},{"location":"Frameworks/Ai4EComponentLib/#结论","page":"Ai4EComponentLib.jl设计理念","title":"结论","text":"","category":"section"},{"location":"Frameworks/Ai4EComponentLib/","page":"Ai4EComponentLib.jl设计理念","title":"Ai4EComponentLib.jl设计理念","text":"组件化模型在构建时具有它本身的优势。依托于ModelingToolkit符号体系构建的组件化模型则有更加广阔的应用前景。ModelingToolkit自动的回调时间相应、DifferentialEquations的求解器分析可以更加灵活地处理仿真问题，基于ModelingToolkit的OptControl.jl可以将组件模型系统转变利用JuMP求解的最优控制问题。此外还有SciML的参数辨识工具包等等。在Julia社区的强力支撑下，组件化模型不仅仅是用于仿真的方程，它也可以是控制问题中的状态方程模型，优化问题中的约束。组件的本质——方程可以用最基本Julia要素描述——函数。","category":"page"},{"location":"Simulation/steadyRC/#MTK稳态系统仿真实例","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"","category":"section"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"tip: Tip\nContents：MTK、组件化建模Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"note: Note\nMTK = ModelingToolkit.jlModelingToolkit.jl Acausal Component-Based Modeling the RC Circuit介绍了组件化建模的例子","category":"page"},{"location":"Simulation/steadyRC/#动态与瞬态","page":"MTK稳态系统仿真实例","title":"动态与瞬态","text":"","category":"section"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"从内涵来说，稳态问题是动态问题的子集。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"对于稳态动态问题，当微分代数方程中对时间项的微分为0时，则由动态问题过渡为稳态问题。也就是说，稳态问题是动态问题的特殊形式，动态问题是问题的一般形式。微分在实际中代表着“变化”，当该“变化”项为0时，意味着“变化”停止，此时则进入了稳态阶段。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"例如，对于这样一个问题：","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"fracdxdt = 1-xx_0=0","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"从物理演化的角度看，初始时刻，x的变化率为1，x将会不断增大。系统发展到最后，当x增大到1的时候。fracdxdt=0，此时此刻变化就停止了。所以x将进入稳态，即x=1。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"这是因为，从物理的角度理解，微分代表一种变化趋势！上述方程的走势如下图，与分析的情况一致。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"(Image: 图 1)  ","category":"page"},{"location":"Simulation/steadyRC/#MTK的稳态求解技巧","page":"MTK稳态系统仿真实例","title":"MTK的稳态求解技巧","text":"","category":"section"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"求解以下稳态电路问题：","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"(Image: 图 4)  ","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"该问题的电路状态是确定值，不随时间而改变。而DE和MTK处理的是关于时间的微分方程，单纯的代数方程无法求解。对于这样稳态问题，应该怎样求解呢？","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"这里主要运用一个技巧——设定一个变化为0的量加入到方程中。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"什么意思呢？问题必须含有关于时间微分的微分方程，在这一基础之上，让fracdxdt=0不就实现了一种稳态么?x可以代表任何变量，电阻值、电源电压值、电流源值等等。于是，微分变为一种形式，只是让问题能够被求解器求解，对于问题的内涵并没有任何改变。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"@MTK版本：8.5.5","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"using ModelingToolkit, Plots, DifferentialEquations\n\n@variables t\n@connector function Pin(; name)\n    sts = @variables v(t) = 1.0 i(t) = 1.0 [connect = Flow]\n    ODESystem(Equation[], t, sts, []; name=name)\nend\n\nfunction Ground(; name)\n    @named g = Pin()\n    eqs = [g.v ~ 0]\n    compose(ODESystem(eqs, t, [], []; name=name), g)\nend\n\nfunction GroundDIFF(; name)\n    @named g = Pin()\n    sts = @variables v(t)\n    D = Differential(t)\n    eqs = [\n        g.v ~ 0,\n        D(v) ~ 0\n    ]\n    compose(ODESystem(eqs, t, sts, []; name=name), g)\nend\n\nfunction OnePort(; name)\n    @named p = Pin()\n    @named n = Pin()\n    sts = @variables v(t) = 1.0 i(t) = 1.0\n    eqs = [\n        v ~ p.v - n.v\n        0 ~ p.i + n.i\n        i ~ p.i\n    ]\n    compose(ODESystem(eqs, t, sts, []; name=name), p, n)\nend\n\nfunction Resistor(; name, R=1.0)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    ps = @parameters R = R\n    eqs = [\n        v ~ i * R\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction ConstantVoltage(; name, V=1.0)\n    @named oneport = OnePort()\n    @unpack v = oneport\n    ps = @parameters V = V\n    eqs = [\n        V ~ v\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\nfunction ConstantCurrent(; name, I=1.0)\n    @named oneport = OnePort()\n    @unpack i = oneport\n    ps = @parameters I = I\n    # D = Differential(t)\n    eqs = [\n        i ~ I\n    ]\n    extend(ODESystem(eqs, t, [], ps; name=name), oneport)\nend\n\n\n@named resistor1 = Resistor(R=5.0)\n@named resistor2 = Resistor(R=5.0)\n@named resistor3 = Resistor(R=30.0)\n@named resistor4 = Resistor(R=20.0)\n@named Isource = ConstantCurrent()\n@named Vsource1 = ConstantVoltage(V=30.0)\n@named Vsource2 = ConstantVoltage(V=5.0)\n@named ground = GroundDIFF()\n\n\nrc_eqs = [\n    connect(Vsource1.p, resistor1.p)\n    connect(resistor1.n, resistor2.p, Isource.p)\n    connect(resistor2.n, resistor3.p, resistor4.p)\n    connect(resistor4.n, Isource.n, Vsource2.p)\n    connect(Vsource1.n, Vsource2.n, resistor3.n, ground.g)\n]\n\n@named _rc_model = ODESystem(rc_eqs, t)\n@named rc_model = compose(_rc_model,\n    [resistor1, resistor2, resistor3, resistor4,\n        Isource, Vsource1, Vsource2, ground])\n\nsys = structural_simplify(rc_model)\n\nusing Plots\n\nu0 = [\n    ground.v => 0.0\n]\nprob = ODAEProblem(sys, u0, (0, 10.0))\nsol = solve(prob, Tsit5())\nobserved(sys)\nplot(sol[resistor4.n.i])\n","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"代码中的关键在于函数GroundDIFF()，这个函数中添加的微分项为电势变化为0，即","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"fracdVdt=0","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"并且这个V没有任何意义，既不是接地的电势，也没有和电路中的任何变量产生关联。它只是为了让问题能够被求解而存在。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"最后求解的结果为：","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"(Image: 图 1)  ","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"可以看到，求解的结果在时间轴上是不变的。随然问题看似是一个动态问题，本质上其实是稳态。因为其没有任何改变，时间轴上的任何状态与其前后状态都一样。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"思想的核心其实就是——稳态是动态的一个子集，当动态过程中状态不再改变则进入稳态。这里不过是将问题设置为状态不发生变化的动态，其本质就是稳态。","category":"page"},{"location":"Simulation/steadyRC/","page":"MTK稳态系统仿真实例","title":"MTK稳态系统仿真实例","text":"tip: Tip\n稳态电路本质是代数方程组，若加上了微分方程，则变成了微分代数方程组。代码中定义的问题是ODAEProblem而不是ODEProblem。DE只有求解微分代数方程的接口而没有求解代数方程的接口。所以需要构造成微分代数问题。","category":"page"},{"location":"Modeling/MTK_intro/#ModelingToolkit建模方法","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"","category":"section"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"tip: Tip\nContents：建模、MTKContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"note: Note\nMTK = ModelingToolkit.jlModelingToolkit.jl为基于符号系统的建模工具包。MTK-Version:8.5 及以上","category":"page"},{"location":"Modeling/MTK_intro/#符号计算内涵","page":"ModelingToolkit建模方法","title":"符号计算内涵","text":"","category":"section"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"符号计算的内涵很简单，其本质就是处理、简化方程的未知数。例如: (x+y)z = xy + yz 又例如: $\\frac{dy}{dt} = 2t => y = t^2 + C $ 它们本质上都是数学符号的推演，而没有涉及到数字的计算。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"一般的情况下，可以计算问题都是人为地把计算推演到数字计算的层面，中间的符号推演、化简的过程都不由计算机处理。随着计算机能力的日益强大，以及计算理论的发展。计算机也能开始进行符号计算。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"例如，(x+y)z = xy + yz就完全能由计算机计算并得到结果。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"MTK，就是这样一种符号计算包。在DE中，我们构建的是方程（function），通过方程来建立模型。而在MTK中，我们构建的是符号，通过符号建立模型。","category":"page"},{"location":"Modeling/MTK_intro/#MTK符号计算实例","page":"ModelingToolkit建模方法","title":"MTK符号计算实例","text":"","category":"section"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"考虑洛伦兹方程：","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"fracdxdt  = sigma(y-x)  fracdydt  = x(rho-z)-y  fracdzdt = xy - beta z","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"通过MTK构建：","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"using ModelingToolkit\nusing DifferentialEquations\n\n@variables t u(t)[1:3]\n@parameters p[1:3]\n\nD = Differential(t)\neqs =[\n    D(u[1]) ~ p[1]*(u[2]-u[1])\n    D(u[2]) ~ u[1]*(p[2]-u[3]) - u[2]\n    D(u[3]) ~ u[1]*u[2] - p[3]*u[3]\n]\n@named Sys = ODESystem(eqs)","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"其中：","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"t是时间变量\nu是关于时间的依赖变量向量\n参数向量p\n微分符号D\neqs本质是一个描述符号方程的数组","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"@variables定义了符号变量，@parameters p[1:3]定义了参数。方程由ODESystem结构体储存，可以看到其中描述“=”的符号为“~”。这些表明，上述代码在处理符号，这是一套符号描述体系！","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"因为是处理符号时，当然也可以更加具象，将符号定义为xyz","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"using ModelingToolkit\nusing DifferentialEquations\n\n@variables t x(t) y(t) z(t)\n@parameters  σ ρ β\nD = Differential(t)\neqs =[\n    D(x) ~ σ*(y-x)\n    D(y) ~ x*(ρ-z) - y\n    D(z) ~ x*y - β*z\n]\n@named sys = ODESystem(eqs)","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"由于符号运算的展现形式更加贴近自然语言，我们几乎可以不加处理地建立与原数学方程几乎一样的符号方程描述，这是符号计算的优势之一。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"在明确MTK的系统构建之后，与DifferentialEquations一样，最后需要明确定义的问题以及初值等要素。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"tspan = (0.0,100.0)\nu0 =[\n    x => 1.0\n    y => 0.0\n    z => 0.0\n]\np=[\n    σ => 10.0\n    ρ => 28.0\n    β => 8/3\n]\nprob = ODEProblem(sys,u0,tspan,p)\nsol = solve(prob,Tsit5())","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"与DE不同是，MTK传值时需要指定具体变量（参数的值）。 最后能得到与DE计算同样的结果。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"全部代码：","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"using ModelingToolkit\nusing DifferentialEquations\n@variables t x(t) y(t) z(t)\n@parameters  σ ρ β\nD = Differential(t)\neqs =[\n    D(x) ~ σ*(y-x)\n    D(y) ~ x*(ρ-z) - y\n    D(z) ~ x*y - β*z\n]\n@named sys = ODESystem(eqs)\ntspan = (0.0,100.0)\nu0 =[\n    x => 1.0\n    y => 0.0\n    z => 0.0\n]\np=[\n    σ => 10.0\n    ρ => 28.0\n    β => 8/3\n]\nprob = ODEProblem(sys,u0,tspan,p)\nsol = solve(prob,Tsit5())\nusing Plots\nplot(sol, idxs=(x,y,z))","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"","category":"page"},{"location":"Modeling/MTK_intro/#DE与MTK的对比","page":"ModelingToolkit建模方法","title":"DE与MTK的对比","text":"","category":"section"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"同一问题，可用MTK与DE来求解。但它们并不完全等价，异同是客观存在的：","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"不同之处：   ModelingToolkit基于符号体系描述问题，等价于在DifferentialEquations问题描述的上层添加了一层符号系统，通过求解符号系统之后，能得到真正的微分方程问题。\n相同之处：   它们最终得到的问题形式是一样的，比如说最终都会生成ODEProblem，也就是说它们可以通过同一个求解器求解。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"MTK凭借着符号计算，在模型建立时会更加方便，更加友好。符号推演功能相当于减轻了模型构造时的工作量，即在数学模型到计算机可计算的模型这个过程中，计算机又往前前进了一步。所以，MTK从某种程度上来说会比DE好用很多。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"从另一个角度来看，DE是MTK的底层求解器，意味着其比MTK更加直接，速度更快。MTK在DE基础之上构建了符号计算系统，其形式与功能上让人惊叹。但要明白的是，这种提供便捷的符号计算系统是要使用资源的，MTK需要花费更多资源去计算、化简符号。好用意味着大量的资源消耗在用户友好方面，效率高意味着资源消耗在真正的问题解决上。这是软件发展过程中始终存在的矛盾。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"note: Note\n就像Linux与Windows一样。大家在开发环境中都愿意用Windows，但在服务器端都用的是Linux。也像是Python与C之间的矛盾。Python代码易用，但运行效率却远远比不上C代码。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"关于DE与MTK的取舍，根据问题的特性选择即可。","category":"page"},{"location":"Modeling/MTK_intro/","page":"ModelingToolkit建模方法","title":"ModelingToolkit建模方法","text":"此外，MTK的符号系统还有更大的妙用，在后面的章节中会逐渐展开。","category":"page"},{"location":"Optimization/JumpMILP/#JuMP混合整数线性优化实例","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"","category":"section"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"tip: Tip\nContents：优化Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Optimization/JumpMILP/#问题简介","page":"JuMP混合整数线性优化实例","title":"问题简介","text":"","category":"section"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"Advent Of Code中有一个很有意思的问题，可用JuMP来求解。同时也是能源系统优化的一个缩影。","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"问题如下：","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"为了收获粘土，你需要专用的粘土收集机器人。要制造任何类型的机器人，你都需要矿石。收集矿石需要带大钻头的矿石收集机器人。幸运的是，你的背包中正好有一个矿石收集机器人，你可以使用它启动整个操作。","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"每个机器人每分钟可以收集1个其资源类型。机器人工厂（也在你的背包中）构建任何类型的机器人也需要一分钟，尽管它在构建开始时会消耗必要的可用资源，同时每分钟最多建造1个机器人。","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"机器人工厂有很多蓝图（问题的输入）你可以选择，但一旦你用蓝图配置好了，你就不能改变它。","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"蓝图1：\n    制造一个矿石机器人（ore robot）消耗4矿石（ore）。\n    制造一个粘土机器人（clay robot）消耗2矿石（ore）。\n    制造一个黑曜石机器人（obsidian robot）消耗3块矿石（ore）和14块粘土（clay）。\n    制造一个紫晶机器人（geode robot）消耗2个矿石（ore）和7个黑曜石（obsidian）。\n\n蓝图2：\n    制造一个矿石机器人消耗2矿石。\n    制造一个粘土机器人消耗3矿石。\n    制造一个黑曜石机器人消耗3块矿石和8块粘土。\n    制造一个紫晶机器人消耗3个矿石和12个黑曜石。","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"优化问题为：如何分配资源去建造机器人，在24分钟后获得最多的紫晶。","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"蓝图1的最优方案为最多获得9个紫晶，具体操作过程为：","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"==第1分钟==\n1台矿石收集机器人收集1个矿石；你现在有1个矿石。\n\n==第2分钟==\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n\n==第3分钟==\n花2矿石开始建造一个粘土收集机器人。\n1台矿石收集机器人收集1个矿石；你现在有1个矿石。\n\n新的粘土收集机器人准备就绪；你现在有一个了。\n\n==第4分钟==\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n1个粘土收集机器人收集1个粘土；你现在有1个粘土。\n\n==第5分钟==\n\n花2矿石开始建造一个粘土收集机器人。\n1台矿石收集机器人收集1个矿石；你现在有1个矿石。\n1个粘土收集机器人收集1个粘土；你现在有2个粘土。\n\n新的粘土收集机器人准备就绪；你现在有两个了。\n\n==第6分钟==\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n2个粘土收集机器人收集2个粘土；你现在有4块粘土。\n\n==第7分钟==\n花2矿石开始建造一个粘土收集机器人。\n1台矿石收集机器人收集1个矿石；你现在有1个矿石。\n2个粘土收集机器人收集2个粘土；你现在有6块粘土。\n\n新的粘土收集机器人准备就绪；你现在有3个了。\n\n==第8分钟==\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n3个粘土收集机器人收集3个粘土；你现在有9块粘土。\n\n==第9分钟==\n1台矿石收集机器人收集1个矿石；你现在有3个矿石。\n3个粘土收集机器人收集3个粘土；你现在有12块粘土。\n\n==第10分钟==\n1台矿石收集机器人收集1个矿石；你现在有4个矿石。\n3个粘土收集机器人收集3个粘土；你现在有15块粘土。\n\n==分钟11==\n花3块矿石和14块粘土开始建造一个黑曜石收集机器人。\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n3个粘土收集机器人收集3个粘土；你现在有4块粘土。\n\n新的黑曜石收集机器人准备就绪；你现在有一个了。\n\n==第12分钟==\n花2矿石开始建造一个粘土收集机器人。\n1台矿石收集机器人收集1个矿石；你现在有1个矿石。\n3个粘土收集机器人收集3个粘土；你现在有7块粘土。\n1个黑曜石收集机器人收集1颗黑曜岩；你现在有1个黑曜石。\n\n新的粘土收集机器人准备就绪；你现在有4个。\n\n==第13分钟==\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n4个粘土收集机器人收集4个粘土；你现在有11块粘土。\n1个黑曜石收集机器人收集1颗黑曜岩；你现在有2颗黑曜石。\n\n==第14分钟==\n1台矿石收集机器人收集1个矿石；你现在有3个矿石。\n4个粘土收集机器人收集4个粘土；你现在有15块粘土。\n1个黑曜石收集机器人收集1颗黑曜岩；你现在有3个黑曜石。\n\n==第15分钟==\n花3块矿石和14块粘土开始建造一个黑曜石收集机器人。\n1台矿石收集机器人收集1个矿石；你现在有1个矿石。\n4个粘土收集机器人收集4个粘土；你现在有5块粘土。\n1个黑曜石收集机器人收集1颗黑曜岩；你现在有4颗黑曜石。\n\n新的黑曜石收集机器人准备就绪；你现在有两个了。\n\n==第16分钟==\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n4个粘土收集机器人收集4个粘土；你现在有9块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有6颗黑曜石。\n\n==第17分钟==\n1台矿石收集机器人收集1个矿石；你现在有3个矿石。\n4个粘土收集机器人收集4个粘土；你现在有13块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有8颗黑曜石。\n\n==第18分钟==\n花2颗矿石和7颗黑曜石开始建造一个紫晶机器人。\n1台矿石收集机器人收集1个矿石；你现在有2个矿石。\n4个粘土收集机器人收集4个粘土；你现在有17块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有3个黑曜石。\n\n新的紫晶机器人准备就绪；你现在有一个了。\n\n==第19分钟==\n1台矿石收集机器人收集1个矿石；你现在有3个矿石。\n4个粘土收集机器人收集4个粘土；你现在有21块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有5颗黑曜石。\n\n1个紫晶机器人收集1个紫晶；你现在有一个紫晶。\n\n==第20分钟==\n1台矿石收集机器人收集1个矿石；你现在有4个矿石。\n4个粘土收集机器人收集4个粘土；你现在有25块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有7颗黑曜石。\n\n1个紫晶机器人收集1个紫晶；你现在有2个紫晶。\n\n==第21分钟==\n花2颗矿石和7颗黑曜石开始建造一个紫晶机器人。\n1台矿石收集机器人收集1个矿石；你现在有3个矿石。\n4个粘土收集机器人收集4个粘土；你现在有29块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有2颗黑曜石。\n1个紫晶开裂机器人开裂1个大地洞；你现在有3个紫晶。\n\n新的紫晶机器人准备就绪；你现在有两个了。\n\n==第22分钟==\n1台矿石收集机器人收集1个矿石；你现在有4个矿石。\n4个粘土收集机器人收集4个粘土；你现在有33块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有4颗黑曜石。\n2个紫晶机器人收集2个紫晶；你现在有5个紫晶。\n\n==第23分钟==\n1台矿石收集机器人收集1个矿石；你现在有5个矿石。\n4个粘土收集机器人收集4个粘土；你现在有37块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有6颗黑曜石。\n2个紫晶机器人收集2个紫晶；你现在有7个紫晶。\n\n==第24分钟==\n1台矿石收集机器人收集1个矿石；你现在有6个矿石。\n4个粘土收集机器人收集4个粘土；你现在有41块粘土。\n2个黑曜石收集机器人收集2个黑曜石；你现在有8颗黑曜石。\n2个紫晶机器人收集2个紫晶；你现在有9个紫晶。","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"蓝图2最多获得12个紫晶。","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"对于以下蓝图，分别能获得的最多紫晶是多少？","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"Blueprint 1: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 17 clay. Each geode robot costs 4 ore and 20 obsidian.\nBlueprint 2: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 3 ore and 17 clay. Each geode robot costs 3 ore and 8 obsidian.\nBlueprint 3: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 7 clay. Each geode robot costs 4 ore and 13 obsidian.\nBlueprint 4: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 10 clay. Each geode robot costs 3 ore and 14 obsidian.\nBlueprint 5: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 17 clay. Each geode robot costs 3 ore and 16 obsidian.\nBlueprint 6: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 16 clay. Each geode robot costs 2 ore and 15 obsidian.\nBlueprint 7: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 15 clay. Each geode robot costs 2 ore and 15 obsidian.\nBlueprint 8: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 19 clay. Each geode robot costs 2 ore and 18 obsidian.\nBlueprint 9: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 7 clay. Each geode robot costs 2 ore and 19 obsidian.\nBlueprint 10: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 6 clay. Each geode robot costs 3 ore and 16 obsidian.\nBlueprint 11: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 8 clay. Each geode robot costs 3 ore and 19 obsidian.\nBlueprint 12: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 19 clay. Each geode robot costs 2 ore and 12 obsidian.\nBlueprint 13: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 14 clay. Each geode robot costs 4 ore and 17 obsidian.\nBlueprint 14: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 2 ore and 14 obsidian.\nBlueprint 15: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 10 clay. Each geode robot costs 2 ore and 11 obsidian.\nBlueprint 16: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 13 clay. Each geode robot costs 3 ore and 11 obsidian.\nBlueprint 17: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 19 clay. Each geode robot costs 3 ore and 10 obsidian.\nBlueprint 18: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 2 ore and 17 obsidian.\nBlueprint 19: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 11 clay. Each geode robot costs 4 ore and 12 obsidian.\nBlueprint 20: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 7 clay. Each geode robot costs 3 ore and 10 obsidian.\nBlueprint 21: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 13 clay. Each geode robot costs 3 ore and 7 obsidian.\nBlueprint 22: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 15 clay. Each geode robot costs 2 ore and 7 obsidian.\nBlueprint 23: Each ore robot costs 3 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 3 ore and 18 obsidian.\nBlueprint 24: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 18 clay. Each geode robot costs 4 ore and 8 obsidian.\nBlueprint 25: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 3 ore and 14 clay. Each geode robot costs 4 ore and 15 obsidian.\nBlueprint 26: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 3 ore and 9 obsidian.\nBlueprint 27: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 5 clay. Each geode robot costs 3 ore and 7 obsidian.\nBlueprint 28: Each ore robot costs 3 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 11 clay. Each geode robot costs 2 ore and 8 obsidian.\nBlueprint 29: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 12 clay. Each geode robot costs 3 ore and 15 obsidian.\nBlueprint 30: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 10 clay. Each geode robot costs 3 ore and 10 obsidian.","category":"page"},{"location":"Optimization/JumpMILP/#优化问题的数学表达","page":"JuMP混合整数线性优化实例","title":"优化问题的数学表达","text":"","category":"section"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"因为涉及到时间域上的状态改变（本质就是离散），所以需要在求解时间域上的每个时间点上设置一个变量。同时，每个不同种类的矿石也需要设置变量。","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"变量设置：","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"每个种类每个时间点矿石数量，整数\n每个种类每个时间点机器人数量，整数\n每个种类每个时间点是否建造，0或1","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"所以有：","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"\nrobots_ij  in N\nisBuild_ij in 01\nobtains_ij in N\ni in ore clay obsidian geode\nj in 1232324\n","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"优化目标为第24分钟，紫晶最多：","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"\nmax obtains_geode24 \n","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"约束：","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"矿石量等于上一周期的矿石量加上本周期的产出减去本周期的消耗。","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"note: Note\ncosts的每一行是建造不同种机器人消耗的材料个数。costs =  beginbmatrix4 3 2 3  0 0 17 0  0 0 0 16  0 0 0 0endbmatrix例如，第一行为建造4中不同的机器人，分别要消耗4，3，2，3个ore；第二行为建造4中不同的机器人,分别要消耗0，0，17，0个clay：","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"obtains_ij = obtains_ij-1+robots_ij - sum_k^ costs_ik * isBulid_kj","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"上一个周期结束，矿石足够才能在本周期建造机器人","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"obtains_ij-1 geqslant sum_k^ costs_ik * isBulid_kj","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"建造机器人，数量增加","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"robots_ij =  robots_ij-1  + isBulid_ij-1","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"一次只能建造一个机器人","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"sum_k^ isBulid_kj leqslant 1","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"初值条件，没有材料且只有一台矿石机器人：","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"isBulid_i1 = 0 i in ore clay obsidian geode\nobtain_i1 = 0 i in  clay obsidian geode\nrobots_i1 = 0 i in  clay obsidian geode\nobtain_ore1 = 1 \nrobots_ore1 = 1 ","category":"page"},{"location":"Optimization/JumpMILP/#JuMP求解代码","page":"JuMP混合整数线性优化实例","title":"JuMP求解代码","text":"","category":"section"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"using JuMP\nimport HiGHS\n\ninputs = \"\"\"Blueprint 1: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 17 clay. Each geode robot costs 4 ore and 20 obsidian.\nBlueprint 2: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 3 ore and 17 clay. Each geode robot costs 3 ore and 8 obsidian.\nBlueprint 3: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 7 clay. Each geode robot costs 4 ore and 13 obsidian.\nBlueprint 4: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 10 clay. Each geode robot costs 3 ore and 14 obsidian.\nBlueprint 5: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 17 clay. Each geode robot costs 3 ore and 16 obsidian.\nBlueprint 6: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 16 clay. Each geode robot costs 2 ore and 15 obsidian.\nBlueprint 7: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 15 clay. Each geode robot costs 2 ore and 15 obsidian.\nBlueprint 8: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 19 clay. Each geode robot costs 2 ore and 18 obsidian.\nBlueprint 9: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 7 clay. Each geode robot costs 2 ore and 19 obsidian.\nBlueprint 10: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 6 clay. Each geode robot costs 3 ore and 16 obsidian.\nBlueprint 11: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 8 clay. Each geode robot costs 3 ore and 19 obsidian.\nBlueprint 12: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 19 clay. Each geode robot costs 2 ore and 12 obsidian.\nBlueprint 13: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 14 clay. Each geode robot costs 4 ore and 17 obsidian.\nBlueprint 14: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 2 ore and 14 obsidian.\nBlueprint 15: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 10 clay. Each geode robot costs 2 ore and 11 obsidian.\nBlueprint 16: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 13 clay. Each geode robot costs 3 ore and 11 obsidian.\nBlueprint 17: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 19 clay. Each geode robot costs 3 ore and 10 obsidian.\nBlueprint 18: Each ore robot costs 2 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 2 ore and 17 obsidian.\nBlueprint 19: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 11 clay. Each geode robot costs 4 ore and 12 obsidian.\nBlueprint 20: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 7 clay. Each geode robot costs 3 ore and 10 obsidian.\nBlueprint 21: Each ore robot costs 3 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 13 clay. Each geode robot costs 3 ore and 7 obsidian.\nBlueprint 22: Each ore robot costs 2 ore. Each clay robot costs 2 ore. Each obsidian robot costs 2 ore and 15 clay. Each geode robot costs 2 ore and 7 obsidian.\nBlueprint 23: Each ore robot costs 3 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 3 ore and 18 obsidian.\nBlueprint 24: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 18 clay. Each geode robot costs 4 ore and 8 obsidian.\nBlueprint 25: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 3 ore and 14 clay. Each geode robot costs 4 ore and 15 obsidian.\nBlueprint 26: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 2 ore and 20 clay. Each geode robot costs 3 ore and 9 obsidian.\nBlueprint 27: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 4 ore and 5 clay. Each geode robot costs 3 ore and 7 obsidian.\nBlueprint 28: Each ore robot costs 3 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 11 clay. Each geode robot costs 2 ore and 8 obsidian.\nBlueprint 29: Each ore robot costs 4 ore. Each clay robot costs 4 ore. Each obsidian robot costs 2 ore and 12 clay. Each geode robot costs 3 ore and 15 obsidian.\nBlueprint 30: Each ore robot costs 4 ore. Each clay robot costs 3 ore. Each obsidian robot costs 3 ore and 10 clay. Each geode robot costs 3 ore and 10 obsidian.\n\"\"\"\n\ninputs = IOBuffer(inputs)\n\nfunction readData(path=inputs)\n    rawData = readlines(path)\n    rawData = split.(rawData, c -> c == '.' || c == ':')\n    regs = [\n        r\"Blueprint (\\d+)\",\n        r\"costs (\\d+) ore\",\n        r\"costs (\\d+) ore\",\n        r\"costs (\\d+) ore and (\\d+) clay\",\n        r\"costs (\\d+) ore and (\\d+) obsidian\",\n    ]\n    d = Dict{Int,Vector{Vector{Int64}}}()\n    for line in rawData |> eachindex\n        c = map(x -> zeros(Int64, 4), 1:4)\n        r = Vector{Int64}[]\n        for i in 1:5\n            m = match(regs[i], rawData[line][i]).captures\n            m = map(x -> parse(Int64, x), m)\n            push!(r, m)\n        end\n        c[1][1] = r[2][1]\n        c[1][2] = r[3][1]\n        c[1][3] = r[4][1]\n        c[1][4] = r[5][1]\n        c[2][3] = r[4][2]\n        c[3][4] = r[5][2]\n        d[r[1][1]] = c\n    end\n    return d\nend\n\n\nfunction solve_1(costs, periods)\n    model = Model(HiGHS.Optimizer)\n    set_silent(model)\n    names = [\"ore\", \"clay\", \"obsidian\", \"geode\"]\n    # robots为每个机器人的数量，obtains为每个机器人每个周期的产出，isBuild为每个机器人每个周期是否建造\n    @variable(model, robots[names, periods], Int)\n    @variable(model, obtains[names, periods], Int)\n    @variable(model, isBuild[names, periods], Bin)\n    # 矿石量等于上一周期的矿石量加上本周期的产出减去本周期的消耗\n    for (p1, p2) ∈ zip(periods[1:end-1], periods[2:end])\n        @constraint(model, [ind = 1:4], obtains[names[ind], p2] == obtains[names[ind], p1] + robots[names[ind], p2] - sum(costs[ind] .* isBuild[:, p2]))\n    end\n    # 矿石足够才能建造机器人\n    for (p1, p2) ∈ zip(periods[1:end-1], periods[2:end])\n        @constraint(model, [ind = 1:4], obtains[names[ind], p1] >= sum(costs[ind] .* isBuild[:, p2]))\n    end\n    # 建造机器人\n    for (p1, p2) ∈ zip(periods[1:end-1], periods[2:end])\n        @constraint(model, [ind = 1:4], robots[names[ind], p2] == robots[names[ind], p1] + isBuild[names[ind], p1])\n    end\n    # 一次只能建造一个机器人\n    @constraint(model, [i = periods], sum(isBuild[:, i]) <= 1)\n    # 初始条件\n    @constraint(model, [ind = 2:4], robots[names[ind], 1] == 0)\n    @constraint(model, [ind = 1:1], robots[names[ind], 1] == 1)\n    @constraint(model, [ind = 2:4], obtains[names[ind], 1] == 0)\n    @constraint(model, [ind = 1:1], obtains[names[ind], 1] == 1)\n    @constraint(model, [ind = 1:4], isBuild[names[ind], 1] == 0)\n    # 目标函数\n    @objective(model, Max, obtains[\"geode\", lastindex(periods)])\n    optimize!(model)\n    return objective_value(model) |> Int\nend\n\nfunction solve_P1()\n    d = readData()\n    s = String[]\n    for (i, c) in d\n        res = solve_1(c, 1:24)\n        push!(s,\"第$(i)个结果:\"*string(res))\n    end\n    return s\nend\n\nsolve_P1()","category":"page"},{"location":"Optimization/JumpMILP/#小结","page":"JuMP混合整数线性优化实例","title":"小结","text":"","category":"section"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"这个问题重要的特点为：","category":"page"},{"location":"Optimization/JumpMILP/","page":"JuMP混合整数线性优化实例","title":"JuMP混合整数线性优化实例","text":"存在时域上的状态转移（能源系统中负荷的变化等等），以及如何用变量之间的关联体现状态转移的关系\n包含整数与布尔变量（设备启停、满足最小需求的设备数量等等）","category":"page"},{"location":"Modeling/neural_network/#数学视角下的神经网络","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"tip: Tip\nContents：Flux，神经网络Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"note: Note\nFlux.jl Julia机器学习包\n著作\nPattern Recognition and Machine Learning - Christopher M. Bishop\n机器学习 - 周志华\nDive into Deep Learning - 阿斯顿·张，李沐\n博文\nApacheCN 人工智能知识树\n机器学习原理\n视频\n吴恩达 deeplearning.ai\n李宏毅 Course-Machine Learning\n前言\npapers with code","category":"page"},{"location":"Modeling/neural_network/#神经网络的数学内涵","page":"数学视角下的神经网络","title":"1 神经网络的数学内涵","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 2)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"对于这样一个简单的神经网络，其中间神经元的激活函数为tanh，输入x与输出y之间的数学表达式为：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"y=w_21tanhleft(w_11x+b_11right)+w_22tanhleft(w_12x+b_12right)+b_2","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"训练的目标为：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"minsum_i=0^n left(y_reali-y_trainiright)^2 tag1-1","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"其中y_reali为实际数据，y_traini为通过模型计算出来的数据。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"如果y也是一个激活函数tanh，经过激活函数后输出，那么数学模型则变为：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"y=tanh(w_21tanhleft(w_11x+b_11right)+w_22tanhleft(w_12x+b_12right)+b_2)+b","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"神经网络的参数训练，则是为了要找到使训练目标最小的一组参数：w_ijb_ij。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"由此可以归纳：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"神经网络的本质是一个关于激活函数的复合函数\n训练的内涵是寻优的过程，内涵是优化问题（回归问题）\n神经网络处理问题的内涵是用复合函数去拟合数据集","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"所以从数学内涵上来说，作为人工智能代表之一的神经网络并没有那么神秘。事实上，它也并没有那么强大！根据其内涵，可以总结出其优缺点。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"优点：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"普适性的优化框架，如BP算法\n模型任意搭建，成熟的工具（Tensorflow等）","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"缺点：包含了拟合的缺点。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"其模型的内涵（机理）不明确，只是从数学的角度逼近真实数据\n容易过拟合","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"下面通过一些实验来说明。","category":"page"},{"location":"Modeling/neural_network/#神经网络的学习特性探究","page":"数学视角下的神经网络","title":"2 神经网络的学习特性探究","text":"","category":"section"},{"location":"Modeling/neural_network/#.1-一维曲线学习","page":"数学视角下的神经网络","title":"2.1 一维曲线学习","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"考虑简单的函数学习问题，用神经网络（1隐藏层2节点，如上图所示，中间层激活函数采用双曲正弦函数）来学习一个一元函数，即单输入单输出网络，一共有7（2*2+2+1）个参数。在数据集中生成中，严格按照二次曲线规律生成，不添加任何扰动。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"采用下面的程序计算，训练10000次，训练结果的均方差为5.52E-5。为了验证学习的效果。在区间010内取一些原函数（y= x^2）上的点，作为测试集。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"using Flux\nusing Flux: train!\nusing Plots\n\nW1 = rand(2,1)\nb1 = rand(2)\nlayer1(x) = W1 * x .+ b1\n\nW2 = rand(1,2)\nb2 = rand(1)\nlayer2(x) = W2 * x .+ b2\n\ng(x) = x^2\n\nmodel(x) = layer2(g.(layer1(x)))[1]\n\nx_train = collect(0:.1:1)\ny_train = x_train.^2\nscatter(x_train,y_train,legend=false)\n\nmodel.(x_train)\nloss(x,y) = Flux.Losses.mse(model.(x),y)\nparameters = [W1,b1,W2,b2]\ndata = [(x_train,y_train)]\nopt = Descent(0.1)\nfor i in 1:5000\n    train!(loss, parameters, data, opt)\nend\nprintln(loss(x_train,y_train))\nbegin\n    scatter(x_train,y_train,legend=false,title=\"x^2\",color=\"red\")\n    plot!(x_train,model.(x_train),color=\"blue\")\nend\n\nbegin\n    x_learned = collect(0.07:0.07:1)\n    scatter!(x_learned,x_learned.^2,legend=false,color=\"green\")\nend","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 3)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"学习的结果如上图，红色点为训练集，以绿色点为测试集。可以认为，学习机很好地找到了在区间010原有数据的“机理”，因为学习结果几乎和原函数一致。这是一个非常漂亮的学习过程！","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"上述学习训练过程的核心特点为：训练集的学习域覆盖了测试集的测试域，它们都在之内010。自然而然地想到，没有学习过的区域呢？比如1020left-1000right这些区间表现会表现得怎么样？","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"begin\n    x_pred = collect(1:.1:2)\n    scatter!(x_pred, x_pred.^2,legend=false,color=\"green\")\n    plot!(x_pred,model.(x_pred),color=\"blue\")\nend\n\nbegin\n    x_pred = collect(-1.0:.1:0)\n    scatter!(x_pred, x_pred.^2,legend=false,color=\"green\")\n    plot!(x_pred,model.(x_pred),color=\"blue\")\nend","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 5)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"在1020left-1000right区间上，结果如图所示。表现为没有“学会”。因为实际值和测试值偏离了。","category":"page"},{"location":"Modeling/neural_network/#.2-内涵探讨","page":"数学视角下的神经网络","title":"2.2 内涵探讨","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"事实上，这个结果应该是意料之中的。上面说过，神经网络学习的本质上是用复合函数逼近。用一个构造的数学函数y去代替数据点二次曲线的实际内涵。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"Tanh的泰勒展开为：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"tanh=x-fracx^35+frac2x^515+o(x^7)","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"在式（1-1）中，学习机除去偏移量b_2还有6个参数，简单认为逼近的精度为tanh泰勒展开的前6项，误差为项为o(x^13)。在数据训练集区间内，o(x^13)可以保证在训练域误差可以很小，但一旦扩展到全实数域，这部分误差是无法避免的。因为其本质的“机理”并不相同。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"上面的问题中，神经网络通过参数优化，逼近了0 10区间内关于x^2的数据特性，可以使得学习机在0 10 完美替代x^2$。在这个区间外，它还是它自己，即tanh。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"所以，神经网络的数学内涵是逼近，其预测世界规律的方法是激活函数。采用统一的方法去逼近任意区间内的数据。所以，从数学的角度，激活函数与神经元个数都体现神经网络结构的逼近能力。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"下图分表表示了激活函数为exp与x^2训练与预测情况。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 6)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 7)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"在0 10内，可以认为神经网络可以代表x^2。而在0 10外，函数走势都是它们“本来的样子”。","category":"page"},{"location":"Modeling/neural_network/#.3-二维曲线学习","page":"数学视角下的神经网络","title":"2.3 二维曲线学习","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"拓展到二维平面拥有相同的规律。采用10节点2隐藏层全连接网络逼近二元函数函数:","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"gleft(xyright)=sinleft(xright)ast c o sleft(yright)   xyinleft(01right)","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"神经网络图与训练结果如下图：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 8)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 9)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"散点代表真实值。平面代表预测平面。可以看到散点图几乎都在平面上，训练效果较好。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 10)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"学习机在xyinleft(02right)的表现如上图所示。红点为训练数据集，黄点为训练集域内的测试集，绿点为训练集外的测试集。可以看到随着预测范围往外扩展，绿点作为测试集与预测平面已经“分道扬镳”。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"这与前面的分析一致，不同之处在于学习机逼近二元函数，逼近的对象是面而不是曲线。再拓展到更高维度的超平面上，神经网络逼近的特性仍然成立。这是由它的数学内涵决定的。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"代码如下。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"using Flux\nusing Flux: train!\nusing Plots\n\nW1 = rand(10,2)\nb1 = rand(10)\nlayer1(x) = W1 * x .+ b1\n\nW2 = rand(10,10)\nb2 = rand(10)\nlayer2(x) = W2 * x .+ b2\n\nW3 = rand(1,10)\nb3 = rand(1)\nlayer3(x) = W3 * x .+ b3\n\nmodel(x) = layer3(tanh.(layer2(tanh.(layer1(x)))))[1]\n\nxs = collect(0:0.1:1.0)\nx_grid = [x for x = xs for y = xs]\na_grid = [y for x = xs for y = xs]\nz_train = cos.(x_grid) .* sin.(a_grid)\nxy = [[x,y] for x in xs for y in xs]\nmodel.(z_train)\n\nloss(x,y) = Flux.Losses.mse(model.(x),y)\nparameters = [W1,b1,W2,b2,W3,b3]\ndata = [(xy,z_train)]\nopt = Descent(0.1)\n\nfor i in 1:1000\n    train!(loss, parameters, data, opt)\nend\nprintln(loss(xy,z_train))\n\n\n\nxs = collect(0:0.1:2.0)\nx_grid = [x for x = xs for y = xs]\na_grid = [y for x = xs for y = xs]\nxy = [[x,y] for x in xs for y in xs]\nz_predic = model.(xy)\nplot(x_grid,a_grid,z_predic, st = :surface)\nscatter!(x_grid,a_grid,cos.(x_grid) .* sin.(a_grid))\n\n\nxs = collect(0:0.1:2.0)\nx_grid = [x for x = xs for y = xs]\na_grid = [y for x = xs for y = xs]\nxy = [[x,y] for x in xs for y in xs]\nz_predic = model.(xy)\nplot(x_grid,a_grid,z_predic, st = :surface)\nxs = collect(0.05:0.1:1.0)\nx_grid = [x for x = xs for y = xs]\na_grid = [y for x = xs for y = xs]\nscatter!(x_grid,a_grid,cos.(x_grid) .* sin.(a_grid),color=\"yellow\",legend=false)\nxs = collect(0:0.1:1.0)\nx_grid = [x for x = xs for y = xs]\na_grid = [y for x = xs for y = xs]\nscatter!(x_grid,a_grid,cos.(x_grid) .* sin.(a_grid),color=\"red\")\nxs = collect(0:0.1:2.0)\nx_grid = [x for x = xs for y = xs if x>=1.0||y>=1.0]\na_grid = [y for x = xs for y = xs if x>=1.0||y>=1.0]\nscatter!(x_grid,a_grid,cos.(x_grid) .* sin.(a_grid),color=\"green\")","category":"page"},{"location":"Modeling/neural_network/#.4-正则化对逼近的影响","page":"数学视角下的神经网络","title":"2.4 正则化对逼近的影响","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"那么正则化的引入有没有改变这一内涵呢？答案是否定的。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"在前面的讨论中，数据集都严格符合函数规律，没有任何误差。在实际的数据集中，不可能由如此理想的情况。而正则项就是对这测量值误差的一种折中处理，神经网络的设计者可以通过正则项来指引网络的优化方向，从人的智能角度规避纯数据带来的“误导”。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"首先，基于y=x^2在0010范围内生成一些点，并且加上随机扰动作为训练集。如下图所示。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 11)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"从散点图依稀可以看出二次函数的影子。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"下面尝试不同的正则化。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"情况1，无正则化：Loss=sum_i=1^Nleft(y_i-fleft(x_iright)right)^2","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 13)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"情况2，正则化大权值逼近y=05：Loss=sum_i=1^Nleft(y_i-fleft(x_iright)right)^2+100ast(fleft(x_iright)-05)^2","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 14)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"情况2，正则化大权值逼近y=x^2：Loss=sum_i=1^Nleft(y_i-fleft(x_iright)right)^2+100ast(fleft(x_iright)-x_i^2)^2","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 16)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"学习机是否克服了“逼近”带来的缺点呢？答案依旧是否定的。在未知域，学习机并没有带来惊喜。如图下图所示，在1020的预测范围内，预测能力也没有得到显著的提升。Loss方程的改变，只是规避了数据观测误差带来的影响，防止神经网络因某些异常点陷入过拟合状态。其并没有改变神经网络架构逼近的数学内涵，所以其仍然不具备学习域外的预测能力，因为其“探索世界的根本方法论”依旧是——tanh。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"但正则项所带来的泛化能力是毋庸置疑的，在遇到特定问题时也许不容易知道数据的“机理”，但是从方法论的进程上来说，正则化已经向“探索未知”迈出了重要的一步。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"(Image: 图 17)  ","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"using Flux\nusing Flux: train!\nusing Plots\nusing Statistics\n\nN = 10\nW1 = rand(N,1)\nb1 = rand(N)\nlayer1(x) = W1 * x .+ b1\n\nW2 = rand(1,N)\nb2 = rand(1)\nlayer2(x) = W2 * x .+ b2\n\nmodel(x) = layer2(tanh.(layer1(x)))[1]\n\nx_train = collect(0:.1:1)\ny_train = x_train.^2 .+ rand(length(x_train))*0.2\n\nmodel.(x_train)\nloss(x,y) = 0.1*Flux.Losses.mse(model.(x),y) + mean((model.(x).-x.^2).^2)\nparameters = [W1,b1,W2,b2]\ndata = [(x_train,y_train)]\nopt = Descent(0.1)\nbegin\n    for i in 1:2000\n        train!(loss, parameters, data, opt)\n    end\n    println(loss(x_train,y_train))\nend\n\nbegin\n    scatter(x_train,y_train,legend=false)\n    plot!(x_train,model.(x_train))\nend\n\nbegin\n    x_pred = collect(1:0.1:2)\n    y_pred = model.(x_pred)\n    scatter!(x_pred,x_pred.^2,color=\"green\")\n    plot!(x_pred,y_pred,color=\"green\")\nend\n","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"神经网络的数学内涵是用函数去逼近某个区间内的数据集，其本质的特征是激活函数。这一点决定了在未学习过的未知域，神经网络的预测作用有限。 在纷杂又充满噪声的数据中，正则化是探索数据内涵重要的利器！正则项代表人的智能对学习机学习的一种指导，在已知域内正则化可以剔除噪声发现已知域的本质。这是从完全的数据挖掘以至于陷入过拟合发展状态的重大突破。虽然如此，但正则项没有改变根本的拟合逼近问题。","category":"page"},{"location":"Modeling/neural_network/#启发与讨论","page":"数学视角下的神经网络","title":"3 启发与讨论","text":"","category":"section"},{"location":"Modeling/neural_network/#神经网络应用的启示","page":"数学视角下的神经网络","title":"神经网络应用的启示","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"从上面的分析中，我们可以划分定义两个概念：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"训练域：训练集涉及到的变量区间\n未知域：训练集未涉及到的变量区间","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"可以把测试集分成两类。一类是在训练域中的，一类是在未知域中的。由上面的实验可以推知，在训练域中训练集的临域通过学习机“逼近”了，那么在临域内的测试集就能有很高预测精度。而在未知域中的测试集，那么就只能听天由命。因为训练域之外，学习机就呈现了激活函数本来的面貌。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"对其应用而言，又要引入两个概念：","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"结构化问题：传统的机理明确（能用完备的数学方程描述，如欧姆定律：U=I*R）的问题\n非结构化问题：机理不明确的问题（只知变量之间有关联但无明确的机理量化关系，如喝牛奶频率和身高的关系）","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"从以上分析，可以知道。在结构化问题中，神经网络无优势。其优势在于非结构化问题的预测，因为非结构化问题本就机理不明，不明就“暴力拟合”试试呗 :)！虽然上述过程中讨论的都是结构化问题，但是对于非结构化问题也有一定的参考。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"例如，人脸识别。这可以从某种程度上解释人脸学习时为何需要一组端端正正的人脸。图像可以视作高维函数（自变量为RGB值）。一组端正的人脸保证了不管是训练集还是测试集，他们作为“数”的特性的坐标都比较相近，即保证了用来测试的人脸一定是在训练时“见过的”，或者“和见过的非常相近”。类比至上述实验的解释是，采用端正的0 10区间的“人脸”作为训练集，当测试集的人脸也很端正，也在0 10区间内，或者在其“附近”，那么学习机就能准确识别，因为已经学过了。但是，出现了一张“奇怪”的人脸，假设它是在25 30区间内。这没有学过，那就不会！","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"那么，机器学习的应用中可以获得一些启示。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"对于分类问题判别问题，应该用训练集包含更加广泛的训练域，如果训练域涵盖了测试集，那么精度会非常高。类似与高维的图像识别在数据量少的如何做到这一点呢？就需要在特征提取与降维方面下功夫。简单来说是，训练时让学习机见识过了所有的情况，那么测试时再见到，它一定可以处理得很好。如果见识太少，那就只能靠猜。人的经验不就是这样的道理吗？但问题是，在一维0 10区间，我们很容易界定训练域与未知域。在实际问题中，这是很难定义的。例如，怎么量化定义人脸的训练域？仅通过RGB颜色值？似乎不好说。所以，这还有待长远的探索。\n关于预测，若是对于训练域之外的测试集要想准确预测，要么改变tanh能够让激活函数体现出数据发展趋势的“道”；要么提取被学习对象的精髓让激活函数能够成为它的“道”。但预测本来就有巨大的不确定性。在实际问题的非结构性问题中，神经网络拟合的这个“机理”究竟是否是“真实的机理”呢？没人说得清，依旧要靠其它测试集来实践检验！或者，面对一些复杂的问题，通过一系列“猛如虎的操作”（例如池化卷积等等），本质上没有提升神经网络的预测能力，而是通过调参把训练集与测试集的尽可能缩到了处理后的变量训练域内。这样，逼近就有效果了，但这内涵难道不更像是插值处理？所以预测在某些些问题上，本就是一个伪命题。要真正实现预测，一定是机理得以明确，找到了事物最本质的规律之后的“对未知的预测”，而不是基于统计原理的“带插值含义的预测”。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"所以，对于神经网络，我们不需要过于神话。其本质可以看作一个强有力的拟合工具，尤其是在计算机技术飞速发展的今天，神经网络有它巨大的使用价值。但作为工具来说，科学的发展并不依赖于工具。工具只是手段，有些时候我们也应该“不忘初心”，回到对问题本质的结构化性质探索的方向上去。从另一个角度来说，神经网络可以成为结构化性质探索道路上的得力帮手，但是其大概率不能成为决定性因素。若是我们心中对它已经有了一种依赖，或者陷入了某种网络调参的狂热。那么我们是不是应该反思，我们是否陷入了对机器学习的路径依赖，是否忘了探索的真谛——研究问题本身？","category":"page"},{"location":"Modeling/neural_network/#.2-学习的本质","page":"数学视角下的神经网络","title":"3.2 学习的本质","text":"","category":"section"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"人类探索真理的过程，本质上是一个演绎推理、实验验证的过程。对应机器学习，一次训练对应演绎推理，测试集测试对应实验验证。对于人类的科学发展而言，这一探索是螺旋式上升的。从实践到理论，再用理论指导实践，实践结果修正理论，这是马克思科学原理的哲学观。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"在探索与发展的过程中，没有什么是绝对成立的，没有绝对的真理。就像牛顿定律不适用于量子领域，正是在“大误差”中，科学得以修正发展，本质上是一个理论与实践的Loss方程数值不断缩小的过程。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"类比科学发展的本质，在有限的数据集下，机器学习的学习方法或者学习范式还不够具有发展性。机器学习的学习方式更加接近于“一锤子买卖”。学习训练然后测试，没有测试结果指导理论的过程，或者说这一过程是由人来完成的。人根据测试结果的准确性来判断模型是否需要修改提升。目前阶段学习机没有自我驱动的迭代能力，即根据学习的效果来修正学习模型。人类智能的巨大潜力，正是体现在驱动实践理论再实践这一个过程当中。从这哲学的角度，这样一种实践理论再实践的学习范式是面对“未知的虚无”最强有力的手段，也是最强大的学习方法。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"学习的本质，在机器学习中更加接近元学习的思想。即在学习模型中提供根据结果修正模型参数的接口，让学习机能够在Loss方程的指引下，自我迭代。目前可能是调整超参数，未来可能就能发展成为自我修正网络结构、激活函数等学习模型的框架结构。从计算的本质来说，这一过程对应Code Generation。目前普遍的学习方法是修改模型参数，元学习的学习方法是学习机能够修改模型代码。对应的实现方式为元编程——用代码写代码。","category":"page"},{"location":"Modeling/neural_network/","page":"数学视角下的神经网络","title":"数学视角下的神经网络","text":"目前来说元编程的技术实现完全没有问题，Julia语言中就有成熟高效的元编程方式。元学习的技术实现不是问题。但从它的学习过程可以轻易推断，元学习的难点在于Loss方程的量化指标。由损失到参数，是在数的领域。而由损失到网络结构，这不是一个可以直接跨越的鸿沟。在它们中间，需要架起一座由数到结构的桥梁，也就是变成一个可计算的问题。要实现这一点，还需要长时间的探索。","category":"page"},{"location":"Optimization/DE_Estim/#微分方程参数辨识实例","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"section"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"tip: Tip\nContents：微分方程参数辨识、优化、DiffEqParamEstimContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"note: Note\nDEPE = DiffEqParamEstim.jl(Differential Equation Parameters Estimate)DiffEqParamEstim.jl是计算微分方程参数估计的软件包。","category":"page"},{"location":"Optimization/DE_Estim/#微分方程参数辨识问题","page":"微分方程参数辨识实例","title":"微分方程参数辨识问题","text":"","category":"section"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"在JuMP非线性参数辨识实例与MTK非线性参数辨识实例中介绍了参数辨识问题的形式与求解工具。求解的问题的数学形式为一般方程：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"y = ax^2+sin(bx)a=15b=08","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"DEPE则是针对另外一种数学形式进行参数辨识求解的工具包——微分方程形式。例如，如下问题：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"fracdydt = at^2+sin(bt)a=15b=08","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"对于这样一个微分问题。假设我们并不知道参数ab的值是多少。同样只能过实验和测量获得对应时间点上y的观测值。参数辨识需要解决的问题是：根据t，y观测值。反推出ab的值。与前面解决的问题不同的是，它是微分方程形式。相同的是，它们的核心逻辑是“优化”。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"要求解这样一个含有微分方程的参数辨识问题，可以很自然地想到：将微分方程的原函数求出来，再进行常规方程的参数辨识，问题就解决了。但是这有一个前提——能够求出原函数。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"DEPE的解决方式是，直接将微分方程离散，通过离散后的节点直接构造优化问题，进行求解。这样就避免了求解原函数问题。","category":"page"},{"location":"Optimization/DE_Estim/#离散的概念","page":"微分方程参数辨识实例","title":"离散的概念","text":"","category":"section"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"离散是微分方程数值解法中的一个概念。例如，求解：fracdydt = ytin(01)","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"具体的方法是在tin(01)选特定步长的点，假如选定步长为0.1，那么有：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"t_0=0t_1=01t_2=02t_10=10","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"同时，对于函数y，有","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"y_n-y_n-1 = y_n-1 * 01nin01210","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"所以，对于微分方程问题，就转为了求y_0至y_10的值，也就是求出具体时间点上的函数值。问题就由一个连续的方程变成了有限个点上的函数值，这个过程就成为离散。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"数值求解算法的精度与离散的方法有紧密关系。上面的离散方式可以换成：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"y_n-y_n-1 = y_n * 01nin01210","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"区别不过不过是等式右端取y_n-1还是y_n的区别。但却是两种不同的方法——向前与向后差分，求解的精度也不一样。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"此外，求解的精度还与步长等因素相关。更多理论，可以查阅《数值分析》一书。","category":"page"},{"location":"Optimization/DE_Estim/#微分参数辨识的优化表达","page":"微分方程参数辨识实例","title":"微分参数辨识的优化表达","text":"","category":"section"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"回到问题fracdydt = at^2+sin(bt)，已知系列观测值：y_real那么优化问题的数学表达为：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"undersetabminsum_i=0^n(y_reali-y_i)^2sthspace5mmy_i+1-y_i=at_i^2+sin(bt_i)","category":"page"},{"location":"Optimization/DE_Estim/#加热器实例","page":"微分方程参数辨识实例","title":"加热器实例","text":"","category":"section"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"现有一个加热系统，由加热器、温度传感器、散热器构成。那么其控制方程为：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"mcfracdTdt=(-Sh(T-T_out)+Q)*u(t-t_0)","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"可以简单理解为：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"温度变化=加热-散热*延迟函数","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"经过化简之后：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"beginarrayc\nfracd Td t=left(-fracTa+fracbaright) * u(t-c) \nu(t-c)=f(x)=leftbeginarrayll\n0  x0 1  x geq 0endarrayrightendarray","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"参数辨识的目标是辨识出a，b，c。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"数据（数据在文档最后，以CSV文件格式保存到julia程序文件夹即可）的第二列中为加热功率，在方程模型中我们做了简化。由于功率只有0和100，在方程中我们简化为开关延时函数。所以第二列的原始数据后面并没有使用。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"首先，实际的曲线如下：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"using CSV,DataFrames,Plots\ndata = CSV.read(\"./codetest/data.csv\",DataFrame)\n########根据第一列与第三列数据画出图像#########\nplot(data[:,1],data[:,3]) ","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"(Image: 图 1)  ","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"使用DE作为建模基础建立方程：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"using DifferentialEquations\nfunction fun(a)\n    if a>=0\n        1\n    else\n        0\n    end\nend\nfunction ff(u,p,t)\n    -u * fun( t- p[3])/p[1] + p[2] * fun( t- p[3])/p[1]\nend","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"这里采用了简写方式，省略了du，只包含微分方程右边的部分，因为只有一个微分变量所以可以简写。\nFun表示函数u的作用，其本质是单位阶跃函数。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"定义参数等要素：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"u0=3.6\ntspan = (0.0,3000.0)\np = [1.0,1.0,1.0]\nprob = ODEProblem(ff,u0,tspan,p)","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"需要留意p的值，这里p为选定的初始值。p的最终值是需要通过优化才能得到。优化目标为找到一组p，使得Loss方程的数值最小。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"如果按照初值p = [1.0,1.0,1.0]求解，则可以得到如下结果：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"sol = solve(prob, Tsit5())\nplot(sol)","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"(Image: 图 2)  ","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"可以看到，相去甚远！说明这个初值与真实值相差很远。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"通过DiffEqParamEstim构建优化模型：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"using DiffEqParamEstim\nrealdata = data[:,3]\nt= data[:,1]\ncost_function = build_loss_objective(prob, Tsit5(), L2Loss(t, realdata),\n    maxiters=10000, verbose=false)","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"其中，","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"realdata是实际过程中的温度值向量\nt是实际采样过程中的温度点\nbuildlossobjective 直接构建了Loss方程，其方法是L2Loss，即差的平方和。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"求解优化问题：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"using Optim\nresult_bfgs = Optim.optimize(cost_function, [1.0, 1.0, 1.0])\nprint(result_bfgs.minimizer)\n","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"Optim.optimize就是求解器，能求cost_function的最小值。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"得到结果：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"(Image: 图 3)  ","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"画图测试优化结果：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"u0=3.6\ntspan = (0.0,3000.0)\np = [779.0,49.0,-652.0]\nprob = ODEProblem(ff,u0,tspan,p)\nsol = solve(prob, Tsit5())\nplot(sol)","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"(Image: 图 4)  ","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"似乎结果差得有点远！","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"再次优化：这是因为初值对优化问题造成的影响。由于初值与目标相去甚远，所以结果有些出入。p[3]应该是正数。把优化初值的第三项改为正数。再次优化","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"result_bfgs = Optim.optimize(cost_function, [773.0,49.0,652.0])\nprint(result_bfgs.minimizer)","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"(Image: 图 5)  ","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"在这个结果下，画出来的图像如图：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"(Image: 图 6)  ","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"这是一个让人满意的结果！","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"note: Note\n多次优化是优化中一种常见的策略。某些问题的优化结果可能是一个局部最优解，这并不代表结果是错误的。所以，当优化结果不满意时，可以选择不同的初值进行优化求解。当初值离最优值越近，结果越准确。","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"全部代码：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"using CSV, DataFrames, Plots\ndata = CSV.read(\"./codetest/data.csv\", DataFrame)\ndata[!, 3]\nplot(data[:, 1], data[:, 3]) #画出图像\n\nusing DifferentialEquations\nfunction fun(a)\n    if a >= 0\n        1\n    else\n        0\n    end\nend\nfunction ff(u, p, t)\n    -u * fun(t - p[3]) / p[1] + p[2] * fun(t - p[3]) / p[1]\nend\n\nu0 = 3.6\ntspan = (0.0, 3000.0)\np = [1.0, 1.0, 1.0]\nprob = ODEProblem(ff, u0, tspan, p)\n\nsol = solve(prob, Tsit5())\nplot(sol)\n\nusing DiffEqParamEstim\nrealdata = data[:, 3]\nt = data[:, 1]\ncost_function = build_loss_objective(prob, Tsit5(), L2Loss(t, realdata),\n    maxiters=10000, verbose=false)\n\nusing Optim\nresult_bfgs = Optim.optimize(cost_function, [1.0, 1.0, 1.0])\nprint(result_bfgs.minimizer)\n\nresult_bfgs = Optim.optimize(cost_function, [773.0,49.0,652.0])\nprint(result_bfgs.minimizer)\n\n\nu0=3.6\ntspan = (0.0,3000.0)\np = [267.0,45.0,343.0]\nprob = ODEProblem(ff,u0,tspan,p)\nsol = solve(prob, Tsit5())\nplot(sol)","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"原始数据：","category":"page"},{"location":"Optimization/DE_Estim/","page":"微分方程参数辨识实例","title":"微分方程参数辨识实例","text":"Time (min),Valve Position (% open),Temperature (degC)\n0,0,3.6\n5,0,3.7\n10,0,3.6\n15,0,3.7\n20,0,3.6\n25,0,3.7\n30,0,3.7\n35,0,3.6\n40,0,3.6\n45,0,3.6\n50,0,3.6\n55,0,3.7\n60,0,3.7\n65,0,3.7\n70,0,3.7\n75,0,3.5\n80,0,3.6\n85,0,3.7\n90,0,3.5\n95,0,3.6\n100,0,3.5\n105,0,3.7\n110,0,3.6\n115,0,3.7\n120,0,3.6\n125,0,3.7\n130,0,3.7\n135,0,3.7\n140,0,3.7\n145,0,3.7\n150,0,3.7\n155,0,3.5\n160,0,3.6\n165,0,3.6\n170,0,3.6\n175,0,3.7\n180,0,3.6\n185,0,3.6\n190,0,3.7\n195,0,3.6\n200,0,3.5\n205,0,3.6\n210,0,3.5\n215,0,3.7\n220,0,3.6\n225,0,3.5\n230,0,3.7\n235,0,3.7\n240,0,3.6\n245,0,3.7\n250,0,3.5\n255,0,3.7\n260,0,3.7\n265,0,3.6\n270,0,3.6\n275,0,3.7\n280,0,3.7\n285,0,3.7\n290,0,3.5\n295,0,3.7\n300,0,3.5\n305,0,3.5\n310,0,3.7\n315,0,3.6\n320,0,3.7\n325,0,3.6\n330,0,3.7\n335,0,3.5\n340,0,3.5\n345,0,3.5\n350,0,3.7\n355,0,3.7\n360,0,3.6\n365,0,3.6\n370,0,3.7\n375,0,3.5\n380,0,3.7\n385,0,3.5\n390,0,3.7\n395,0,3.6\n400,100,3.7\n405,100,14.9\n410,100,18.2\n415,100,19.2\n420,100,19.9\n425,100,20.1\n430,100,20.8\n435,100,21.0\n440,100,21.3\n445,100,21.4\n450,100,21.5\n455,100,22.0\n460,100,21.8\n465,100,21.8\n470,100,21.9\n475,100,21.5\n480,100,21.7\n485,100,21.2\n490,100,20.7\n495,100,20.3\n500,100,20.3\n505,100,20.1\n510,100,21.2\n515,100,22.8\n520,100,23.9\n525,100,24.2\n530,100,24.9\n535,100,25.7\n540,100,26.4\n545,100,26.5\n550,100,26.7\n555,100,27.3\n560,100,27.6\n565,100,27.5\n570,100,27.5\n575,100,27.7\n580,100,27.8\n585,100,27.8\n590,100,27.9\n595,100,27.9\n600,100,28.0\n605,100,28.2\n610,100,28.2\n615,100,28.5\n620,100,28.7\n625,100,28.9\n630,100,29.0\n635,100,29.2\n640,100,29.7\n645,100,29.8\n650,100,30.1\n655,100,30.4\n660,100,30.5\n665,100,30.9\n670,100,31.6\n675,100,31.8\n680,100,32.2\n685,100,32.7\n690,100,32.8\n695,100,33.0\n700,100,33.4\n705,100,33.8\n710,100,34.0\n715,100,34.6\n720,100,34.8\n725,100,35.2\n730,100,35.4\n735,100,35.7\n740,100,36.0\n745,100,36.6\n750,100,36.8\n755,100,36.9\n760,100,37.3\n765,100,37.5\n770,100,37.7\n775,100,37.9\n780,100,37.9\n785,100,38.3\n790,100,38.2\n795,100,38.4\n800,100,38.7\n805,100,38.8\n810,100,39.1\n815,100,39.2\n820,100,39.2\n825,100,39.4\n830,100,39.4\n835,100,39.3\n840,100,39.5\n845,100,39.5\n850,100,39.7\n855,100,39.7\n860,100,39.8\n865,100,40.1\n870,100,39.9\n875,100,40.1\n880,100,40.0\n885,100,40.2\n890,100,40.1\n895,100,40.3\n900,100,40.3\n905,100,40.2\n910,100,40.1\n915,100,40.1\n920,100,40.1\n925,100,40.2\n930,100,40.3\n935,100,40.4\n940,100,40.4\n945,100,40.8\n950,100,40.8\n955,100,40.8\n960,100,40.7\n965,100,40.9\n970,100,41.0\n975,100,41.2\n980,100,41.3\n985,100,41.3\n990,100,41.3\n995,100,41.3\n1000,100,41.4\n1005,100,41.7\n1010,100,41.7\n1015,100,41.6\n1020,100,41.8\n1025,100,41.6\n1030,100,41.7\n1035,100,41.8\n1040,100,41.9\n1045,100,42.0\n1050,100,42.1\n1055,100,42.0\n1060,100,42.2\n1065,100,42.1\n1070,100,42.4\n1075,100,42.4\n1080,100,42.6\n1085,100,42.7\n1090,100,42.7\n1095,100,42.9\n1100,100,43.0\n1105,100,43.0\n1110,100,43.1\n1115,100,43.2\n1120,100,43.4\n1125,100,43.4\n1130,100,43.5\n1135,100,43.4\n1140,100,43.5\n1145,100,43.8\n1150,100,43.8\n1155,100,43.8\n1160,100,44.0\n1165,100,44.0\n1170,100,44.0\n1175,100,44.1\n1180,100,44.1\n1185,100,44.2\n1190,100,44.3\n1195,100,44.2\n1200,100,44.4\n1205,100,44.4\n1210,100,44.3\n1215,100,44.4\n1220,100,44.2\n1225,100,44.2\n1230,100,44.0\n1235,100,44.1\n1240,100,43.9\n1245,100,43.9\n1250,100,43.8\n1255,100,44.0\n1260,100,44.0\n1265,100,43.8\n1270,100,43.9\n1275,100,43.9\n1280,100,44.0\n1285,100,44.0\n1290,100,44.1\n1295,100,44.1\n1300,100,44.2\n1305,100,43.9\n1310,100,43.9\n1315,100,44.0\n1320,100,43.8\n1325,100,43.9\n1330,100,43.8\n1335,100,43.9\n1340,100,43.8\n1345,100,43.6\n1350,100,43.7\n1355,100,43.7\n1360,100,43.8\n1365,100,43.7\n1370,100,43.6\n1375,100,43.8\n1380,100,43.6\n1385,100,43.7\n1390,100,43.4\n1395,100,43.4\n1400,100,43.5\n1405,100,43.4\n1410,100,43.4\n1415,100,43.6\n1420,100,43.7\n1425,100,43.6\n1430,100,43.6\n1435,100,43.5\n1440,100,43.5\n1445,100,43.6\n1450,100,43.6\n1455,100,43.5\n1460,100,43.4\n1465,100,43.6\n1470,100,43.6\n1475,100,43.6\n1480,100,43.6\n1485,100,43.7\n1490,100,43.7\n1495,100,43.7\n1500,100,43.7\n1505,100,43.6\n1510,100,43.6\n1515,100,43.7\n1520,100,43.7\n1525,100,43.5\n1530,100,43.5\n1535,100,43.7\n1540,100,43.8\n1545,100,43.7\n1550,100,43.8\n1555,100,43.8\n1560,100,43.8\n1565,100,43.8\n1570,100,43.9\n1575,100,44.0\n1580,100,43.8\n1585,100,43.9\n1590,100,44.0\n1595,100,44.1\n1600,100,44.1\n1605,100,44.1\n1610,100,44.2\n1615,100,44.0\n1620,100,44.1\n1625,100,44.0\n1630,100,44.0\n1635,100,44.1\n1640,100,44.1\n1645,100,44.2\n1650,100,44.2\n1655,100,44.2\n1660,100,44.2\n1665,100,44.1\n1670,100,44.3\n1675,100,44.3\n1680,100,44.3\n1685,100,44.5\n1690,100,44.5\n1695,100,44.5\n1700,100,44.5\n1705,100,44.5\n1710,100,44.6\n1715,100,44.7\n1720,100,44.5\n1725,100,44.7\n1730,100,44.7\n1735,100,44.9\n1740,100,44.8\n1745,100,45.0\n1750,100,44.8\n1755,100,44.9\n1760,100,44.9\n1765,100,45.0\n1770,100,45.1\n1775,100,45.1\n1780,100,45.1\n1785,100,45.2\n1790,100,45.1\n1795,100,45.2\n1800,100,45.2\n1805,100,45.3\n1810,100,45.3\n1815,100,45.2\n1820,100,45.3\n1825,100,45.2\n1830,100,45.2\n1835,100,45.3\n1840,100,45.3\n1845,100,45.2\n1850,100,45.3\n1855,100,45.2\n1860,100,45.4\n1865,100,45.4\n1870,100,45.2\n1875,100,45.4\n1880,100,45.3\n1885,100,45.4\n1890,100,45.4\n1895,100,45.2\n1900,100,45.1\n1905,100,45.2\n1910,100,45.1\n1915,100,45.3\n1920,100,45.1\n1925,100,45.2\n1930,100,45.2\n1935,100,45.0\n1940,100,45.0\n1945,100,45.1\n1950,100,45.2\n1955,100,45.0\n1960,100,45.2\n1965,100,45.3\n1970,100,45.2\n1975,100,45.3\n1980,100,45.1\n1985,100,45.2\n1990,100,45.3\n1995,100,45.3\n2000,100,45.3\n2005,100,45.3\n2010,100,45.2\n2015,100,45.3\n2020,100,45.1\n2025,100,45.3\n2030,100,45.2\n2035,100,45.2\n2040,100,45.4\n2045,100,45.2\n2050,100,45.3\n2055,100,45.4\n2060,100,45.5\n2065,100,45.4\n2070,100,45.4\n2075,100,45.3\n2080,100,45.4\n2085,100,45.3\n2090,100,45.5\n2095,100,45.4\n2100,100,45.5\n2105,100,45.3\n2110,100,45.5\n2115,100,45.5\n2120,100,45.5\n2125,100,45.3\n2130,100,45.4\n2135,100,45.4\n2140,100,45.4\n2145,100,45.5\n2150,100,45.3\n2155,100,45.5\n2160,100,45.4\n2165,100,45.5\n2170,100,45.3\n2175,100,45.5\n2180,100,45.5\n2185,100,45.5\n2190,100,45.5\n2195,100,45.4\n2200,100,45.5\n2205,100,45.3\n2210,100,45.4\n2215,100,45.4\n2220,100,45.5\n2225,100,45.3\n2230,100,45.3\n2235,100,45.4\n2240,100,45.5\n2245,100,45.5\n2250,100,45.5\n2255,100,45.5\n2260,100,45.5\n2265,100,45.5\n2270,100,45.5\n2275,100,45.6\n2280,100,45.5\n2285,100,45.6\n2290,100,45.5\n2295,100,45.5\n2300,100,45.5\n2305,100,45.5\n2310,100,45.6\n2315,100,45.6\n2320,100,45.7\n2325,100,45.5\n2330,100,45.6\n2335,100,45.6\n2340,100,45.7\n2345,100,45.8\n2350,100,45.7\n2355,100,45.7\n2360,100,45.6\n2365,100,45.8\n2370,100,45.7\n2375,100,45.9\n2380,100,45.8\n2385,100,45.8\n2390,100,45.7\n2395,100,45.6\n2400,100,45.9\n2405,100,45.7\n2410,100,45.7\n2415,100,45.7\n2420,100,45.7\n2425,100,45.8\n2430,100,45.9\n2435,100,45.8\n2440,100,45.7\n2445,100,45.9\n2450,100,45.8\n2455,100,45.7\n2460,100,45.9\n2465,100,45.9\n2470,100,45.9\n2475,100,45.9\n2480,100,45.7\n2485,100,45.8\n2490,100,45.7\n2495,100,45.7\n2500,100,45.9\n2505,100,45.8\n2510,100,45.9\n2515,100,45.8\n2520,100,45.7\n2525,100,45.7\n2530,100,45.9\n2535,100,45.8\n2540,100,45.9\n2545,100,45.9\n2550,100,45.9\n2555,100,45.7\n2560,100,46.0\n2565,100,45.8\n2570,100,45.8\n2575,100,45.9\n2580,100,46.0\n2585,100,45.8\n2590,100,46.0\n2595,100,45.8\n2600,100,45.8\n2605,100,45.9\n2610,100,46.0\n2615,100,46.0\n2620,100,45.9\n2625,100,46.0\n2630,100,46.1\n2635,100,45.9\n2640,100,46.0\n2645,100,46.0\n2650,100,45.9\n2655,100,46.0\n2660,100,46.0\n2665,100,46.0\n2670,100,46.0\n2675,100,46.1\n2680,100,46.0\n2685,100,46.1\n2690,100,46.1\n2695,100,46.0\n2700,100,45.9\n2705,100,46.1\n2710,100,45.9\n2715,100,46.1\n2720,100,46.0\n2725,100,46.0\n2730,100,46.1\n2735,100,46.0\n2740,100,46.0\n2745,100,46.0\n2750,100,46.0\n2755,100,46.0\n2760,100,46.0\n2765,100,45.8\n2770,100,46.0\n2775,100,46.0\n2780,100,45.8\n2785,100,45.9\n2790,100,45.9\n2795,100,45.9\n2800,100,45.9\n2805,100,46.0\n2810,100,46.0\n2815,100,46.0\n2820,100,46.0\n2825,100,46.0\n2830,100,45.9\n2835,100,45.9\n2840,100,45.9\n2845,100,45.9\n2850,100,45.9\n2855,100,46.0\n2860,100,46.0\n2865,100,45.9\n2870,100,45.8\n2875,100,45.8\n2880,100,46.1\n2885,100,46.0\n2890,100,46.1\n2895,100,45.9\n2900,100,46.1\n2905,100,45.9\n2910,100,46.1\n2915,100,45.9\n2920,100,46.0\n2925,100,45.9\n2930,100,46.1\n2935,100,46.0\n2940,100,46.0\n2945,100,46.1\n2950,100,46.0\n2955,100,46.0\n2960,100,46.1\n2965,100,46.1\n2970,100,46.0\n2975,100,45.9\n2980,100,46.0\n2985,100,46.1\n2990,100,46.0\n2995,100,46.1\n3000,100,46.0","category":"page"},{"location":"CS Base/env_variable/#环境（变量）的本质","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"","category":"section"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"tip: Tip\nContents：环境、环境变量Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"我们都听过环境、环境变量等等名词。那么，它的本质到底是什么呢？","category":"page"},{"location":"CS Base/env_variable/#命名","page":"环境（变量）的本质","title":"命名","text":"","category":"section"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"假设现在有一个程序对象：","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"akdhihei","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"你知道这是个什么高级语法吗？","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"对的，这就是我胡乱打的，我也不知道它是什么。","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"那么再看一个对象：","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"path","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"这可能就有些熟悉了，配置过环境的同学都知道，path是我们的环境变量。","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"再看：","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"a","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"a又是什么呢？与上面的path类比，那么a就是一个变量呗！","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"那么这个变量有什么含义吗？没有！","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"那么现在再反问，上面的path有意义吗？","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"你可能说：有！它是环境变量！","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"但是上面那个path是谁的环境变量，它又指向了谁！","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"你可能有一点点明白了！","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"这些变量：akdhihei、path、a他们都是变量，本质可以说是容器可以存放值，也可以说是一个程序的对象，它本身没有意义！","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"它就是一个名称罢了，我们称之为命名。","category":"page"},{"location":"CS Base/env_variable/#环境","page":"环境（变量）的本质","title":"环境","text":"","category":"section"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"那么，怎样才能让命名有意义呢？","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"没错，就是给他赋值！","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"也可以说，没有值的变量并没有存在的意义","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"（你是不是联想到了，你写Python，Java的时候，当你没有使用某个变量，没有赋值，只是定义的时候，编辑器会有小波浪，向你提出warnings！）","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"现在你应该明白了，定而不用，就是没有意义，没有价值，浪费内存资源。因为这个内存（地址）就被占了。用一句话概括就是，占着茅坑不拉屎！","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"为了让它有意义，应该干嘛？赋值！","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"比如:","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"#define a 5\n\n#define akdhihei 8","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"那么现在可以说，这些被命名的对象们有了意义。它们和某一个具体的值联系起来了，后面的程序中，你看到a就知道它代表5！看到akdhihei就知道它代表8！","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"print(a + 1)","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"你一定知道这个程序的结果是什么。而在a被赋值之前，你并不知道！","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"那么这个操作的本质是什么呢？","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"是值与符号进行关联，关联之后，又可以通过符号提取数值。那么这是怎么做到的呢？解释器会维护着这样一种储存能力，以便保持着有关的名字-值对偶的关联！","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"而这种存储，就被称之为环境，（更加准确是，全局环境），那么局部变量，和其它不同作用域，就是不同的环境！这就是环境的本质！","category":"page"},{"location":"CS Base/env_variable/#path环境变量","page":"环境（变量）的本质","title":"path环境变量","text":"","category":"section"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"刚刚所说的是广义的环境。那么以path代表的环境变量是环境概念下的子集。","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"以python环境为例，在没有配置python环境之前，你在CMD终端中输入python，会显示","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"'python' 不是内部或外部命令，也不是可运行的程序或批处理文件。","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"而你把python环境配置一下之后，就可以了。","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"那其中到底干了什么呢？","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"其本质就是，path是一个变量，里面储存着一些文件的路径。在CMD命令行中输入命令的时候，系统会去path里面找相应的程序（或者在写程序的时候对调用path的路径等等）。比如说你的python.exe 路径为\"E:/\"，你把\"E:/\"加入到环境变量path中，那么就可以找到了，就可以在终端中运行了。","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"那么，这个概念依旧是名字-值的关联。path是名字，文件路径是\"E:/\"，环境变量这个狭义概念的赋予是因为，在windows系统中，CMD会通过path中提供的路径去搜寻，如果没有在path中配置（把路径赋值给path），就找不到，就可以通过CMD执行（你手动进入那个文件夹，鼠标点击运行是一点问题也没有的！）。这相当于在Windows下的一个CMD运行环境path，CMD是系统级别的，所以这个环境比较高级。上面的a=5这个环境就很不重要了！但他们的本质都是一样的——","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"那就是字符（名称）-值的关联。","category":"page"},{"location":"CS Base/env_variable/","page":"环境（变量）的本质","title":"环境（变量）的本质","text":"配置环境=把变量（path）和值（文件路径）关联上这一行为过程","category":"page"},{"location":"Frameworks/OptControl/#OptControl.jl设计理念","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"tip: Tip\nContents：OptControl：最优控制问题的解释器Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"note: Note\nOptControl地址。arXiv文章引用","category":"page"},{"location":"Frameworks/OptControl/#摘要","page":"OptControl.jl设计理念","title":"摘要","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"最优控制问题的本质是一个优化问题。OptControl.jl(OptControl)基于Julia语言，实现了最优控制的符号化建模过程，并生成相应的基于Julia生态的最优控制问题的数值优化求解代码。OptControl没有定义数据类型(struct)，而是通过处理字符生成解决方案脚本，并在内部解析并运行脚本。OptControl也提供保存脚本文件到本地的接口。同时，OptControl支持组件化建模，这让构建复杂系统的最优控制问题变得简单。OptControl的依赖包完全来自于Julia生态。","category":"page"},{"location":"Frameworks/OptControl/#Motivation","page":"OptControl.jl设计理念","title":"1 Motivation","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"最优控制问题的本质是一个优化问题，更准确的说是一个泛函求极值问题。从实现的角度，最优控制的解析解只有在特定的几种情况下才能求出，例如线性系统。而实际问题中往往需要面对非线性系统或者一些复杂的系统，这些问题的解析解一般而言难以求得。因此，能算出结果的数值解则是一个利器。虽然数值解在结果上会有一些偏差，但有偏差的结果也能带给人们一定理解问题的灵感。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"最优控制问题的数值解法一般而言可以转化为数值优化问题。数值优化问题可以使用JuMP.jl来求解。使用JuMP.jl求解一个最优控制问题，可以分为5步：","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"抽象实际问题\n获得状态方程模型\n构建数值优化模型\n生成JuMP模型\n求解","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"事实上，JuMP.jl完成了第4步，第5步的内容由具体的求解器完成。但JuMP.jl在完成第4步的基础上，提供了到第5步的接口。因此也可以认为，JuMP.jl包揽了第4步和第5步的工作。那么整个问题需要留给用户解决的，还有前3步。它们的关系由下图所示。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"(Image: 图 1)  ","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"事实上，第一步包含了从实际问题到数学表达的抽象过程，这一过程只有高级的人脑才能完成。那么，第2步和第3步能否实现自动化呢？这正是OptControl所希望完成的内容。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"OptControl的重点在于自动化，即如何自动构建最优问题，如何自动构建JuMP优化模型以及调用求解器自动求解。如何求解一个最优问题，如何构建符号化的系统等类型的问题，OptControl都不涉及。OptControl关心的是，整合已有的资源（Julia生态中的各种软件包），尽可能地自动化完成上述5个步骤。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"所以可以视OptControl是一个解释器，实现状态空间模型到最优控制问题的转化。它有三个特点：","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"接受Symbolics.jl或ModelingToolkit.jl构建的基于符号系统的状态空间模型\n自动生成以JuMP模型表达的最优化问题求解脚本，并自动运行\n提供保存脚本文件的接口，供用户自由修改","category":"page"},{"location":"Frameworks/OptControl/#OptControl框架","page":"OptControl.jl设计理念","title":"2 OptControl框架","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"OptControl的能力是逐步提高的。","category":"page"},{"location":"Frameworks/OptControl/#.1-构建优化模型","page":"OptControl.jl设计理念","title":"2.1 构建优化模型","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"首先完成的是第3步到第5步的解决方案。该解决方案的函数是","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"generateJuMPcodes——处理线性系统\ngenerateNLJuMPcodes——处理非线性系统","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"generateJuMPcodes与generateNLJuMPcodes接受以符号形式表达的状态方程。符号表达通过Symbolics.jl构建。Symbolics.jl是一个拥有高性能，并能够以用户语言进行拓展的符号代数系统。用符号表达的状态方程能够转变成Julia函数，通过该函数对问题进行离散化处理，将离散后的模型中的状态作为JuMP系统的优化变量，构建JuMP优化模型进行求解。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"(Image: 图 3)  ","category":"page"},{"location":"Frameworks/OptControl/#.2-获得状态方程模型","page":"OptControl.jl设计理念","title":"2.2 获得状态方程模型","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"更进一步，我们希望自动化实现第2步到第5步。第2步到第5步的解决方案需要使用ModelingToolkit.jl的非因果组件建模系统。该解决方案的函数是","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"generateMTKcodes——处理ODESystem系统","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"generateMTKcodes接受ODESystem系统。ODESystem中描述系统的微分方程事实上就是最优控制问题的状态方程。它们的区别是，ODESystem系统中的某些变量在最优控制问题中是状态量，而另一些是控制量。换而言之即，在最优控制中的状态方程与仿真系统中的微分方程本质上是相同的，不同的是最优控制问题赋予了某些变量特殊的含义。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"generateMTKcodes使用ModelingToolkit.jl中的generate_function函数生成Julia函数，并使用函数进行离散，将离散后的状态作为JuMP系统的优化变量，构建JuMP优化模型进行求解。2.1与2.2中解决方案的思路是相同的。它们都生成了Julia函数。2.1中的函数来自Symbolics.jl符号矩阵，2.2中的函数来自ModelingToolkit.jl中的ODESystem。OptControl利用生成的Julia函数进行状态空间的离散，并构建JuMP优化模型。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"(Image: 图 4)  ","category":"page"},{"location":"Frameworks/OptControl/#OptControl中的数学推演","page":"OptControl.jl设计理念","title":"3 OptControl中的数学推演","text":"","category":"section"},{"location":"Frameworks/OptControl/#.1-仿真或者控制？","page":"OptControl.jl设计理念","title":"3.1 仿真或者控制？","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"最优控制问题的中描述系统的方程为:","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"dotboldsymbolx(t)=boldsymbolAboldsymbolx(t)+boldsymbolBboldsymbolu(t)=fboldsymbolx(t)boldsymbolu(t)ttag1","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"其中，boldsymbolx(t)是系统的状态向量，boldsymbolu(t)是系统的控制量向量。它们都是关于自变量t的函数，也就是说它们随时间的变化而变化。事实上，在控制问题中，系数矩阵boldsymbolAboldsymbolB也是可以随时间而变化的，则变为boldsymbolA(t)boldsymbolB(t)。这根据实际需要而定。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"省去关于时间的函数表达，上述方程可以简写成：","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"dotboldsymbolx=boldsymbolAboldsymbolx+boldsymbolBboldsymbolu=f(boldsymbolxboldsymbolut)tag2","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"如果从数学的角度思考，不考虑boldsymbolxboldsymbolu的物理含义，这是一个关于时间的常微分方程问题。如果boldsymbolu的值不人为地决定，而是在系统中自我演化。那么这个就是一个微分方程求解问题。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"dotboldsymbolx=f(boldsymbolxboldsymbolpt)tag3","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"求解该微分方程的在真实世界中对应系统的动态仿真。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"所以，控制问题和动态仿真问题的本质是相同的。系统的描述方程都为关于时间的微分方程（组）。不同之处在于，问题的中的某些变量是否可以人为介入改变。也可以说，动态仿真问题是我们希望看到系统是如何演化的，而控制问题是，我们希望系统按照我们的期望去演化。正因为我们有期望，所以我们需要介入，对系统进行人为干预。而在方程中的体现是boldsymbolu，boldsymbolu是对系统干预的数学表达。所以，如果我们构造了boldsymbolu而不改变它，即它没有起到干预的作用，那这样的问题仍然是一个动态仿真问题。因为人的影响并没有通过boldsymbolu传递到系统。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"这正是为何OptControl能够用ModelingToolkit.jl构建系统的原因。ModelingToolkit.jl原本是用来构建动态仿真问题的工具，ODESystem描述的是动态系统的仿真模型，它并不存在可以人为干预系统的接口——控制变量boldsymbolu。我们可以构建ODESystem，观察系统是怎样变化的，而不能从头至尾地控制它的演化方向（事实上，偶尔的干预是可以通过Callback功能实现的，但它远没有达到“控制”的内涵）。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"但我们只要稍加改变，就能够将仿真问题转变为控制问题。只需要给ODESystem中的某些变量加上控制属性，工作就完成了。这正是OptControl使用的方法——把ODESystem中的参数boldsymbolp变为了控制量boldsymbolu。就得到到了控制问题中状态空间方程的最原始形式。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"dotboldsymbolx=f(boldsymbolxboldsymbolpt)Rightarrow dotboldsymbolx=f(boldsymbolxboldsymbolut)tag4","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"为了实现这一点，在构建ODESystem时需要做一点设计——需要把我们系统中某需要转变为控制量的变量设置成参数boldsymbolp。","category":"page"},{"location":"Frameworks/OptControl/#.2-最优控制怎样最优","page":"OptControl.jl设计理念","title":"3.2 最优控制怎样最优","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"上一节中我们探讨了boldsymbolu的内涵。那么还剩下一个问题是，如何用于数学语言描述最优。整个最优问题可以分为两个部分，控制过程中的最优以及控制终态的最优。方程5表示对最优的一个目标。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"min Phi(boldsymbolx(t_f)t_f)+int_t_0^t_f Lboldsymbolx(t)boldsymbolu(t)tdt  tag5","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"其中，Phi(boldsymbolx(t_f)t_f)表示对终端状态的一个期望，积分int_t_0^t_f Lboldsymbolx(t)boldsymbolu(t)tdt表示控制过程中的期望状态达到的最小指标。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"方程2和方程5合起来，就成为了最优控制问题控制方程的一般形式。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"beginmatrix\nminPhi(boldsymbolx(t_f)t_f)+int_t_0^t_f Lboldsymbolx(t)boldsymbolu(t)tdtst hspace10cm dotboldsymbolx =\nfboldsymbolx(t)boldsymbolu(t)t \nendmatrix tag6","category":"page"},{"location":"Frameworks/OptControl/#.3-数值优化模型","page":"OptControl.jl设计理念","title":"3.3 数值优化模型","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"方程6是连续形式，如果采用数值优化方法则需要将其离散化。离散方法采用欧拉法，则有:","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"beginmatrix\nminPhi(boldsymbolx(t_f)t_f)+sum_i=1^n L(boldsymbolx_iboldsymbolu_it_i) st hspace04cm boldsymbolx_i+1 =boldsymbolx_i+f(boldsymbolx_iboldsymbolu_it_i)*dt\nendmatrix tag6","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"如果采用后退欧拉法则有：","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"beginmatrix\nminPhi(boldsymbolx(t_f)t_f)+sum_i=1^n L(boldsymbolx_iboldsymbolu_it_i) st hspace04cm boldsymbolx_i+1 =boldsymbolx_i+f(boldsymbolx_i+1boldsymbolu_i+1t_i+1)*dt\nendmatrix tag7","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"此外，还有很多的离散方法，如梯形法，亚当斯方法等等。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"一旦获得了方程6和方程7的结果，下一步可以用JuMP.jl来构建相应的JuMP模型，以便调用相关的求解器求解。这由OptControl自动化地完成。","category":"page"},{"location":"Frameworks/OptControl/#求解实例","page":"OptControl.jl设计理念","title":"4 求解实例","text":"","category":"section"},{"location":"Frameworks/OptControl/#.1-Case1:-线性系统最优控制问题","page":"OptControl.jl设计理念","title":"4.1 Case1: 线性系统最优控制问题","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"求解以下线性最优控制问题：","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"min int_0^2 u^2dt newline st  dotboldsymbolx =beginbmatrix01 newline 00endbmatrixboldsymbolx+ beginbmatrix0 newline 1 endbmatrixu newline boldsymbolx(0) = beginbmatrix 1 newline 1 endbmatrix boldsymbolx(2)=beginbmatrix 0 newline 0 endbmatrix","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"使用OptControl求解该问题的步骤是：","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"使用ModelingToolkit.jl或者Symbolics.jl描述系统方程\n确定初态和终态等参数\n调用generateJuMPcodes求解","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"using OptControl, Statistics, ModelingToolkit\n@variables t u x[1:2]\nf = [0 1; 0 0] * x + [0, 1] * u\nL = 0.5 * u^2\nt0 = [1.0, 1.0]\ntf = [0.0, 0.0]\ntspan = (0.0, 2.0)\nN = 100\nsol = generateJuMPcodes(L, f, x, u, tspan, t0, tf; N=N)","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"该最优问题中，x_1的解析解是","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"x_1(t) = 05*t^3-175*t^2+t+1","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"比较解析解和优化数值解，可以得到它们的均方差是2.696E-6。在这个误差下的结果即使不能使用，它也是极具参考意义的，能给与人们启示。","category":"page"},{"location":"Frameworks/OptControl/#.2-Case2:-非线性系统最优控制问题","page":"OptControl.jl设计理念","title":"4.2 Case2: 非线性系统最优控制问题","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"求解以下非线性最优控制问题：","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"min int_0^2 u^2dt newline st  dotboldsymbolx =beginbmatrixexpcos newline sin1endbmatrixboldsymbolx+ beginbmatrix0 newline 1 endbmatrixu newline boldsymbolx(0) = beginbmatrix 1 newline 1 endbmatrix boldsymbolx(1)=beginbmatrix 0 newline 0 endbmatrix","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"使用ModelingToolkit.jl或者Symbolics.jl定义符号变量，给定初态和终态。调用generateNLJuMPcodes则可以得到结果。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"using OptControl, ModelingToolkit, Test\n@variables t u x[1:2]\nf = [exp(x[1]) + cos(x[2]), sin(x[1]) + x[2]] + [1, 0] * u\nL = u^2\nt0 = [1.0, 1.0]\ntf = [0.0, 0.0]\ntspan = (0.0, 2.0)\nN = 100\nsol = generateNLJuMPcodes(L, f, x, u, tspan, t0, tf; N=N)","category":"page"},{"location":"Frameworks/OptControl/#.3-Case3:-RC电路系统最优控制","page":"OptControl.jl设计理念","title":"4.3 Case3: RC电路系统最优控制","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"这是一个简单的电路系统。电源电压1V，电阻1欧姆，电容1法拉。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"(Image: 图 2)  ","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"我们构造的最优控制问题是，电压如何变化才能使得电容电压在1s内从1V变化到3V的同时，满足整个过程中电压尽可能低的目标。这在物理上是有意义的，但是可能没有应用价值。但它能充分说明问题所在。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"using OptControl, ModelingToolkit, Test\n\n# Components ......\n\n# Define and Simplify System\nR = 1.0\nC = 1.0\nV = 1.0\n@named resistor = Resistor(R=R)\n@named capacitor = Capacitor(C=C)\n@named source = ConstantVoltage(V=V)\n@named ground = Ground()\nrc_eqs = [\n    connect(source.p, resistor.p)\n    connect(resistor.n, capacitor.p)\n    connect(capacitor.n, source.n)\n    connect(capacitor.n, ground.g)\n]\n@named _rc_model = ODESystem(rc_eqs, t)\n@named rc_model = compose(_rc_model,\n    [resistor, capacitor, source, ground])\nsys = structural_simplify(rc_model)\n\n# Build Optimal Control Problem and Solve\nL = 0.5 * (source.V^2)\nt0 = [1.0]\ntf = [3.0]\ntspan = (0.0, 1.0)\nN = 100\nsol = OptControl.generateMTKcodes(L, sys, states(sys), [source.V], tspan, t0, tf;N=N)","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"上述代码的组件来自于ModelingToolkit.jl的文档。如果是一个仿真问题，当ODESystem被化简完成后应该需要调用DifferentialEquations.jl来求解。现在是一个最优控制问题，所以我们指定优化目标，以及定义相关参数，通过generateMTKcodes求解。","category":"page"},{"location":"Frameworks/OptControl/#结论","page":"OptControl.jl设计理念","title":"5 结论","text":"","category":"section"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"OptControl实现了从状态方程到最优控制问题的自动化构建以及从ModelingToolkit的常微分方程系统到系统最优控制问题的自动化构建。问题的核心在于选择设计控制变量boldsymbolu。在状态空间方程离散过程中，OptControl提供了选择离散方法的接口。在未来的工作中，会发展更多离散方法。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"OptControl另外一个重要特点是，它不直接解决问题，而是生成解决方案脚本并解释运行。这意味OptControl像一个指挥者，它把问题分解，再调用Julia生态中的包解决问题。OptControl提供了获得脚本的接口，这意味当OptControl的功能不能满足你的需求时，你可以直接修改脚本。在它基础之上添加任何你需要的功能。如果你不熟悉JuMP的建模语言，那么你正好可以通过生成的脚本学习一些JuMP的高级用法。如果你还想选择一些不同的求解器，那就修改脚本吧。","category":"page"},{"location":"Frameworks/OptControl/","page":"OptControl.jl设计理念","title":"OptControl.jl设计理念","text":"在未来，OptControl也许会提供更多的接口。但它不会改变指挥者的角色。也就是说，OptControl会一直致力于自动化生成最优控制问题的解决方法，而不是像ModelingToolkit.jl和JuMP.jl发展一种建模语言，也不会像JuMP.jl调用的求解器一样发展求解算法。OptControl的初衷是打通壁垒，整合工具，方便快捷的解决最优控制的问题。","category":"page"},{"location":"Simulation/MTK_heattran/#MTK手动空间离散求解PDE","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"tip: Tip\nContents：MTK、PDE、手动空间离散Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"note: Note\nMTK = ModelingToolkit.jlPDE = Partial Differential EquationModelingToolkit.jl 符号建模包","category":"page"},{"location":"Simulation/MTK_heattran/#MTK的PDE求解技巧","page":"MTK手动空间离散求解PDE","title":"MTK的PDE求解技巧","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"在之前介绍的例子中，所有的微分都是基于时间的微分。从数学的角度来说，微分变量只有一个。而对于有多个微分变量的PDE问题，能否通过MTK手动求解呢？例如，对时间对空间微分的PDE问题。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"答案是肯定的。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"求解PDE的数值方法有这么几步：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"建立数学描述方程\n对变量进行离散\n迭代求解","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"MTK用法中，提供了基于时间的一条龙求解。至于多变量的PDE，也有对应的PDESystem。但是目前来说，PDESystem还不是很完善。其离散方法涉及NeuralPDE.jl的相关内容。就MTK.jl本身来说，没有打通PDE的建模与求解过程。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"所以，使用MTK求解PDE的缺口在于，没有针对其它变量的离散——空间离散。那么，如果我们能够手动完成空间离散，这个问题就解决了。事实上，手动空间离散是可行的。","category":"page"},{"location":"Simulation/MTK_heattran/#数值传热学实例","page":"MTK手动空间离散求解PDE","title":"数值传热学实例","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"考虑一个正方形铸件的散热过程，正方形铸件初始温度1000℃，环境温度为0℃。如图","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"(Image: 图 1)  ","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"传热的控制方程为：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"rho c_p fracpartial Tpartial t=lambda(fracpartial^2 Tpartial x^2 +fracpartial^2 Tpartial y^2)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"将参数统一在等式右端，即","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"fracpartial Tpartial t=a(fracpartial^2 Tpartial x^2+fracpartial^2 Tpartial y^2)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"其中，","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"rho密度单位为frackgm^3","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"c_p物体热容单位为fracJkgcdot k","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"lambda导热系数单位为fracWmcdot k","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"a热扩散系数单位为fracm^2s","category":"page"},{"location":"Simulation/MTK_heattran/#内部节点空间离散","page":"MTK手动空间离散求解PDE","title":"内部节点空间离散","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"对方程进行空间离散，采用二阶中心差分，有：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"fracpartial T_ijpartial t=a (fracT_i+1 j^n- 2 T_i j^n+T_i-1 j^nDelta x^2+fracT_i j+1^n- 2 T_i j^n+T_i j-1^nDelta y^2)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"若使用化简表达，","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"Delta x = Delta y = deltaT_i j=T_PT_i+1 j=T_WT_i-1 j=T_ET_i j-1=T_NT_i j+1=T_S","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"则有内部节点的空间离散：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"fracpartial Tpartial t=fracadelta^2(T_W^n+T_E^n+T_N^n+T_S^n - 4T_P^n)","category":"page"},{"location":"Simulation/MTK_heattran/#边边界空间离散","page":"MTK手动空间离散求解PDE","title":"边边界空间离散","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"下面考虑边界条件。以W边为例。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"(Image: 图 2)  ","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"边界条件使用第三类边界条件。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"delta h(T_f-T_W^n)=delta lambda fracT_W^n-T_P^nfracdelta2","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"为了消去T_W^n，考虑该式子的等比式：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"frac(T_f-T_W^n)frac1h=fracT_W^n-T_P^nfracdelta2 lambda=frac(T_f-T_P^n)frac1h+fracdelta2 lambda taga","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"note: Note\n当对流散热系数h足够大时，frac2lambdadelta happrox0，即T_W approx T_f。第三类边界条件可以近似为第一类边界条件——壁温恒定为环境温度，如下式推导：T_W=frach T_f+frac2 lambdadelta T_P^nh+frac2 lambdadelta=fracT_f+frac2 lambdadelta h T_P^n1+frac2 lambdadelta h approx T_f这是从数学上的一种理解，后面并没使用到该近似。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"对边界采用附加源法进行分析。T_W为边界点温度，T_P节点的能量守恒方程为：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"beginarraycdelta lambda fracT_E^n-T_P^ndelta+delta lambda fracT_N^n-T_P^ndelta+delta lambda fracT_S^n-T_P^ndelta+delta lambda fracT_W^n-T_P^nfracdelta2=rho c delta^2 fracpartial T_Ppartial tendarray","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"将式(a)的第三项代入上式中的T_W-T_P项并化简，最终能得到边边界的边界方程：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"beginarraycfracpartial T_Ppartial t=fraca delta^2(T_E^n+T_N^n + T_S^n)-(fracafraclambda deltah+fracdelta^22+frac3 a delta^2) T_P^n+fraca fraclambda deltah+fracdelta^22 T_fendarray","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"同理可得其它3个边的边边界方程。","category":"page"},{"location":"Simulation/MTK_heattran/#角边界空间离散","page":"MTK手动空间离散求解PDE","title":"角边界空间离散","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"最后考虑角边界。以铸件左上角为例进行分析，下如图所示的角边界。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"(Image: 图 3)  ","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"分析方法同边边界的分析方法，最后可得：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"fracpartial T_Ppartial t=fracadelta^2(T_E^n+T_N^n+T_S^n)-(fracafraclambda deltah+fracdelta^22+frac2adelta^2) T_P^n+frac2afraclambda deltah+fracdelta^22 T_f","category":"page"},{"location":"Simulation/MTK_heattran/#离散方程汇总","page":"MTK手动空间离散求解PDE","title":"离散方程汇总","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"经过以上推导，得到了内节点表达式、边边界表达式和角边界表达式。为了方便程序表达，对方程的系数进行化简，令，","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"A = fracadelta^2B = fracafraclambdadeltah+fracdelta^22","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"note: Note\n当h很大时，fraclambda deltahapprox 0，所以B approx 2A。和前面边界条件的理解相似。同样的，这只是一种理解方式，并没有使用。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"内节点：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"fracpartial T_Ppartial t=A(T_W^n+T_E^n+ T_N^n+T_S^n - 4T_P^n)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"边边界节点：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"fracpartial T_Ppartial t=A(T_W^n+T_N^n+T_S^n)-(B+3A)T_P^n+BT_f","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"角边界节点：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"fracpartial T_Ppartial t=A(T_E^n + T_N^n )-(2B+2A)T_P^n+2BT_f","category":"page"},{"location":"Simulation/MTK_heattran/#求解实例","page":"MTK手动空间离散求解PDE","title":"求解实例","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"求解的全部代码如下：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"using ModelingToolkit, DifferentialEquations\n\n# 参数设定\na = 1.27E-5\nn = 10\nL = 0.2\nδ = L / n\nλ = 50\nh = 1.0E9\nTf = 0.0\nA = a / δ^2\nB = a / (δ^2 / 2 + δ * λ / h)\n\n@variables t (T(t))[1:n, 1:n]\n\nD = Differential(t)\n\n# 内节点代码\ninsides = [\n    D(T[i, j]) ~ A * (T[i+1, j] + T[i-1, j] + T[i, j+1] + T[i, j-1] - 4 * T[i, j])\n    for i in 2:n-1 for j in 2:n-1]\n\n# 边边界代码\nWb = [\n    D(T[i, 1]) ~ A * (T[i+1, 1] + T[i-1, 1] + T[i, 2]) - (3B + A) * T[i, 1] + B * Tf\n    for i in 2:n-1\n]\nEb = [\n    D(T[i, n]) ~ A * (T[i+1, n] + T[i-1, n] + T[i, n-1]) - (3B + A) * T[i, n] + B * Tf\n    for i in 2:n-1\n]\nNb = [\n    D(T[1, i]) ~ A * (T[1, i+1] + T[1, i-1] + T[2, i]) - (3B + A) * T[1, i] + B * Tf\n    for i in 2:n-1\n]\nSb = [\n    D(T[n, i]) ~ A * (T[n, i+1] + T[n, i-1] + T[n-1, i]) - (3B + A) * T[1, i] + B * Tf\n    for i in 2:n-1\n]\n\n# 4 corner boundary\ncorner = [\n    D(T[1, 1]) ~ A * (T[2, 1] + T[1, 2]) - (2B + 2A) * T[1, 1] + 2B * Tf,\n    D(T[n, n]) ~ A * (T[n-1, n] + T[n, n-1]) - (2B + 2A) * T[n, n] + 2B * Tf,\n    D(T[n, 1]) ~ A * (T[n, 2] + T[n-1, 1]) - (2B + 2A) * T[n, 1] + 2B * Tf,\n    D(T[1, n]) ~ A * (T[2, n] + T[1, n-1]) - (2B + 2A) * T[1, n] + 2B * Tf\n]\n\neqs = append!(insides, Wb, Eb, Nb, Sb, corner)\n\n@named sys = ODESystem(eqs, t)\n\nsys = structural_simplify(sys)\n\n# u0 = [1000.0 for i in 1:n for j in 1:n]\nu0 = Dict(T[i, j] => 1000.0 for i in 1:n for j in 1:n)\nprob = ODEProblem(sys, u0, (0, 100), [], saveat=0.1)\nsol = solve(prob, Tsit5())\n","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"值得一提的是：","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"MTK变量定义:","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"这是有效的变量数组（矩阵）的定义方式，也就是说MTK支持变量数运算。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"@variables t (T(t))[1:n, 1:n]","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"ODESystem定义","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"ODESystem定义时，既没有传递变量，也没有传递参数，甚至连t也可以不用传递，这都是可行的。ODESystem定义时能够自动检查（check）方程结构，从方程中获得变量信息。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"@named sys = ODESystem(eqs, t)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"tip: Tip\nODESystem定义时，若传递变量数组或者参数数组，check时不能通过。目前来说这是一个bug，所以可以不写。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"MTK初值设定","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"初值或者参数传递时，以下两种方式都可以。但也有区别。在符号计算中，符号在数组中的位置是不确定的。假如以数组的形式传递进去，那么就不知道哪个初值传递给了哪个变量（如果初值或参数都相同那就无所谓）。所以，初值传递需要精确到变量时，最好使用Dict。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"\nu0 = [1000.0 for i in 1:n for j in 1:n]\n\nu0 = Dict(T[i, j] => 1000.0 for i in 1:n for j in 1:n)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"saveat","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"saveat是solution handle中的内容。其作用是使sol中结果存储结果的时间步长为给定步长。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"当然，也可以使用sol()获得任意时刻的值。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"sol(2.5)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"但是这样会丢失变量的顺序，就是无法得知变量与数值的对应关系了。能否解决这个问题，这里还有许多可测试与探索的空间。","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"","category":"page"},{"location":"Simulation/MTK_heattran/#可视化","page":"MTK手动空间离散求解PDE","title":"可视化","text":"","category":"section"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"tip: Tip\nJulia生态中，可视化也是很强的！Plots.ji远比想象的强大！","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"最后，动画走你！","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"an_len= length(sol[T[1,1]])\nusing Plots, GR\nres = rand(n,n,an_len)\nfor t in 1:an_len\n    for i in 1:n\n        for j in 1:n\n            res[i,j,t] = sol[T[i,j]][t]\n        end\n    end\nend\nxs = LinRange(0.0, L, n)\nys = LinRange(0.0, L, n)\ncontourf!(xs, ys, res[:,:,10])\nanim = @animate for i ∈ 1:50\n    contourf!(xs, ys, res[:,:,i])\nend\ngif(anim, \"anim.gif\", fps = 24)","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"(Image: )","category":"page"},{"location":"Simulation/MTK_heattran/","page":"MTK手动空间离散求解PDE","title":"MTK手动空间离散求解PDE","text":"物体温度是下降的，在不断散热。","category":"page"},{"location":"Tools/CoolProp/#CoolProp使用介绍","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"","category":"section"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"tip: Tip\nContents：CoolPropContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"note: Note\nCoolProp为开源物性包。 Unitful.jl为计算单位的包","category":"page"},{"location":"Tools/CoolProp/#CoolProp是什么","page":"CoolProp使用介绍","title":"CoolProp是什么","text":"","category":"section"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"这是一个开源的调用物性包，通过几行代码就可以很容易的调用流体的物性，对于需要进行工程计算的小伙伴很有帮助！因为使用这个包之后，就可以可以省去大量查表的麻烦！","category":"page"},{"location":"Tools/CoolProp/#Python使用CoolProp","page":"CoolProp使用介绍","title":"Python使用CoolProp","text":"","category":"section"},{"location":"Tools/CoolProp/#.CoolProp安装","page":"CoolProp使用介绍","title":"1.CoolProp安装","text":"","category":"section"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"打开cmd命令行，输入","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"pip install CoolProp","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"即可安装完成 (Image: 图1)","category":"page"},{"location":"Tools/CoolProp/#.-使用示例","page":"CoolProp使用介绍","title":"2. 使用示例","text":"","category":"section"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"import CoolProp.CoolProp as CP\n\na = CP.PropsSI('H','P',1.0E6,'T',500,'Water')\n\n#H代表输出的需要查找的参数，H为焓\n#P为压强，T为温度，第二个和第四个参数就是状态\n#这个例子就是查询1MPa气压与500K的温度下，水蒸气的焓（如果是液体的话就是液体性质）\n\nprint(a)\n","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"查询时，输入任意两个参数，就能够查询第三个参数。 具体的属性为可以看下表","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"状态量 参数名称 单位\n比焓 H J/kg\n比熵 S J/mol/K\n压强 P Pa\n温度 T K\n密度 D kg/m^3","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"更多参数，可以查看官网文档。","category":"page"},{"location":"Tools/CoolProp/#Julia使用Coolprop","page":"CoolProp使用介绍","title":"Julia使用Coolprop","text":"","category":"section"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"在2022的2月，Coolprop完成了Julia包的更新。可以直接在Julia中调用，而不需要通过python了！","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"using Pkg\nPkg.add(\"CoolProp\")\n\nusing CoolProp\nPropsSI(\"T\", \"P\", 101325.0, \"Q\", 0.0, \"Water\")\n373.1242958476844","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"在Julia中支持单位处理包——Unitful","category":"page"},{"location":"Tools/CoolProp/","page":"CoolProp使用介绍","title":"CoolProp使用介绍","text":"using CoolProp\nusing Unitful: °C, Pa\n\nPropsSI(\"P\", \"T\", 100°C, \"Q\", 0.0, \"Water\")\n101417.99665788244 Pa","category":"page"},{"location":"Optimization/systemParaEste_batter/#MTK部分参数辨识实例","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"","category":"section"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"tip: Tip\nContents：MTK模型、优化、DiffEqParamEstimContributor: HYEmail:1171006975@qq.com如有错误，请批评指正。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"note: Note\nDEPE = DiffEqParamEstim.jl(Differential Equation Parameters Estimate)DiffEqParamEstim.jl是计算微分方程参数估计的软件包。","category":"page"},{"location":"Optimization/systemParaEste_batter/#原理","page":"MTK部分参数辨识实例","title":"原理","text":"","category":"section"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"在进行参数辨识的时候，我们往往会遇到一个问题——实验只能测一到两个关键数据，例如温度、电压电流等。但在咱们的ODEsystem中，状态量states往往不止一两个（甚至有几十个），而在DiffEqParamEstim.jl包中，构建损失函数时要求我们导入所有states的实验数据，显然咱们是办不到的。这个时候，咱们有两种解决方案：1.自己重构损失函数，这个方法显然是最高级的，是真正的治标又治本的方法，但是重构损失函数对初学者可能不够友好（比如说我）。因此，在这里给大家介绍第2种解决方案：引入加权值weight，无法通过实验测得的数据，我们可以将其的weight设为0，其他能测得的states设为1。这样，我们相当于重构了损失函数，程序只会根据我们“指定”的那些数据进行参数辨识，效果跟方案1是一样的。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"下面以三星18650锂电池为例，对锂电池的模型参数进行辨识。","category":"page"},{"location":"Optimization/systemParaEste_batter/#等效电路建模","page":"MTK部分参数辨识实例","title":"等效电路建模","text":"","category":"section"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"基于ModelingToolkit，建立Thevenin二阶RC等效电路模型，如下图所示。 该等效电路模型是由开路电压Uoc，欧姆内阻R0和两个RC网络结构组成，U1、U2分别为R1、R2的端电压，UT表示电池的端电压。 (Image: 图1)","category":"page"},{"location":"Optimization/systemParaEste_batter/#构建组件","page":"MTK部分参数辨识实例","title":"构建组件","text":"","category":"section"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"组件总共有两个，一个是锂电池组件，用来模拟锂电池的伏安特性，另一个是充放电控制器组件，用来模拟锂电池的恒流充放电。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"using DiffEqParamEstim, DifferentialEquations, Random, ModelingToolkit, PlotlyJS\nusing OptimizationOptimJL\nusing IfElse: ifelse\nimport RecursiveArrayTools.VectorOfArray\n@variables t\n∂ = Differential(t)\n@connector function Pin(; name)\n    sts = @variables v(t) = 1.0 i(t) = 1.0 [connect = Flow]\n    ODESystem(Equation[], t, sts, []; name=name)\nend\nfunction OnePort(; name)\n    @named p = Pin()\n    @named n = Pin()\n    sts = @variables v(t) = 1.0 i(t) = 1.0\n    eqs = [\n        v ~ p.v - n.v\n        0 ~ p.i + n.i\n        i ~ p.i\n    ]\n    compose(ODESystem(eqs, t, sts, []; name=name), p, n)\nend\nfunction OnePort_key(; name, v_start = 1.0, i_start = 0.0)\n    @named p = Pin()\n    @named n = Pin()\n    sts = @variables v(t) = v_start [irreducible=true] i(t) = i_start [irreducible=true]\n    eqs = [\n        v ~ p.v - n.v\n        0 ~ p.i + n.i\n        i ~ p.i\n    ]\n    compose(ODESystem(eqs, t, sts, []; name=name), p, n)\nend\nfunction Ground(; name)\n    @named g = Pin()\n    eqs = [g.v ~ 0]\n    compose(ODESystem(eqs, t, [], []; name=name), g)\nend\nfunction Lithium_ion_batteries(; name, OCV=3.9998, R0=0.029031, R1=0.00994, R2=0.01408, C1=147.462, C2=902.911)\n    @named oneport = OnePort()\n    @unpack v, i = oneport\n    sts = @variables v_c1(t) = 0.001 v_c2(t) = 0.001 v_b(t) = 1.0 i_b(t) = 0.0\n    ps = @parameters(\n        R0 = R0,\n        R1 = R1,\n        R2 = R2,\n        C1 = C1,\n        C2 = C2,\n        OCV = OCV,\n    )\n    eqs = [\n        OCV ~ i_b * R0 + v_c1 + v_c2 + v_b\n        i_b ~ C1 * ∂(v_c1) + v_c1 / R1\n        i_b ~ C2 * ∂(v_c2) + v_c2 / R2\n        v ~ v_b\n        i ~ -i_b\n    ]\n    return extend(ODESystem(eqs, t, sts, ps; name=name), oneport)\nend\nfunction charge_controller(; name)\n    @named oneport = OnePort_key()\n    @unpack v, i = oneport\n    equa = ifelse(t <= 10.0,16.0,ifelse(t <= 40.0,0.0,ifelse(t <= 50.0,-16.0,0.0)))\n    eqs = [i ~ equa]\n    return extend(ODESystem(eqs, t, [], []; name=name), oneport)\nend","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"不难发现，系统一共定义有6个参数，分别是欧姆内阻R0,两个RC支路所对应的R1,R2,C1,C2以及开路电压OCV。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"然后，通过连接函数，组建系统","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"@named ground = Ground()\n@named cg = charge_controller()\n@named batter = Lithium_ion_batteries()\neqs = [\n    connect(batter.p, cg.p)\n    connect(batter.n, cg.n, ground.g)\n]\n\n@named OdeFun = ODESystem(eqs, t)\n@named model = compose(OdeFun, [batter, cg, ground])\nsys = structural_simplify(model)\nu0 = [\n    batter.v_c1 => 0.024058864\n    batter.v_c2 => 0.002594792\n    cg.v => 3.928902637\n    cg.i => 0\n    batter.R0 => 0.037517357\n    batter.R1 => 0.020913201\n    batter.R2 => 0.006915906\n    batter.C1 => 4636.08469\n    batter.C2 => 1292.103841\n    batter.OCV => 3.955556293\n]\nprob = ODEProblem(sys, u0, (40.0, 60.0))","category":"page"},{"location":"Optimization/systemParaEste_batter/#导入实验数据","page":"MTK部分参数辨识实例","title":"导入实验数据","text":"","category":"section"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"导入实验数据，并对数据的格式进行一定的处理。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"time = [\n    40.98797751\n    42.00601125\n    42.99980609\n    43.99360093\n    45.01163467\n    46.00542951\n    46.99922436\n    47.9930192\n    50.99864262\n    53.0104712\n    55.99185573]\nreal_data = [\n    4.511920324\n    4.536819172\n    4.551011516\n    4.570183629\n    4.57665733\n    4.5881108\n    4.593588547\n    4.598817305\n    3.985060691\n    3.94746343\n    3.910364146]\n\nrandomized = VectorOfArray([[0, 0, real_data[i], 0] for i in 1:length(time)])\ndata = convert(Array, randomized)\n\nweight = VectorOfArray([[0.0, 0.0, 1.0, 0.0] for i in 1:length(time)])\ndata_weight = convert(Array, weight)","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"本实例的数据通过getdata软件从文献中扣取。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"系统变量有四个，分别为batter.v_c1,batter.v_c2,cg.v,cg.i。其中cg.v的数据通过实验获得，其权重值weight设为1，其他的变量权重值设为0。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"系统参数有六个，分别为batter.R0,batter.R1,batter.R2,batter.C1,batter.C2,batter.OCV。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"最终生成了data和data_weight矩阵，分别代表实验数据和相应权重值。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"(Image: 图2)","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"在不知道参数的顺序时，可以使用parameters和states函数查看系统参数。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"parameters(sys)\nstates(sys)","category":"page"},{"location":"Optimization/systemParaEste_batter/#构建损失函数并求解","page":"MTK部分参数辨识实例","title":"构建损失函数并求解","text":"","category":"section"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"obj = build_loss_objective(prob, Rosenbrock23(), L2Loss(time, data, data_weight=data_weight), maxiters=100000)\n\nresult = OptimizationOptimJL.optimize(obj,[0.037517357, 0.020913201, 0.006915906, 4636.08469, 1292.103841, 3.955556293])\nresult.minimizer","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"参数辨识结果为：","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"(Image: 图3)","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"至此，锂电池充电阶段的参数辨识完毕。同理可辨识放电阶段的参数。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"放电阶段实验数据：","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"time = [\n    1.502811712\t\n    3.005623424\n    4.508435137\t\n    6.011246849\t\n    7.489819663\t\n    11.9982548\t\n    13.50106651\t\n    15.00387822\t\n    16.50668994\t\n    18.00950165\t\n    19.48807446\t\n    20.99088617\t\n    22.49369789\t\n    23.9965096\t\n    25.49932131\t\n    27.00213302\t\n    28.50494474\n    30.00775645\t\n    31.51056816\t\n    32.98914097\n    34.49195269\n    35.9947644]\nreal_data = [\n    3.335698724\n    3.31503268\n    3.295860566\n    3.277933396\n    3.266977902\n    3.864799253\n    3.878244631\n    3.880734516\n    3.888702148\n    3.897167756\n    3.898910675\n    3.902645503\n    3.908372238\n    3.911858077\n    3.915094927\n    3.918082789\n    3.91957672\n    3.926797386\n    3.923311547\n    3.92107065\n    3.92107065\n    3.926299409]","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"放电阶段参数辨识结果为：","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"(Image: 图4)","category":"page"},{"location":"Optimization/systemParaEste_batter/#模型验证","page":"MTK部分参数辨识实例","title":"模型验证","text":"","category":"section"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"当放电阶段和充电阶段的模型参数全部辨识出来了以后，我们再将模型参数重新带回ODEsystem中，验证一下辨识结果是否有效。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"continuous_events = [\n    [t ~ 40.0] => [batter.R0 ~ 0.037203619\n        batter.R1 ~ 0.062205413\n        batter.R2 ~ 0.007078411\n        batter.C1 ~ 6373.89753\n        batter.C2 ~ 407.3465496\n        batter.OCV ~ 3.902760964]\n]\n\n@named OdeFun = ODESystem(eqs,t,continuous_events=continuous_events)\n@named model = compose(OdeFun, [batter, cg, ground])\nsys = structural_simplify(model)\nu0 = [\n    batter.v_c1 => 0.0\n    batter.v_c2 => 0.0\n    cg.v => 0.0\n    cg.i => 0.0\n    batter.R0 => 0.037517357\n    batter.R1 => 0.020913201\n    batter.R2 => 0.006915906\n    batter.C1 => 4636.08469\n    batter.C2 => 1292.103841\n    batter.OCV => 3.955556293\n]\nprob = ODEProblem(sys, u0, (0.0, 60.0))\nsol = solve(prob)","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"对比锂电池的实验数据和仿真数据，可以得到锂电池模型的端电压响应拟合曲线与实际端电压响应曲线的误差，如下图所示。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"(Image: 图5)","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"(Image: 图6)","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"可以看到，各点的拟合电压曲线误差范围均在约±0.006 V以内，即0.19%。电压最大误差为0.0059 V，平均误差为0.0021 V。电压误差大小远远较锂电池平台电压的变化范围小。因此从精度上看，模型误差尚在可接受的范围之内。","category":"page"},{"location":"Optimization/systemParaEste_batter/","page":"MTK部分参数辨识实例","title":"MTK部分参数辨识实例","text":"note: Note\n该参数辨识仍然是优化问题的子集，选择不同的初值很可能得到不同的结果。 完整代码可以在/src目录下查看","category":"page"},{"location":"Control/KalmanFiltering/#卡尔曼滤波理论与应用","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"","category":"section"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"tip: Tip\nContents：卡尔曼滤波(Kalman Filtering)Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"note: Note\n一篇卡尔曼滤波的英文博客，兼具理论与感性认识。上述博客的中文翻译版本","category":"page"},{"location":"Control/KalmanFiltering/#卡尔曼滤波介绍","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波介绍","text":"","category":"section"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"一句简单的话概括卡尔曼滤波：综合考虑模型计算值与实际测量值，估计动态系统中状态的真实值。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"对这句概括的话，提出2个问题：","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"为什么要综合考虑模型计算值和实际测量值？\n如何综合考虑？","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"对于问题1，有2个事实：","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"模型不是准确的。例如，欧姆定律中，电阻值真的是一个常数吗？基础模型尚且如此，更不用说复杂系统的模型了。所以，描述系统的模型，一定是有偏差的。\n测量值不代表真实值。通过各种仪表读数时，读出来的数不能代表真实值，读数时会有各种随机误差。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"所以，Kalman觉得可以结合模型计算值与观测值，对状态的真实值进行估计。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"对于问题2：","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"综合考虑的方式为：先通过状态空间方程的计算出结果，再对结合误差对结果进行修正。由此可见，卡尔曼滤波是控制学与统计学的交叉学科方法。","category":"page"},{"location":"Control/KalmanFiltering/#卡尔曼滤波的数学表达","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波的数学表达","text":"","category":"section"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"只给结论，不推导。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"leftbeginarrayl\nx_k=F_k-1 x_k-1+Gamma_k-1 w_k-1 \nz_k=H_k x_k+v_k\nendarrayright","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"其中：","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"下表k代表k时刻\n系统状态向量——x_k（行向量）\n系统状态转移矩阵——F_k，如果在时间域上不变则为——F\n模型噪声——w_k\n模型噪声矩阵（描述噪声对变量的影响）——Gamma_k（行向量）\n系统量的测向量——z_k\n量测矩阵——H_k（行向量）\n模型噪声——v_k","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"同时，噪声满足正态分布：","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"w_k sim N(0Q_k)  v_k sim N(0R_k)","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"下面为卡尔曼滤波的滤波过程:","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"Step1 模型计算:","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"x_k=F_k-1 x_k-1\nP_k=F_k-1 P_k-1 F_k-1^T+Gamma_k-1 Q_k-1 Gamma_k-1^T","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"Step2 滤波:","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"G_k=P_k  H_k^TleftH_k P_k H_k^T+R_kright^-1\nhatx_k=x_k+G_k(tildez_k - H_kx_k)\nhatP_k = (I-G_kH_k)P_k","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"其中：","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"系统的量测的协方差矩阵——P\n滤波后的系统状态向量——hatx_k\n滤波后的系统状态向量——hatx_k\n模型噪声的方差——Q_k，如果在时间域上不变则为——Q\n测量噪声的方差——R_k，如果在时间域上不变则为——R\n滤波后的系统的量测的协方差矩阵——hatP_k\n测量值向量——tildez_k\n模型噪声——v_k","category":"page"},{"location":"Control/KalmanFiltering/#卡尔曼滤波实例","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波实例","text":"","category":"section"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"考虑加热器：fracdTdt = -(T-20) + 10 即散热系数为1，加热功率为10，环境温度为20。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"使用DifferentialEquations.jl获得仿真数据并加上扰动。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"using DifferentialEquations\nusing Statistics, Plots\n\nf(u, t, p) = -(u - 20) + 10\n\nprob = ODEProblem(f, 20.0, (0, 5))\n\nsol = solve(prob, saveat=0.1)\nnoise = rand(-0.5:0.0001:0.5, length(sol.u))\ncov(noise)\n\nmeasureT = noise + sol.u\nt = collect(0:0.1:5)\nplot(t, measureT, label=\"measure\", legend_position=:topleft)\nplot!(t, sol.u, label=\"real\", legend_position=:topleft)","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"获得的measureT将作为未来每个时间点上的温度测量数据（实际为精确解加随机误差生成的数据）。真实值与测量值如下图。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"(Image: 图 1)  ","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"若取dt=01，使用欧拉法离散，则上述微分则转变为状态空间方程：T_k+1 = 09T_k+3","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"若采用上述状态空间方程，则可以称之为“完美模型”。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"为了验证卡尔曼滤波的有效性，我们设计一个十分错误的模型：T_k+1 = T_k","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"即，我们认为这是一个温度不变的系统（错得不能再错的模型）。同时，给一个比较大的Q_w，说明模型扰动的方差比较大。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"begin\n    F = 1\n    Γ = 0.1\n    H = 1\n    Qv = 0.8\n    Qw = 10\n\n    P = 10\n    x = 20.0\n\n    x_res = zeros(1, length(measureT))\n    p_res = zeros(1, length(measureT))\n\n    p_res[:, 1] = [P]\n    x_res[:, 1] = [x]\n\n    for i in 1:length(measureT)-1\n        _P = F * p_res[1, i] * F' .+ Γ' * Qw * Γ\n        _G = _P * H * inv(H * _P * H + Qv)\n        _x = F * x_res[1, i]\n        global x_res[1, i+1] = _x + _G * (measureT[i+1] - H' * _x)\n        global p_res[1, i+1] = (1 - _G' * H) * _P\n    end\n\n    plot!(t, x_res[1, :], label=\"Wrong Model\", legend_position=:topleft)\nend","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"(Image: 图 2) ","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"结果显示，居然和真实值差不多。如果令Q_w=1，给得比较小。则变成了：","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"(Image: 图 3)  ","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"没那么好，但也不差（比直线好太多了）。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"如果把模型设置成原本的模型则:","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"begin\n    F = 0.9\n    Γ = 0.1\n    H = 1\n    Qv = 0.8\n    Qw = 10\n\n    P = 10\n    x = 20.0\n\n    x_res = zeros(1, length(measureT))\n    p_res = zeros(1, length(measureT))\n\n    p_res[:, 1] = [P]\n    x_res[:, 1] = [x]\n\n    for i in 1:length(measureT)-1\n        _P = F * p_res[1, i] * F' .+ Γ' * Qw * Γ\n        _G = _P * H * inv(H * _P * H + Qv)\n        _x = F * x_res[1, i] + 3\n        global x_res[1, i+1] = _x + _G * (measureT[i+1] - H' * _x)\n        global p_res[1, i+1] = (1 - _G' * H) * _P\n    end\n\n    plot!(t, x_res[1, :], label=\"Right Model\", legend_position=:topleft)\nend","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"(Image: 图 4)  ","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"基本就一致了。","category":"page"},{"location":"Control/KalmanFiltering/#小结","page":"卡尔曼滤波理论与应用","title":"小结","text":"","category":"section"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"卡尔曼滤波的重要意义是利用了测量值带来的信息。模型不准确的时候，利用滤波带来的效果，可以对模型进行一个矫正。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"但它的缺点在于，对预测没有帮助。对未来的多点预测只能是通过模型。既然是预测，说明事情还没有发生，那测量值无法获得，也就无法通过测量值进行矫正。","category":"page"},{"location":"Control/KalmanFiltering/","page":"卡尔曼滤波理论与应用","title":"卡尔曼滤波理论与应用","text":"其特点是，对已经发生的事情做一个优化，而不能提升预测未来的能力。","category":"page"},{"location":"Optimization/参数辨识实例_MTK/#MTK非线性参数辨识实例","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"","category":"section"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"tip: Tip\nContents：参数辨识、优化、MTKContributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"note: Note\nMTK = ModelingToolkit.jlNLP = NonlinearnProblem，非线性问题OptimizationSystem为MTK中的系统类型之一","category":"page"},{"location":"Optimization/参数辨识实例_MTK/#参数辨识概念","page":"MTK非线性参数辨识实例","title":"参数辨识概念","text":"","category":"section"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"系统中的参数作为优化变量，找到一组参数，使得通过模型计算结果与实际值误差最小，实际值一般为一系列数值。参数辨识本质为回归问题。数学表达如下：","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"y = f(ab)\nmin (y_real - y)^2","category":"page"},{"location":"Optimization/参数辨识实例_MTK/#实例","page":"MTK非线性参数辨识实例","title":"实例","text":"","category":"section"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"考虑下面的模型：","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"y = ax^2+sin(bx)a=15b=08","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"采用生成数据的方法构造真实的数据y_real。 方法为通过模型计算出准确值并加上随机误差。","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"##### 生成真实数据 ####\nx = collect(-1:0.01:1)\nN = length(x)\n# 产生随机误差，范围在-0.1~0.1之间\nrands = rand(-0.1:0.01:0.1, N)\na1 = 1.5\na2 = 0.8\n# 计算y值\ny = @. a1 * x^2 + sin(a2 * x) + rands\n","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"因为测试数据集y_real本身即来自模型，同时添加的扰动范围不大，可以认为数据集的内涵就是模型y = ax^2+sin(bx) 接下来构建问题并且求解：","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"# 计算损失Loss\n@variables para[1:2]\nerrors = @. (para[1] * x^2 + sin(para[2] * x) - y)^2\n\n# 计算方差和，采用均方差亦可\nLoss = sum(errors)\n\n# 构建问题并求解\n@named sys = OptimizationSystem(Loss, [para[i] for i in 1:2], [])\na0 = [0.1,0.1]\nprob = OptimizationProblem(sys, a0, [], grad=true, hess=true, reltol=1e-8, abstol=1e-8)\ns = solve(prob, Optim.Newton())","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"最后的结果为:","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"u: 2-element Vector{Float64}:\n 1.502064883762093\n 0.7908724806965902","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"和我们的真实值a=15b=08比较接近。 优化成功！","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"tip: Tip\n影响优化效果的因素有初值\n生成扰动大小可以尝试修改它们并查看求解效果。","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"全部代码：","category":"page"},{"location":"Optimization/参数辨识实例_MTK/","page":"MTK非线性参数辨识实例","title":"MTK非线性参数辨识实例","text":"using ModelingToolkit, OptimizationOptimJL\n\nLoss = 0.0\n#number of samples\nypre = 0\n#y-predict\nx = collect(-1:0.01:1)\nN = length(x)\nrands = rand(-0.1:0.01:0.1, N)\na1 = 1.5\na2 = 0.8\ny = @. a1 * x^2 + sin(a2 * x) + rands\n\n\n@variables para[1:2]\nerrors = @. (para[1] * x^2 + sin(para[2] * x) - y)^2\nLoss = sum(errors)\n\n#Opt\n@named sys = OptimizationSystem(Loss, [para[i] for i in 1:2], [])\na0 = [0.1, 0.1]\nprob = OptimizationProblem(sys, a0, [], grad=true, hess=true, reltol=1e-8, abstol=1e-8)\ns = solve(prob, Optim.Newton())","category":"page"},{"location":"WorkFlow/julia的安装/#Julia安装","page":"Julia安装","title":"Julia安装","text":"","category":"section"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"tip: Tip\nContents：julia安装Contributor: 孙蓓蓓、张启Email:如有错误，请批评指正。","category":"page"},{"location":"WorkFlow/julia的安装/#下载网址","page":"Julia安装","title":"下载网址","text":"","category":"section"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"搜索清华大学开源软件镜像站。   (Image: )","category":"page"},{"location":"WorkFlow/julia的安装/#下载julia-xxx-win64.zip安装包","page":"Julia安装","title":"下载julia-xxx-win64.zip安装包","text":"","category":"section"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"note: Note\nv1.7.2(Feb 6,2022)为julia当前稳定版本。新安装时，下载最新版。","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"首先，在搜索框中搜索julia，点击julia-releases： (Image: ) 其次，点击bin/： (Image: ) 找到winnt/： (Image: ) 选择x64/： (Image: ) 然后，找到最新版本系列： (Image: ) 最后，下拉找到julia-xxx-win64.zip安装包，点击下载。 (Image: )","category":"page"},{"location":"WorkFlow/julia的安装/#解压安装","page":"Julia安装","title":"解压安装","text":"","category":"section"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"找到下载好的安装包，右键解压。解压后，生成一个julia-1.7.2文件夹。可执行文件julia.exe就在julia-1.7.2文件夹的bin文件夹下。 (Image: )","category":"page"},{"location":"WorkFlow/julia的安装/#将路径加到环境变量中","page":"Julia安装","title":"将路径加到环境变量中","text":"","category":"section"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"在任务栏搜索框中找到“编辑系统环境变量”： (Image: ) 打开环境变量；在用户变量中选择变量Path，点击编辑；新建，将julia.exe文件所在路径复制进去，然后点击确定。 (Image: )","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"tip: Tip\n也可使直接“(Image: ) + r”打开运行▱，输入 rundll32 sysdm.cpl,EditEnvironmentVariables 直接打开环境变量设置界面，注意，此时无法编辑系统环境变量（实际上也并不建议直接编辑系统环境变量），编辑用户环境变量即可。","category":"page"},{"location":"WorkFlow/julia的安装/#执行julia","page":"Julia安装","title":"执行julia","text":"","category":"section"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"在任务栏搜索框输入cmd，打开命令提示符，输入julia，进入Julie REPL，此时julia就可以执行了。 (Image: ) 直接输入exit()，即可退出。","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"另外，Windows下推荐使用Windows Terminal作为交互终端（直接的Cmd或Powershell终端中，均不支持类似","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"20px\" height=\"20px\" viewBox=\"220 280 180 120\" xml:space=\"preserve\">\n    <g>\n        <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" fill=\"currentColor\" d=\"M259.618,401.811l1.231,0.268l-4.314,13.678h-39.031v-1.371h1.903\n  c2.132,0,3.654-0.699,4.568-2.082c0.521-0.799,0.774-2.639,0.774-5.506v-32.534c0-3.147-0.343-5.114-1.041-5.9\n  c-0.964-1.091-2.398-1.637-4.301-1.637h-1.903v-1.383h22.827v1.383c-2.677-0.025-4.556,0.216-5.634,0.736\n  c-1.078,0.52-1.814,1.18-2.208,1.979c-0.394,0.787-0.596,2.69-0.596,5.685v31.671c0,2.057,0.203,3.465,0.596,4.238\n  c0.292,0.52,0.749,0.9,1.37,1.154c0.622,0.242,2.551,0.367,5.799,0.367h3.68c3.87,0,6.586-0.279,8.146-0.85\n  c1.561-0.57,2.982-1.586,4.276-3.031C257.042,407.229,258.336,404.932,259.618,401.811L259.618,401.811L259.618,401.811z\" />\n        <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" fill=\"currentColor\" d=\"M265.631,392.346h-15.192l-2.657,6.193c-0.662,1.521-0.988,2.658-0.988,3.418\n  c0,0.594,0.287,1.117,0.85,1.57c0.573,0.455,1.797,0.752,3.694,0.889v1.068H238.98v-1.068c1.64-0.295,2.697-0.672,3.181-1.135\n  c0.988-0.92,2.074-2.805,3.27-5.641l13.809-32.292h1.008l13.661,32.637c1.097,2.627,2.094,4.326,2.993,5.107\n  c0.899,0.779,2.153,1.225,3.753,1.322v1.068h-15.489v-1.068c1.561-0.078,2.618-0.346,3.171-0.789\n  c0.553-0.436,0.83-0.979,0.83-1.621c0-0.848-0.396-2.182-1.166-4.02L265.631,392.346L265.631,392.346L265.631,392.346z\n   M264.821,390.202l-6.658-15.854l-6.826,15.854H264.821L264.821,390.202L264.821,390.202z\" />\n        <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" fill=\"currentColor\" d=\"M313.479,365.008l0.563,11.921h-1.432c-0.27-2.098-0.64-3.594-1.126-4.502\n  c-0.768-1.445-1.804-2.507-3.083-3.197c-1.292-0.691-2.98-1.036-5.077-1.036h-7.163v38.833c0,3.121,0.345,5.064,1.011,5.844\n  c0.946,1.051,2.417,1.574,4.387,1.574h1.766v1.381h-21.552v-1.381h1.803c2.149,0,3.671-0.652,4.566-1.957\n  c0.55-0.793,0.832-2.621,0.832-5.461v-38.833h-6.114c-2.367,0-4.055,0.179-5.053,0.524c-1.305,0.473-2.417,1.394-3.338,2.737\n  c-0.92,1.356-1.471,3.172-1.65,5.475h-1.42l0.602-11.921H313.479L313.479,365.008L313.479,365.008z\" />\n        <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" fill=\"currentColor\" d=\"M319.647,381.675v19.259h10.708c2.785,0,4.637-0.418,5.569-1.252\n  c1.251-1.104,1.938-3.042,2.085-5.826h1.325v16.965h-1.325c-0.331-2.367-0.674-3.889-1.006-4.564\n  c-0.429-0.834-1.141-1.496-2.122-1.975c-0.981-0.477-2.49-0.723-4.526-0.723h-10.708v16.068c0,2.158,0.098,3.471,0.281,3.938\n  c0.197,0.467,0.528,0.834,1.006,1.117c0.479,0.27,1.398,0.404,2.736,0.404h8.267c2.748,0,4.76-0.184,5.999-0.576\n  c1.251-0.381,2.44-1.129,3.594-2.258c1.484-1.484,3.006-3.729,4.563-6.723h1.435l-4.194,12.219h-37.56v-1.326h1.73\n  c1.141,0,2.232-0.281,3.263-0.834c0.772-0.379,1.288-0.957,1.569-1.717c0.271-0.773,0.405-2.344,0.405-4.709v-31.661\n  c0-3.091-0.307-4.992-0.933-5.716c-0.858-0.957-2.294-1.435-4.305-1.435h-1.73v-1.337h37.56l0.539,10.672h-1.41\n  c-0.503-2.563-1.055-4.318-1.668-5.274c-0.613-0.957-1.509-1.693-2.711-2.196c-0.957-0.355-2.65-0.54-5.066-0.54H319.647\n  L319.647,381.675L319.647,381.675z\" />\n        <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" fill=\"currentColor\" d=\"M370.217,387.709l10.832,16.14c2.997,4.469,5.219,7.289,6.679,8.469\n  c1.448,1.182,3.29,1.83,5.524,1.957v1.371h-21.651v-1.371c1.435-0.025,2.502-0.18,3.2-0.457c0.521-0.217,0.939-0.561,1.282-1.016\n  c0.331-0.459,0.496-0.928,0.496-1.398c0-0.57-0.114-1.143-0.331-1.713c-0.178-0.42-0.862-1.512-2.044-3.277l-8.559-12.94\n  l-10.565,13.538c-1.117,1.447-1.791,2.4-2.006,2.883c-0.229,0.482-0.344,0.99-0.344,1.51c0,0.801,0.344,1.447,1.004,1.969\n  c0.672,0.521,1.955,0.826,3.835,0.902v1.371h-17.893v-1.371c1.27-0.127,2.349-0.395,3.276-0.789\n  c1.536-0.646,2.996-1.51,4.381-2.602c1.396-1.092,2.984-2.77,4.762-5.029l11.911-15.022l-9.93-14.552\n  c-2.705-3.937-5.004-6.527-6.883-7.747c-1.893-1.232-4.063-1.879-6.515-1.956v-1.384h23.327v1.384\n  c-1.98,0.076-3.34,0.394-4.076,0.965c-0.724,0.571-1.092,1.207-1.092,1.893c0,0.927,0.597,2.26,1.778,4.025l7.745,11.568\n  l8.966-11.353c1.041-1.333,1.676-2.248,1.917-2.743c0.229-0.508,0.355-1.016,0.355-1.537s-0.152-0.978-0.457-1.372\n  c-0.368-0.521-0.838-0.889-1.409-1.092c-0.571-0.216-1.752-0.331-3.53-0.356v-1.384h17.893v1.384\n  c-1.41,0.076-2.565,0.292-3.467,0.661c-1.333,0.571-2.565,1.346-3.683,2.311c-1.117,0.965-2.692,2.755-4.724,5.358L370.217,387.709\n  L370.217,387.709L370.217,387.709z\" />\n    </g>\n</svg>","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"的用法输入UTF-8字符）。","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"直接在Microsoft Store上下载Windows Terminal，打开软件后进入设置界面： (Image: 打开Windows Teminal设置)","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"可以直接在界面中运行julia命令，或者将Julia添加到终端中。","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"左侧导航栏划至最下，新建配置文件，这里这就复制Windows Powershell的（有兴趣可以复制Cmd的试试）。 (Image: Winwdos Termianl 新建设置文件)","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"在新建的配置文件里面编辑设计即可，详细如图： (Image: Julia终端设置)","category":"page"},{"location":"WorkFlow/julia的安装/","page":"Julia安装","title":"Julia安装","text":"注：终端界面的图标自己找一个，如果懒着找，就接着使用Powershell的也行。","category":"page"},{"location":"#Ai4EDocs","page":"Home","title":"Ai4EDocs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: 图 4)  ","category":"page"},{"location":"","page":"Home","title":"Home","text":"tip: Tip\n智慧能源系统导论 \nOptControl.jl 对MTK中ODESystem的最优控制支持包。\nAi4ELab 虚拟仿真实验室\nAi4EComponentLib.jl 组件库\nAi4EMetaPSE.jl 微分方程的Json文件解析器\nAi4Server 基于Genie.jl架构的Ai4E后端服务框架。","category":"page"},{"location":"#Ai4EDocs简介","page":"Home","title":"Ai4EDocs简介","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Ai4EDocs是Ai4E小组在学习中整理的一些可操作案例。案例的核心主要与建模仿真优化控制相关。文档主要特点为：","category":"page"},{"location":"","page":"Home","title":"Home","text":"既有数学层面的探究，也包含了应用层面的案例。\n包含大量Julia生态中软件包的使用\n兼顾建模仿真优化控制核心与拓展\n分享对理论抽象问题的认识\n分享软件使用过程中的技巧\n分享学习的心路历程与对库使用的理解\nAi4Energy组的合作开发流程","category":"page"},{"location":"","page":"Home","title":"Home","text":"供学习参考。","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable)","category":"page"},{"location":"","page":"Home","title":"Home","text":"欢迎贡献文档！","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable)","category":"page"},{"location":"#Julia资源传送门","page":"Home","title":"Julia资源传送门","text":"","category":"section"},{"location":"#基础文档","page":"Home","title":"基础文档","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia中文文档\nJulia官方文档\nSciml总站","category":"page"},{"location":"#数值计算","page":"Home","title":"数值计算","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DifferentialEquations.jl（常微分方程求解包）\nNeuralPDE.jl（偏微分方程求解包）\nJuMP.jl（优化求解器包）\nDiffEqParamEstim.jl（基于DE的参数辨识包）\nFlux.jl Julia机器学习包(The Julia Machine Learning Library)\nEquationsSolver 自制的小型方程（组）求解器\nOptimization.jl(Sciml优化包)","category":"page"},{"location":"#符号计算","page":"Home","title":"符号计算","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ModelingToolkit.jl（符号建模包）\nSymbolics.jl（MTK依赖的符号求解包）\nSymPy.jl 符号计算包（可求方程解析解），与Matlab中的符号工具包类似","category":"page"},{"location":"#计算图形学","page":"Home","title":"计算图形学","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Meshes.jl 纯Julia的CGAL（计算图形学算法库）实现\nGmsh.jl gmsh的Julia接口","category":"page"},{"location":"#数据处理","page":"Home","title":"数据处理","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"FileIO.jl Julia中不同类型文件读入的统一接口（包括MeshIO）\nCSV.jl\nDataFrames.jl（大规模数据批量处理包）\nUnitful（单位计算包）\nJSON3.jl JSON到类型的读入\nJSON.jl","category":"page"},{"location":"#可视化","page":"Home","title":"可视化","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Plots.ji（可视化包）\nPkg.jl 包管理\nMakie.jl 高性能绘图包。\nPlotlyJS.jl 网页绘图，图可拖动。","category":"page"},{"location":"#WEB框架","page":"Home","title":"WEB框架","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Geine.jl and Stipple.jl Julia Web 框架Geine和Stipple的文档\nHTTP.jl","category":"page"},{"location":"#其它资源传送门","page":"Home","title":"其它资源传送门","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CoolProp\nAPMonitor-github\nAPMonitor\nGreet\nMqtt系列教程\nMixed Integer Distributed Ant Colony Optimization(midaco-solver)\nPython的GUI开发工具PYQT\nMathematica","category":"page"},{"location":"#文档内容","page":"Home","title":"文档内容","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"dirs = [\"Frameworks\",\"Modeling\",\"Simulation\",\"Optimization\",\"Control\",\"CS Base\",\"Tools\",\"WorkFlow\"]\n\n\"总篇数：$(sum(map(file -> length(readdir(joinpath(@__DIR__,\"..\",\"src\",file))), dirs)))\"","category":"page"},{"location":"#建模","page":"Home","title":"建模","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"Modeling\", file), readdir(\"Modeling\"))","category":"page"},{"location":"#仿真","page":"Home","title":"仿真","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"Simulation\", file), readdir(\"Simulation\"))","category":"page"},{"location":"#优化","page":"Home","title":"优化","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"Optimization\", file), readdir(\"Optimization\"))","category":"page"},{"location":"#控制","page":"Home","title":"控制","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"Control\", file), readdir(\"Control\"))","category":"page"},{"location":"#框架","page":"Home","title":"框架","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"Frameworks\", file), readdir(\"Frameworks\"))","category":"page"},{"location":"#基础知识","page":"Home","title":"基础知识","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"CS Base\", file), readdir(\"CS Base\"))","category":"page"},{"location":"#工具集","page":"Home","title":"工具集","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"Tools\", file), readdir(\"Tools\"))","category":"page"},{"location":"#工作流程","page":"Home","title":"工作流程","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"WorkFlow\", file), readdir(\"WorkFlow\"))","category":"page"},{"location":"CS Base/SSH_Git/#SSH、Git与Git图形化软件","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"","category":"section"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"tip: Tip\nContents：SSH、Git与Git的图形化软件Contributor: YJYEmail:522432938@qq.com如有错误，请批评指正。","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"本文介绍ssh、git与git的图形化软件。他们之间的关系为：","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git基于ssh通讯操作\ngit图形化软件是操作git的图形化软件","category":"page"},{"location":"CS Base/SSH_Git/#SSH使用","page":"SSH、Git与Git图形化软件","title":"SSH使用","text":"","category":"section"},{"location":"CS Base/SSH_Git/#SSH是什么","page":"SSH、Git与Git图形化软件","title":"SSH是什么","text":"","category":"section"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"SSH是一种网络协议，用于计算机之间的加密登录。一个用户从本地计算机，使用SSH协议登录另一台远程计算机，就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。","category":"page"},{"location":"CS Base/SSH_Git/#SSH密钥登录原理","page":"SSH、Git与Git图形化软件","title":"SSH密钥登录原理","text":"","category":"section"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"客户端发出认证请求；\n服务器端使用客户端发送的公钥对一个随机的256位的字符串进行加密，并发送给 客户端；\n客户端使用私钥对字符串进行解密，并生成一个MD5值发送给服务器端；\n服务器端根据原始随机字符串生成MD5值进行匹配, 确认客户端身份；\n至此, 双方互相确认对方身份并建立加密信道, 可以正式进行安全通信。","category":"page"},{"location":"CS Base/SSH_Git/#SSH的两种认证方式","page":"SSH、Git与Git图形化软件","title":"SSH的两种认证方式","text":"","category":"section"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"1.基于口令的安全认证 ：提供正确的用户口令后可以登录远程服务器。","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"操作方式：","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"(默认端口为22)","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"ssh user@host\n\nexample：\nssh root@127.0.0.1\nssh yjy@152.20.45.154","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"然后输入登录密码进行登录 使用p参数，可以修改端口","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"ssh -p 端口号 user@host\n\nexample：\nssh -p 8080 yjy@152.20.45.154 ","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"上面这个例子是以8080端口登录","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"2.基于密钥的安全认证 ：使用公钥和私钥对的方式对用户进行认证。","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"密钥登录首先需要产生公钥和私钥。","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"公钥放在服务端，私钥放在需要远程登录服务端的客户端","category":"page"},{"location":"CS Base/SSH_Git/#产生公钥和私钥","page":"SSH、Git与Git图形化软件","title":"产生公钥和私钥","text":"","category":"section"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"ssh-keygen -t rsa","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"在~/.ssh文件夹（~为用户目录，windows和linux目录下都会有）下会出现idrsa与idrsa.pub两个文件。","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"idrsa是私钥，idrsa.pub是公钥。","category":"page"},{"location":"CS Base/SSH_Git/#修改配置文件","page":"SSH、Git与Git图形化软件","title":"修改配置文件","text":"","category":"section"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"之后，在远程主机的ssh配置文件(/etc/ssh/sshd_config)中做如下修改，开启权限。这几项有些是新加上的，有些原来是no：","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"RSAAuthentication yes\nPubkeyAuthentication yes\nAuthorizedKeysFile .ssh/authorized_keys","category":"page"},{"location":"CS Base/SSH_Git/#在服务端存放公钥","page":"SSH、Git与Git图形化软件","title":"在服务端存放公钥","text":"","category":"section"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"方法一：","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"将公钥中的一大串字符添加到服务端~/.ssh/authorized_keys文件中去，如果已经存在，那么在后面再添上一条。不建议覆盖，因为这样其它客户端远程登录的公钥就会被覆盖！","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"方法二：","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"也可以用一段代码自动加过去","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"ssh root@111.20.45.124 \"mkdir -p .ssh && cat >> .ssh/authorized_keys\" < ~/.ssh/id_rsa.pub","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"这条命令由多个语句组成，依次分解开来看：","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"（1）\"$ ssh user@host\"，表示登录远程主机；\n（2）双引号中的mkdir .ssh && cat >> .ssh/authorized_keys，表示登录后在远程shell上执行的命令：\n（3）\"$ mkdir -p .ssh\"的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；\n（4）'cat >> .ssh/authorizedkeys' < ~/.ssh/idrsa.pub的作用是，将本地的公钥文件~/.ssh/idrsa.pub，重定向追加到远程文件authorizedkeys的末尾。","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"写入authorized_keys文件后，公钥登录的设置就完成了。","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"现在就可以远程免密登录了！","category":"page"},{"location":"CS Base/SSH_Git/#可能出现的问题","page":"SSH、Git与Git图形化软件","title":"可能出现的问题","text":"","category":"section"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"基本都是文件权限的问题，比如报错too open。Linux和Windows都会出现这样的情况，相关的解决方案很多，可以直接查找。","category":"page"},{"location":"CS Base/SSH_Git/#登录github或者码云","page":"SSH、Git与Git图形化软件","title":"登录github或者码云","text":"","category":"section"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"用ssh怎么操作呢？","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"做一个转换，github相当于就是服务端，只需要把公钥放在服务端就可以了。在github上更加方便，因为它都是图形化软件操作。进入设置软件，选择ssh就可以进行调试了（码云同理）。","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"配置好了之后，可以进行如下测试：","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"ssh -T git@github.com\n（ssh -T git@gitee.com）","category":"page"},{"location":"CS Base/SSH_Git/#git的使用","page":"SSH、Git与Git图形化软件","title":"git的使用","text":"","category":"section"},{"location":"CS Base/SSH_Git/#git和ssh的关联","page":"SSH、Git与Git图形化软件","title":"git和ssh的关联","text":"","category":"section"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"之前讲了那么多ssh的知识，有什么作用呢？ 会了ssh，git基本就会了一半了！","category":"page"},{"location":"CS Base/SSH_Git/#git的关键要素","page":"SSH、Git与Git图形化软件","title":"git的关键要素","text":"","category":"section"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"本地工作区（自己电脑的文件夹）\n远程仓库（远端服务器上的文件夹）","category":"page"},{"location":"CS Base/SSH_Git/#git基本操作","page":"SSH、Git与Git图形化软件","title":"git基本操作","text":"","category":"section"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"初始化本地仓库\n从远端拉取\n在本地编写文件\n文件暂存\n提交修改\n提交到远程","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"1.初始化本地仓库","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"通过git bash或者cmd进入仓库文件夹 输入：","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git init","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"简单配置(相关教程也很多，不赘述)：","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git config user.name \"Your Name\"\ngit config user.email \"email@example.com\"","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"链接到仓库的地址，相当于后面的操作就不需要输入地址了： （origin相当于变量，储存远端的地址）","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git remote add origin \"仓库的ssh地址\"","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"2.从远端拉取","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"拉取origin的master分支","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git pull origin master","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"3.本地编写文件 编写hello.txt","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"4.提交暂存","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git add .\n##或者\ngit add hello.txt","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"5.提交修改","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git commit -m \"文件说明\"","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"6.推送到远端","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git push origin master","category":"page"},{"location":"CS Base/SSH_Git/#git进阶操作","page":"SSH、Git与Git图形化软件","title":"git进阶操作","text":"","category":"section"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"提交多个版本的文件\n回退","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"1. 提交多个版本的文件 hello.txt 版本1：","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"i love you","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"提交暂存并修改","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git add hello.txt\ngit commit -m \"first\"","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"hello.txt 版本2：","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"i love you\nI love you","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"提交暂存并修改","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git add hello.txt\ngit commit -m \"second\"","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"hello.txt 版本3：","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"i love you\nI love you\nI love you too much","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"提交暂存并修改","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git add hello.txt\ngit commit -m \"third\"","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"接下来查看日志：","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git log","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"如图： (Image: 在这里插入图片描述)","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"可以看到，HEAD 指向的是最新版本（head可以理解为当前版本，也就说如果要推到远程就是推这个版本）","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"2.回退 接下来回退到上一个版本：","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git reset --hard HEAD^ ##回退到上上个就是：HEAD^^","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"那么可以看到head确实变了","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"又不想回退了，还是要回到第三次改变的最新版本","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git reset --hard 3ed54(commid的id，只能这样操作)","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"其实回退了之后就看不到id了，如果想要回到最新版本，就要记下id，所以说善变是有代价的！","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"可以方便查看id与修改信息：","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git log --pretty=oneline","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"3.Push 在善变之后，找到了真爱，不管是谁吧，反正证还是要领的。最后就是把文件推送到远端了。","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git push origin master","category":"page"},{"location":"CS Base/SSH_Git/#git图形化软件","page":"SSH、Git与Git图形化软件","title":"git图形化软件","text":"","category":"section"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"git图形化软件的好处就是，把以上对git的操作图形化。","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"常用且免费的有：","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"sourcetree\nvscode中内嵌的git操作页面\ngitkraken（团队版付费，个人免费）","category":"page"},{"location":"CS Base/SSH_Git/#sourcetree示例","page":"SSH、Git与Git图形化软件","title":"sourcetree示例","text":"","category":"section"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"软件如下：","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"比如说clone：","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"某一个链接仓库的工作软件：","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"(Image: 在这里插入图片描述)","category":"page"},{"location":"CS Base/SSH_Git/#vscode示例","page":"SSH、Git与Git图形化软件","title":"vscode示例","text":"","category":"section"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"(Image: 图 4)  ","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"更多操作见vscode中使用git","category":"page"},{"location":"CS Base/SSH_Git/#gitkraken示例","page":"SSH、Git与Git图形化软件","title":"gitkraken示例","text":"","category":"section"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"gitkraken网址","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"(Image: 图 5)  ","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"不管什么软件，拉取、提交、暂存等等都是相同的！","category":"page"},{"location":"CS Base/SSH_Git/","page":"SSH、Git与Git图形化软件","title":"SSH、Git与Git图形化软件","text":"如果你明白git的操作原理了，那么这个无师自通，因为本质上sourcetree就是提供一个图形化的操作软件。再没有其它新鲜玩意了！","category":"page"}]
}
